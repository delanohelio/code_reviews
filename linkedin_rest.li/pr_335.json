{"pr_number": 335, "pr_title": "Supply default values in restli response if the return data does not have it", "pr_author": "BrianPin", "pr_createdAt": "2020-06-20T01:53:41Z", "pr_url": "https://github.com/linkedin/rest.li/pull/335", "timeline": [{"oid": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "url": "https://github.com/linkedin/rest.li/commit/29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-06-22T17:32:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyOTk3NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443829974", "body": "combine these 2 conditions in one statement", "bodyText": "combine these 2 conditions in one statement", "bodyHTML": "<p dir=\"auto\">combine these 2 conditions in one statement</p>", "author": "aman1309", "createdAt": "2020-06-22T21:13:58Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,20 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNTQ3OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444415479", "bodyText": "Since I added the else section, it seems to me it is ok to keep it separate?", "author": "BrianPin", "createdAt": "2020-06-23T18:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyOTk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 09bbef46a..ae3975e7d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +93,92 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n             }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas of this field in the record\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -176,9 +179,8 @@ public class ResponseUtils\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443831615", "body": "can you add integration test for this to test based on query param", "bodyText": "can you add integration test for this to test based on query param", "bodyHTML": "<p dir=\"auto\">can you add integration test for this to test based on query param</p>", "author": "aman1309", "createdAt": "2020-06-22T21:17:22Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzNzQ0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444437444", "bodyText": "+1, you can probably just add extra test cases to existing integration tests", "author": "evanw555", "createdAt": "2020-06-23T18:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTExNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447111117", "bodyText": "Integration test is added", "author": "BrianPin", "createdAt": "2020-06-29T16:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\ndeleted file mode 100644\nindex 02a8fd91b..000000000\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ /dev/null\n", "chunk": "@@ -1,122 +0,0 @@\n-/*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n-package com.linkedin.restli.server.test;\n-\n-import com.google.common.collect.ImmutableMap;\n-import com.linkedin.data.DataList;\n-import com.linkedin.data.DataMap;\n-import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.NamedDataSchema;\n-import com.linkedin.data.schema.RecordDataSchema;\n-import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.SchemaParserFactory;\n-import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n-import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n-import com.linkedin.data.template.DataTemplateUtil;\n-import com.linkedin.restli.internal.server.response.ResponseUtils;\n-import java.io.File;\n-import java.io.IOException;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.testng.reporters.Files;\n-\n-\n-public class TestRestLiDefaultInResponse\n-{\n-  final static String FS = File.separator;\n-  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n-  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n-  final static String resolverDir = testDir + FS + \"pegasus\";\n-\n-  @BeforeTest\n-  public void beforeTest()\n-  {\n-    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n-  }\n-\n-  @DataProvider(name = \"default_serialization\")\n-  public Object[][] schemaFilesForDefaultSerializationTest()\n-  {\n-    DataList recordBField1 = new DataList(1);\n-    recordBField1.add(-1);\n-\n-    DataMap recordBField2 = new DataMap();\n-    DataList recordBField2DefaultValues = new DataList(2);\n-    recordBField2DefaultValues.add(\"defaultValue1\");\n-    recordBField2DefaultValues.add(\"defaultValue2\");\n-    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n-\n-    return new Object[][]{\n-        {\n-            \"RecordA.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .put(\"field3\", 0L)\n-                .put(\"field4\", \"default\")\n-                .build())\n-        },\n-        {\n-            \"RecordB.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", recordBField1)\n-                .put(\"field2\", recordBField2)\n-                .build())\n-        },\n-        {\n-            \"RecordC.pdl\",\n-            new DataMap(),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"name\", \"default+\")\n-                .build()),\n-        }\n-    };\n-  }\n-\n-  @Test(dataProvider = \"default_serialization\")\n-  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n-  {\n-    try\n-    {\n-      MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n-\n-      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n-      DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n-      ResponseUtils.getAbsentFieldsDefaultValues((RecordDataSchema) schema, data);\n-      Assert.assertEquals(data, expected);\n-    }\n-    catch (Exception e)\n-    {\n-      Assert.fail(\"Read test schema file failure, check file read successful \\n\" + e);\n-    }\n-  }\n-\n-  @AfterTest\n-  public void afterTest()\n-  {\n-    System.clearProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH);\n-  }\n-}\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nnew file mode 100644\nindex 000000000..02a8fd91b\n--- /dev/null\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -0,0 +1,122 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    DataList recordBField1 = new DataList(1);\n+    recordBField1.add(-1);\n+\n+    DataMap recordBField2 = new DataMap();\n+    DataList recordBField2DefaultValues = new DataList(2);\n+    recordBField2DefaultValues.add(\"defaultValue1\");\n+    recordBField2DefaultValues.add(\"defaultValue2\");\n+    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n+\n+    return new Object[][]{\n+        {\n+            \"RecordA.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .put(\"field3\", 0L)\n+                .put(\"field4\", \"default\")\n+                .build())\n+        },\n+        {\n+            \"RecordB.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", recordBField1)\n+                .put(\"field2\", recordBField2)\n+                .build())\n+        },\n+        {\n+            \"RecordC.pdl\",\n+            new DataMap(),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"name\", \"default+\")\n+                .build()),\n+        }\n+    };\n+  }\n+\n+  @Test(dataProvider = \"default_serialization\")\n+  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n+  {\n+    try\n+    {\n+      MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n+\n+      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n+      DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n+      ResponseUtils.getAbsentFieldsDefaultValues((RecordDataSchema) schema, data);\n+      Assert.assertEquals(data, expected);\n+    }\n+    catch (Exception e)\n+    {\n+      Assert.fail(\"Read test schema file failure, check file read successful \\n\" + e);\n+    }\n+  }\n+\n+  @AfterTest\n+  public void afterTest()\n+  {\n+    System.clearProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH);\n+  }\n+}\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex 02a8fd91b..b5dce7cec 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -120,3 +121,4 @@ public class TestRestLiDefaultInResponse\n     System.clearProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH);\n   }\n }\n+\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\ndeleted file mode 100644\nindex b5dce7cec..000000000\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ /dev/null\n", "chunk": "@@ -1,124 +0,0 @@\n-/*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n-package com.linkedin.restli.server.test;\n-\n-import com.google.common.collect.ImmutableMap;\n-import com.linkedin.data.DataList;\n-import com.linkedin.data.DataMap;\n-import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.RecordDataSchema;\n-import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n-import com.linkedin.data.template.DataTemplateUtil;\n-import com.linkedin.restli.internal.server.response.ResponseUtils;\n-import java.io.File;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.testng.reporters.Files;\n-\n-\n-public class TestRestLiDefaultInResponse\n-{\n-  final static String FS = File.separator;\n-  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n-  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n-  final static String resolverDir = testDir + FS + \"pegasus\";\n-\n-  @BeforeTest\n-  public void beforeTest()\n-  {\n-    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n-  }\n-\n-  @DataProvider(name = \"default_serialization\")\n-  public Object[][] schemaFilesForDefaultSerializationTest()\n-  {\n-    DataList recordBField1 = new DataList(1);\n-    recordBField1.add(-1);\n-\n-    DataMap recordBField2 = new DataMap();\n-    DataList recordBField2DefaultValues = new DataList(2);\n-    recordBField2DefaultValues.add(\"defaultValue1\");\n-    recordBField2DefaultValues.add(\"defaultValue2\");\n-    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n-    DataMap personalRecordD = new DataMap();\n-    personalRecordD.put(\"field3\", 0L);\n-    personalRecordD.put(\"field4\", \"default\");\n-    personalRecordD.put(\"field5\", \"a-typeref-default\");\n-\n-    return new Object[][]{\n-        {\n-            \"RecordA.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .put(\"field3\", 0L)\n-                .put(\"field4\", \"default\")\n-                .build())\n-        },\n-        {\n-            \"RecordB.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", recordBField1)\n-                .put(\"field2\", recordBField2)\n-                .build())\n-        },\n-        {\n-            \"RecordC.pdl\",\n-            new DataMap(),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"name\", \"default+\")\n-                .put(\"personalRecordD\", personalRecordD)\n-                .build()),\n-        }\n-    };\n-  }\n-\n-  @Test(dataProvider = \"default_serialization\")\n-  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n-  {\n-    try\n-    {\n-      MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n-\n-      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n-      DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n-      ResponseUtils.fillInDefaultValues(schema, data);\n-      Assert.assertEquals(data, expected);\n-    }\n-    catch (Exception e)\n-    {\n-      Assert.fail(\"Read test schema file failure, check file read successful \\n\" + e);\n-    }\n-  }\n-\n-  @AfterTest\n-  public void afterTest()\n-  {\n-    System.clearProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH);\n-  }\n-}\n-\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMjkzNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443832935", "body": "$sendDefaults, doc was updated to add $ as prefix to not conflict with other fields.\r\nAlso, can you move it to as constant instead of hard coding here", "bodyText": "$sendDefaults, doc was updated to add $ as prefix to not conflict with other fields.\nAlso, can you move it to as constant instead of hard coding here", "bodyHTML": "<p dir=\"auto\">$sendDefaults, doc was updated to add $ as prefix to not conflict with other fields.<br>\nAlso, can you move it to as constant instead of hard coding here</p>", "author": "aman1309", "createdAt": "2020-06-22T21:20:16Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +117,19 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(\"sendDefaults\") &&", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTI3MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447111270", "bodyText": "this is updated", "author": "BrianPin", "createdAt": "2020-06-29T16:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMjkzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 09bbef46a..ae3975e7d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -125,8 +131,9 @@ public class ResponseUtils\n       }\n \n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(\"sendDefaults\") &&\n-          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          dataSchema != null)\n       {\n         getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n       }\n", "next_change": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -123,19 +148,15 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n-      DataSchema dataSchema = null;\n-      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-      if (valueClass != null)\n-      {\n-        dataSchema = DataTemplateUtil.getSchema(valueClass);\n-      }\n-\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          dataSchema != null)\n+      if (context.isDefaultValueFillInRequested())\n       {\n-        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          fillInDefaultValues(dataSchema, dataMap);\n+        }\n       }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n", "next_change": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -149,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -194,7 +117,19 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(\"sendDefaults\") &&\n+          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      {\n+        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -125,8 +131,9 @@ public class ResponseUtils\n       }\n \n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(\"sendDefaults\") &&\n-          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          dataSchema != null)\n       {\n         getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n       }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -123,19 +148,15 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n-      DataSchema dataSchema = null;\n-      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-      if (valueClass != null)\n-      {\n-        dataSchema = DataTemplateUtil.getSchema(valueClass);\n-      }\n-\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          dataSchema != null)\n+      if (context.isDefaultValueFillInRequested())\n       {\n-        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          fillInDefaultValues(dataSchema, dataMap);\n+        }\n       }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -155,7 +195,7 @@ public class ResponseUtils\n         if (valueClass != null)\n         {\n           DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          fillInDefaultValues(dataSchema, dataMap);\n+          dataMap = fillInDefaultValues(dataSchema, dataMap);\n         }\n       }\n       String mimeType = context.getResponseMimeType();\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..c5991edc8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -189,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          dataMap = fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443833719", "body": "move this inside if statement if we have fill defaults", "bodyText": "move this inside if statement if we have fill defaults", "bodyHTML": "<p dir=\"auto\">move this inside if statement if we have fill defaults</p>", "author": "aman1309", "createdAt": "2020-06-22T21:21:55Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +117,19 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MjYzMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444442632", "bodyText": "+1, logic is only necessary when needed", "author": "evanw555", "createdAt": "2020-06-23T19:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUzOTU5Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444539592", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-06-23T22:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 09bbef46a..ae3975e7d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -125,8 +131,9 @@ public class ResponseUtils\n       }\n \n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(\"sendDefaults\") &&\n-          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          dataSchema != null)\n       {\n         getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n       }\n", "next_change": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -123,19 +148,15 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n-      DataSchema dataSchema = null;\n-      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-      if (valueClass != null)\n-      {\n-        dataSchema = DataTemplateUtil.getSchema(valueClass);\n-      }\n-\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          dataSchema != null)\n+      if (context.isDefaultValueFillInRequested())\n       {\n-        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          fillInDefaultValues(dataSchema, dataMap);\n+        }\n       }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n", "next_change": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -149,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -194,7 +117,19 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(\"sendDefaults\") &&\n+          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      {\n+        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -125,8 +131,9 @@ public class ResponseUtils\n       }\n \n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(\"sendDefaults\") &&\n-          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          dataSchema != null)\n       {\n         getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n       }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -123,19 +148,15 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n-      DataSchema dataSchema = null;\n-      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-      if (valueClass != null)\n-      {\n-        dataSchema = DataTemplateUtil.getSchema(valueClass);\n-      }\n-\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          dataSchema != null)\n+      if (context.isDefaultValueFillInRequested())\n       {\n-        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          fillInDefaultValues(dataSchema, dataMap);\n+        }\n       }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -155,7 +195,7 @@ public class ResponseUtils\n         if (valueClass != null)\n         {\n           DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          fillInDefaultValues(dataSchema, dataMap);\n+          dataMap = fillInDefaultValues(dataSchema, dataMap);\n         }\n       }\n       String mimeType = context.getResponseMimeType();\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..c5991edc8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -189,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          dataMap = fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNDI5OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443834299", "body": "as discussed update this logic to fill nested defaults if field value is not null", "bodyText": "as discussed update this logic to fill nested defaults if field value is not null", "bodyHTML": "<p dir=\"auto\">as discussed update this logic to fill nested defaults if field value is not null</p>", "author": "aman1309", "createdAt": "2020-06-22T21:23:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,20 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)\n+        {\n+          dataMap.put(field.getName(), field.getDefault());", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 09bbef46a..ae3975e7d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +93,92 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n             }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas of this field in the record\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -176,9 +179,8 @@ public class ResponseUtils\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "bb55c5b526dcc244bcbb2463b41d5de338188168", "url": "https://github.com/linkedin/rest.li/commit/bb55c5b526dcc244bcbb2463b41d5de338188168", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-06-22T23:13:34Z", "type": "forcePushed"}, {"oid": "89a6060586011c826a2609468bd2c969f6aa3f35", "url": "https://github.com/linkedin/rest.li/commit/89a6060586011c826a2609468bd2c969f6aa3f35", "message": "Address Aman's comment about recursive resolve default values for record and fix the query key for this feature", "committedDate": "2020-06-23T18:10:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MTMwNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444441305", "body": "I'd suggest renaming this to something like `fillInDefaultValues`, since `get...` seems to imply it's a side effect-less get accessor. Also add a javadoc since it's a public method (alternatively consider reducing to private/p-private)", "bodyText": "I'd suggest renaming this to something like fillInDefaultValues, since get... seems to imply it's a side effect-less get accessor. Also add a javadoc since it's a public method (alternatively consider reducing to private/p-private)", "bodyHTML": "<p dir=\"auto\">I'd suggest renaming this to something like <code>fillInDefaultValues</code>, since <code>get...</code> seems to imply it's a side effect-less get accessor. Also add a javadoc since it's a public method (alternatively consider reducing to private/p-private)</p>", "author": "evanw555", "createdAt": "2020-06-23T18:59:17Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +86,30 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUzNTEyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444535123", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-06-23T22:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MTMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +93,92 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n             }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas of this field in the record\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -176,9 +179,8 @@ public class ResponseUtils\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzU0Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444443543", "body": "Consider moving this logic to the `ResourceContext` interface. This is what I did for `ResourceContext#isReturnEntityRequested` rather than directly looking at the parameters.", "bodyText": "Consider moving this logic to the ResourceContext interface. This is what I did for ResourceContext#isReturnEntityRequested rather than directly looking at the parameters.", "bodyHTML": "<p dir=\"auto\">Consider moving this logic to the <code>ResourceContext</code> interface. This is what I did for <code>ResourceContext#isReturnEntityRequested</code> rather than directly looking at the parameters.</p>", "author": "evanw555", "createdAt": "2020-06-23T19:03:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +123,20 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MzM3Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444543372", "bodyText": "Yeah that makes the code consistent, thanks", "author": "BrianPin", "createdAt": "2020-06-23T22:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzU0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -123,19 +148,15 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n-      DataSchema dataSchema = null;\n-      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-      if (valueClass != null)\n-      {\n-        dataSchema = DataTemplateUtil.getSchema(valueClass);\n-      }\n-\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          dataSchema != null)\n+      if (context.isDefaultValueFillInRequested())\n       {\n-        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          fillInDefaultValues(dataSchema, dataMap);\n+        }\n       }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n", "next_change": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -149,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -194,7 +117,19 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(\"sendDefaults\") &&\n+          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      {\n+        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -125,8 +131,9 @@ public class ResponseUtils\n       }\n \n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(\"sendDefaults\") &&\n-          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          dataSchema != null)\n       {\n         getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n       }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -123,19 +148,15 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n-      DataSchema dataSchema = null;\n-      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-      if (valueClass != null)\n-      {\n-        dataSchema = DataTemplateUtil.getSchema(valueClass);\n-      }\n-\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          dataSchema != null)\n+      if (context.isDefaultValueFillInRequested())\n       {\n-        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          fillInDefaultValues(dataSchema, dataMap);\n+        }\n       }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -155,7 +195,7 @@ public class ResponseUtils\n         if (valueClass != null)\n         {\n           DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          fillInDefaultValues(dataSchema, dataMap);\n+          dataMap = fillInDefaultValues(dataSchema, dataMap);\n         }\n       }\n       String mimeType = context.getResponseMimeType();\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..c5991edc8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -189,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          dataMap = fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzY3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444443678", "body": "nit: add newline", "bodyText": "nit: add newline", "bodyHTML": "<p dir=\"auto\">nit: add newline</p>", "author": "evanw555", "createdAt": "2020-06-23T19:03:36Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex e2d721867..7b5c9c196 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -15,21 +15,15 @@\n */\n package com.linkedin.restli.server.test;\n \n-import com.google.common.collect.ImmutableMap;\n import com.linkedin.data.DataList;\n import com.linkedin.data.DataMap;\n import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.NamedDataSchema;\n-import com.linkedin.data.schema.RecordDataSchema;\n import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.SchemaParserFactory;\n import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n import com.linkedin.restli.internal.server.response.ResponseUtils;\n import java.io.File;\n-import java.io.IOException;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n import org.testng.annotations.BeforeTest;\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nsimilarity index 95%\nrename from restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nrename to restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 7b5c9c196..98d3075ae 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n", "chunk": "@@ -22,7 +22,6 @@ import com.linkedin.data.schema.SchemaFormatType;\n import com.linkedin.data.schema.generator.AbstractGenerator;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n-import com.linkedin.restli.internal.server.response.ResponseUtils;\n import java.io.File;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n", "next_change": null}, {"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nsimilarity index 95%\nrename from restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nrename to restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 7b5c9c196..98d3075ae 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n", "chunk": "@@ -32,7 +31,7 @@ import org.testng.annotations.Test;\n import org.testng.reporters.Files;\n \n \n-public class TestRestLiDefaultInResponse\n+public class TestResponseUtils\n {\n   final static String FS = File.separator;\n   final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444444622", "body": "What's the purpose of this change?", "bodyText": "What's the purpose of this change?", "bodyHTML": "<p dir=\"auto\">What's the purpose of this change?</p>", "author": "evanw555", "createdAt": "2020-06-23T19:05:25Z", "path": "restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java", "diffHunk": "@@ -1210,7 +1210,7 @@ public FixedTemplatePlaceholder(Object object, FixedDataSchema schema)\n \n   private static ResourceModel buildPlaceholderResourceModel(ResourceSchema resourceSchema)\n   {\n-    return new ResourceModel(RecordTemplatePlaceholder.class,", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTU2MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444481561", "bodyText": "This is good question, so when I do gradle test, this test class failed because it uses the RecordTemplatePlaceholder and it is not a real template,  on the other hand, in my newly added code, i need to have a fully function resource model instance.\nroutingResult.getResourceMethod().getResourceModel().getValueClass();\n\nIf we keep using the RecordTemplatePlaceholder, we will get an exception.\nThe ResourceModel takes an RecordTemplate as the input, the change from  RecordTemplatePlaceholder  to use resourceSchema seems to be a perfect fit. It is needed to say, I don't know why the original code uses the RecordTemplatePlaceholder rather than the real resourceSchema", "author": "BrianPin", "createdAt": "2020-06-23T20:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTgxMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r445169812", "bodyText": "I don't think this is a good idea. Using a random record type like ResourceSchema is misleading and made me believe that this logic is inherently related to resource schemas. I'd suggest you do one of two things:\n\nBe explicit about using a dummy record by using something like EmptyRecord.\nFix the issue in RecordTemplatePlaceholder, this is an easy fix, since you can just define the schema as new RecordDataSchema(new Name(RecordTemplatePlaceholder.class.getCanonicalName()), RecordDataSchema.RecordType.RECORD).", "author": "evanw555", "createdAt": "2020-06-24T21:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ5ODEyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447498123", "bodyText": "I removed the change, it looks like I no longer need this change anymore. Will notice your suggestion next time when same situation happen", "author": "BrianPin", "createdAt": "2020-06-30T08:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java b/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\nindex d0d932cae..21976e6e5 100644\n--- a/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\n+++ b/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\n", "chunk": "@@ -1210,7 +1210,7 @@ public class ExampleRequestResponseGenerator\n \n   private static ResourceModel buildPlaceholderResourceModel(ResourceSchema resourceSchema)\n   {\n-    return new ResourceModel(ResourceSchema.class,\n+    return new ResourceModel(RecordTemplatePlaceholder.class,\n         Object.class,\n         null,\n         resourceSchema.getName(),\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java b/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\nindex 21976e6e5..d0d932cae 100644\n--- a/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\n+++ b/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\n", "chunk": "@@ -1210,7 +1210,7 @@ public class ExampleRequestResponseGenerator\n \n   private static ResourceModel buildPlaceholderResourceModel(ResourceSchema resourceSchema)\n   {\n-    return new ResourceModel(RecordTemplatePlaceholder.class,\n+    return new ResourceModel(ResourceSchema.class,\n         Object.class,\n         null,\n         resourceSchema.getName(),\n", "next_change": {"commit": "3dcb85552f3653b177932480593368e1aa1a835a", "changed_code": [{"header": "diff --git a/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java b/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\nindex d0d932cae..21976e6e5 100644\n--- a/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\n+++ b/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\n", "chunk": "@@ -1210,7 +1210,7 @@ public class ExampleRequestResponseGenerator\n \n   private static ResourceModel buildPlaceholderResourceModel(ResourceSchema resourceSchema)\n   {\n-    return new ResourceModel(ResourceSchema.class,\n+    return new ResourceModel(RecordTemplatePlaceholder.class,\n         Object.class,\n         null,\n         resourceSchema.getName(),\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0Njk1Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444446956", "body": "Move to `com.linkedin.restli.internal.server.response` to be aligned with the location of `ResponseUtils`", "bodyText": "Move to com.linkedin.restli.internal.server.response to be aligned with the location of ResponseUtils", "bodyHTML": "<p dir=\"auto\">Move to <code>com.linkedin.restli.internal.server.response</code> to be aligned with the location of <code>ResponseUtils</code></p>", "author": "evanw555", "createdAt": "2020-06-23T19:09:22Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex e2d721867..7b5c9c196 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -15,21 +15,15 @@\n */\n package com.linkedin.restli.server.test;\n \n-import com.google.common.collect.ImmutableMap;\n import com.linkedin.data.DataList;\n import com.linkedin.data.DataMap;\n import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.NamedDataSchema;\n-import com.linkedin.data.schema.RecordDataSchema;\n import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.SchemaParserFactory;\n import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n import com.linkedin.restli.internal.server.response.ResponseUtils;\n import java.io.File;\n-import java.io.IOException;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n import org.testng.annotations.BeforeTest;\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nsimilarity index 95%\nrename from restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nrename to restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 7b5c9c196..98d3075ae 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n", "chunk": "@@ -22,7 +22,6 @@ import com.linkedin.data.schema.SchemaFormatType;\n import com.linkedin.data.schema.generator.AbstractGenerator;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n-import com.linkedin.restli.internal.server.response.ResponseUtils;\n import java.io.File;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n", "next_change": null}, {"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nsimilarity index 95%\nrename from restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nrename to restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 7b5c9c196..98d3075ae 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n", "chunk": "@@ -32,7 +31,7 @@ import org.testng.annotations.Test;\n import org.testng.reporters.Files;\n \n \n-public class TestRestLiDefaultInResponse\n+public class TestResponseUtils\n {\n   final static String FS = File.separator;\n   final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0ODA5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444448097", "body": "Consider renaming this to just be `TestResponseUtils` to be aligned with the class it's testing.", "bodyText": "Consider renaming this to just be TestResponseUtils to be aligned with the class it's testing.", "bodyHTML": "<p dir=\"auto\">Consider renaming this to just be <code>TestResponseUtils</code> to be aligned with the class it's testing.</p>", "author": "evanw555", "createdAt": "2020-06-23T19:11:32Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\ndeleted file mode 100644\nindex e2d721867..000000000\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ /dev/null\n", "chunk": "@@ -1,126 +0,0 @@\n-/*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n-package com.linkedin.restli.server.test;\n-\n-import com.google.common.collect.ImmutableMap;\n-import com.linkedin.data.DataList;\n-import com.linkedin.data.DataMap;\n-import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.NamedDataSchema;\n-import com.linkedin.data.schema.RecordDataSchema;\n-import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.SchemaParserFactory;\n-import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n-import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n-import com.linkedin.data.template.DataTemplateUtil;\n-import com.linkedin.restli.internal.server.response.ResponseUtils;\n-import java.io.File;\n-import java.io.IOException;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.testng.reporters.Files;\n-\n-\n-public class TestRestLiDefaultInResponse\n-{\n-  final static String FS = File.separator;\n-  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n-  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n-  final static String resolverDir = testDir + FS + \"pegasus\";\n-\n-  @BeforeTest\n-  public void beforeTest()\n-  {\n-    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n-  }\n-\n-  @DataProvider(name = \"default_serialization\")\n-  public Object[][] schemaFilesForDefaultSerializationTest()\n-  {\n-    DataList recordBField1 = new DataList(1);\n-    recordBField1.add(-1);\n-\n-    DataMap recordBField2 = new DataMap();\n-    DataList recordBField2DefaultValues = new DataList(2);\n-    recordBField2DefaultValues.add(\"defaultValue1\");\n-    recordBField2DefaultValues.add(\"defaultValue2\");\n-    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n-    DataMap personalRecordD = new DataMap();\n-    personalRecordD.put(\"field3\", 0L);\n-    personalRecordD.put(\"field4\", \"default\");\n-\n-    return new Object[][]{\n-        {\n-            \"RecordA.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .put(\"field3\", 0L)\n-                .put(\"field4\", \"default\")\n-                .build())\n-        },\n-        {\n-            \"RecordB.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", recordBField1)\n-                .put(\"field2\", recordBField2)\n-                .build())\n-        },\n-        {\n-            \"RecordC.pdl\",\n-            new DataMap(),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"name\", \"default+\")\n-                .put(\"personalRecordD\", personalRecordD)\n-                .build()),\n-        }\n-    };\n-  }\n-\n-  @Test(dataProvider = \"default_serialization\")\n-  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n-  {\n-    try\n-    {\n-      MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n-\n-      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n-      DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n-      ResponseUtils.getAbsentFieldsDefaultValues((RecordDataSchema) schema, data);\n-      Assert.assertEquals(data, expected);\n-    }\n-    catch (Exception e)\n-    {\n-      Assert.fail(\"Read test schema file failure, check file read successful \\n\" + e);\n-    }\n-  }\n-\n-  @AfterTest\n-  public void afterTest()\n-  {\n-    System.clearProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH);\n-  }\n-}\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nnew file mode 100644\nindex 000000000..02a8fd91b\n--- /dev/null\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -0,0 +1,122 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    DataList recordBField1 = new DataList(1);\n+    recordBField1.add(-1);\n+\n+    DataMap recordBField2 = new DataMap();\n+    DataList recordBField2DefaultValues = new DataList(2);\n+    recordBField2DefaultValues.add(\"defaultValue1\");\n+    recordBField2DefaultValues.add(\"defaultValue2\");\n+    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n+\n+    return new Object[][]{\n+        {\n+            \"RecordA.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .put(\"field3\", 0L)\n+                .put(\"field4\", \"default\")\n+                .build())\n+        },\n+        {\n+            \"RecordB.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", recordBField1)\n+                .put(\"field2\", recordBField2)\n+                .build())\n+        },\n+        {\n+            \"RecordC.pdl\",\n+            new DataMap(),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"name\", \"default+\")\n+                .build()),\n+        }\n+    };\n+  }\n+\n+  @Test(dataProvider = \"default_serialization\")\n+  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n+  {\n+    try\n+    {\n+      MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n+\n+      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n+      DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n+      ResponseUtils.getAbsentFieldsDefaultValues((RecordDataSchema) schema, data);\n+      Assert.assertEquals(data, expected);\n+    }\n+    catch (Exception e)\n+    {\n+      Assert.fail(\"Read test schema file failure, check file read successful \\n\" + e);\n+    }\n+  }\n+\n+  @AfterTest\n+  public void afterTest()\n+  {\n+    System.clearProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH);\n+  }\n+}\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex 02a8fd91b..b5dce7cec 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -120,3 +121,4 @@ public class TestRestLiDefaultInResponse\n     System.clearProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH);\n   }\n }\n+\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\ndeleted file mode 100644\nindex b5dce7cec..000000000\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ /dev/null\n", "chunk": "@@ -1,124 +0,0 @@\n-/*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n-package com.linkedin.restli.server.test;\n-\n-import com.google.common.collect.ImmutableMap;\n-import com.linkedin.data.DataList;\n-import com.linkedin.data.DataMap;\n-import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.RecordDataSchema;\n-import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n-import com.linkedin.data.template.DataTemplateUtil;\n-import com.linkedin.restli.internal.server.response.ResponseUtils;\n-import java.io.File;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.testng.reporters.Files;\n-\n-\n-public class TestRestLiDefaultInResponse\n-{\n-  final static String FS = File.separator;\n-  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n-  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n-  final static String resolverDir = testDir + FS + \"pegasus\";\n-\n-  @BeforeTest\n-  public void beforeTest()\n-  {\n-    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n-  }\n-\n-  @DataProvider(name = \"default_serialization\")\n-  public Object[][] schemaFilesForDefaultSerializationTest()\n-  {\n-    DataList recordBField1 = new DataList(1);\n-    recordBField1.add(-1);\n-\n-    DataMap recordBField2 = new DataMap();\n-    DataList recordBField2DefaultValues = new DataList(2);\n-    recordBField2DefaultValues.add(\"defaultValue1\");\n-    recordBField2DefaultValues.add(\"defaultValue2\");\n-    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n-    DataMap personalRecordD = new DataMap();\n-    personalRecordD.put(\"field3\", 0L);\n-    personalRecordD.put(\"field4\", \"default\");\n-    personalRecordD.put(\"field5\", \"a-typeref-default\");\n-\n-    return new Object[][]{\n-        {\n-            \"RecordA.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .put(\"field3\", 0L)\n-                .put(\"field4\", \"default\")\n-                .build())\n-        },\n-        {\n-            \"RecordB.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", recordBField1)\n-                .put(\"field2\", recordBField2)\n-                .build())\n-        },\n-        {\n-            \"RecordC.pdl\",\n-            new DataMap(),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"name\", \"default+\")\n-                .put(\"personalRecordD\", personalRecordD)\n-                .build()),\n-        }\n-    };\n-  }\n-\n-  @Test(dataProvider = \"default_serialization\")\n-  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n-  {\n-    try\n-    {\n-      MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n-\n-      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n-      DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n-      ResponseUtils.fillInDefaultValues(schema, data);\n-      Assert.assertEquals(data, expected);\n-    }\n-    catch (Exception e)\n-    {\n-      Assert.fail(\"Read test schema file failure, check file read successful \\n\" + e);\n-    }\n-  }\n-\n-  @AfterTest\n-  public void afterTest()\n-  {\n-    System.clearProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH);\n-  }\n-}\n-\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0ODMzNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444448337", "body": "Consider renaming this to `TestGetAbsentFieldsDefaultValues` to be aligned with the method it's testing. If you rename that method, rename this test accordingly.", "bodyText": "Consider renaming this to TestGetAbsentFieldsDefaultValues to be aligned with the method it's testing. If you rename that method, rename this test accordingly.", "bodyHTML": "<p dir=\"auto\">Consider renaming this to <code>TestGetAbsentFieldsDefaultValues</code> to be aligned with the method it's testing. If you rename that method, rename this test accordingly.</p>", "author": "evanw555", "createdAt": "2020-06-23T19:12:03Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    DataList recordBField1 = new DataList(1);\n+    recordBField1.add(-1);\n+\n+    DataMap recordBField2 = new DataMap();\n+    DataList recordBField2DefaultValues = new DataList(2);\n+    recordBField2DefaultValues.add(\"defaultValue1\");\n+    recordBField2DefaultValues.add(\"defaultValue2\");\n+    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n+    DataMap personalRecordD = new DataMap();\n+    personalRecordD.put(\"field3\", 0L);\n+    personalRecordD.put(\"field4\", \"default\");\n+\n+    return new Object[][]{\n+        {\n+            \"RecordA.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .put(\"field3\", 0L)\n+                .put(\"field4\", \"default\")\n+                .build())\n+        },\n+        {\n+            \"RecordB.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", recordBField1)\n+                .put(\"field2\", recordBField2)\n+                .build())\n+        },\n+        {\n+            \"RecordC.pdl\",\n+            new DataMap(),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"name\", \"default+\")\n+                .put(\"personalRecordD\", personalRecordD)\n+                .build()),\n+        }\n+    };\n+  }\n+\n+  @Test(dataProvider = \"default_serialization\")\n+  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex e2d721867..7b5c9c196 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -54,48 +48,100 @@ public class TestRestLiDefaultInResponse\n   @DataProvider(name = \"default_serialization\")\n   public Object[][] schemaFilesForDefaultSerializationTest()\n   {\n-    DataList recordBField1 = new DataList(1);\n-    recordBField1.add(-1);\n-\n-    DataMap recordBField2 = new DataMap();\n-    DataList recordBField2DefaultValues = new DataList(2);\n-    recordBField2DefaultValues.add(\"defaultValue1\");\n-    recordBField2DefaultValues.add(\"defaultValue2\");\n-    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n-    DataMap personalRecordD = new DataMap();\n-    personalRecordD.put(\"field3\", 0L);\n-    personalRecordD.put(\"field4\", \"default\");\n+    // case 1\n+    DataMap case1Input = new DataMap();\n+    case1Input.put(\"field1\", 1);\n+    case1Input.put(\"field2\", \"2\");\n+    DataMap case1Expect = new DataMap();\n+    case1Expect.put(\"field1\", 1);\n+    case1Expect.put(\"field2\", \"2\");\n+    case1Expect.put(\"field3\", 0L);\n+    case1Expect.put(\"field4\", \"default\");\n \n+    // case 2\n+    DataMap case2Input = new DataMap();\n+    DataMap case2Expect = new DataMap();\n+    DataList case2F1 = new DataList(1);\n+    case2F1.add(-1);\n+    case2Expect.put(\"field1\", case2F1);\n+    DataMap case2F2 = new DataMap();\n+    DataList case2F2Default = new DataList(2);\n+    case2F2Default.add(\"defaultValue1\");\n+    case2F2Default.add(\"defaultValue2\");\n+    case2F2.put(\"defaultKey\", case2F2Default);\n+    case2Expect.put(\"field2\", case2F2);\n+\n+    // case 3\n+    DataMap case3Input = new DataMap();\n+    case3Input.put(\"name\", \"not-a-default\");\n+    case3Input.put(\"personalRecordD\", new DataMap());\n+    DataMap case3Expect = new DataMap();\n+    DataMap case3RecordDExpect = new DataMap();\n+    case3RecordDExpect.put(\"field3\", 0L);\n+    case3RecordDExpect.put(\"field4\", \"default\");\n+    case3RecordDExpect.put(\"field5\", \"a-typeref-default\");\n+    case3Expect.put(\"name\", \"not-a-default\");\n+    case3Expect.put(\"personalRecordD\", case3RecordDExpect);\n+\n+    // case 4\n+    DataMap case4B1 = new DataMap();\n+    case4B1.put(\"f1\", 1);\n+    DataMap case4Input = new DataMap();\n+    case4Input.put(\"b1\", case4B1);\n+    case4Input.put(\"b2\", new DataMap());\n+    DataMap case4Expect = new DataMap();\n+    DataMap case4ExpectB1 = new DataMap();\n+    case4ExpectB1.put(\"f1\", 1);\n+    DataMap case4ExpectB2 = new DataMap();\n+    case4ExpectB2.put(\"f1\", 5);\n+    case4Expect.put(\"b1\", case4ExpectB1);\n+    case4Expect.put(\"b2\", case4ExpectB2);\n+\n+    // case 5\n+    DataMap case5B3 = new DataMap();\n+    case5B3.put(\"f2\", 1);\n+    DataMap case5Input = new DataMap();\n+    case5Input.put(\"b3\", case5B3);\n+    DataMap case5Expect = new DataMap();\n+    DataMap case5ExpectB1 = new DataMap();\n+    case5ExpectB1.put(\"f1\", 5);\n+    case5ExpectB1.put(\"f2\", 10);\n+    DataMap case5ExpectB3 = new DataMap();\n+    case5ExpectB3.put(\"f2\", 1);\n+    case5ExpectB3.put(\"f1\", 5);\n+    case5Expect.put(\"b1\", case5ExpectB1);\n+    case5Expect.put(\"b3\", case5ExpectB3);\n+\n+\n+    // Each test case has 3 elements:\n+    // Index 0: PDL file name\n+    // Index 1: data before filling default\n+    // Index 2: expected data after filling default\n     return new Object[][]{\n         {\n             \"RecordA.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", 1)\n-                .put(\"field2\", \"2\")\n-                .put(\"field3\", 0L)\n-                .put(\"field4\", \"default\")\n-                .build())\n+            case1Input,\n+            case1Expect\n         },\n         {\n             \"RecordB.pdl\",\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .build()),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"field1\", recordBField1)\n-                .put(\"field2\", recordBField2)\n-                .build())\n+            case2Input,\n+            case2Expect\n         },\n         {\n             \"RecordC.pdl\",\n-            new DataMap(),\n-            new DataMap(new ImmutableMap.Builder<String, Object>()\n-                .put(\"name\", \"default+\")\n-                .put(\"personalRecordD\", personalRecordD)\n-                .build()),\n+            case3Input,\n+            case3Expect\n+        },\n+        {\n+            \"Bar.pdl\",\n+            case4Input,\n+            case4Expect\n+        },\n+        {\n+            \"Bar.pdl\",\n+            case5Input,\n+            case5Expect\n         }\n     };\n   }\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nsimilarity index 95%\nrename from restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nrename to restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 7b5c9c196..98d3075ae 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n", "chunk": "@@ -147,7 +146,7 @@ public class TestRestLiDefaultInResponse\n   }\n \n   @Test(dataProvider = \"default_serialization\")\n-  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n+  public void testGetAbsentFieldsDefaultValues(String filename, DataMap data, DataMap expected)\n   {\n     try\n     {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444542146", "body": "test this for typerefs", "bodyText": "test this for typerefs", "bodyHTML": "<p dir=\"auto\">test this for typerefs</p>", "author": "aman1309", "createdAt": "2020-06-23T22:24:58Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +86,30 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)\n+        {\n+          dataMap.put(field.getName(), field.getDefault());\n+        }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxODkyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444618923", "bodyText": "Got an exception:\njava.lang.ClassCastException: com.linkedin.data.schema.TyperefDataSchema cannot be cast to com.linkedin.data.schema.RecordDataSchema", "author": "BrianPin", "createdAt": "2020-06-24T03:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMTc0OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447131748", "bodyText": "yeah, you might want to use dereferenced schema for typerefs", "author": "aman1309", "createdAt": "2020-06-29T17:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMDAyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447510023", "bodyText": "Resolved this, Aman!", "author": "BrianPin", "createdAt": "2020-06-30T08:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +93,92 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n             }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas of this field in the record\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -176,9 +179,8 @@ public class ResponseUtils\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "url": "https://github.com/linkedin/rest.li/commit/49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "message": "Address comment: integration test and recursive resolve and typeref test", "committedDate": "2020-06-25T23:26:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NzE0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r446047144", "body": "You need to handle the else part for this.", "bodyText": "You need to handle the else part for this.", "bodyHTML": "<p dir=\"auto\">You need to handle the else part for this.</p>", "author": "karthikbalasub", "createdAt": "2020-06-26T08:35:49Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,51 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        if (!dataMap.containsKey(field.getName()))", "originalCommit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +93,92 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n             }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas of this field in the record\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -176,9 +179,8 @@ public class ResponseUtils\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1Mzc0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r446053744", "body": "This is not needed. You need to traverse the nested schemas only if the value is present at the top-level.\r\n\r\nConsider this:\r\n```\r\nrecord Foo {\r\n  f1: int = 5\r\n  f2: optional int\r\n }\r\n\r\nrecord Bar {\r\n   b1: Foo = { f2: 10 }\r\n   b2: optional Foo\r\n   b3: Foo\r\n}\r\n\r\n```\r\nSo the scenarios are (top-level is Bar):\r\n1. \r\n```\r\n{\r\n  b1: {\r\n    f1: 1\r\n  },\r\n  b2: {}\r\n}\r\n\r\n```\r\nOutput with defaults filled in should be:\r\n```\r\n{\r\n  b1: {\r\n    f1: 1\r\n  },\r\n   b2: {\r\n    f1: 5,     // Filled using default value in Foo\r\n  }\r\n}\r\n\r\n```\r\nb3 is not present in the input data and so shouldn't be filled in.\r\n\r\n2.\r\n```\r\n{\r\n  b3: {\r\n    f2: 1\r\n  }\r\n}\r\n\r\n```\r\nOutput with defaults filled in should be:\r\n```\r\n{\r\n b1: {.         // Filled because of default value in Bar\r\n   f1: 5,        // Filled using default value in Foo\r\n    f2: 10     // Filled using default value in Bar\r\n  },\r\n  b3: {\r\n    f1: 5,     // Filled using default value in Foo\r\n    f2: 1\r\n  }\r\n}\r\n\r\n```\r\nBasically, fill in the defaults for fields only if the record is present or record is filled in using a default. Do not create a record only because a nested field specifies default value.", "bodyText": "This is not needed. You need to traverse the nested schemas only if the value is present at the top-level.\nConsider this:\nrecord Foo {\n  f1: int = 5\n  f2: optional int\n }\n\nrecord Bar {\n   b1: Foo = { f2: 10 }\n   b2: optional Foo\n   b3: Foo\n}\n\n\nSo the scenarios are (top-level is Bar):\n1.\n{\n  b1: {\n    f1: 1\n  },\n  b2: {}\n}\n\n\nOutput with defaults filled in should be:\n{\n  b1: {\n    f1: 1\n  },\n   b2: {\n    f1: 5,     // Filled using default value in Foo\n  }\n}\n\n\nb3 is not present in the input data and so shouldn't be filled in.\n\n\n\n{\n  b3: {\n    f2: 1\n  }\n}\n\n\nOutput with defaults filled in should be:\n{\n b1: {.         // Filled because of default value in Bar\n   f1: 5,        // Filled using default value in Foo\n    f2: 10     // Filled using default value in Bar\n  },\n  b3: {\n    f1: 5,     // Filled using default value in Foo\n    f2: 1\n  }\n}\n\n\nBasically, fill in the defaults for fields only if the record is present or record is filled in using a default. Do not create a record only because a nested field specifies default value.", "bodyHTML": "<p dir=\"auto\">This is not needed. You need to traverse the nested schemas only if the value is present at the top-level.</p>\n<p dir=\"auto\">Consider this:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"record Foo {\n  f1: int = 5\n  f2: optional int\n }\n\nrecord Bar {\n   b1: Foo = { f2: 10 }\n   b2: optional Foo\n   b3: Foo\n}\n\"><pre><code>record Foo {\n  f1: int = 5\n  f2: optional int\n }\n\nrecord Bar {\n   b1: Foo = { f2: 10 }\n   b2: optional Foo\n   b3: Foo\n}\n\n</code></pre></div>\n<p dir=\"auto\">So the scenarios are (top-level is Bar):<br>\n1.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"{\n  b1: {\n    f1: 1\n  },\n  b2: {}\n}\n\"><pre><code>{\n  b1: {\n    f1: 1\n  },\n  b2: {}\n}\n\n</code></pre></div>\n<p dir=\"auto\">Output with defaults filled in should be:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"{\n  b1: {\n    f1: 1\n  },\n   b2: {\n    f1: 5,     // Filled using default value in Foo\n  }\n}\n\"><pre><code>{\n  b1: {\n    f1: 1\n  },\n   b2: {\n    f1: 5,     // Filled using default value in Foo\n  }\n}\n\n</code></pre></div>\n<p dir=\"auto\">b3 is not present in the input data and so shouldn't be filled in.</p>\n<ol start=\"2\" dir=\"auto\">\n<li></li>\n</ol>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"{\n  b3: {\n    f2: 1\n  }\n}\n\"><pre><code>{\n  b3: {\n    f2: 1\n  }\n}\n\n</code></pre></div>\n<p dir=\"auto\">Output with defaults filled in should be:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"{\n b1: {.         // Filled because of default value in Bar\n   f1: 5,        // Filled using default value in Foo\n    f2: 10     // Filled using default value in Bar\n  },\n  b3: {\n    f1: 5,     // Filled using default value in Foo\n    f2: 1\n  }\n}\n\"><pre><code>{\n b1: {.         // Filled because of default value in Bar\n   f1: 5,        // Filled using default value in Foo\n    f2: 10     // Filled using default value in Bar\n  },\n  b3: {\n    f1: 5,     // Filled using default value in Foo\n    f2: 1\n  }\n}\n\n</code></pre></div>\n<p dir=\"auto\">Basically, fill in the defaults for fields only if the record is present or record is filled in using a default. Do not create a record only because a nested field specifies default value.</p>", "author": "karthikbalasub", "createdAt": "2020-06-26T08:48:56Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,51 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        if (!dataMap.containsKey(field.getName()))\n+        {\n+          if (field.getDefault() != null)\n+          {\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n+          }", "originalCommit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NTI1MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447875251", "bodyText": "I think this is addressed, had put exact same cases in test", "author": "BrianPin", "createdAt": "2020-06-30T17:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1Mzc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +93,92 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n             }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas of this field in the record\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -176,9 +179,8 @@ public class ResponseUtils\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMDg1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447530854", "body": "If you change this to a create with return entity, then you can controll the data being returned (by sending it for create) and thus can test multiple scenarios", "bodyText": "If you change this to a create with return entity, then you can controll the data being returned (by sending it for create) and thus can test multiple scenarios", "bodyHTML": "<p dir=\"auto\">If you change this to a create with return entity, then you can controll the data being returned (by sending it for create) and thus can test multiple scenarios</p>", "author": "karthikbalasub", "createdAt": "2020-06-30T09:06:38Z", "path": "restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.linkedin.restli.examples.greetings.server.defaults;\n+\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.server.annotations.RestLiCollection;\n+import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n+\n+\n+@RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n+public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long, HighLevelRecordWithDefault>\n+{\n+  @Override\n+  public HighLevelRecordWithDefault get(Long keyId)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NDg1NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447874855", "bodyText": "ok", "author": "BrianPin", "createdAt": "2020-06-30T17:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMDg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\nindex dfa578c84..0ee81a92a 100644\n--- a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n+++ b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n", "chunk": "@@ -1,8 +1,29 @@\n package com.linkedin.restli.examples.greetings.server.defaults;\n \n+import com.linkedin.restli.common.HttpStatus;\n import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n+import com.linkedin.restli.examples.greetings.api.Empty;\n+import com.linkedin.restli.server.ActionResult;\n+import com.linkedin.restli.server.BatchFinderResult;\n+import com.linkedin.restli.server.CollectionResult;\n+import com.linkedin.restli.server.PagingContext;\n+import com.linkedin.restli.server.annotations.Action;\n+import com.linkedin.restli.server.annotations.ActionParam;\n+import com.linkedin.restli.server.annotations.BatchFinder;\n+import com.linkedin.restli.server.annotations.Finder;\n+import com.linkedin.restli.server.annotations.PagingContextParam;\n+import com.linkedin.restli.server.annotations.QueryParam;\n import com.linkedin.restli.server.annotations.RestLiCollection;\n import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import sun.util.resources.cldr.ha.CalendarData_ha_Latn_GH;\n \n \n @RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\nindex 0ee81a92a..99b91f8a9 100644\n--- a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n+++ b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n", "chunk": "@@ -23,7 +23,6 @@ import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-import sun.util.resources.cldr.ha.CalendarData_ha_Latn_GH;\n \n \n @RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\ndeleted file mode 100644\nindex 99b91f8a9..000000000\n--- a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n+++ /dev/null\n", "chunk": "@@ -1,92 +0,0 @@\n-package com.linkedin.restli.examples.greetings.server.defaults;\n-\n-import com.linkedin.restli.common.HttpStatus;\n-import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n-import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n-import com.linkedin.restli.examples.greetings.api.Empty;\n-import com.linkedin.restli.server.ActionResult;\n-import com.linkedin.restli.server.BatchFinderResult;\n-import com.linkedin.restli.server.CollectionResult;\n-import com.linkedin.restli.server.PagingContext;\n-import com.linkedin.restli.server.annotations.Action;\n-import com.linkedin.restli.server.annotations.ActionParam;\n-import com.linkedin.restli.server.annotations.BatchFinder;\n-import com.linkedin.restli.server.annotations.Finder;\n-import com.linkedin.restli.server.annotations.PagingContextParam;\n-import com.linkedin.restli.server.annotations.QueryParam;\n-import com.linkedin.restli.server.annotations.RestLiCollection;\n-import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-\n-@RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n-public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long, HighLevelRecordWithDefault>\n-{\n-  @Override\n-  public HighLevelRecordWithDefault get(Long keyId)\n-  {\n-    return new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(keyId));\n-  }\n-\n-  @Override\n-  public Map<Long, HighLevelRecordWithDefault> batchGet(Set<Long> ids)\n-  {\n-    Map<Long, HighLevelRecordWithDefault> result = new HashMap<>();\n-    for (Long id : ids)\n-    {\n-      result.put(id, new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(id)));\n-    }\n-    return result;\n-  }\n-\n-  @Override\n-  public List<HighLevelRecordWithDefault> getAll(@PagingContextParam PagingContext pagingContext)\n-  {\n-    List<HighLevelRecordWithDefault> result = new LinkedList<>();\n-    for (int i = 0; i < 3; i++)\n-    {\n-      result.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n-    }\n-    return result;\n-  }\n-\n-  @Finder(\"findRecords\")\n-  public List<HighLevelRecordWithDefault> findRecords(@QueryParam(\"noDefaultFieldA\") Integer fieldA)\n-  {\n-    List<HighLevelRecordWithDefault> finderResult = new ArrayList<>();\n-    finderResult.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(fieldA));\n-    return finderResult;\n-  }\n-\n-  @BatchFinder(value = \"searchRecords\", batchParam = \"criteria\")\n-  public BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> searchRecords(\n-      @QueryParam(\"criteria\") RecordCriteria[] criteria)\n-  {\n-\n-    BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> result = new BatchFinderResult<RecordCriteria,\n-        HighLevelRecordWithDefault, Empty>();\n-    for (int i = 0; i < criteria.length; i++)\n-    {\n-      List<HighLevelRecordWithDefault> currentCriteriaResult = Collections.singletonList(\n-          new HighLevelRecordWithDefault().setNoDefaultFieldA(criteria[i].getIntWithoutDefault()));\n-      CollectionResult<HighLevelRecordWithDefault, Empty> cr = new CollectionResult<HighLevelRecordWithDefault, Empty>(\n-          currentCriteriaResult, currentCriteriaResult.size());\n-      result.putResult(criteria[i], cr);\n-    }\n-    return result;\n-  }\n-\n-  @Action(name = \"defaultFillAction\")\n-  public ActionResult<HighLevelRecordWithDefault> takeAction(@ActionParam(\"actionParam\") Long id)\n-  {\n-    return new ActionResult<HighLevelRecordWithDefault>(new HighLevelRecordWithDefault().setNoDefaultFieldA(\n-        Math.toIntExact(id)),\n-        HttpStatus.S_200_OK);\n-  }\n-}\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\nnew file mode 100644\nindex 000000000..dfa578c84\n--- /dev/null\n+++ b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n", "chunk": "@@ -0,0 +1,19 @@\n+package com.linkedin.restli.examples.greetings.server.defaults;\n+\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.server.annotations.RestLiCollection;\n+import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n+\n+\n+@RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n+public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long, HighLevelRecordWithDefault>\n+{\n+  @Override\n+  public HighLevelRecordWithDefault get(Long keyId)\n+  {\n+    HighLevelRecordWithDefault result = new HighLevelRecordWithDefault();\n+    result.setIntDefaultFieldB(-1);\n+    return result;\n+  }\n+}\n+\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\nindex dfa578c84..0ee81a92a 100644\n--- a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n+++ b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n", "chunk": "@@ -11,9 +32,65 @@ public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long\n   @Override\n   public HighLevelRecordWithDefault get(Long keyId)\n   {\n-    HighLevelRecordWithDefault result = new HighLevelRecordWithDefault();\n-    result.setIntDefaultFieldB(-1);\n+    return new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(keyId));\n+  }\n+\n+  @Override\n+  public Map<Long, HighLevelRecordWithDefault> batchGet(Set<Long> ids)\n+  {\n+    Map<Long, HighLevelRecordWithDefault> result = new HashMap<>();\n+    for (Long id : ids)\n+    {\n+      result.put(id, new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(id)));\n+    }\n     return result;\n   }\n-}\n \n+  @Override\n+  public List<HighLevelRecordWithDefault> getAll(@PagingContextParam PagingContext pagingContext)\n+  {\n+    List<HighLevelRecordWithDefault> result = new LinkedList<>();\n+    for (int i = 0; i < 3; i++)\n+    {\n+      result.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n+    }\n+    return result;\n+  }\n+\n+  @Finder(\"HighLevelRecord\")\n+  public List<HighLevelRecordWithDefault> findHighLevelRecord(@QueryParam(\"totalCount\") Integer totalCount)\n+  {\n+    List<HighLevelRecordWithDefault> ordersCollection = new ArrayList<>();\n+    for (int i = 0; i < totalCount; i++)\n+    {\n+      ordersCollection.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n+    }\n+    return ordersCollection;\n+  }\n+\n+  @BatchFinder(value = \"searchRecords\", batchParam = \"criteria\")\n+  public BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> searchRecords(\n+      @QueryParam(\"criteria\") RecordCriteria[] criteria)\n+  {\n+\n+    BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> result = new BatchFinderResult<RecordCriteria,\n+        HighLevelRecordWithDefault, Empty>();\n+    for (int i = 0; i < criteria.length; i++)\n+    {\n+      List<HighLevelRecordWithDefault> currentCriteriaResult = Collections.singletonList(\n+          new HighLevelRecordWithDefault().setNoDefaultFieldA(criteria[i].getIntWithoutDefault()));\n+      CollectionResult<HighLevelRecordWithDefault, Empty> cr = new CollectionResult<HighLevelRecordWithDefault, Empty>(\n+          currentCriteriaResult, currentCriteriaResult.size());\n+      result.putResult(criteria[i], cr);\n+    }\n+    return result;\n+  }\n+\n+  @Action(name = \"defaultFillAction\")\n+  public ActionResult<HighLevelRecordWithDefault> takeAction(@ActionParam(\"actionParam\") Long id)\n+  {\n+    return new ActionResult<HighLevelRecordWithDefault>(new HighLevelRecordWithDefault().setNoDefaultFieldA(\n+        Math.toIntExact(id)),\n+        HttpStatus.S_200_OK);\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\nindex dfa578c84..0ee81a92a 100644\n--- a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n+++ b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n", "chunk": "@@ -11,9 +32,65 @@ public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long\n   @Override\n   public HighLevelRecordWithDefault get(Long keyId)\n   {\n-    HighLevelRecordWithDefault result = new HighLevelRecordWithDefault();\n-    result.setIntDefaultFieldB(-1);\n+    return new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(keyId));\n+  }\n+\n+  @Override\n+  public Map<Long, HighLevelRecordWithDefault> batchGet(Set<Long> ids)\n+  {\n+    Map<Long, HighLevelRecordWithDefault> result = new HashMap<>();\n+    for (Long id : ids)\n+    {\n+      result.put(id, new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(id)));\n+    }\n     return result;\n   }\n-}\n \n+  @Override\n+  public List<HighLevelRecordWithDefault> getAll(@PagingContextParam PagingContext pagingContext)\n+  {\n+    List<HighLevelRecordWithDefault> result = new LinkedList<>();\n+    for (int i = 0; i < 3; i++)\n+    {\n+      result.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n+    }\n+    return result;\n+  }\n+\n+  @Finder(\"HighLevelRecord\")\n+  public List<HighLevelRecordWithDefault> findHighLevelRecord(@QueryParam(\"totalCount\") Integer totalCount)\n+  {\n+    List<HighLevelRecordWithDefault> ordersCollection = new ArrayList<>();\n+    for (int i = 0; i < totalCount; i++)\n+    {\n+      ordersCollection.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n+    }\n+    return ordersCollection;\n+  }\n+\n+  @BatchFinder(value = \"searchRecords\", batchParam = \"criteria\")\n+  public BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> searchRecords(\n+      @QueryParam(\"criteria\") RecordCriteria[] criteria)\n+  {\n+\n+    BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> result = new BatchFinderResult<RecordCriteria,\n+        HighLevelRecordWithDefault, Empty>();\n+    for (int i = 0; i < criteria.length; i++)\n+    {\n+      List<HighLevelRecordWithDefault> currentCriteriaResult = Collections.singletonList(\n+          new HighLevelRecordWithDefault().setNoDefaultFieldA(criteria[i].getIntWithoutDefault()));\n+      CollectionResult<HighLevelRecordWithDefault, Empty> cr = new CollectionResult<HighLevelRecordWithDefault, Empty>(\n+          currentCriteriaResult, currentCriteriaResult.size());\n+      result.putResult(criteria[i], cr);\n+    }\n+    return result;\n+  }\n+\n+  @Action(name = \"defaultFillAction\")\n+  public ActionResult<HighLevelRecordWithDefault> takeAction(@ActionParam(\"actionParam\") Long id)\n+  {\n+    return new ActionResult<HighLevelRecordWithDefault>(new HighLevelRecordWithDefault().setNoDefaultFieldA(\n+        Math.toIntExact(id)),\n+        HttpStatus.S_200_OK);\n+  }\n+}\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\ndeleted file mode 100644\nindex 0ee81a92a..000000000\n--- a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n+++ /dev/null\n", "chunk": "@@ -1,96 +0,0 @@\n-package com.linkedin.restli.examples.greetings.server.defaults;\n-\n-import com.linkedin.restli.common.HttpStatus;\n-import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n-import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n-import com.linkedin.restli.examples.greetings.api.Empty;\n-import com.linkedin.restli.server.ActionResult;\n-import com.linkedin.restli.server.BatchFinderResult;\n-import com.linkedin.restli.server.CollectionResult;\n-import com.linkedin.restli.server.PagingContext;\n-import com.linkedin.restli.server.annotations.Action;\n-import com.linkedin.restli.server.annotations.ActionParam;\n-import com.linkedin.restli.server.annotations.BatchFinder;\n-import com.linkedin.restli.server.annotations.Finder;\n-import com.linkedin.restli.server.annotations.PagingContextParam;\n-import com.linkedin.restli.server.annotations.QueryParam;\n-import com.linkedin.restli.server.annotations.RestLiCollection;\n-import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import sun.util.resources.cldr.ha.CalendarData_ha_Latn_GH;\n-\n-\n-@RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n-public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long, HighLevelRecordWithDefault>\n-{\n-  @Override\n-  public HighLevelRecordWithDefault get(Long keyId)\n-  {\n-    return new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(keyId));\n-  }\n-\n-  @Override\n-  public Map<Long, HighLevelRecordWithDefault> batchGet(Set<Long> ids)\n-  {\n-    Map<Long, HighLevelRecordWithDefault> result = new HashMap<>();\n-    for (Long id : ids)\n-    {\n-      result.put(id, new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(id)));\n-    }\n-    return result;\n-  }\n-\n-  @Override\n-  public List<HighLevelRecordWithDefault> getAll(@PagingContextParam PagingContext pagingContext)\n-  {\n-    List<HighLevelRecordWithDefault> result = new LinkedList<>();\n-    for (int i = 0; i < 3; i++)\n-    {\n-      result.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n-    }\n-    return result;\n-  }\n-\n-  @Finder(\"HighLevelRecord\")\n-  public List<HighLevelRecordWithDefault> findHighLevelRecord(@QueryParam(\"totalCount\") Integer totalCount)\n-  {\n-    List<HighLevelRecordWithDefault> ordersCollection = new ArrayList<>();\n-    for (int i = 0; i < totalCount; i++)\n-    {\n-      ordersCollection.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n-    }\n-    return ordersCollection;\n-  }\n-\n-  @BatchFinder(value = \"searchRecords\", batchParam = \"criteria\")\n-  public BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> searchRecords(\n-      @QueryParam(\"criteria\") RecordCriteria[] criteria)\n-  {\n-\n-    BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> result = new BatchFinderResult<RecordCriteria,\n-        HighLevelRecordWithDefault, Empty>();\n-    for (int i = 0; i < criteria.length; i++)\n-    {\n-      List<HighLevelRecordWithDefault> currentCriteriaResult = Collections.singletonList(\n-          new HighLevelRecordWithDefault().setNoDefaultFieldA(criteria[i].getIntWithoutDefault()));\n-      CollectionResult<HighLevelRecordWithDefault, Empty> cr = new CollectionResult<HighLevelRecordWithDefault, Empty>(\n-          currentCriteriaResult, currentCriteriaResult.size());\n-      result.putResult(criteria[i], cr);\n-    }\n-    return result;\n-  }\n-\n-  @Action(name = \"defaultFillAction\")\n-  public ActionResult<HighLevelRecordWithDefault> takeAction(@ActionParam(\"actionParam\") Long id)\n-  {\n-    return new ActionResult<HighLevelRecordWithDefault>(new HighLevelRecordWithDefault().setNoDefaultFieldA(\n-        Math.toIntExact(id)),\n-        HttpStatus.S_200_OK);\n-  }\n-}\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\nnew file mode 100644\nindex 000000000..dfa578c84\n--- /dev/null\n+++ b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n", "chunk": "@@ -0,0 +1,19 @@\n+package com.linkedin.restli.examples.greetings.server.defaults;\n+\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.server.annotations.RestLiCollection;\n+import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n+\n+\n+@RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n+public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long, HighLevelRecordWithDefault>\n+{\n+  @Override\n+  public HighLevelRecordWithDefault get(Long keyId)\n+  {\n+    HighLevelRecordWithDefault result = new HighLevelRecordWithDefault();\n+    result.setIntDefaultFieldB(-1);\n+    return result;\n+  }\n+}\n+\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\nindex dfa578c84..0ee81a92a 100644\n--- a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n+++ b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n", "chunk": "@@ -11,9 +32,65 @@ public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long\n   @Override\n   public HighLevelRecordWithDefault get(Long keyId)\n   {\n-    HighLevelRecordWithDefault result = new HighLevelRecordWithDefault();\n-    result.setIntDefaultFieldB(-1);\n+    return new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(keyId));\n+  }\n+\n+  @Override\n+  public Map<Long, HighLevelRecordWithDefault> batchGet(Set<Long> ids)\n+  {\n+    Map<Long, HighLevelRecordWithDefault> result = new HashMap<>();\n+    for (Long id : ids)\n+    {\n+      result.put(id, new HighLevelRecordWithDefault().setNoDefaultFieldA(Math.toIntExact(id)));\n+    }\n     return result;\n   }\n-}\n \n+  @Override\n+  public List<HighLevelRecordWithDefault> getAll(@PagingContextParam PagingContext pagingContext)\n+  {\n+    List<HighLevelRecordWithDefault> result = new LinkedList<>();\n+    for (int i = 0; i < 3; i++)\n+    {\n+      result.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n+    }\n+    return result;\n+  }\n+\n+  @Finder(\"HighLevelRecord\")\n+  public List<HighLevelRecordWithDefault> findHighLevelRecord(@QueryParam(\"totalCount\") Integer totalCount)\n+  {\n+    List<HighLevelRecordWithDefault> ordersCollection = new ArrayList<>();\n+    for (int i = 0; i < totalCount; i++)\n+    {\n+      ordersCollection.add(new HighLevelRecordWithDefault().setNoDefaultFieldA(i));\n+    }\n+    return ordersCollection;\n+  }\n+\n+  @BatchFinder(value = \"searchRecords\", batchParam = \"criteria\")\n+  public BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> searchRecords(\n+      @QueryParam(\"criteria\") RecordCriteria[] criteria)\n+  {\n+\n+    BatchFinderResult<RecordCriteria, HighLevelRecordWithDefault, Empty> result = new BatchFinderResult<RecordCriteria,\n+        HighLevelRecordWithDefault, Empty>();\n+    for (int i = 0; i < criteria.length; i++)\n+    {\n+      List<HighLevelRecordWithDefault> currentCriteriaResult = Collections.singletonList(\n+          new HighLevelRecordWithDefault().setNoDefaultFieldA(criteria[i].getIntWithoutDefault()));\n+      CollectionResult<HighLevelRecordWithDefault, Empty> cr = new CollectionResult<HighLevelRecordWithDefault, Empty>(\n+          currentCriteriaResult, currentCriteriaResult.size());\n+      result.putResult(criteria[i], cr);\n+    }\n+    return result;\n+  }\n+\n+  @Action(name = \"defaultFillAction\")\n+  public ActionResult<HighLevelRecordWithDefault> takeAction(@ActionParam(\"actionParam\") Long id)\n+  {\n+    return new ActionResult<HighLevelRecordWithDefault>(new HighLevelRecordWithDefault().setNoDefaultFieldA(\n+        Math.toIntExact(id)),\n+        HttpStatus.S_200_OK);\n+  }\n+}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTUyMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447531522", "body": "Complete the doc, I think it would be useful to provide the pseudo code you had in the doc.", "bodyText": "Complete the doc, I think it would be useful to provide the pseudo code you had in the doc.", "bodyHTML": "<p dir=\"auto\">Complete the doc, I think it would be useful to provide the pseudo code you had in the doc.</p>", "author": "karthikbalasub", "createdAt": "2020-06-30T09:07:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -92,9 +93,26 @@ public class ResponseUtils\n   }\n \n   /**\n-   *\n-   * @param dataSchema\n-   * @param dataMap\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n    * @return a new different data map that contains original data plus the default values\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,11 +118,17 @@ public class ResponseUtils\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled = new DataMap();\n+\n+    DataMap dataDefaultFilled;\n     if (dataMap != null)\n     {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n       dataDefaultFilled.putAll(dataMap);\n     }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();\n+    }\n \n     if (dataSchema instanceof TyperefDataSchema)\n     {\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 19fcd2134..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -130,12 +129,7 @@ public class ResponseUtils\n       dataDefaultFilled = new DataMap();\n     }\n \n-    if (dataSchema instanceof TyperefDataSchema)\n-    {\n-      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n-    }\n-    else if (dataSchema instanceof RecordDataSchema)\n+    if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTgzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447531831", "body": "Why do you need to copy?", "bodyText": "Why do you need to copy?", "bodyHTML": "<p dir=\"auto\">Why do you need to copy?</p>", "author": "karthikbalasub", "createdAt": "2020-06-30T09:08:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NDQ2MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447874460", "bodyText": "It is for return, If I don't return a DataMap, then for non existing field that has a default value, I will need to pass in a DataMap for putting data.", "author": "BrianPin", "createdAt": "2020-06-30T17:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTgzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -92,9 +93,26 @@ public class ResponseUtils\n   }\n \n   /**\n-   *\n-   * @param dataSchema\n-   * @param dataMap\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n    * @return a new different data map that contains original data plus the default values\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,11 +118,17 @@ public class ResponseUtils\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled = new DataMap();\n+\n+    DataMap dataDefaultFilled;\n     if (dataMap != null)\n     {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n       dataDefaultFilled.putAll(dataMap);\n     }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();\n+    }\n \n     if (dataSchema instanceof TyperefDataSchema)\n     {\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 19fcd2134..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -130,12 +129,7 @@ public class ResponseUtils\n       dataDefaultFilled = new DataMap();\n     }\n \n-    if (dataSchema instanceof TyperefDataSchema)\n-    {\n-      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n-    }\n-    else if (dataSchema instanceof RecordDataSchema)\n+    if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzY3MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447533670", "body": "redundant as the containsKey check above ensures the value wouldn't be null", "bodyText": "redundant as the containsKey check above ensures the value wouldn't be null", "bodyHTML": "<p dir=\"auto\">redundant as the containsKey check above ensures the value wouldn't be null</p>", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:01Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDIzOA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447870238", "bodyText": "yes", "author": "BrianPin", "createdAt": "2020-06-30T17:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,18 +138,9 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n             DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n           }\n           else if (field.getDefault() != null)\n           {\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -149,24 +156,7 @@ public class ResponseUtils\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n-            {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n-            }\n-            else\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n-          }\n+          dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, null));\n         }\n         else // primitive | complex data schemas of this field in the record\n         {\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 19fcd2134..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -145,18 +139,37 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-            dataDefaultFilled.put(field.getName(), fieldFilled);\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, null));\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            if (dereferencedSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n+            }\n+            else\n+            {\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n+            }\n+          }\n         }\n         else // primitive | complex data schemas of this field in the record\n         {\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzg4OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447533889", "body": "redundant as you are updating the field value inplace", "bodyText": "redundant as you are updating the field value inplace", "bodyHTML": "<p dir=\"auto\">redundant as you are updating the field value inplace</p>", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:20Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2OTM2NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447869365", "bodyText": "Just to be sure I get you correctly, I don't get why this is redundant, because as for now it is not in place yet.", "author": "BrianPin", "createdAt": "2020-06-30T17:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,18 +138,9 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n             DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n           }\n           else if (field.getDefault() != null)\n           {\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -149,24 +156,7 @@ public class ResponseUtils\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n-            {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n-            }\n-            else\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n-          }\n+          dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, null));\n         }\n         else // primitive | complex data schemas of this field in the record\n         {\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 19fcd2134..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -145,18 +139,37 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-            dataDefaultFilled.put(field.getName(), fieldFilled);\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, null));\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            if (dereferencedSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n+            }\n+            else\n+            {\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n+            }\n+          }\n         }\n         else // primitive | complex data schemas of this field in the record\n         {\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDE4Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447534182", "body": "Non reachable code block", "bodyText": "Non reachable code block", "bodyHTML": "<p dir=\"auto\">Non reachable code block</p>", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:47Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDEwOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447870109", "bodyText": "agree, will make fix", "author": "BrianPin", "createdAt": "2020-06-30T17:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDE4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,18 +138,9 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n             DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n           }\n           else if (field.getDefault() != null)\n           {\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -149,24 +156,7 @@ public class ResponseUtils\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n-            {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n-            }\n-            else\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n-          }\n+          dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, null));\n         }\n         else // primitive | complex data schemas of this field in the record\n         {\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 19fcd2134..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -145,18 +139,37 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-            dataDefaultFilled.put(field.getName(), fieldFilled);\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, null));\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            if (dereferencedSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n+            }\n+            else\n+            {\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n+            }\n+          }\n         }\n         else // primitive | complex data schemas of this field in the record\n         {\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447535229", "body": "Why duplicate the logic for checking Record/Typeref again? Why not just make a recursive call for each field?", "bodyText": "Why duplicate the logic for checking Record/Typeref again? Why not just make a recursive call for each field?", "bodyHTML": "<p dir=\"auto\">Why duplicate the logic for checking Record/Typeref again? Why not just make a recursive call for each field?</p>", "author": "karthikbalasub", "createdAt": "2020-06-30T09:13:27Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2NTk2Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447865962", "bodyText": "good suggestion -> For each field, make a recursive call for its field schema and data, to make code shorter", "author": "BrianPin", "createdAt": "2020-06-30T17:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MzA5OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r449273098", "bodyText": "I found here it is needed to differentiate the case but I do changed the code for the redundant logic of checking assigned field. but for this part about \"record field and typeref field logic redundancy\" I feel I can not change it because there are some logic necessary, let me know!", "author": "BrianPin", "createdAt": "2020-07-02T21:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTUyNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454615524", "bodyText": "I think you can simplify the logic by reversing the checks.\nFirst check and compute the field value:\nif( dataDefaultFilled.containsKey())\n   Object fieldData = // get data from datamap\nelse if field has default\n  fieldData = // get field default.\nelse\n  // continue (nothing to do).\n\nThen compute the default for the field by calling recursively:\nif fieldData instaceOf DataMap || instance of DataList\n  fieldData = fillInDefaults(fieldData, fieldSchema)\n\ndataDefaultFilled.put(fieldName, fieldData)", "author": "karthikbalasub", "createdAt": "2020-07-14T20:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,18 +138,9 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n             DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n           }\n           else if (field.getDefault() != null)\n           {\n", "next_change": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -149,24 +156,7 @@ public class ResponseUtils\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n-            {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n-            }\n-            else\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n-          }\n+          dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, null));\n         }\n         else // primitive | complex data schemas of this field in the record\n         {\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 19fcd2134..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -145,18 +139,37 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-            dataDefaultFilled.put(field.getName(), fieldFilled);\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, null));\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            if (dereferencedSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n+            }\n+            else\n+            {\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n+            }\n+          }\n         }\n         else // primitive | complex data schemas of this field in the record\n         {\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzOTU4NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447539585", "body": "I'm don't think this would work for batch, finder or action methods. Can you add test coverage for these?\r\n\r\nCheck the restli validator on response method to understand different response structures. I feel it might be easier to add the fill default logic in ResponseBuilders\r\n", "bodyText": "I'm don't think this would work for batch, finder or action methods. Can you add test coverage for these?\nCheck the restli validator on response method to understand different response structures. I feel it might be easier to add the fill default logic in ResponseBuilders", "bodyHTML": "<p dir=\"auto\">I'm don't think this would work for batch, finder or action methods. Can you add test coverage for these?</p>\n<p dir=\"auto\">Check the restli validator on response method to understand different response structures. I feel it might be easier to add the fill default logic in ResponseBuilders</p>", "author": "karthikbalasub", "createdAt": "2020-06-30T09:20:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -98,6 +189,15 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.isDefaultValueFillInRequested())\n+      {\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          dataMap = fillInDefaultValues(dataSchema, dataMap);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2MzIyOA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447863228", "bodyText": "I saw there is a RestLiValidationFilter which implements Filter interface, it has a onResponse function,\nalso there are multiple **ResponseBuilders where they all share same interface RestLiResponseBuilder\nI don't know how to fit the fill-default in there yet, will dig deeper.", "author": "BrianPin", "createdAt": "2020-06-30T17:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzOTU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -189,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          dataMap = fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -194,7 +117,19 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(\"sendDefaults\") &&\n+          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      {\n+        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -125,8 +131,9 @@ public class ResponseUtils\n       }\n \n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(\"sendDefaults\") &&\n-          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          dataSchema != null)\n       {\n         getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n       }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -123,19 +148,15 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n-      DataSchema dataSchema = null;\n-      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-      if (valueClass != null)\n-      {\n-        dataSchema = DataTemplateUtil.getSchema(valueClass);\n-      }\n-\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          dataSchema != null)\n+      if (context.isDefaultValueFillInRequested())\n       {\n-        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          fillInDefaultValues(dataSchema, dataMap);\n+        }\n       }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -155,7 +195,7 @@ public class ResponseUtils\n         if (valueClass != null)\n         {\n           DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          fillInDefaultValues(dataSchema, dataMap);\n+          dataMap = fillInDefaultValues(dataSchema, dataMap);\n         }\n       }\n       String mimeType = context.getResponseMimeType();\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..c5991edc8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -189,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          dataMap = fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MDMxNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447940317", "body": "I'd suggest renaming this to be consistent with the terminology used elsewhere in this PR. `String FILL_DEFAULTS_PARAM = \"$fillDefaults\";` or `String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\"`", "bodyText": "I'd suggest renaming this to be consistent with the terminology used elsewhere in this PR. String FILL_DEFAULTS_PARAM = \"$fillDefaults\"; or String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\"", "bodyHTML": "<p dir=\"auto\">I'd suggest renaming this to be consistent with the terminology used elsewhere in this PR. <code>String FILL_DEFAULTS_PARAM = \"$fillDefaults\";</code> or <code>String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\"</code></p>", "author": "evanw555", "createdAt": "2020-06-30T19:52:13Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java", "diffHunk": "@@ -77,6 +77,7 @@\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n+  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex 37758a929..a2b8a1c0f 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -77,7 +77,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex a2b8a1c0f..fd57f0e78 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -77,7 +78,6 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex fd57f0e78..28f01e8c0 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -78,6 +78,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n+  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex 28f01e8c0..b507cd2d4 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -78,7 +78,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex b507cd2d4..525f40775 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -78,7 +78,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MTk5Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447941992", "body": "This is a mouthful. I'd suggest renaming to `isFillDefaultsRequested` or `isFillInDefaultsRequested`", "bodyText": "This is a mouthful. I'd suggest renaming to isFillDefaultsRequested or isFillInDefaultsRequested", "bodyHTML": "<p dir=\"auto\">This is a mouthful. I'd suggest renaming to <code>isFillDefaultsRequested</code> or <code>isFillInDefaultsRequested</code></p>", "author": "evanw555", "createdAt": "2020-06-30T19:55:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java", "diffHunk": "@@ -220,4 +220,15 @@\n    * @return whether the request specifies that the resource should return an entity\n    */\n   boolean isReturnEntityRequested();\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * This is to determine whether the service will fill in default values when the returned value record has some missing\n+   * field. In case:\n+   * 1. the client is requesting that the default value to be returned. Reads the appropriate\n+   * query parameter to determine this information, defaults to false if the query parameter isn't present.\n+   * 2. the server is configured to return default value for every request-response pair\n+   * @return true if the service need to fill in default value when the field of the return value record is absent\n+   */\n+  boolean isDefaultValueFillInRequested();", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\nindex 3acb4a94c..269d659a6 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n", "chunk": "@@ -229,6 +229,6 @@ public interface ResourceContext extends CustomRequestContext\n    * 2. the server is configured to return default value for every request-response pair\n    * @return true if the service need to fill in default value when the field of the return value record is absent\n    */\n-  boolean isDefaultValueFillInRequested();\n+  boolean isFillInDefaultsRequested();\n }\n \n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\nindex 269d659a6..087d0baa3 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n", "chunk": "@@ -230,5 +230,6 @@ public interface ResourceContext extends CustomRequestContext\n    * @return true if the service need to fill in default value when the field of the return value record is absent\n    */\n   boolean isFillInDefaultsRequested();\n+  void setFillInDefaultValues(boolean fillInDefaultValues);\n }\n \n", "next_change": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\nindex 087d0baa3..fa044255f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n", "chunk": "@@ -232,4 +239,3 @@ public interface ResourceContext extends CustomRequestContext\n   boolean isFillInDefaultsRequested();\n   void setFillInDefaultValues(boolean fillInDefaultValues);\n }\n-\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\nindex fa044255f..5f657463c 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n", "chunk": "@@ -227,15 +227,4 @@ public interface ResourceContext extends CustomRequestContext\n    * specified at the service level and apply to all resources and methods.\n    */\n   Set<String> getAlwaysProjectedFields();\n-\n-  /**\n-   * This is to determine whether the service will fill in default values when the returned value record has some missing\n-   * field. In case:\n-   * 1. the client is requesting that the default value to be returned. Reads the appropriate\n-   * query parameter to determine this information, defaults to false if the query parameter isn't present.\n-   * 2. the server is configured to return default value for every request-response pair\n-   * @return true if the service need to fill in default value when the field of the return value record is absent\n-   */\n-  boolean isFillInDefaultsRequested();\n-  void setFillInDefaultValues(boolean fillInDefaultValues);\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\nindex 5f657463c..9ff61935e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n", "chunk": "@@ -227,4 +227,14 @@ public interface ResourceContext extends CustomRequestContext\n    * specified at the service level and apply to all resources and methods.\n    */\n   Set<String> getAlwaysProjectedFields();\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * This is to determine whether the service will fill in default values when the returned value record has some missing\n+   * field. In case:\n+   * 1. the client is requesting that the default value to be returned. Reads the appropriate\n+   * query parameter to determine this information, defaults to false if the query parameter isn't present.\n+   * 2. the server is configured to return default value for every request-response pair\n+   * @return true if the service need to fill in default value when the field of the return value record is absent\n+   */\n+  boolean isDefaultValueFillInRequested();\n+}\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\nindex 9ff61935e..06eee88db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n", "chunk": "@@ -236,5 +236,5 @@ public interface ResourceContext extends CustomRequestContext\n    * 2. the server is configured to return default value for every request-response pair\n    * @return true if the service need to fill in default value when the field of the return value record is absent\n    */\n-  boolean isDefaultValueFillInRequested();\n+  boolean isFillInDefaultsRequested();\n }\n", "next_change": {"commit": "a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\nindex 06eee88db..fa044255f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n", "chunk": "@@ -237,4 +237,5 @@ public interface ResourceContext extends CustomRequestContext\n    * @return true if the service need to fill in default value when the field of the return value record is absent\n    */\n   boolean isFillInDefaultsRequested();\n+  void setFillInDefaultValues(boolean fillInDefaultValues);\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"oid": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "url": "https://github.com/linkedin/rest.li/commit/bc7fb8498fbed875417ca1926bb6bdc3560c144d", "message": "address Karthiks comment about right place to fill in default, also review the logic of filling defaults", "committedDate": "2020-07-02T21:13:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMTYwNg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454521606", "body": "Suggest changing the param to `$fillInDefaults` to be consistent", "bodyText": "Suggest changing the param to $fillInDefaults to be consistent", "bodyHTML": "<p dir=\"auto\">Suggest changing the param to <code>$fillInDefaults</code> to be consistent</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T17:27:16Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java", "diffHunk": "@@ -77,6 +77,7 @@\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0Mzg5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r457143897", "bodyText": "Yeah, will also need to change design doc", "author": "BrianPin", "createdAt": "2020-07-20T07:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMTYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex a886f9bde..a2b8a1c0f 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -77,7 +77,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex a2b8a1c0f..fd57f0e78 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -77,7 +78,6 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex fd57f0e78..28f01e8c0 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -78,6 +78,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n+  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex 28f01e8c0..b507cd2d4 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -78,7 +78,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex b507cd2d4..525f40775 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n", "chunk": "@@ -78,7 +78,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MDQwNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454580405", "body": "nit: remove the extra comma", "bodyText": "nit: remove the extra comma", "bodyHTML": "<p dir=\"auto\">nit: remove the extra comma</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T19:07:00Z", "path": "restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.examples;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.r2.RemoteInvocationException;\n+import com.linkedin.restli.client.ActionRequest;\n+import com.linkedin.restli.client.BatchFindRequest;\n+import com.linkedin.restli.client.BatchGetEntityRequest;\n+import com.linkedin.restli.client.FindRequest;\n+import com.linkedin.restli.client.GetAllRequest;\n+import com.linkedin.restli.client.GetRequest;\n+import com.linkedin.restli.client.response.BatchKVResponse;\n+import com.linkedin.restli.common.BatchFinderCriteriaResult;\n+import com.linkedin.restli.common.EntityResponse;\n+import com.linkedin.restli.common.RestConstants;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ * @author Brian Pin\n+ */\n+public class TestFillInDefaultValue  extends RestLiIntegrationTest\n+{\n+  private DataMap expectedTestData;\n+\n+  @BeforeClass\n+  public void initClass() throws Exception\n+  {\n+    super.init(Collections.emptyList());\n+    expectedTestData = new DataMap();\n+    expectedTestData.put(\"intDefaultFieldB\", -1);\n+    DataMap case1MidLevelRecordWithDefault = new DataMap();\n+    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n+    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n+    DataMap case1LowLevelRecordWithDefault = new DataMap();\n+    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n+    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n+    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n+    expectedTestData.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n+  }\n+\n+  @AfterClass\n+  public void shutDown() throws Exception\n+  {\n+    super.shutdown();\n+  }\n+\n+  @DataProvider(name = \"testGetData\")\n+  private Object[][] testGetData() throws CloneNotSupportedException\n+  {\n+    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    return new Object[][] {{1L, expected},};", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex e40135ff5..e452a7e01 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -79,7 +87,7 @@ public class TestFillInDefaultValue  extends RestLiIntegrationTest\n   private Object[][] testGetData() throws CloneNotSupportedException\n   {\n     HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    return new Object[][] {{1L, expected},};\n+    return new Object[][] {{1L, expected}};\n   }\n \n   @Test(dataProvider = \"testGetData\")\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\ndeleted file mode 100644\nindex e452a7e01..000000000\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ /dev/null\n", "chunk": "@@ -1,252 +0,0 @@\n-/*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n-package com.linkedin.restli.examples;\n-\n-import com.linkedin.data.Data;\n-import com.linkedin.data.DataList;\n-import com.linkedin.data.DataMap;\n-import com.linkedin.r2.RemoteInvocationException;\n-import com.linkedin.restli.client.ActionRequest;\n-import com.linkedin.restli.client.BatchFindRequest;\n-import com.linkedin.restli.client.BatchGetEntityRequest;\n-import com.linkedin.restli.client.FindRequest;\n-import com.linkedin.restli.client.GetAllRequest;\n-import com.linkedin.restli.client.GetRequest;\n-import com.linkedin.restli.client.response.BatchKVResponse;\n-import com.linkedin.restli.common.BatchFinderCriteriaResult;\n-import com.linkedin.restli.common.EntityResponse;\n-import com.linkedin.restli.common.RestConstants;\n-import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n-import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n-import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n-import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-/**\n- *\n- * @author Brian Pin\n- */\n-public class TestFillInDefaultValue  extends RestLiIntegrationTest\n-{\n-  private DataMap expectedTestData;\n-\n-  @BeforeClass\n-  public void initClass() throws Exception\n-  {\n-    super.init(Collections.emptyList());\n-    expectedTestData = new DataMap();\n-    expectedTestData.put(\"intDefaultFieldB\", -1);\n-    DataMap case1MidLevelRecordWithDefault = new DataMap();\n-    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n-    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n-    DataMap case1LowLevelRecordWithDefault = new DataMap();\n-    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n-    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n-    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n-    expectedTestData.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n-    DataMap defaultInArray = new DataMap();\n-    defaultInArray.put(\"intWithDefault\", 0);\n-    defaultInArray.put(\"intWithoutDefault\", 0);\n-    DataList defaultArrayField = new DataList();\n-    defaultArrayField.add(defaultInArray);\n-    expectedTestData.put(\"testFieldArray\", defaultArrayField);\n-  }\n-\n-  @AfterClass\n-  public void shutDown() throws Exception\n-  {\n-    super.shutdown();\n-  }\n-\n-  @DataProvider(name = \"testGetData\")\n-  private Object[][] testGetData() throws CloneNotSupportedException\n-  {\n-    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    return new Object[][] {{1L, expected}};\n-  }\n-\n-  @Test(dataProvider = \"testGetData\")\n-  public void testGet(Long id, HighLevelRecordWithDefault expectedRecord)\n-      throws RemoteInvocationException, IOException\n-  {\n-    FillInDefaultsRequestBuilders requestBuilders = new FillInDefaultsRequestBuilders();\n-    FillInDefaultsGetRequestBuilder getRequestBuilder = requestBuilders.get();\n-    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(id).setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true).build();\n-    HighLevelRecordWithDefault actual = getClient().sendRequest(req).getResponse().getEntity();\n-    Assert.assertEquals(actual, expectedRecord);\n-  }\n-\n-  @DataProvider(name = \"testGetDataNoFillIn\")\n-  private Object[][] testGetDataNoFillIn() throws CloneNotSupportedException\n-  {\n-    DataMap data = new DataMap();\n-    data.put(\"noDefaultFieldA\", 1);\n-    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(data.clone());\n-    return new Object[][] {{1L, expected}};\n-  }\n-\n-  @Test(dataProvider = \"testGetDataNoFillIn\")\n-  public void testGetWithFillInDefaults(Long id, HighLevelRecordWithDefault expectedRecord) throws RemoteInvocationException\n-  {\n-    FillInDefaultsRequestBuilders requestBuilders = new FillInDefaultsRequestBuilders();\n-    FillInDefaultsGetRequestBuilder getRequestBuilder = requestBuilders.get();\n-    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(id).build();\n-    HighLevelRecordWithDefault actual = getClient().sendRequest(req).getResponse().getEntity();\n-    Assert.assertEquals(actual, expectedRecord);\n-  }\n-\n-  @DataProvider(name = \"testBatchGetData\")\n-  private Object[][] testBatchGetData() throws CloneNotSupportedException\n-  {\n-    HighLevelRecordWithDefault a = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    HighLevelRecordWithDefault b = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n-    HighLevelRecordWithDefault c = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(3);\n-    return new Object[][]{\n-            {new Long[]{1L, 2L, 3L}, new HighLevelRecordWithDefault[]{a, b, c}}\n-    };\n-  }\n-\n-  @Test(dataProvider = \"testBatchGetData\")\n-  public void testFillInDefaultBatchGet(Long[] ids, HighLevelRecordWithDefault[] expected) throws RemoteInvocationException\n-  {\n-    Map<Integer, HighLevelRecordWithDefault> idToRecord = new HashMap<>();\n-    for (int i = 0; i < ids.length; i++)\n-    {\n-      idToRecord.put(Math.toIntExact(ids[i]), expected[i]);\n-    }\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    BatchGetEntityRequest<Long, HighLevelRecordWithDefault> request =\n-        builders.batchGet().setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true).ids(ids).build();\n-    BatchKVResponse<Long, EntityResponse<HighLevelRecordWithDefault>> batchKVResponse =\n-        getClient().sendRequest(request).getResponse().getEntity();\n-    for (Map.Entry<Long, EntityResponse<HighLevelRecordWithDefault>> entry : batchKVResponse.getResults().entrySet())\n-    {\n-      HighLevelRecordWithDefault actualEntity = entry.getValue().getEntity();\n-      Assert.assertEquals(actualEntity, idToRecord.getOrDefault(actualEntity.getNoDefaultFieldA(), null));\n-    }\n-  }\n-\n-  @DataProvider(name = \"testGetAllData\")\n-  private Object[] testGetAllData() throws CloneNotSupportedException {\n-    HighLevelRecordWithDefault a = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(0);\n-    HighLevelRecordWithDefault b = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    HighLevelRecordWithDefault c = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n-    Map<Integer, HighLevelRecordWithDefault> expect = new HashMap<>();\n-    expect.put(0, a);\n-    expect.put(1, b);\n-    expect.put(2, c);\n-    return new Object[]{expect};\n-  }\n-\n-  @Test(dataProvider = \"testGetAllData\")\n-  public void testFillInDefaultGetAll(Map<Integer, HighLevelRecordWithDefault> expected) throws RemoteInvocationException\n-  {\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    GetAllRequest<HighLevelRecordWithDefault> request =\n-        builders.getAll().setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true).build();\n-    List<HighLevelRecordWithDefault> allResult = getClient().sendRequest(request).getResponse().getEntity().getElements();\n-    Map<Integer, HighLevelRecordWithDefault> actual = new HashMap<>();\n-    for (HighLevelRecordWithDefault oneRecord : allResult)\n-    {\n-      actual.put(oneRecord.getNoDefaultFieldA(), oneRecord);\n-    }\n-    Assert.assertEquals(actual, expected);\n-  }\n-\n-  @DataProvider(name = \"testFinderData\")\n-  private Object[] testFinderData()\n-  {\n-    return new Integer[]{2, 3};\n-  }\n-\n-  @Test(dataProvider = \"testFinderData\")\n-  public void testFillInDefaultFinder(Integer fieldA) throws RemoteInvocationException\n-  {\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    FindRequest<HighLevelRecordWithDefault> request = builders.findByFindRecords()\n-        .setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true)\n-        .setParam(\"noDefaultFieldA\", fieldA).build();\n-    List<HighLevelRecordWithDefault> result = getClient().sendRequest(request).getResponse().getEntity().getElements();\n-    Set<HighLevelRecordWithDefault> actual = new HashSet<>(result);\n-    Set<HighLevelRecordWithDefault> expect = new HashSet<>();\n-    System.out.println(result);\n-    expect.add(new HighLevelRecordWithDefault(expectedTestData).setNoDefaultFieldA(fieldA));\n-    Assert.assertEquals(actual, expect);\n-  }\n-\n-  @DataProvider(name = \"testBatchFinderData\")\n-  private Object[][] testBatchFinderData() throws CloneNotSupportedException {\n-\n-    HighLevelRecordWithDefault expected1 = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    HighLevelRecordWithDefault expected2 = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n-    return new Object[][]{\n-            {\n-              new RecordCriteria[]{new RecordCriteria().setIntWithoutDefault(1), new RecordCriteria().setIntWithoutDefault(2)},\n-              new HighLevelRecordWithDefault[]{expected1, expected2}\n-            }\n-    };\n-  }\n-\n-  @Test(dataProvider = \"testBatchFinderData\")\n-  public void testFillInDefaultBatchFinder(Object[] criteria, HighLevelRecordWithDefault[] expected)\n-          throws RemoteInvocationException\n-  {\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    BatchFindRequest<HighLevelRecordWithDefault> request = builders.batchFindBySearchRecords()\n-        .addCriteriaParam((RecordCriteria) criteria[0])\n-        .addCriteriaParam((RecordCriteria) criteria[1])\n-        .setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true).build();\n-    List<BatchFinderCriteriaResult<HighLevelRecordWithDefault>> batchFinderCriteriaResults = getClient()\n-        .sendRequest(request).getResponse().getEntity().getResults();\n-    Set<HighLevelRecordWithDefault> actualActionResponse = new HashSet<>();\n-    for (BatchFinderCriteriaResult<HighLevelRecordWithDefault> result : batchFinderCriteriaResults)\n-    {\n-      actualActionResponse.addAll(result.getElements());\n-    }\n-    Set<HighLevelRecordWithDefault> expectedActionResponse = new HashSet<>(Arrays.asList(expected));\n-    Assert.assertEquals(actualActionResponse, expectedActionResponse);\n-  }\n-\n-  @DataProvider(name = \"testActionData\")\n-  private Object[] testActionData()\n-  {\n-    return new Long[]{1L, 2L};\n-  }\n-\n-  @Test(dataProvider = \"testActionData\")\n-  public void testFillInDefaultAction(Long actionParam) throws RemoteInvocationException {\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    ActionRequest<HighLevelRecordWithDefault> request = builders.actionDefaultFillAction().actionParamParam(actionParam)\n-        .setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true)\n-        .build();\n-    HighLevelRecordWithDefault actual = getClient().sendRequest(request).getResponse().getEntity();\n-    HighLevelRecordWithDefault expect = new HighLevelRecordWithDefault(expectedTestData)\n-            .setNoDefaultFieldA(Math.toIntExact(actionParam));\n-    Assert.assertEquals(actual, expect);\n-  }\n-}\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nnew file mode 100644\nindex 000000000..f2d249ac2\n--- /dev/null\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -0,0 +1,92 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.examples;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.r2.RemoteInvocationException;\n+import com.linkedin.restli.client.GetRequest;\n+import com.linkedin.restli.client.Response;\n+import com.linkedin.restli.common.RestConstants;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import java.io.IOException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ * @author Brian Pin\n+ */\n+public class TestFillInDefaultValue  extends RestLiIntegrationTest\n+{\n+  @BeforeClass\n+  public void initClass() throws Exception\n+  {\n+    super.init();\n+  }\n+\n+  @AfterClass\n+  public void shutDown() throws Exception\n+  {\n+    super.shutdown();\n+  }\n+\n+  @Test(dataProvider = \"testCaseProvider\")\n+  public void testClientControlledDefaultFilledIn(Long id, DataMap expectedData)\n+      throws RemoteInvocationException, IOException\n+  {\n+    FillInDefaultsRequestBuilders requestBuilders = new FillInDefaultsRequestBuilders();\n+    FillInDefaultsGetRequestBuilder getRequestBuilder = requestBuilders.get();\n+    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(1L).setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n+    HighLevelRecordWithDefault expectedRecord = new HighLevelRecordWithDefault(expectedData);\n+    Response<HighLevelRecordWithDefault> response = getClient().sendRequest(req).getResponse();\n+    Assert.assertEquals(response.getEntity(), expectedRecord);\n+  }\n+\n+  @DataProvider(name = \"testCaseProvider\")\n+  private static Object[][] testCaseProvider()\n+  {\n+    DataMap testCase1Data = new DataMap();\n+    testCase1Data.put(\"intDefaultFieldB\", -1);\n+    DataMap case1DataMidLevel = new DataMap();\n+    case1DataMidLevel.put(\"intWithDefault\", -1);\n+    DataMap case1DataLowLevel = new DataMap();\n+    case1DataLowLevel.put(\"nameWithDefault\", \"i_am_default_name\");\n+    DataMap case1DataLowLevelDefault = new DataMap();\n+    case1DataLowLevelDefault.put(\"nameWithDefault\", \"mid_default_a\");\n+    case1DataLowLevelDefault.put(\"nameWithoutDefault\", \"i_am_without_default_in_midlevel\");\n+    case1DataMidLevel.put(\"lowLevelRecordWithoutDefault\", case1DataLowLevel);\n+    case1DataMidLevel.put(\"lowLevelRecordWithDefault\", case1DataLowLevelDefault);\n+    testCase1Data.put(\"midLevelRecordWithoutDefault\", case1DataMidLevel);\n+    DataMap case1DataMidLevelDefault = new DataMap();\n+    case1DataMidLevelDefault.put(\"intWithDefault\", 0);\n+    case1DataMidLevelDefault.put(\"intWithoutDefault\", 0);\n+    testCase1Data.put(\"midLevelRecordWithoutDefault\", case1DataMidLevel);\n+    testCase1Data.put(\"midLevelRecordWithDefault\", case1DataMidLevelDefault);\n+\n+    return new Object[][] {\n+        {1L, testCase1Data},\n+    };\n+  }\n+}\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex f2d249ac2..6aa417eaa 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -67,26 +64,20 @@ public class TestFillInDefaultValue  extends RestLiIntegrationTest\n   @DataProvider(name = \"testCaseProvider\")\n   private static Object[][] testCaseProvider()\n   {\n-    DataMap testCase1Data = new DataMap();\n-    testCase1Data.put(\"intDefaultFieldB\", -1);\n-    DataMap case1DataMidLevel = new DataMap();\n-    case1DataMidLevel.put(\"intWithDefault\", -1);\n-    DataMap case1DataLowLevel = new DataMap();\n-    case1DataLowLevel.put(\"nameWithDefault\", \"i_am_default_name\");\n-    DataMap case1DataLowLevelDefault = new DataMap();\n-    case1DataLowLevelDefault.put(\"nameWithDefault\", \"mid_default_a\");\n-    case1DataLowLevelDefault.put(\"nameWithoutDefault\", \"i_am_without_default_in_midlevel\");\n-    case1DataMidLevel.put(\"lowLevelRecordWithoutDefault\", case1DataLowLevel);\n-    case1DataMidLevel.put(\"lowLevelRecordWithDefault\", case1DataLowLevelDefault);\n-    testCase1Data.put(\"midLevelRecordWithoutDefault\", case1DataMidLevel);\n-    DataMap case1DataMidLevelDefault = new DataMap();\n-    case1DataMidLevelDefault.put(\"intWithDefault\", 0);\n-    case1DataMidLevelDefault.put(\"intWithoutDefault\", 0);\n-    testCase1Data.put(\"midLevelRecordWithoutDefault\", case1DataMidLevel);\n-    testCase1Data.put(\"midLevelRecordWithDefault\", case1DataMidLevelDefault);\n+    // case 1\n+    DataMap testCase1Expected = new DataMap();\n+    testCase1Expected.put(\"intDefaultFieldB\", -1);\n+    DataMap case1MidLevelRecordWithDefault = new DataMap();\n+    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n+    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n+    DataMap case1LowLevelRecordWithDefault = new DataMap();\n+    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n+    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n+    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n+    testCase1Expected.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n \n     return new Object[][] {\n-        {1L, testCase1Data},\n+        {1L, testCase1Expected},\n     };\n   }\n }\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex 6aa417eaa..db2df0fd4 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -49,35 +76,153 @@ public class TestFillInDefaultValue  extends RestLiIntegrationTest\n     super.shutdown();\n   }\n \n-  @Test(dataProvider = \"testCaseProvider\")\n-  public void testClientControlledDefaultFilledIn(Long id, DataMap expectedData)\n+  @DataProvider(name = \"testGetData\")\n+  private Object[][] testGetData() throws CloneNotSupportedException\n+  {\n+    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    return new Object[][] {{1L, expected},};\n+  }\n+\n+  @Test(dataProvider = \"testGetData\")\n+  public void testGet(Long id, HighLevelRecordWithDefault expectedRecord)\n       throws RemoteInvocationException, IOException\n   {\n     FillInDefaultsRequestBuilders requestBuilders = new FillInDefaultsRequestBuilders();\n     FillInDefaultsGetRequestBuilder getRequestBuilder = requestBuilders.get();\n-    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(1L).setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n-    HighLevelRecordWithDefault expectedRecord = new HighLevelRecordWithDefault(expectedData);\n-    Response<HighLevelRecordWithDefault> response = getClient().sendRequest(req).getResponse();\n-    Assert.assertEquals(response.getEntity(), expectedRecord);\n+    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(id).setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n+    HighLevelRecordWithDefault actual = getClient().sendRequest(req).getResponse().getEntity();\n+    Assert.assertEquals(actual, expectedRecord);\n   }\n \n-  @DataProvider(name = \"testCaseProvider\")\n-  private static Object[][] testCaseProvider()\n+  @DataProvider(name = \"testBatchGetData\")\n+  private Object[][] testBatchGetData() throws CloneNotSupportedException\n   {\n-    // case 1\n-    DataMap testCase1Expected = new DataMap();\n-    testCase1Expected.put(\"intDefaultFieldB\", -1);\n-    DataMap case1MidLevelRecordWithDefault = new DataMap();\n-    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n-    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n-    DataMap case1LowLevelRecordWithDefault = new DataMap();\n-    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n-    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n-    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n-    testCase1Expected.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n+    HighLevelRecordWithDefault a = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    HighLevelRecordWithDefault b = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n+    HighLevelRecordWithDefault c = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(3);\n+    return new Object[][]{\n+            {new Long[]{1L, 2L, 3L}, new HighLevelRecordWithDefault[]{a, b, c}}\n+    };\n+  }\n \n-    return new Object[][] {\n-        {1L, testCase1Expected},\n+  @Test(dataProvider = \"testBatchGetData\")\n+  public void testFillInDefaultBatchGet(Long[] ids, HighLevelRecordWithDefault[] expected) throws RemoteInvocationException\n+  {\n+    Map<Integer, HighLevelRecordWithDefault> idToRecord = new HashMap<>();\n+    for (int i = 0; i < ids.length; i++)\n+    {\n+      idToRecord.put(Math.toIntExact(ids[i]), expected[i]);\n+    }\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    BatchGetEntityRequest<Long, HighLevelRecordWithDefault> request =\n+        builders.batchGet().setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).ids(ids).build();\n+    BatchKVResponse<Long, EntityResponse<HighLevelRecordWithDefault>> batchKVResponse =\n+        getClient().sendRequest(request).getResponse().getEntity();\n+    for (Map.Entry<Long, EntityResponse<HighLevelRecordWithDefault>> entry : batchKVResponse.getResults().entrySet())\n+    {\n+      HighLevelRecordWithDefault actualEntity = entry.getValue().getEntity();\n+      Assert.assertEquals(actualEntity, idToRecord.getOrDefault(actualEntity.getNoDefaultFieldA(), null));\n+    }\n+  }\n+\n+  @DataProvider(name = \"testGetAllData\")\n+  private Object[] testGetAllData() throws CloneNotSupportedException {\n+    HighLevelRecordWithDefault a = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(0);\n+    HighLevelRecordWithDefault b = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    HighLevelRecordWithDefault c = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n+    Map<Integer, HighLevelRecordWithDefault> expect = new HashMap<>();\n+    expect.put(0, a);\n+    expect.put(1, b);\n+    expect.put(2, c);\n+    return new Object[]{expect};\n+  }\n+\n+  @Test(dataProvider = \"testGetAllData\")\n+  public void testFillInDefaultGetAll(Map<Integer, HighLevelRecordWithDefault> expected) throws RemoteInvocationException\n+  {\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    GetAllRequest<HighLevelRecordWithDefault> request =\n+        builders.getAll().setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n+    List<HighLevelRecordWithDefault> allResult = getClient().sendRequest(request).getResponse().getEntity().getElements();\n+    Map<Integer, HighLevelRecordWithDefault> actual = new HashMap<>();\n+    for (HighLevelRecordWithDefault oneRecord : allResult)\n+    {\n+      actual.put(oneRecord.getNoDefaultFieldA(), oneRecord);\n+    }\n+    Assert.assertEquals(actual, expected);\n+  }\n+\n+  @DataProvider(name = \"testFinderData\")\n+  private Object[] testFinderData()\n+  {\n+    return new Integer[]{2, 3};\n+  }\n+\n+  @Test(dataProvider = \"testFinderData\")\n+  public void testFillInDefaultFinder(Integer count) throws RemoteInvocationException\n+  {\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    FindRequest<HighLevelRecordWithDefault> request = builders.findByHighLevelRecord()\n+        .setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true)\n+        .setParam(\"totalCount\", count).build();\n+    List<HighLevelRecordWithDefault> result = getClient().sendRequest(request).getResponse().getEntity().getElements();\n+    Set<HighLevelRecordWithDefault> actual = new HashSet<>(result);\n+    Set<HighLevelRecordWithDefault> expect = new HashSet<>();\n+    for (int i = 0; i < count; i++)\n+    {\n+      expect.add(new HighLevelRecordWithDefault(expectedTestData).setNoDefaultFieldA(i));\n+    }\n+    Assert.assertEquals(actual, expect);\n+  }\n+\n+  @DataProvider(name = \"testBatchFinderData\")\n+  private Object[][] testBatchFinderData() throws CloneNotSupportedException {\n+\n+    HighLevelRecordWithDefault expected1 = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    HighLevelRecordWithDefault expected2 = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n+    return new Object[][]{\n+            {\n+              new RecordCriteria[]{new RecordCriteria().setIntWithoutDefault(1), new RecordCriteria().setIntWithoutDefault(2)},\n+              new HighLevelRecordWithDefault[]{expected1, expected2}\n+            }\n     };\n   }\n+\n+  @Test(dataProvider = \"testBatchFinderData\")\n+  public void testFillInDefaultBatchFinder(Object[] criteria, HighLevelRecordWithDefault[] expected)\n+          throws RemoteInvocationException\n+  {\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    BatchFindRequest<HighLevelRecordWithDefault> request = builders.batchFindBySearchRecords()\n+        .addCriteriaParam((RecordCriteria) criteria[0])\n+        .addCriteriaParam((RecordCriteria) criteria[1])\n+        .setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n+    List<BatchFinderCriteriaResult<HighLevelRecordWithDefault>> batchFinderCriteriaResults = getClient()\n+        .sendRequest(request).getResponse().getEntity().getResults();\n+    Set<HighLevelRecordWithDefault> actualActionResponse = new HashSet<>();\n+    for (BatchFinderCriteriaResult<HighLevelRecordWithDefault> result : batchFinderCriteriaResults)\n+    {\n+      actualActionResponse.addAll(result.getElements());\n+    }\n+    Set<HighLevelRecordWithDefault> expectedActionResponse = new HashSet<>(Arrays.asList(expected));\n+    Assert.assertEquals(actualActionResponse, expectedActionResponse);\n+  }\n+\n+  @DataProvider(name = \"testActionData\")\n+  private Object[] testActionData()\n+  {\n+    return new Long[]{1L, 2L};\n+  }\n+\n+  @Test(dataProvider = \"testActionData\")\n+  public void testFillInDefaultAction(Long actionParam) throws RemoteInvocationException {\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    ActionRequest<HighLevelRecordWithDefault> request = builders.actionDefaultFillAction().actionParamParam(actionParam)\n+        .setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true)\n+        .build();\n+    HighLevelRecordWithDefault actual = getClient().sendRequest(request).getResponse().getEntity();\n+    HighLevelRecordWithDefault expect = new HighLevelRecordWithDefault(expectedTestData)\n+            .setNoDefaultFieldA(Math.toIntExact(actionParam));\n+    Assert.assertEquals(actual, expect);\n+  }\n }\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex db2df0fd4..e40135ff5 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -218,7 +217,7 @@ public class TestFillInDefaultValue  extends RestLiIntegrationTest\n   public void testFillInDefaultAction(Long actionParam) throws RemoteInvocationException {\n     FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n     ActionRequest<HighLevelRecordWithDefault> request = builders.actionDefaultFillAction().actionParamParam(actionParam)\n-        .setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true)\n+        .setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true)\n         .build();\n     HighLevelRecordWithDefault actual = getClient().sendRequest(request).getResponse().getEntity();\n     HighLevelRecordWithDefault expect = new HighLevelRecordWithDefault(expectedTestData)\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MTE1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454581154", "body": "I suggest you test both scenarios: with fillInDefaults flag and without it. \r\n\r\nYou don't have to do it for all methods, just doing that for GET should be enough. For other methods, test only with fillInDefaults flag.", "bodyText": "I suggest you test both scenarios: with fillInDefaults flag and without it.\nYou don't have to do it for all methods, just doing that for GET should be enough. For other methods, test only with fillInDefaults flag.", "bodyHTML": "<p dir=\"auto\">I suggest you test both scenarios: with fillInDefaults flag and without it.</p>\n<p dir=\"auto\">You don't have to do it for all methods, just doing that for GET should be enough. For other methods, test only with fillInDefaults flag.</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T19:08:13Z", "path": "restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.examples;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.r2.RemoteInvocationException;\n+import com.linkedin.restli.client.ActionRequest;\n+import com.linkedin.restli.client.BatchFindRequest;\n+import com.linkedin.restli.client.BatchGetEntityRequest;\n+import com.linkedin.restli.client.FindRequest;\n+import com.linkedin.restli.client.GetAllRequest;\n+import com.linkedin.restli.client.GetRequest;\n+import com.linkedin.restli.client.response.BatchKVResponse;\n+import com.linkedin.restli.common.BatchFinderCriteriaResult;\n+import com.linkedin.restli.common.EntityResponse;\n+import com.linkedin.restli.common.RestConstants;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ * @author Brian Pin\n+ */\n+public class TestFillInDefaultValue  extends RestLiIntegrationTest\n+{\n+  private DataMap expectedTestData;\n+\n+  @BeforeClass\n+  public void initClass() throws Exception\n+  {\n+    super.init(Collections.emptyList());\n+    expectedTestData = new DataMap();\n+    expectedTestData.put(\"intDefaultFieldB\", -1);\n+    DataMap case1MidLevelRecordWithDefault = new DataMap();\n+    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n+    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n+    DataMap case1LowLevelRecordWithDefault = new DataMap();\n+    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n+    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n+    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n+    expectedTestData.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n+  }\n+\n+  @AfterClass\n+  public void shutDown() throws Exception\n+  {\n+    super.shutdown();\n+  }\n+\n+  @DataProvider(name = \"testGetData\")\n+  private Object[][] testGetData() throws CloneNotSupportedException\n+  {\n+    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    return new Object[][] {{1L, expected},};", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex e40135ff5..e452a7e01 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -79,7 +87,7 @@ public class TestFillInDefaultValue  extends RestLiIntegrationTest\n   private Object[][] testGetData() throws CloneNotSupportedException\n   {\n     HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    return new Object[][] {{1L, expected},};\n+    return new Object[][] {{1L, expected}};\n   }\n \n   @Test(dataProvider = \"testGetData\")\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\ndeleted file mode 100644\nindex e452a7e01..000000000\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ /dev/null\n", "chunk": "@@ -1,252 +0,0 @@\n-/*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n-package com.linkedin.restli.examples;\n-\n-import com.linkedin.data.Data;\n-import com.linkedin.data.DataList;\n-import com.linkedin.data.DataMap;\n-import com.linkedin.r2.RemoteInvocationException;\n-import com.linkedin.restli.client.ActionRequest;\n-import com.linkedin.restli.client.BatchFindRequest;\n-import com.linkedin.restli.client.BatchGetEntityRequest;\n-import com.linkedin.restli.client.FindRequest;\n-import com.linkedin.restli.client.GetAllRequest;\n-import com.linkedin.restli.client.GetRequest;\n-import com.linkedin.restli.client.response.BatchKVResponse;\n-import com.linkedin.restli.common.BatchFinderCriteriaResult;\n-import com.linkedin.restli.common.EntityResponse;\n-import com.linkedin.restli.common.RestConstants;\n-import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n-import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n-import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n-import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-/**\n- *\n- * @author Brian Pin\n- */\n-public class TestFillInDefaultValue  extends RestLiIntegrationTest\n-{\n-  private DataMap expectedTestData;\n-\n-  @BeforeClass\n-  public void initClass() throws Exception\n-  {\n-    super.init(Collections.emptyList());\n-    expectedTestData = new DataMap();\n-    expectedTestData.put(\"intDefaultFieldB\", -1);\n-    DataMap case1MidLevelRecordWithDefault = new DataMap();\n-    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n-    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n-    DataMap case1LowLevelRecordWithDefault = new DataMap();\n-    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n-    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n-    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n-    expectedTestData.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n-    DataMap defaultInArray = new DataMap();\n-    defaultInArray.put(\"intWithDefault\", 0);\n-    defaultInArray.put(\"intWithoutDefault\", 0);\n-    DataList defaultArrayField = new DataList();\n-    defaultArrayField.add(defaultInArray);\n-    expectedTestData.put(\"testFieldArray\", defaultArrayField);\n-  }\n-\n-  @AfterClass\n-  public void shutDown() throws Exception\n-  {\n-    super.shutdown();\n-  }\n-\n-  @DataProvider(name = \"testGetData\")\n-  private Object[][] testGetData() throws CloneNotSupportedException\n-  {\n-    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    return new Object[][] {{1L, expected}};\n-  }\n-\n-  @Test(dataProvider = \"testGetData\")\n-  public void testGet(Long id, HighLevelRecordWithDefault expectedRecord)\n-      throws RemoteInvocationException, IOException\n-  {\n-    FillInDefaultsRequestBuilders requestBuilders = new FillInDefaultsRequestBuilders();\n-    FillInDefaultsGetRequestBuilder getRequestBuilder = requestBuilders.get();\n-    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(id).setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true).build();\n-    HighLevelRecordWithDefault actual = getClient().sendRequest(req).getResponse().getEntity();\n-    Assert.assertEquals(actual, expectedRecord);\n-  }\n-\n-  @DataProvider(name = \"testGetDataNoFillIn\")\n-  private Object[][] testGetDataNoFillIn() throws CloneNotSupportedException\n-  {\n-    DataMap data = new DataMap();\n-    data.put(\"noDefaultFieldA\", 1);\n-    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(data.clone());\n-    return new Object[][] {{1L, expected}};\n-  }\n-\n-  @Test(dataProvider = \"testGetDataNoFillIn\")\n-  public void testGetWithFillInDefaults(Long id, HighLevelRecordWithDefault expectedRecord) throws RemoteInvocationException\n-  {\n-    FillInDefaultsRequestBuilders requestBuilders = new FillInDefaultsRequestBuilders();\n-    FillInDefaultsGetRequestBuilder getRequestBuilder = requestBuilders.get();\n-    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(id).build();\n-    HighLevelRecordWithDefault actual = getClient().sendRequest(req).getResponse().getEntity();\n-    Assert.assertEquals(actual, expectedRecord);\n-  }\n-\n-  @DataProvider(name = \"testBatchGetData\")\n-  private Object[][] testBatchGetData() throws CloneNotSupportedException\n-  {\n-    HighLevelRecordWithDefault a = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    HighLevelRecordWithDefault b = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n-    HighLevelRecordWithDefault c = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(3);\n-    return new Object[][]{\n-            {new Long[]{1L, 2L, 3L}, new HighLevelRecordWithDefault[]{a, b, c}}\n-    };\n-  }\n-\n-  @Test(dataProvider = \"testBatchGetData\")\n-  public void testFillInDefaultBatchGet(Long[] ids, HighLevelRecordWithDefault[] expected) throws RemoteInvocationException\n-  {\n-    Map<Integer, HighLevelRecordWithDefault> idToRecord = new HashMap<>();\n-    for (int i = 0; i < ids.length; i++)\n-    {\n-      idToRecord.put(Math.toIntExact(ids[i]), expected[i]);\n-    }\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    BatchGetEntityRequest<Long, HighLevelRecordWithDefault> request =\n-        builders.batchGet().setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true).ids(ids).build();\n-    BatchKVResponse<Long, EntityResponse<HighLevelRecordWithDefault>> batchKVResponse =\n-        getClient().sendRequest(request).getResponse().getEntity();\n-    for (Map.Entry<Long, EntityResponse<HighLevelRecordWithDefault>> entry : batchKVResponse.getResults().entrySet())\n-    {\n-      HighLevelRecordWithDefault actualEntity = entry.getValue().getEntity();\n-      Assert.assertEquals(actualEntity, idToRecord.getOrDefault(actualEntity.getNoDefaultFieldA(), null));\n-    }\n-  }\n-\n-  @DataProvider(name = \"testGetAllData\")\n-  private Object[] testGetAllData() throws CloneNotSupportedException {\n-    HighLevelRecordWithDefault a = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(0);\n-    HighLevelRecordWithDefault b = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    HighLevelRecordWithDefault c = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n-    Map<Integer, HighLevelRecordWithDefault> expect = new HashMap<>();\n-    expect.put(0, a);\n-    expect.put(1, b);\n-    expect.put(2, c);\n-    return new Object[]{expect};\n-  }\n-\n-  @Test(dataProvider = \"testGetAllData\")\n-  public void testFillInDefaultGetAll(Map<Integer, HighLevelRecordWithDefault> expected) throws RemoteInvocationException\n-  {\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    GetAllRequest<HighLevelRecordWithDefault> request =\n-        builders.getAll().setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true).build();\n-    List<HighLevelRecordWithDefault> allResult = getClient().sendRequest(request).getResponse().getEntity().getElements();\n-    Map<Integer, HighLevelRecordWithDefault> actual = new HashMap<>();\n-    for (HighLevelRecordWithDefault oneRecord : allResult)\n-    {\n-      actual.put(oneRecord.getNoDefaultFieldA(), oneRecord);\n-    }\n-    Assert.assertEquals(actual, expected);\n-  }\n-\n-  @DataProvider(name = \"testFinderData\")\n-  private Object[] testFinderData()\n-  {\n-    return new Integer[]{2, 3};\n-  }\n-\n-  @Test(dataProvider = \"testFinderData\")\n-  public void testFillInDefaultFinder(Integer fieldA) throws RemoteInvocationException\n-  {\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    FindRequest<HighLevelRecordWithDefault> request = builders.findByFindRecords()\n-        .setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true)\n-        .setParam(\"noDefaultFieldA\", fieldA).build();\n-    List<HighLevelRecordWithDefault> result = getClient().sendRequest(request).getResponse().getEntity().getElements();\n-    Set<HighLevelRecordWithDefault> actual = new HashSet<>(result);\n-    Set<HighLevelRecordWithDefault> expect = new HashSet<>();\n-    System.out.println(result);\n-    expect.add(new HighLevelRecordWithDefault(expectedTestData).setNoDefaultFieldA(fieldA));\n-    Assert.assertEquals(actual, expect);\n-  }\n-\n-  @DataProvider(name = \"testBatchFinderData\")\n-  private Object[][] testBatchFinderData() throws CloneNotSupportedException {\n-\n-    HighLevelRecordWithDefault expected1 = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n-    HighLevelRecordWithDefault expected2 = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n-    return new Object[][]{\n-            {\n-              new RecordCriteria[]{new RecordCriteria().setIntWithoutDefault(1), new RecordCriteria().setIntWithoutDefault(2)},\n-              new HighLevelRecordWithDefault[]{expected1, expected2}\n-            }\n-    };\n-  }\n-\n-  @Test(dataProvider = \"testBatchFinderData\")\n-  public void testFillInDefaultBatchFinder(Object[] criteria, HighLevelRecordWithDefault[] expected)\n-          throws RemoteInvocationException\n-  {\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    BatchFindRequest<HighLevelRecordWithDefault> request = builders.batchFindBySearchRecords()\n-        .addCriteriaParam((RecordCriteria) criteria[0])\n-        .addCriteriaParam((RecordCriteria) criteria[1])\n-        .setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true).build();\n-    List<BatchFinderCriteriaResult<HighLevelRecordWithDefault>> batchFinderCriteriaResults = getClient()\n-        .sendRequest(request).getResponse().getEntity().getResults();\n-    Set<HighLevelRecordWithDefault> actualActionResponse = new HashSet<>();\n-    for (BatchFinderCriteriaResult<HighLevelRecordWithDefault> result : batchFinderCriteriaResults)\n-    {\n-      actualActionResponse.addAll(result.getElements());\n-    }\n-    Set<HighLevelRecordWithDefault> expectedActionResponse = new HashSet<>(Arrays.asList(expected));\n-    Assert.assertEquals(actualActionResponse, expectedActionResponse);\n-  }\n-\n-  @DataProvider(name = \"testActionData\")\n-  private Object[] testActionData()\n-  {\n-    return new Long[]{1L, 2L};\n-  }\n-\n-  @Test(dataProvider = \"testActionData\")\n-  public void testFillInDefaultAction(Long actionParam) throws RemoteInvocationException {\n-    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n-    ActionRequest<HighLevelRecordWithDefault> request = builders.actionDefaultFillAction().actionParamParam(actionParam)\n-        .setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true)\n-        .build();\n-    HighLevelRecordWithDefault actual = getClient().sendRequest(request).getResponse().getEntity();\n-    HighLevelRecordWithDefault expect = new HighLevelRecordWithDefault(expectedTestData)\n-            .setNoDefaultFieldA(Math.toIntExact(actionParam));\n-    Assert.assertEquals(actual, expect);\n-  }\n-}\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nnew file mode 100644\nindex 000000000..f2d249ac2\n--- /dev/null\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -0,0 +1,92 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.examples;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.r2.RemoteInvocationException;\n+import com.linkedin.restli.client.GetRequest;\n+import com.linkedin.restli.client.Response;\n+import com.linkedin.restli.common.RestConstants;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import java.io.IOException;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ * @author Brian Pin\n+ */\n+public class TestFillInDefaultValue  extends RestLiIntegrationTest\n+{\n+  @BeforeClass\n+  public void initClass() throws Exception\n+  {\n+    super.init();\n+  }\n+\n+  @AfterClass\n+  public void shutDown() throws Exception\n+  {\n+    super.shutdown();\n+  }\n+\n+  @Test(dataProvider = \"testCaseProvider\")\n+  public void testClientControlledDefaultFilledIn(Long id, DataMap expectedData)\n+      throws RemoteInvocationException, IOException\n+  {\n+    FillInDefaultsRequestBuilders requestBuilders = new FillInDefaultsRequestBuilders();\n+    FillInDefaultsGetRequestBuilder getRequestBuilder = requestBuilders.get();\n+    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(1L).setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n+    HighLevelRecordWithDefault expectedRecord = new HighLevelRecordWithDefault(expectedData);\n+    Response<HighLevelRecordWithDefault> response = getClient().sendRequest(req).getResponse();\n+    Assert.assertEquals(response.getEntity(), expectedRecord);\n+  }\n+\n+  @DataProvider(name = \"testCaseProvider\")\n+  private static Object[][] testCaseProvider()\n+  {\n+    DataMap testCase1Data = new DataMap();\n+    testCase1Data.put(\"intDefaultFieldB\", -1);\n+    DataMap case1DataMidLevel = new DataMap();\n+    case1DataMidLevel.put(\"intWithDefault\", -1);\n+    DataMap case1DataLowLevel = new DataMap();\n+    case1DataLowLevel.put(\"nameWithDefault\", \"i_am_default_name\");\n+    DataMap case1DataLowLevelDefault = new DataMap();\n+    case1DataLowLevelDefault.put(\"nameWithDefault\", \"mid_default_a\");\n+    case1DataLowLevelDefault.put(\"nameWithoutDefault\", \"i_am_without_default_in_midlevel\");\n+    case1DataMidLevel.put(\"lowLevelRecordWithoutDefault\", case1DataLowLevel);\n+    case1DataMidLevel.put(\"lowLevelRecordWithDefault\", case1DataLowLevelDefault);\n+    testCase1Data.put(\"midLevelRecordWithoutDefault\", case1DataMidLevel);\n+    DataMap case1DataMidLevelDefault = new DataMap();\n+    case1DataMidLevelDefault.put(\"intWithDefault\", 0);\n+    case1DataMidLevelDefault.put(\"intWithoutDefault\", 0);\n+    testCase1Data.put(\"midLevelRecordWithoutDefault\", case1DataMidLevel);\n+    testCase1Data.put(\"midLevelRecordWithDefault\", case1DataMidLevelDefault);\n+\n+    return new Object[][] {\n+        {1L, testCase1Data},\n+    };\n+  }\n+}\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex f2d249ac2..6aa417eaa 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -67,26 +64,20 @@ public class TestFillInDefaultValue  extends RestLiIntegrationTest\n   @DataProvider(name = \"testCaseProvider\")\n   private static Object[][] testCaseProvider()\n   {\n-    DataMap testCase1Data = new DataMap();\n-    testCase1Data.put(\"intDefaultFieldB\", -1);\n-    DataMap case1DataMidLevel = new DataMap();\n-    case1DataMidLevel.put(\"intWithDefault\", -1);\n-    DataMap case1DataLowLevel = new DataMap();\n-    case1DataLowLevel.put(\"nameWithDefault\", \"i_am_default_name\");\n-    DataMap case1DataLowLevelDefault = new DataMap();\n-    case1DataLowLevelDefault.put(\"nameWithDefault\", \"mid_default_a\");\n-    case1DataLowLevelDefault.put(\"nameWithoutDefault\", \"i_am_without_default_in_midlevel\");\n-    case1DataMidLevel.put(\"lowLevelRecordWithoutDefault\", case1DataLowLevel);\n-    case1DataMidLevel.put(\"lowLevelRecordWithDefault\", case1DataLowLevelDefault);\n-    testCase1Data.put(\"midLevelRecordWithoutDefault\", case1DataMidLevel);\n-    DataMap case1DataMidLevelDefault = new DataMap();\n-    case1DataMidLevelDefault.put(\"intWithDefault\", 0);\n-    case1DataMidLevelDefault.put(\"intWithoutDefault\", 0);\n-    testCase1Data.put(\"midLevelRecordWithoutDefault\", case1DataMidLevel);\n-    testCase1Data.put(\"midLevelRecordWithDefault\", case1DataMidLevelDefault);\n+    // case 1\n+    DataMap testCase1Expected = new DataMap();\n+    testCase1Expected.put(\"intDefaultFieldB\", -1);\n+    DataMap case1MidLevelRecordWithDefault = new DataMap();\n+    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n+    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n+    DataMap case1LowLevelRecordWithDefault = new DataMap();\n+    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n+    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n+    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n+    testCase1Expected.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n \n     return new Object[][] {\n-        {1L, testCase1Data},\n+        {1L, testCase1Expected},\n     };\n   }\n }\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex 6aa417eaa..db2df0fd4 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -49,35 +76,153 @@ public class TestFillInDefaultValue  extends RestLiIntegrationTest\n     super.shutdown();\n   }\n \n-  @Test(dataProvider = \"testCaseProvider\")\n-  public void testClientControlledDefaultFilledIn(Long id, DataMap expectedData)\n+  @DataProvider(name = \"testGetData\")\n+  private Object[][] testGetData() throws CloneNotSupportedException\n+  {\n+    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    return new Object[][] {{1L, expected},};\n+  }\n+\n+  @Test(dataProvider = \"testGetData\")\n+  public void testGet(Long id, HighLevelRecordWithDefault expectedRecord)\n       throws RemoteInvocationException, IOException\n   {\n     FillInDefaultsRequestBuilders requestBuilders = new FillInDefaultsRequestBuilders();\n     FillInDefaultsGetRequestBuilder getRequestBuilder = requestBuilders.get();\n-    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(1L).setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n-    HighLevelRecordWithDefault expectedRecord = new HighLevelRecordWithDefault(expectedData);\n-    Response<HighLevelRecordWithDefault> response = getClient().sendRequest(req).getResponse();\n-    Assert.assertEquals(response.getEntity(), expectedRecord);\n+    GetRequest<HighLevelRecordWithDefault> req = getRequestBuilder.id(id).setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n+    HighLevelRecordWithDefault actual = getClient().sendRequest(req).getResponse().getEntity();\n+    Assert.assertEquals(actual, expectedRecord);\n   }\n \n-  @DataProvider(name = \"testCaseProvider\")\n-  private static Object[][] testCaseProvider()\n+  @DataProvider(name = \"testBatchGetData\")\n+  private Object[][] testBatchGetData() throws CloneNotSupportedException\n   {\n-    // case 1\n-    DataMap testCase1Expected = new DataMap();\n-    testCase1Expected.put(\"intDefaultFieldB\", -1);\n-    DataMap case1MidLevelRecordWithDefault = new DataMap();\n-    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n-    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n-    DataMap case1LowLevelRecordWithDefault = new DataMap();\n-    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n-    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n-    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n-    testCase1Expected.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n+    HighLevelRecordWithDefault a = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    HighLevelRecordWithDefault b = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n+    HighLevelRecordWithDefault c = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(3);\n+    return new Object[][]{\n+            {new Long[]{1L, 2L, 3L}, new HighLevelRecordWithDefault[]{a, b, c}}\n+    };\n+  }\n \n-    return new Object[][] {\n-        {1L, testCase1Expected},\n+  @Test(dataProvider = \"testBatchGetData\")\n+  public void testFillInDefaultBatchGet(Long[] ids, HighLevelRecordWithDefault[] expected) throws RemoteInvocationException\n+  {\n+    Map<Integer, HighLevelRecordWithDefault> idToRecord = new HashMap<>();\n+    for (int i = 0; i < ids.length; i++)\n+    {\n+      idToRecord.put(Math.toIntExact(ids[i]), expected[i]);\n+    }\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    BatchGetEntityRequest<Long, HighLevelRecordWithDefault> request =\n+        builders.batchGet().setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).ids(ids).build();\n+    BatchKVResponse<Long, EntityResponse<HighLevelRecordWithDefault>> batchKVResponse =\n+        getClient().sendRequest(request).getResponse().getEntity();\n+    for (Map.Entry<Long, EntityResponse<HighLevelRecordWithDefault>> entry : batchKVResponse.getResults().entrySet())\n+    {\n+      HighLevelRecordWithDefault actualEntity = entry.getValue().getEntity();\n+      Assert.assertEquals(actualEntity, idToRecord.getOrDefault(actualEntity.getNoDefaultFieldA(), null));\n+    }\n+  }\n+\n+  @DataProvider(name = \"testGetAllData\")\n+  private Object[] testGetAllData() throws CloneNotSupportedException {\n+    HighLevelRecordWithDefault a = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(0);\n+    HighLevelRecordWithDefault b = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    HighLevelRecordWithDefault c = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n+    Map<Integer, HighLevelRecordWithDefault> expect = new HashMap<>();\n+    expect.put(0, a);\n+    expect.put(1, b);\n+    expect.put(2, c);\n+    return new Object[]{expect};\n+  }\n+\n+  @Test(dataProvider = \"testGetAllData\")\n+  public void testFillInDefaultGetAll(Map<Integer, HighLevelRecordWithDefault> expected) throws RemoteInvocationException\n+  {\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    GetAllRequest<HighLevelRecordWithDefault> request =\n+        builders.getAll().setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n+    List<HighLevelRecordWithDefault> allResult = getClient().sendRequest(request).getResponse().getEntity().getElements();\n+    Map<Integer, HighLevelRecordWithDefault> actual = new HashMap<>();\n+    for (HighLevelRecordWithDefault oneRecord : allResult)\n+    {\n+      actual.put(oneRecord.getNoDefaultFieldA(), oneRecord);\n+    }\n+    Assert.assertEquals(actual, expected);\n+  }\n+\n+  @DataProvider(name = \"testFinderData\")\n+  private Object[] testFinderData()\n+  {\n+    return new Integer[]{2, 3};\n+  }\n+\n+  @Test(dataProvider = \"testFinderData\")\n+  public void testFillInDefaultFinder(Integer count) throws RemoteInvocationException\n+  {\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    FindRequest<HighLevelRecordWithDefault> request = builders.findByHighLevelRecord()\n+        .setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true)\n+        .setParam(\"totalCount\", count).build();\n+    List<HighLevelRecordWithDefault> result = getClient().sendRequest(request).getResponse().getEntity().getElements();\n+    Set<HighLevelRecordWithDefault> actual = new HashSet<>(result);\n+    Set<HighLevelRecordWithDefault> expect = new HashSet<>();\n+    for (int i = 0; i < count; i++)\n+    {\n+      expect.add(new HighLevelRecordWithDefault(expectedTestData).setNoDefaultFieldA(i));\n+    }\n+    Assert.assertEquals(actual, expect);\n+  }\n+\n+  @DataProvider(name = \"testBatchFinderData\")\n+  private Object[][] testBatchFinderData() throws CloneNotSupportedException {\n+\n+    HighLevelRecordWithDefault expected1 = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    HighLevelRecordWithDefault expected2 = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(2);\n+    return new Object[][]{\n+            {\n+              new RecordCriteria[]{new RecordCriteria().setIntWithoutDefault(1), new RecordCriteria().setIntWithoutDefault(2)},\n+              new HighLevelRecordWithDefault[]{expected1, expected2}\n+            }\n     };\n   }\n+\n+  @Test(dataProvider = \"testBatchFinderData\")\n+  public void testFillInDefaultBatchFinder(Object[] criteria, HighLevelRecordWithDefault[] expected)\n+          throws RemoteInvocationException\n+  {\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    BatchFindRequest<HighLevelRecordWithDefault> request = builders.batchFindBySearchRecords()\n+        .addCriteriaParam((RecordCriteria) criteria[0])\n+        .addCriteriaParam((RecordCriteria) criteria[1])\n+        .setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true).build();\n+    List<BatchFinderCriteriaResult<HighLevelRecordWithDefault>> batchFinderCriteriaResults = getClient()\n+        .sendRequest(request).getResponse().getEntity().getResults();\n+    Set<HighLevelRecordWithDefault> actualActionResponse = new HashSet<>();\n+    for (BatchFinderCriteriaResult<HighLevelRecordWithDefault> result : batchFinderCriteriaResults)\n+    {\n+      actualActionResponse.addAll(result.getElements());\n+    }\n+    Set<HighLevelRecordWithDefault> expectedActionResponse = new HashSet<>(Arrays.asList(expected));\n+    Assert.assertEquals(actualActionResponse, expectedActionResponse);\n+  }\n+\n+  @DataProvider(name = \"testActionData\")\n+  private Object[] testActionData()\n+  {\n+    return new Long[]{1L, 2L};\n+  }\n+\n+  @Test(dataProvider = \"testActionData\")\n+  public void testFillInDefaultAction(Long actionParam) throws RemoteInvocationException {\n+    FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n+    ActionRequest<HighLevelRecordWithDefault> request = builders.actionDefaultFillAction().actionParamParam(actionParam)\n+        .setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true)\n+        .build();\n+    HighLevelRecordWithDefault actual = getClient().sendRequest(request).getResponse().getEntity();\n+    HighLevelRecordWithDefault expect = new HighLevelRecordWithDefault(expectedTestData)\n+            .setNoDefaultFieldA(Math.toIntExact(actionParam));\n+    Assert.assertEquals(actual, expect);\n+  }\n }\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex db2df0fd4..e40135ff5 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n", "chunk": "@@ -218,7 +217,7 @@ public class TestFillInDefaultValue  extends RestLiIntegrationTest\n   public void testFillInDefaultAction(Long actionParam) throws RemoteInvocationException {\n     FillInDefaultsRequestBuilders builders = new FillInDefaultsRequestBuilders();\n     ActionRequest<HighLevelRecordWithDefault> request = builders.actionDefaultFillAction().actionParamParam(actionParam)\n-        .setParam(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM, true)\n+        .setParam(RestConstants.FILL_IN_DEFAULTS_PARAM, true)\n         .build();\n     HighLevelRecordWithDefault actual = getClient().sendRequest(request).getResponse().getEntity();\n     HighLevelRecordWithDefault expect = new HighLevelRecordWithDefault(expectedTestData)\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MzYzMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454583633", "body": "remove", "bodyText": "remove", "bodyHTML": "<p dir=\"auto\">remove</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T19:12:49Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex ee039b3b9..f565b1ab5 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -103,24 +102,22 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       }\n       catch (Exception e)\n       {\n-        System.out.println(\"Happened \" + e.getCause());\n-        valueWithDefault = value;\n+        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n+            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n+                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n+                + routingResult.getResourceMethod());\n       }\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = valueWithDefault;\n     }\n     else\n     {\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = value;\n     }\n+    @SuppressWarnings(\"unchecked\")\n+    FieldDef<Object> actionReturnFieldDef =\n+        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+    final ActionResponse<?> actionResponse =\n+        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex f565b1ab5..4e56eceed 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -87,37 +85,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-\n-    final Object actionResponseValue;\n-    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n-        && routingResult.getContext().isFillInDefaultsRequested())\n-    {\n-      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n-      Object valueWithDefault = null;\n-      try\n-      {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n-      }\n-      catch (Exception e)\n-      {\n-        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n-            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n-                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n-                + routingResult.getResourceMethod());\n-      }\n-      actionResponseValue = valueWithDefault;\n-    }\n-    else\n-    {\n-      actionResponseValue = value;\n-    }\n     @SuppressWarnings(\"unchecked\")\n     FieldDef<Object> actionReturnFieldDef =\n         (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n     final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n+\n     return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 4e56eceed..1b6337df8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -85,12 +90,40 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isDefaultValueFillInRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;\n+      }\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    }\n+    else\n+    {\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    }\n   }\n }\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 1b6337df8..2712ce8ad 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -91,39 +88,36 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n-        && routingResult.getContext().isDefaultValueFillInRequested())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      DataMap dataMap = actionResponseRecordTemplate.data();\n+      dataMap = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataMap);\n       Object valueWithDefault = null;\n       try\n       {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataMap);\n       }\n       catch (Exception e)\n       {\n-        System.out.println(\"Happened \" + e.getCause());\n-        valueWithDefault = value;\n+        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n+            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n+                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n+                + routingResult.getResourceMethod());\n       }\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = valueWithDefault;\n     }\n     else\n     {\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = value;\n     }\n+    @SuppressWarnings(\"unchecked\")\n+    FieldDef<Object> actionReturnFieldDef =\n+        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+    final ActionResponse<?> actionResponse =\n+        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5OTY3Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454599677", "body": "Change to a log message (debug/info)", "bodyText": "Change to a log message (debug/info)", "bodyHTML": "<p dir=\"auto\">Change to a log message (debug/info)</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T19:42:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex ee039b3b9..f565b1ab5 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -88,13 +88,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n         && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n       DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n       DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n       Object valueWithDefault = null;\n       try\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex f565b1ab5..2712ce8ad 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -93,12 +93,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n         && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      DataMap dataMap = actionResponseRecordTemplate.data();\n+      dataMap = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataMap);\n       Object valueWithDefault = null;\n       try\n       {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataMap);\n       }\n       catch (Exception e)\n       {\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 2712ce8ad..a71fb1ffc 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -94,7 +94,7 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n       DataMap dataMap = actionResponseRecordTemplate.data();\n-      dataMap = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataMap);\n+      dataMap = (DataMap) ResponseUtils.fillInDataDefault(actionResponseRecordTemplate.schema(), dataMap);\n       Object valueWithDefault = null;\n       try\n       {\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex a71fb1ffc..4e56eceed 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -87,37 +85,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-\n-    final Object actionResponseValue;\n-    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n-        && routingResult.getContext().isFillInDefaultsRequested())\n-    {\n-      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataMap = actionResponseRecordTemplate.data();\n-      dataMap = (DataMap) ResponseUtils.fillInDataDefault(actionResponseRecordTemplate.schema(), dataMap);\n-      Object valueWithDefault = null;\n-      try\n-      {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataMap);\n-      }\n-      catch (Exception e)\n-      {\n-        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n-            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n-                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n-                + routingResult.getResourceMethod());\n-      }\n-      actionResponseValue = valueWithDefault;\n-    }\n-    else\n-    {\n-      actionResponseValue = value;\n-    }\n     @SuppressWarnings(\"unchecked\")\n     FieldDef<Object> actionReturnFieldDef =\n         (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n     final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n+\n     return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 4e56eceed..1b6337df8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -85,12 +90,40 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isDefaultValueFillInRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;\n+      }\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    }\n+    else\n+    {\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    }\n   }\n }\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 1b6337df8..2712ce8ad 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -91,39 +88,36 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n-        && routingResult.getContext().isDefaultValueFillInRequested())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      DataMap dataMap = actionResponseRecordTemplate.data();\n+      dataMap = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataMap);\n       Object valueWithDefault = null;\n       try\n       {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataMap);\n       }\n       catch (Exception e)\n       {\n-        System.out.println(\"Happened \" + e.getCause());\n-        valueWithDefault = value;\n+        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n+            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n+                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n+                + routingResult.getResourceMethod());\n       }\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = valueWithDefault;\n     }\n     else\n     {\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = value;\n     }\n+    @SuppressWarnings(\"unchecked\")\n+    FieldDef<Object> actionReturnFieldDef =\n+        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+    final ActionResponse<?> actionResponse =\n+        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNDUyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454604525", "body": "This section should be refactored to avoid duplication with the else block", "bodyText": "This section should be refactored to avoid duplication with the else block", "bodyHTML": "<p dir=\"auto\">This section should be refactored to avoid duplication with the else block</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T19:51:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;\n+      }\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex ee039b3b9..f565b1ab5 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -103,24 +102,22 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       }\n       catch (Exception e)\n       {\n-        System.out.println(\"Happened \" + e.getCause());\n-        valueWithDefault = value;\n+        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n+            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n+                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n+                + routingResult.getResourceMethod());\n       }\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = valueWithDefault;\n     }\n     else\n     {\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = value;\n     }\n+    @SuppressWarnings(\"unchecked\")\n+    FieldDef<Object> actionReturnFieldDef =\n+        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+    final ActionResponse<?> actionResponse =\n+        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex f565b1ab5..4e56eceed 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -87,37 +85,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-\n-    final Object actionResponseValue;\n-    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n-        && routingResult.getContext().isFillInDefaultsRequested())\n-    {\n-      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n-      Object valueWithDefault = null;\n-      try\n-      {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n-      }\n-      catch (Exception e)\n-      {\n-        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n-            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n-                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n-                + routingResult.getResourceMethod());\n-      }\n-      actionResponseValue = valueWithDefault;\n-    }\n-    else\n-    {\n-      actionResponseValue = value;\n-    }\n     @SuppressWarnings(\"unchecked\")\n     FieldDef<Object> actionReturnFieldDef =\n         (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n     final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n+\n     return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 4e56eceed..1b6337df8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -85,12 +90,40 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isDefaultValueFillInRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;\n+      }\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    }\n+    else\n+    {\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    }\n   }\n }\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 1b6337df8..2712ce8ad 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -91,39 +88,36 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n-        && routingResult.getContext().isDefaultValueFillInRequested())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      DataMap dataMap = actionResponseRecordTemplate.data();\n+      dataMap = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataMap);\n       Object valueWithDefault = null;\n       try\n       {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataMap);\n       }\n       catch (Exception e)\n       {\n-        System.out.println(\"Happened \" + e.getCause());\n-        valueWithDefault = value;\n+        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n+            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n+                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n+                + routingResult.getResourceMethod());\n       }\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = valueWithDefault;\n     }\n     else\n     {\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = value;\n     }\n+    @SuppressWarnings(\"unchecked\")\n+    FieldDef<Object> actionReturnFieldDef =\n+        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+    final ActionResponse<?> actionResponse =\n+        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNTU2NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454605564", "body": "Avoid duplication", "bodyText": "Avoid duplication", "bodyHTML": "<p dir=\"auto\">Avoid duplication</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T19:53:12Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java", "diffHunk": "@@ -153,9 +154,22 @@ else if (result.getErrors().containsKey(criteria))\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n-      response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(),\n-                                                         resourceContext.getProjectionMode(),\n-                                                         resourceContext.getProjectionMask())));\n+      if (resourceContext.isFillInDefaultsRequested())\n+      {\n+        DataMap elementData = elements.get(j).data();\n+        RecordDataSchema schema = elements.get(j).schema();\n+        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elementData);\n+        response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault,\n+            resourceContext.getProjectionMode(),\n+            resourceContext.getProjectionMask())));", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\nindex 45df1567e..feae705c2 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n", "chunk": "@@ -154,22 +154,15 @@ public class BatchFinderResponseBuilder\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n+      DataMap elementData = elements.get(j).data();\n       if (resourceContext.isFillInDefaultsRequested())\n       {\n-        DataMap elementData = elements.get(j).data();\n         RecordDataSchema schema = elements.get(j).schema();\n-        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elementData);\n-        response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault,\n-            resourceContext.getProjectionMode(),\n-            resourceContext.getProjectionMask())));\n-\n-      }\n-      else\n-      {\n-        response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(),\n-            resourceContext.getProjectionMode(),\n-            resourceContext.getProjectionMask())));\n+        elementData = ResponseUtils.fillInDefaultValues(schema, elementData);\n       }\n+      response.add(new AnyRecord(RestUtils.projectFields(elementData,\n+          resourceContext.getProjectionMode(),\n+          resourceContext.getProjectionMask())));\n     }\n     return response;\n   }\n", "next_change": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\nindex feae705c2..7e455edcb 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n", "chunk": "@@ -154,15 +154,16 @@ public class BatchFinderResponseBuilder\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n-      DataMap elementData = elements.get(j).data();\n       if (resourceContext.isFillInDefaultsRequested())\n       {\n         RecordDataSchema schema = elements.get(j).schema();\n-        elementData = ResponseUtils.fillInDefaultValues(schema, elementData);\n+        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elements.get(j).data());\n+        response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault, resourceContext)));\n+      }\n+      else\n+      {\n+        response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(), resourceContext)));\n       }\n-      response.add(new AnyRecord(RestUtils.projectFields(elementData,\n-          resourceContext.getProjectionMode(),\n-          resourceContext.getProjectionMask())));\n     }\n     return response;\n   }\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\nindex 7e455edcb..f090bb231 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n", "chunk": "@@ -154,16 +153,7 @@ public class BatchFinderResponseBuilder\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n-      if (resourceContext.isFillInDefaultsRequested())\n-      {\n-        RecordDataSchema schema = elements.get(j).schema();\n-        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elements.get(j).data());\n-        response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault, resourceContext)));\n-      }\n-      else\n-      {\n-        response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(), resourceContext)));\n-      }\n+      response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(), resourceContext)));\n     }\n     return response;\n   }\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\nindex f090bb231..cbfdfb3ba 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n", "chunk": "@@ -153,7 +154,18 @@ public class BatchFinderResponseBuilder\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n-      response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(), resourceContext)));\n+      if (resourceContext.isDefaultValueFillInRequested())\n+      {\n+        DataMap elementData = elements.get(j).data();\n+        RecordDataSchema schema = elements.get(j).schema();\n+        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elementData);\n+        response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault, resourceContext)));\n+\n+      }\n+      else\n+      {\n+        response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(), resourceContext));\n+      }\n     }\n     return response;\n   }\n", "next_change": {"commit": "8f39f3c1023fd79c185e53636c412e3d30947827", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\nindex cbfdfb3ba..7e455edcb 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n", "chunk": "@@ -154,17 +154,15 @@ public class BatchFinderResponseBuilder\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n-      if (resourceContext.isDefaultValueFillInRequested())\n+      if (resourceContext.isFillInDefaultsRequested())\n       {\n-        DataMap elementData = elements.get(j).data();\n         RecordDataSchema schema = elements.get(j).schema();\n-        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elementData);\n+        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elements.get(j).data());\n         response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault, resourceContext)));\n-\n       }\n       else\n       {\n-        response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(), resourceContext));\n+        response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(), resourceContext)));\n       }\n     }\n     return response;\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNjgyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454606825", "body": "When you fail to create the value instance, you should return 500 error, not fall back to value without default.\r\n", "bodyText": "When you fail to create the value instance, you should return 500 error, not fall back to value without default.", "bodyHTML": "<p dir=\"auto\">When you fail to create the value instance, you should return 500 error, not fall back to value without default.</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T19:55:28Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex ee039b3b9..f565b1ab5 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -103,24 +102,22 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       }\n       catch (Exception e)\n       {\n-        System.out.println(\"Happened \" + e.getCause());\n-        valueWithDefault = value;\n+        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n+            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n+                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n+                + routingResult.getResourceMethod());\n       }\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = valueWithDefault;\n     }\n     else\n     {\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = value;\n     }\n+    @SuppressWarnings(\"unchecked\")\n+    FieldDef<Object> actionReturnFieldDef =\n+        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+    final ActionResponse<?> actionResponse =\n+        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex f565b1ab5..4e56eceed 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -87,37 +85,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-\n-    final Object actionResponseValue;\n-    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n-        && routingResult.getContext().isFillInDefaultsRequested())\n-    {\n-      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n-      Object valueWithDefault = null;\n-      try\n-      {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n-      }\n-      catch (Exception e)\n-      {\n-        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n-            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n-                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n-                + routingResult.getResourceMethod());\n-      }\n-      actionResponseValue = valueWithDefault;\n-    }\n-    else\n-    {\n-      actionResponseValue = value;\n-    }\n     @SuppressWarnings(\"unchecked\")\n     FieldDef<Object> actionReturnFieldDef =\n         (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n     final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n+\n     return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 4e56eceed..1b6337df8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -85,12 +90,40 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isDefaultValueFillInRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;\n+      }\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    }\n+    else\n+    {\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    }\n   }\n }\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex 1b6337df8..2712ce8ad 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n", "chunk": "@@ -91,39 +88,36 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n-        && routingResult.getContext().isDefaultValueFillInRequested())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n-      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      DataMap dataMap = actionResponseRecordTemplate.data();\n+      dataMap = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataMap);\n       Object valueWithDefault = null;\n       try\n       {\n-        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataMap);\n       }\n       catch (Exception e)\n       {\n-        System.out.println(\"Happened \" + e.getCause());\n-        valueWithDefault = value;\n+        throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n+            \"Unexpected error encountered. Can not create return value class \" + value.getClass().getSimpleName()\n+                + \" with default filled  inside of an ActionResult returned by the resource method: \"\n+                + routingResult.getResourceMethod());\n       }\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = valueWithDefault;\n     }\n     else\n     {\n-      @SuppressWarnings(\"unchecked\")\n-      FieldDef<Object> actionReturnFieldDef =\n-          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-      final ActionResponse<?> actionResponse =\n-          new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n-      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+      actionResponseValue = value;\n     }\n+    @SuppressWarnings(\"unchecked\")\n+    FieldDef<Object> actionReturnFieldDef =\n+        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+    final ActionResponse<?> actionResponse =\n+        new ActionResponse<>(actionResponseValue, actionReturnFieldDef, actionReturnRecordDataSchema);\n+    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwOTkzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454609931", "body": "Initialize with size computed using DataMapBuilder::getOptimumHashMapCapacityFromSize", "bodyText": "Initialize with size computed using DataMapBuilder::getOptimumHashMapCapacityFromSize", "bodyHTML": "<p dir=\"auto\">Initialize with size computed using DataMapBuilder::getOptimumHashMapCapacityFromSize</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T20:01:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +92,95 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,11 +118,17 @@ public class ResponseUtils\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled = new DataMap();\n+\n+    DataMap dataDefaultFilled;\n     if (dataMap != null)\n     {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n       dataDefaultFilled.putAll(dataMap);\n     }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();\n+    }\n \n     if (dataSchema instanceof TyperefDataSchema)\n     {\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 19fcd2134..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -130,12 +129,7 @@ public class ResponseUtils\n       dataDefaultFilled = new DataMap();\n     }\n \n-    if (dataSchema instanceof TyperefDataSchema)\n-    {\n-      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n-    }\n-    else if (dataSchema instanceof RecordDataSchema)\n+    if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454615927", "body": "You would also need a method to handle DataLists. What if you have a field which is an array of records?", "bodyText": "You would also need a method to handle DataLists. What if you have a field which is an array of records?", "bodyHTML": "<p dir=\"auto\">You would also need a method to handle DataLists. What if you have a field which is an array of records?</p>", "author": "karthikbalasub", "createdAt": "2020-07-14T20:12:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +92,95 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MDk0NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r456960945", "bodyText": "For fields of array, in the code I assume the following case:\nCase 1 When the schema provide default\ntestFieldArray: array[MidLevelRecordWithDefault] = [{\"intWithDefault\": 0, \"intWithoutDefault\": 0}]\n\nCase 2 When schema does not have default\nIn case 1, I will just use the default provided.\nIn case 2, there will be no defaults filled in.\nI think this is an important case to discuss.\nI think whats the correct way might be: for a field that is an array, if there is no default provided restli provides no value with this field (This statement matches the example I pasted in design doc)\nIf there is default for an array field, I will just use the default.\nI think now the question is, is it just default provided on the schema or the element record all other default values?\nLet me know if this is wrong", "author": "BrianPin", "createdAt": "2020-07-19T22:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMzgyNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458003827", "bodyText": "You should follow the same behavior as complex fields.\n\nif field is not null, fill it with defaults from item's schema recursively.\nif field is null and schema provides default, use the default and fill it with defaults from the item's schema recursively.\nif field is null and not default provided, do nothin.", "author": "karthikbalasub", "createdAt": "2020-07-21T10:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw=="}], "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,11 +118,17 @@ public class ResponseUtils\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled = new DataMap();\n+\n+    DataMap dataDefaultFilled;\n     if (dataMap != null)\n     {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n       dataDefaultFilled.putAll(dataMap);\n     }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();\n+    }\n \n     if (dataSchema instanceof TyperefDataSchema)\n     {\n", "next_change": {"commit": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 19fcd2134..e598f8b12 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -130,12 +129,7 @@ public class ResponseUtils\n       dataDefaultFilled = new DataMap();\n     }\n \n-    if (dataSchema instanceof TyperefDataSchema)\n-    {\n-      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n-    }\n-    else if (dataSchema instanceof RecordDataSchema)\n+    if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n", "next_change": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "url": "https://github.com/linkedin/rest.li/commit/c18cfcc93ec7698ccead9e1a483956c8160fff02", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-07-20T07:59:08Z", "type": "forcePushed"}, {"oid": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "url": "https://github.com/linkedin/rest.li/commit/20edab3a4a167ffb434e6127da064e312c9dc4e0", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-07-20T17:41:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMTU3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458001578", "body": "Add javadoc", "bodyText": "Add javadoc", "bodyHTML": "<p dir=\"auto\">Add javadoc</p>", "author": "karthikbalasub", "createdAt": "2020-07-21T10:38:52Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java", "diffHunk": "@@ -552,4 +555,14 @@ public void setValidateResourceKeys(boolean validateResourceKeys)\n     setMethodConfig(\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n+\n+  public boolean shouldFillInDefaultValues()", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 10603168d..26afccc5e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n", "chunk": "@@ -556,11 +556,19 @@ public class RestLiConfig\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n \n+  /**\n+   * check config to see if the data in result should fill in default in fields\n+   * @return boolean\n+   */\n   public boolean shouldFillInDefaultValues()\n   {\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * set the flag to decide whether to fill in default values in result record's fields\n+   * @param fillInDefaultValues a boolean for the flag\n+   */\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n     _fillInDefaultValues = fillInDefaultValues;\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 26afccc5e..5c6aaf4db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n", "chunk": "@@ -557,20 +557,16 @@ public class RestLiConfig\n   }\n \n   /**\n-   * check config to see if the data in result should fill in default in fields\n-   * @return boolean\n+   * Get whether fill in stacktrace for {@link com.linkedin.r2.message.rest.RestException}\n    */\n-  public boolean shouldFillInDefaultValues()\n-  {\n-    return _fillInDefaultValues;\n+  public boolean isWritableStackTrace() {\n+    return _writableStackTrace;\n   }\n \n   /**\n-   * set the flag to decide whether to fill in default values in result record's fields\n-   * @param fillInDefaultValues a boolean for the flag\n+   * Set whether fill in stacktrace for {@link com.linkedin.r2.message.rest.RestException}\n    */\n-  public void setFillInDefaultValues(boolean fillInDefaultValues)\n-  {\n-    _fillInDefaultValues = fillInDefaultValues;\n+  public void setWritableStackTrace(boolean writableStackTrace) {\n+    _writableStackTrace = writableStackTrace;\n   }\n }\n", "next_change": {"commit": "a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 5c6aaf4db..52872e3d8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n", "chunk": "@@ -559,14 +562,29 @@ public class RestLiConfig\n   /**\n    * Get whether fill in stacktrace for {@link com.linkedin.r2.message.rest.RestException}\n    */\n-  public boolean isWritableStackTrace() {\n+  public boolean isWritableStackTrace()\n+  {\n     return _writableStackTrace;\n   }\n \n   /**\n    * Set whether fill in stacktrace for {@link com.linkedin.r2.message.rest.RestException}\n    */\n-  public void setWritableStackTrace(boolean writableStackTrace) {\n+  public void setWritableStackTrace(boolean writableStackTrace)\n+  {\n     _writableStackTrace = writableStackTrace;\n   }\n+\n+  /**\n+   * Get/Set for filling default values in restli response\n+   */\n+  public boolean shouldFillInDefaultValues()\n+  {\n+    return _fillInDefaultValues;\n+  }\n+\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)\n+  {\n+    _fillInDefaultValues = fillInDefaultValues;\n+  }\n }\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 52872e3d8..4a2087a4d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n", "chunk": "@@ -577,12 +577,18 @@ public class RestLiConfig\n \n   /**\n    * Get/Set for filling default values in restli response\n+   * check config to see if the data in result should fill in default in fields\n+   * @return boolean\n    */\n   public boolean shouldFillInDefaultValues()\n   {\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * set the flag to decide whether to fill in default values in result record's fields\n+   * @param fillInDefaultValues a boolean for the flag\n+   */\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n     _fillInDefaultValues = fillInDefaultValues;\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMTYyNg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458001626", "body": "Add javadoc", "bodyText": "Add javadoc", "bodyHTML": "<p dir=\"auto\">Add javadoc</p>", "author": "karthikbalasub", "createdAt": "2020-07-21T10:38:57Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java", "diffHunk": "@@ -552,4 +555,14 @@ public void setValidateResourceKeys(boolean validateResourceKeys)\n     setMethodConfig(\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n+\n+  public boolean shouldFillInDefaultValues()\n+  {\n+    return _fillInDefaultValues;\n+  }\n+\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 10603168d..26afccc5e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n", "chunk": "@@ -556,11 +556,19 @@ public class RestLiConfig\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n \n+  /**\n+   * check config to see if the data in result should fill in default in fields\n+   * @return boolean\n+   */\n   public boolean shouldFillInDefaultValues()\n   {\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * set the flag to decide whether to fill in default values in result record's fields\n+   * @param fillInDefaultValues a boolean for the flag\n+   */\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n     _fillInDefaultValues = fillInDefaultValues;\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 26afccc5e..5c6aaf4db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n", "chunk": "@@ -557,20 +557,16 @@ public class RestLiConfig\n   }\n \n   /**\n-   * check config to see if the data in result should fill in default in fields\n-   * @return boolean\n+   * Get whether fill in stacktrace for {@link com.linkedin.r2.message.rest.RestException}\n    */\n-  public boolean shouldFillInDefaultValues()\n-  {\n-    return _fillInDefaultValues;\n+  public boolean isWritableStackTrace() {\n+    return _writableStackTrace;\n   }\n \n   /**\n-   * set the flag to decide whether to fill in default values in result record's fields\n-   * @param fillInDefaultValues a boolean for the flag\n+   * Set whether fill in stacktrace for {@link com.linkedin.r2.message.rest.RestException}\n    */\n-  public void setFillInDefaultValues(boolean fillInDefaultValues)\n-  {\n-    _fillInDefaultValues = fillInDefaultValues;\n+  public void setWritableStackTrace(boolean writableStackTrace) {\n+    _writableStackTrace = writableStackTrace;\n   }\n }\n", "next_change": {"commit": "a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 5c6aaf4db..52872e3d8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n", "chunk": "@@ -559,14 +562,29 @@ public class RestLiConfig\n   /**\n    * Get whether fill in stacktrace for {@link com.linkedin.r2.message.rest.RestException}\n    */\n-  public boolean isWritableStackTrace() {\n+  public boolean isWritableStackTrace()\n+  {\n     return _writableStackTrace;\n   }\n \n   /**\n    * Set whether fill in stacktrace for {@link com.linkedin.r2.message.rest.RestException}\n    */\n-  public void setWritableStackTrace(boolean writableStackTrace) {\n+  public void setWritableStackTrace(boolean writableStackTrace)\n+  {\n     _writableStackTrace = writableStackTrace;\n   }\n+\n+  /**\n+   * Get/Set for filling default values in restli response\n+   */\n+  public boolean shouldFillInDefaultValues()\n+  {\n+    return _fillInDefaultValues;\n+  }\n+\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)\n+  {\n+    _fillInDefaultValues = fillInDefaultValues;\n+  }\n }\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 52872e3d8..4a2087a4d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n", "chunk": "@@ -577,12 +577,18 @@ public class RestLiConfig\n \n   /**\n    * Get/Set for filling default values in restli response\n+   * check config to see if the data in result should fill in default in fields\n+   * @return boolean\n    */\n   public boolean shouldFillInDefaultValues()\n   {\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * set the flag to decide whether to fill in default values in result record's fields\n+   * @param fillInDefaultValues a boolean for the flag\n+   */\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n     _fillInDefaultValues = fillInDefaultValues;\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMjcyMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458002720", "body": "For each case, add a short comment on what it is testing.\r\n\r\nOr even better, include a string in the test data with the context and use that string when tests fail.", "bodyText": "For each case, add a short comment on what it is testing.\nOr even better, include a string in the test data with the context and use that string when tests fail.", "bodyHTML": "<p dir=\"auto\">For each case, add a short comment on what it is testing.</p>\n<p dir=\"auto\">Or even better, include a string in the test data with the context and use that string when tests fail.</p>", "author": "karthikbalasub", "createdAt": "2020-07-21T10:40:59Z", "path": "restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.internal.server.response;\n+\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.util.DataMapUtils;\n+import java.io.File;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestResponseUtils\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    // case 1", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 27874a1a3..0bd6ec9f9 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n", "chunk": "@@ -48,115 +49,33 @@ public class TestResponseUtils\n   @DataProvider(name = \"default_serialization\")\n   public Object[][] schemaFilesForDefaultSerializationTest()\n   {\n-    // case 1\n-    DataMap case1Input = new DataMap();\n-    case1Input.put(\"field1\", 1);\n-    case1Input.put(\"field2\", \"2\");\n-    DataMap case1Expect = new DataMap();\n-    case1Expect.put(\"field1\", 1);\n-    case1Expect.put(\"field2\", \"2\");\n-    case1Expect.put(\"field3\", 0L);\n-    case1Expect.put(\"field4\", \"default\");\n-\n-    // case 2\n-    DataMap case2Input = new DataMap();\n-    DataMap case2Expect = new DataMap();\n-    DataList case2F1 = new DataList(1);\n-    case2F1.add(-1);\n-    case2Expect.put(\"field1\", case2F1);\n-    DataMap case2F2 = new DataMap();\n-    DataList case2F2Default = new DataList(2);\n-    case2F2Default.add(\"defaultValue1\");\n-    case2F2Default.add(\"defaultValue2\");\n-    case2F2.put(\"defaultKey\", case2F2Default);\n-    case2Expect.put(\"field2\", case2F2);\n-\n-    // case 3\n-    DataMap case3Input = new DataMap();\n-    case3Input.put(\"name\", \"not-a-default\");\n-    case3Input.put(\"personalRecordD\", new DataMap());\n-    DataMap case3Expect = new DataMap();\n-    DataMap case3RecordDExpect = new DataMap();\n-    case3RecordDExpect.put(\"field3\", 0L);\n-    case3RecordDExpect.put(\"field4\", \"default\");\n-    case3RecordDExpect.put(\"field5\", \"a-typeref-default\");\n-    case3Expect.put(\"name\", \"not-a-default\");\n-    case3Expect.put(\"personalRecordD\", case3RecordDExpect);\n-\n-    // case 4\n-    DataMap case4B1 = new DataMap();\n-    case4B1.put(\"f1\", 1);\n-    DataMap case4Input = new DataMap();\n-    case4Input.put(\"b1\", case4B1);\n-    case4Input.put(\"b2\", new DataMap());\n-    DataMap case4Expect = new DataMap();\n-    DataMap case4ExpectB1 = new DataMap();\n-    case4ExpectB1.put(\"f1\", 1);\n-    DataMap case4ExpectB2 = new DataMap();\n-    case4ExpectB2.put(\"f1\", 5);\n-    case4Expect.put(\"b1\", case4ExpectB1);\n-    case4Expect.put(\"b2\", case4ExpectB2);\n-\n-    // case 5\n-    DataMap case5B3 = new DataMap();\n-    case5B3.put(\"f2\", 1);\n-    DataMap case5Input = new DataMap();\n-    case5Input.put(\"b3\", case5B3);\n-    DataMap case5Expect = new DataMap();\n-    DataMap case5ExpectB1 = new DataMap();\n-    case5ExpectB1.put(\"f1\", 5);\n-    case5ExpectB1.put(\"f2\", 10);\n-    DataMap case5ExpectB3 = new DataMap();\n-    case5ExpectB3.put(\"f2\", 1);\n-    case5ExpectB3.put(\"f1\", 5);\n-    case5Expect.put(\"b1\", case5ExpectB1);\n-    case5Expect.put(\"b3\", case5ExpectB3);\n-\n-\n-    // Each test case has 3 elements:\n-    // Index 0: PDL file name\n-    // Index 1: data before filling default\n-    // Index 2: expected data after filling default\n     return new Object[][]{\n-        {\n-            \"RecordA.pdl\",\n-            case1Input,\n-            case1Expect\n-        },\n-        {\n-            \"RecordB.pdl\",\n-            case2Input,\n-            case2Expect\n-        },\n-        {\n-            \"RecordC.pdl\",\n-            case3Input,\n-            case3Expect\n-        },\n-        {\n-            \"Bar.pdl\",\n-            case4Input,\n-            case4Expect\n-        },\n-        {\n-            \"Bar.pdl\",\n-            case5Input,\n-            case5Expect\n-        }\n+        {\"case1.json\"},\n+        {\"case2.json\"},\n+        {\"case3.json\"},\n+        {\"case4.json\"},\n+        {\"case5.json\"},\n+        {\"case6.json\"},\n+        {\"case7.json\"},\n+        {\"case8.json\"},\n     };\n   }\n \n   @Test(dataProvider = \"default_serialization\")\n-  public void testGetAbsentFieldsDefaultValues(String filename, DataMap data, DataMap expected)\n+  public void testGetAbsentFieldsDefaultValues(String caseFilename)\n   {\n     try\n     {\n       MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n+      String expectedDataJsonFile = Files.readFile(new File(pegasusDir + FS + caseFilename));\n+      DataMap caseData = DataMapUtils.readMap(new ByteArrayInputStream(expectedDataJsonFile.getBytes()), Collections.emptyMap());\n \n-      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n+      String schemaFileText = Files.readFile(new File(pegasusDir + FS + caseData.get(\"schema\")));\n+      DataMap caseInput = (DataMap) caseData.get(\"input\");\n+      DataMap caseExpect = (DataMap) caseData.get(\"expect\");\n       DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n-      DataMap dataMapToFillDefault = ResponseUtils.fillInDefaultValues(schema, data);\n-      Assert.assertEquals(dataMapToFillDefault, expected);\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, caseInput);\n+      Assert.assertEquals(dataWithDefault, caseExpect, (String) caseData.get(\"context\"));\n     }\n     catch (Exception e)\n     {\n", "next_change": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 0bd6ec9f9..da0d64d52 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n", "chunk": "@@ -75,11 +75,13 @@ public class TestResponseUtils\n       DataMap caseExpect = (DataMap) caseData.get(\"expect\");\n       DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n       DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, caseInput);\n+      System.out.println(\"Expect \" + caseExpect);\n+      System.out.println(\"Actual \" + dataWithDefault);\n       Assert.assertEquals(dataWithDefault, caseExpect, (String) caseData.get(\"context\"));\n     }\n     catch (Exception e)\n     {\n-      Assert.fail(\"Test failed with exception: \\n\" + e);\n+      Assert.fail(\"Test failed with exception: \\n\" + e.toString());\n     }\n   }\n \n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nsimilarity index 52%\nrename from restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nrename to restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex da0d64d52..02a8fd91b 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -49,39 +54,63 @@ public class TestResponseUtils\n   @DataProvider(name = \"default_serialization\")\n   public Object[][] schemaFilesForDefaultSerializationTest()\n   {\n+    DataList recordBField1 = new DataList(1);\n+    recordBField1.add(-1);\n+\n+    DataMap recordBField2 = new DataMap();\n+    DataList recordBField2DefaultValues = new DataList(2);\n+    recordBField2DefaultValues.add(\"defaultValue1\");\n+    recordBField2DefaultValues.add(\"defaultValue2\");\n+    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n+\n     return new Object[][]{\n-        {\"default_filling_for_empty_value_but_keyed.json\"},\n-        {\"default_filling_union_without_alias.json\"},\n-        {\"filling_other_field_in_record.json\"},\n-        {\"iterate_array_element_default.json\"},\n-        {\"iterate_map_entry_default.json\"},\n-        {\"record_field_default_case.json\"},\n-        {\"record_field_is_record.json\"},\n-        {\"record_field_with_array_map.json\"},\n+        {\n+            \"RecordA.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .put(\"field3\", 0L)\n+                .put(\"field4\", \"default\")\n+                .build())\n+        },\n+        {\n+            \"RecordB.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", recordBField1)\n+                .put(\"field2\", recordBField2)\n+                .build())\n+        },\n+        {\n+            \"RecordC.pdl\",\n+            new DataMap(),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"name\", \"default+\")\n+                .build()),\n+        }\n     };\n   }\n \n   @Test(dataProvider = \"default_serialization\")\n-  public void testGetAbsentFieldsDefaultValues(String caseFilename)\n+  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n   {\n     try\n     {\n       MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n-      String expectedDataJsonFile = Files.readFile(new File(pegasusDir + FS + caseFilename));\n-      DataMap caseData = DataMapUtils.readMap(new ByteArrayInputStream(expectedDataJsonFile.getBytes()), Collections.emptyMap());\n \n-      String schemaFileText = Files.readFile(new File(pegasusDir + FS + caseData.get(\"schema\")));\n-      DataMap caseInput = (DataMap) caseData.get(\"input\");\n-      DataMap caseExpect = (DataMap) caseData.get(\"expect\");\n+      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n       DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, caseInput);\n-      System.out.println(\"Expect \" + caseExpect);\n-      System.out.println(\"Actual \" + dataWithDefault);\n-      Assert.assertEquals(dataWithDefault, caseExpect, (String) caseData.get(\"context\"));\n+      ResponseUtils.getAbsentFieldsDefaultValues((RecordDataSchema) schema, data);\n+      Assert.assertEquals(data, expected);\n     }\n     catch (Exception e)\n     {\n-      Assert.fail(\"Test failed with exception: \\n\" + e.toString());\n+      Assert.fail(\"Read test schema file failure, check file read successful \\n\" + e);\n     }\n   }\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwNTE3Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458005173", "body": "Can you explain when this is needed? I feel this should just return null here.", "bodyText": "Can you explain when this is needed? I feel this should just return null here.", "bodyHTML": "<p dir=\"auto\">Can you explain when this is needed? I feel this should just return null here.</p>", "author": "karthikbalasub", "createdAt": "2020-07-21T10:46:08Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled;\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 63bbfff72..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "9e81643c891572982585ede78eb7b5cd20c8aafa", "url": "https://github.com/linkedin/rest.li/commit/9e81643c891572982585ede78eb7b5cd20c8aafa", "message": "Address comment for clarity", "committedDate": "2020-07-22T17:20:51Z", "type": "forcePushed"}, {"oid": "68c81b337a69f7cec5dc68f19a09041ca0785647", "url": "https://github.com/linkedin/rest.li/commit/68c81b337a69f7cec5dc68f19a09041ca0785647", "message": "add union method and re-org test cases", "committedDate": "2020-07-23T23:40:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMTc0Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461201742", "body": "move this as javadoc for the method", "bodyText": "move this as javadoc for the method", "bodyHTML": "<p dir=\"auto\">move this as javadoc for the method</p>", "author": "aman1309", "createdAt": "2020-07-27T22:16:05Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java", "diffHunk": "@@ -626,6 +630,23 @@ public boolean isReturnEntityRequested()\n     return ArgumentUtils.parseReturnEntityParameter(returnEntityValue);\n   }\n \n+  @Override\n+  public boolean isFillInDefaultsRequested()\n+  {\n+    return _fillInDefaultValues;\n+  }\n+\n+  @Override\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)\n+  {\n+    // if a server has a configuration to set the flag to true, it will be set\n+    // through this method, and if the request itself already has the flag set to true\n+    // we will keep the flag remain true even the server config is not set.\n+    // That is => either server config or client request param will be able to\n+    // request fill in default values", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNTU0Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461815543", "bodyText": "done", "author": "BrianPin", "createdAt": "2020-07-28T19:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMTc0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\nindex 3c13ea37f..c7f64eab3 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n", "chunk": "@@ -636,14 +639,17 @@ public class ResourceContextImpl implements ServerResourceContext\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * if a server has a configuration to set the flag to true, it will be set\n+   * through this method, and if the request itself already has the flag set to true\n+   * we will keep the flag remain true even the server config is not set.\n+   * That is => either server config or client request param will be able to\n+   * request fill in default values\n+   * @param fillInDefaultValues boolean to set the flag for filling default values\n+   */\n   @Override\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n-    // if a server has a configuration to set the flag to true, it will be set\n-    // through this method, and if the request itself already has the flag set to true\n-    // we will keep the flag remain true even the server config is not set.\n-    // That is => either server config or client request param will be able to\n-    // request fill in default values\n     _fillInDefaultValues = fillInDefaultValues || _fillInDefaultValues;\n   }\n \n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\nindex c7f64eab3..434fbe72a 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n", "chunk": "@@ -633,26 +629,6 @@ public class ResourceContextImpl implements ServerResourceContext\n     return ArgumentUtils.parseReturnEntityParameter(returnEntityValue);\n   }\n \n-  @Override\n-  public boolean isFillInDefaultsRequested()\n-  {\n-    return _fillInDefaultValues;\n-  }\n-\n-  /**\n-   * if a server has a configuration to set the flag to true, it will be set\n-   * through this method, and if the request itself already has the flag set to true\n-   * we will keep the flag remain true even the server config is not set.\n-   * That is => either server config or client request param will be able to\n-   * request fill in default values\n-   * @param fillInDefaultValues boolean to set the flag for filling default values\n-   */\n-  @Override\n-  public void setFillInDefaultValues(boolean fillInDefaultValues)\n-  {\n-    _fillInDefaultValues = fillInDefaultValues || _fillInDefaultValues;\n-  }\n-\n   @Override\n   public Optional<Object> getCustomContextData(String key)\n   {\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\nindex 434fbe72a..f5d763de7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n", "chunk": "@@ -629,6 +629,14 @@ public class ResourceContextImpl implements ServerResourceContext\n     return ArgumentUtils.parseReturnEntityParameter(returnEntityValue);\n   }\n \n+  @Override\n+  public boolean isDefaultValueFillInRequested()\n+  {\n+    String sendDefaultsQuery = getParameter(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM);\n+\n+    return sendDefaultsQuery != null;\n+  }\n+\n   @Override\n   public Optional<Object> getCustomContextData(String key)\n   {\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\nindex f5d763de7..5510aeff3 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n", "chunk": "@@ -630,9 +630,9 @@ public class ResourceContextImpl implements ServerResourceContext\n   }\n \n   @Override\n-  public boolean isDefaultValueFillInRequested()\n+  public boolean isFillInDefaultsRequested()\n   {\n-    String sendDefaultsQuery = getParameter(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM);\n+    String sendDefaultsQuery = getParameter(RestConstants.FILL_IN_DEFAULTS_PARAM);\n \n     return sendDefaultsQuery != null;\n   }\n", "next_change": {"commit": "a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\nindex 5510aeff3..36a82b9f8 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n", "chunk": "@@ -632,9 +636,18 @@ public class ResourceContextImpl implements ServerResourceContext\n   @Override\n   public boolean isFillInDefaultsRequested()\n   {\n-    String sendDefaultsQuery = getParameter(RestConstants.FILL_IN_DEFAULTS_PARAM);\n+    return _fillInDefaultValues;\n+  }\n \n-    return sendDefaultsQuery != null;\n+  @Override\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)\n+  {\n+    // if a server has a configuration to set the flag to true, it will be set\n+    // through this method, and if the request itself already has the flag set to true\n+    // we will keep the flag remain true even the server config is not set.\n+    // That is => either server config or client request param will be able to\n+    // request fill in default values\n+    _fillInDefaultValues = fillInDefaultValues || _fillInDefaultValues;\n   }\n \n   @Override\n", "next_change": {"commit": "58e8ea8272b72fc5d4084422122e9be77ebcfa86", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\nindex 36a82b9f8..c7f64eab3 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n", "chunk": "@@ -639,14 +639,17 @@ public class ResourceContextImpl implements ServerResourceContext\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * if a server has a configuration to set the flag to true, it will be set\n+   * through this method, and if the request itself already has the flag set to true\n+   * we will keep the flag remain true even the server config is not set.\n+   * That is => either server config or client request param will be able to\n+   * request fill in default values\n+   * @param fillInDefaultValues boolean to set the flag for filling default values\n+   */\n   @Override\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n-    // if a server has a configuration to set the flag to true, it will be set\n-    // through this method, and if the request itself already has the flag set to true\n-    // we will keep the flag remain true even the server config is not set.\n-    // That is => either server config or client request param will be able to\n-    // request fill in default values\n     _fillInDefaultValues = fillInDefaultValues || _fillInDefaultValues;\n   }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNTY5MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461205690", "body": "did you look at any other possible position where this can be inserted instead of response builders? and if not how did we ensure all cases are(will remain) covered where the response is being sent out", "bodyText": "did you look at any other possible position where this can be inserted instead of response builders? and if not how did we ensure all cases are(will remain) covered where the response is being sent out", "bodyHTML": "<p dir=\"auto\">did you look at any other possible position where this can be inserted instead of response builders? and if not how did we ensure all cases are(will remain) covered where the response is being sent out</p>", "author": "aman1309", "createdAt": "2020-07-27T22:26:18Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java", "diffHunk": "@@ -153,8 +154,13 @@ private D buildRestLiResponseData(final Request request,\n         throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n             \"Unexpected null encountered. Null element inside of a List returned by the resource method: \" + routingResult.getResourceMethod());\n       }\n+      DataMap rawData = entry.data();\n+      if (resourceContext.isFillInDefaultsRequested())\n+      {\n+        rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n+      }", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0OTI3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461849278", "bodyText": "The way I find the response builder is by looking up all classes that implements the interface RestLiResponseBuilder so there are only 10 classes, I only need to implement this default filling feature in classes : ActionResponseBuilder BatchFinderResponseBuilder BatchGetResponseBuilder GetResponseBuilder and CollectionResponseBuilder, it covers: Action, Get, GetAll, BatchGet, Finder, BatchFinder methods\nThere are other classes that implements this inferface RestLiResponseBuilder I think they don't need to have this:\nBatchCreateResponseBuilder\nBatchResponseBuilder for  BATCH_UPDATE, BATCH_PARTIAL_UPDATE\nCreateResponseBuilder\nEmptyResponseBuilder\nPartialUpdateResponseBuilder\nLet me know if I miss anything", "author": "BrianPin", "createdAt": "2020-07-28T20:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNTY5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\nindex 0b5a19b6c..ab06558bf 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n", "chunk": "@@ -159,8 +159,7 @@ public abstract class CollectionResponseBuilder<D extends RestLiResponseData<? e\n       {\n         rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n       }\n-      processedElements.add(new AnyRecord(RestUtils\n-          .projectFields(rawData, resourceContext.getProjectionMode(), resourceContext.getProjectionMask())));\n+      processedElements.add(new AnyRecord(RestUtils.projectFields(rawData, resourceContext)));\n     }\n \n     //Now for custom metadata\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\nindex ab06558bf..8b1308430 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n", "chunk": "@@ -157,7 +157,7 @@ public abstract class CollectionResponseBuilder<D extends RestLiResponseData<? e\n       DataMap rawData = entry.data();\n       if (resourceContext.isFillInDefaultsRequested())\n       {\n-        rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n+        rawData = (DataMap) ResponseUtils.fillInDataDefault(entry.schema(), rawData);\n       }\n       processedElements.add(new AnyRecord(RestUtils.projectFields(rawData, resourceContext)));\n     }\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\nindex 8b1308430..c45f89212 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n", "chunk": "@@ -154,12 +153,7 @@ public abstract class CollectionResponseBuilder<D extends RestLiResponseData<? e\n         throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n             \"Unexpected null encountered. Null element inside of a List returned by the resource method: \" + routingResult.getResourceMethod());\n       }\n-      DataMap rawData = entry.data();\n-      if (resourceContext.isFillInDefaultsRequested())\n-      {\n-        rawData = (DataMap) ResponseUtils.fillInDataDefault(entry.schema(), rawData);\n-      }\n-      processedElements.add(new AnyRecord(RestUtils.projectFields(rawData, resourceContext)));\n+      processedElements.add(new AnyRecord(RestUtils.projectFields(entry.data(), resourceContext)));\n     }\n \n     //Now for custom metadata\n", "next_change": {"commit": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\nindex c45f89212..7241b9a99 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n", "chunk": "@@ -153,7 +154,12 @@ public abstract class CollectionResponseBuilder<D extends RestLiResponseData<? e\n         throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n             \"Unexpected null encountered. Null element inside of a List returned by the resource method: \" + routingResult.getResourceMethod());\n       }\n-      processedElements.add(new AnyRecord(RestUtils.projectFields(entry.data(), resourceContext)));\n+      DataMap rawData = entry.data();\n+      if (resourceContext.isDefaultValueFillInRequested())\n+      {\n+        rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n+      }\n+      processedElements.add(new AnyRecord(RestUtils.projectFields(rawData, resourceContext)));\n     }\n \n     //Now for custom metadata\n", "next_change": {"commit": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\nindex 7241b9a99..ab06558bf 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n", "chunk": "@@ -155,7 +155,7 @@ public abstract class CollectionResponseBuilder<D extends RestLiResponseData<? e\n             \"Unexpected null encountered. Null element inside of a List returned by the resource method: \" + routingResult.getResourceMethod());\n       }\n       DataMap rawData = entry.data();\n-      if (resourceContext.isDefaultValueFillInRequested())\n+      if (resourceContext.isFillInDefaultsRequested())\n       {\n         rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n       }\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\nindex ab06558bf..8b1308430 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n", "chunk": "@@ -157,7 +157,7 @@ public abstract class CollectionResponseBuilder<D extends RestLiResponseData<? e\n       DataMap rawData = entry.data();\n       if (resourceContext.isFillInDefaultsRequested())\n       {\n-        rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n+        rawData = (DataMap) ResponseUtils.fillInDataDefault(entry.schema(), rawData);\n       }\n       processedElements.add(new AnyRecord(RestUtils.projectFields(rawData, resourceContext)));\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNjEyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461206125", "body": "switch case?", "bodyText": "switch case?", "bodyHTML": "<p dir=\"auto\">switch case?</p>", "author": "aman1309", "createdAt": "2020-07-27T22:27:28Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMjQwMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r467322400", "bodyText": "Done", "author": "BrianPin", "createdAt": "2020-08-07T23:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNjEyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,13 +116,13 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n       if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n         Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -132,10 +131,10 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(dataMap);\n-    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n-      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n     }\n     return dataWithDefault;\n   }\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwOTA1Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461209057", "body": "this condition seems common and can be moved out of data schema switch construct", "bodyText": "this condition seems common and can be moved out of data schema switch construct", "bodyHTML": "<p dir=\"auto\">this condition seems common and can be moved out of data schema switch construct</p>", "author": "aman1309", "createdAt": "2020-07-27T22:35:17Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,13 +116,13 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n       if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n         Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -132,10 +131,10 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(dataMap);\n-    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n-      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n     }\n     return dataWithDefault;\n   }\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDUxMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461210512", "body": "fillInDefaultOnXYZ.. can be combined into fillInDefaultValues with switch case. why do we need separate methods for each? and separate switch case constructs?", "bodyText": "fillInDefaultOnXYZ.. can be combined into fillInDefaultValues with switch case. why do we need separate methods for each? and separate switch case constructs?", "bodyHTML": "<p dir=\"auto\">fillInDefaultOnXYZ.. can be combined into fillInDefaultValues with switch case. why do we need separate methods for each? and separate switch case constructs?</p>", "author": "aman1309", "createdAt": "2020-07-27T22:39:10Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1NDAzMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463554033", "bodyText": "+1, it seems there is a lot of duplication.\nYou'd just need one fillDefaultOnData which takes dataSchema and an Object, does the branching based on schema type.\nIn all other methods, you just have to get the nested schema (eg, field, item or value schema) and call this method again.", "author": "karthikbalasub", "createdAt": "2020-07-31T11:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDUxMg=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,13 +116,13 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n       if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n         Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -132,10 +131,10 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(dataMap);\n-    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n-      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n     }\n     return dataWithDefault;\n   }\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461212137", "body": "if you are filling in default datamap you shouldn't need to recursively call for record again as all default would be there from schema", "bodyText": "if you are filling in default datamap you shouldn't need to recursively call for record again as all default would be there from schema", "bodyHTML": "<p dir=\"auto\">if you are filling in default datamap you shouldn't need to recursively call for record again as all default would be there from schema</p>", "author": "aman1309", "createdAt": "2020-07-27T22:43:37Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMzU5Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461233596", "bodyText": "Well, according to Karthik's example, even there is a default for a record, we still need to figure out other field to see if there is a default. Let me know if we need a sync with Karthik", "author": "BrianPin", "createdAt": "2020-07-27T23:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNDc0OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461234749", "bodyText": "oh yeah no need thanks", "author": "aman1309", "createdAt": "2020-07-27T23:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,13 +116,13 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n       if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n         Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -132,10 +131,10 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(dataMap);\n-    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n-      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n     }\n     return dataWithDefault;\n   }\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461213493", "body": "this would increase the memory consumption unnecessarily can you optimize for this. why do you need this? you're anyway traversing for list of schema fields. can we not update and return the original datamap?", "bodyText": "this would increase the memory consumption unnecessarily can you optimize for this. why do you need this? you're anyway traversing for list of schema fields. can we not update and return the original datamap?", "bodyHTML": "<p dir=\"auto\">this would increase the memory consumption unnecessarily can you optimize for this. why do you need this? you're anyway traversing for list of schema fields. can we not update and return the original datamap?</p>", "author": "aman1309", "createdAt": "2020-07-27T22:47:14Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMzAwOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461233009", "bodyText": "Do you mean update and return?", "author": "BrianPin", "createdAt": "2020-07-27T23:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNTI5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461235297", "bodyText": "yup or just update will also be fine", "author": "aman1309", "createdAt": "2020-07-27T23:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzMjMxNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r462032314", "bodyText": "I tried just update without creating new dataMap, in some cases it will return exception because the dataMap is read only.\nI think in this regard we can not just assume we can update the dataMap, we have only one way to make the fill.\nThe exception is like the following:, it is caused by an internal field in DataMap _readOnly, which in the function we can not change it.\nGradle suite > Gradle test > com.linkedin.restli.internal.server.response.TestResponseUtils > testGetAbsentFieldsDefaultValues[4](case5.json) FAILED\n    java.lang.AssertionError: Test failed with exception:\n    java.lang.UnsupportedOperationException: Cannot mutate a read-only map\n        at org.testng.Assert.fail(Assert.java:96)\n        at com.linkedin.restli.internal.server.response.TestResponseUtils.testGetAbsentFieldsDefaultValues(TestResponseUtils.java:84)", "author": "BrianPin", "createdAt": "2020-07-29T04:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNTMzNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463705334", "bodyText": "Ah! you may use DataComplex.clone() for shallow copy instead of manual deep copy.", "author": "aman1309", "createdAt": "2020-07-31T16:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,13 +116,13 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n       if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n         Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -132,10 +131,10 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(dataMap);\n-    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n-      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n     }\n     return dataWithDefault;\n   }\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1NjExMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463556113", "body": "This is an interesting way to provide inputs. One suggestion here is to name the files in a meaningful way. \r\neg, basic_case.json, array_map.json", "bodyText": "This is an interesting way to provide inputs. One suggestion here is to name the files in a meaningful way.\neg, basic_case.json, array_map.json", "bodyHTML": "<p dir=\"auto\">This is an interesting way to provide inputs. One suggestion here is to name the files in a meaningful way.<br>\neg, basic_case.json, array_map.json</p>", "author": "karthikbalasub", "createdAt": "2020-07-31T11:27:01Z", "path": "restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.internal.server.response;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.util.DataMapUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.util.Collections;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestResponseUtils\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    return new Object[][]{\n+        {\"case1.json\"},\n+        {\"case2.json\"},\n+        {\"case3.json\"},\n+        {\"case4.json\"},\n+        {\"case5.json\"},\n+        {\"case6.json\"},\n+        {\"case7.json\"},\n+        {\"case8.json\"},", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 0bd6ec9f9..da0d64d52 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n", "chunk": "@@ -50,14 +50,14 @@ public class TestResponseUtils\n   public Object[][] schemaFilesForDefaultSerializationTest()\n   {\n     return new Object[][]{\n-        {\"case1.json\"},\n-        {\"case2.json\"},\n-        {\"case3.json\"},\n-        {\"case4.json\"},\n-        {\"case5.json\"},\n-        {\"case6.json\"},\n-        {\"case7.json\"},\n-        {\"case8.json\"},\n+        {\"default_filling_for_empty_value_but_keyed.json\"},\n+        {\"default_filling_union_without_alias.json\"},\n+        {\"filling_other_field_in_record.json\"},\n+        {\"iterate_array_element_default.json\"},\n+        {\"iterate_map_entry_default.json\"},\n+        {\"record_field_default_case.json\"},\n+        {\"record_field_is_record.json\"},\n+        {\"record_field_with_array_map.json\"},\n     };\n   }\n \n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nsimilarity index 52%\nrename from restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nrename to restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex da0d64d52..02a8fd91b 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n", "chunk": "@@ -49,39 +54,63 @@ public class TestResponseUtils\n   @DataProvider(name = \"default_serialization\")\n   public Object[][] schemaFilesForDefaultSerializationTest()\n   {\n+    DataList recordBField1 = new DataList(1);\n+    recordBField1.add(-1);\n+\n+    DataMap recordBField2 = new DataMap();\n+    DataList recordBField2DefaultValues = new DataList(2);\n+    recordBField2DefaultValues.add(\"defaultValue1\");\n+    recordBField2DefaultValues.add(\"defaultValue2\");\n+    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n+\n     return new Object[][]{\n-        {\"default_filling_for_empty_value_but_keyed.json\"},\n-        {\"default_filling_union_without_alias.json\"},\n-        {\"filling_other_field_in_record.json\"},\n-        {\"iterate_array_element_default.json\"},\n-        {\"iterate_map_entry_default.json\"},\n-        {\"record_field_default_case.json\"},\n-        {\"record_field_is_record.json\"},\n-        {\"record_field_with_array_map.json\"},\n+        {\n+            \"RecordA.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .put(\"field3\", 0L)\n+                .put(\"field4\", \"default\")\n+                .build())\n+        },\n+        {\n+            \"RecordB.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", recordBField1)\n+                .put(\"field2\", recordBField2)\n+                .build())\n+        },\n+        {\n+            \"RecordC.pdl\",\n+            new DataMap(),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"name\", \"default+\")\n+                .build()),\n+        }\n     };\n   }\n \n   @Test(dataProvider = \"default_serialization\")\n-  public void testGetAbsentFieldsDefaultValues(String caseFilename)\n+  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)\n   {\n     try\n     {\n       MultiFormatDataSchemaResolver schemaResolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverDir);\n-      String expectedDataJsonFile = Files.readFile(new File(pegasusDir + FS + caseFilename));\n-      DataMap caseData = DataMapUtils.readMap(new ByteArrayInputStream(expectedDataJsonFile.getBytes()), Collections.emptyMap());\n \n-      String schemaFileText = Files.readFile(new File(pegasusDir + FS + caseData.get(\"schema\")));\n-      DataMap caseInput = (DataMap) caseData.get(\"input\");\n-      DataMap caseExpect = (DataMap) caseData.get(\"expect\");\n+      String schemaFileText = Files.readFile(new File(pegasusDir + FS + filename));\n       DataSchema schema = DataTemplateUtil.parseSchema(schemaFileText, schemaResolver, SchemaFormatType.PDL);\n-      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, caseInput);\n-      System.out.println(\"Expect \" + caseExpect);\n-      System.out.println(\"Actual \" + dataWithDefault);\n-      Assert.assertEquals(dataWithDefault, caseExpect, (String) caseData.get(\"context\"));\n+      ResponseUtils.getAbsentFieldsDefaultValues((RecordDataSchema) schema, data);\n+      Assert.assertEquals(data, expected);\n     }\n     catch (Exception e)\n     {\n-      Assert.fail(\"Test failed with exception: \\n\" + e.toString());\n+      Assert.fail(\"Read test schema file failure, check file read successful \\n\" + e);\n     }\n   }\n \n", "next_change": null}]}}]}}, {"oid": "9827904cb299eb93d624530e2435a0e023944999", "url": "https://github.com/linkedin/rest.li/commit/9827904cb299eb93d624530e2435a0e023944999", "message": "Address logic simplification comment and case renaming comment", "committedDate": "2020-08-07T20:44:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NTQ2NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468095464", "body": "initialize size", "bodyText": "initialize size", "bodyHTML": "<p dir=\"auto\">initialize size</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:25:50Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjc5OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026799", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-08-12T06:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NTQ2NA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -132,10 +131,10 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(dataMap);\n-    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n-      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n     }\n     return dataWithDefault;\n   }\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -143,17 +142,18 @@ public class ResponseUtils\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n   public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataWithDefault = new DataMap(dataMap);\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     if (dataWithDefault.size() == 1)\n     {\n       for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -150,10 +155,9 @@ public class ResponseUtils\n     return dataListWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    DataMap dataWithDefault = dataMap.clone();\n     if (dataWithDefault.size() == 1)\n     {\n       for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -155,7 +160,7 @@ public class ResponseUtils\n     return dataListWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataMap dataWithDefault = dataMap.clone();\n     if (dataWithDefault.size() == 1)\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzgxMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097810", "body": "We should use CheckedUtil::*withoutChecking methods.\r\n\r\nBy default DataMap and DataList check for cycles when a new object is added. However, since we are controling the logic and are not creating cycles, we can skip those checks for performance. ", "bodyText": "We should use CheckedUtil::*withoutChecking methods.\nBy default DataMap and DataList check for cycles when a new object is added. However, since we are controling the logic and are not creating cycles, we can skip those checks for performance.", "bodyHTML": "<p dir=\"auto\">We should use CheckedUtil::*withoutChecking methods.</p>\n<p dir=\"auto\">By default DataMap and DataList check for cycles when a new object is added. However, since we are controling the logic and are not creating cycles, we can skip those checks for performance.</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:19Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjc1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026754", "bodyText": "Sure", "author": "BrianPin", "createdAt": "2020-08-12T06:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzgxMA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,13 +116,13 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n       if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n         Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzg2Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097862", "body": "use CheckedUtil::*withoutChecking methods.\r\n", "bodyText": "use CheckedUtil::*withoutChecking methods.", "bodyHTML": "<p dir=\"auto\">use CheckedUtil::*withoutChecking methods.</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -117,13 +116,13 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n       if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n         Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzkzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097931", "body": "use CheckedUtil::*withoutChecking methods.\r\n", "bodyText": "use CheckedUtil::*withoutChecking methods.", "bodyHTML": "<p dir=\"auto\">use CheckedUtil::*withoutChecking methods.</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:33Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjY4OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026689", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -132,10 +131,10 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(dataMap);\n-    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n-      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n     }\n     return dataWithDefault;\n   }\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzk4OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097988", "body": "use CheckedUtil::*withoutChecking methods.\r\n", "bodyText": "use CheckedUtil::*withoutChecking methods.", "bodyHTML": "<p dir=\"auto\">use CheckedUtil::*withoutChecking methods.</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjY1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026654", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzk4OA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -143,17 +142,18 @@ public class ResponseUtils\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n   public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataWithDefault = new DataMap(dataMap);\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     if (dataWithDefault.size() == 1)\n     {\n       for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -150,10 +155,9 @@ public class ResponseUtils\n     return dataListWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    DataMap dataWithDefault = dataMap.clone();\n     if (dataWithDefault.size() == 1)\n     {\n       for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -155,7 +160,7 @@ public class ResponseUtils\n     return dataListWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataMap dataWithDefault = dataMap.clone();\n     if (dataWithDefault.size() == 1)\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODEyMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468098120", "body": "use CheckedUtil::*withoutChecking methods.\r\n", "bodyText": "use CheckedUtil::*withoutChecking methods.", "bodyHTML": "<p dir=\"auto\">use CheckedUtil::*withoutChecking methods.</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:57Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    if (dataWithDefault.size() == 1)\n+    {\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        dataWithDefault.put(memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjYyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026623", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -164,7 +164,7 @@ public class ResponseUtils\n         {\n           return dataWithDefault;\n         }\n-        dataWithDefault.put(memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n     return dataWithDefault;\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTAwMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468099003", "body": "This will check all the entries again.. so better option is to create an empty dataMap and put items inside the loop without checking\r\n(Similar to how you are handling lists)", "bodyText": "This will check all the entries again.. so better option is to create an empty dataMap and put items inside the loop without checking\n(Similar to how you are handling lists)", "bodyHTML": "<p dir=\"auto\">This will check all the entries again.. so better option is to create an empty dataMap and put items inside the loop without checking<br>\n(Similar to how you are handling lists)</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:32:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjU5MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026590", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTAwMw=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -132,10 +131,10 @@ public class ResponseUtils\n   public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(dataMap);\n-    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n-      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n     }\n     return dataWithDefault;\n   }\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -128,10 +133,10 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    DataMap dataWithDefault = dataMap.clone();\n     for (Map.Entry<String, Object> entry : dataMap.entrySet())\n     {\n       CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -133,7 +138,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataSchema valueSchema = schema.getValues();\n     DataMap dataWithDefault = dataMap.clone();\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -144,7 +149,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n     DataList dataListWithDefault = new DataList(dataList.size());\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTc4NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468099785", "body": "Do not initialize the default map with original data. Update it as you iterate the data to fill defaults, use putWithoutchecking", "bodyText": "Do not initialize the default map with original data. Update it as you iterate the data to fill defaults, use putWithoutchecking", "bodyHTML": "<p dir=\"auto\">Do not initialize the default map with original data. Update it as you iterate the data to fill defaults, use putWithoutchecking</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:34:12Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjQ5Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026493", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -143,17 +142,18 @@ public class ResponseUtils\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n   public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataWithDefault = new DataMap(dataMap);\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     if (dataWithDefault.size() == 1)\n     {\n       for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n", "next_change": {"commit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -150,10 +155,9 @@ public class ResponseUtils\n     return dataListWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    DataMap dataWithDefault = dataMap.clone();\n     if (dataWithDefault.size() == 1)\n     {\n       for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n", "next_change": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -155,7 +160,7 @@ public class ResponseUtils\n     return dataListWithDefault;\n   }\n \n-  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataMap dataWithDefault = dataMap.clone();\n     if (dataWithDefault.size() == 1)\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDc3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468100778", "body": "You don't need this method. Just make fillInDataDefault public and use that. ", "bodyText": "You don't need this method. Just make fillInDataDefault public and use that.", "bodyHTML": "<p dir=\"auto\">You don't need this method. Just make fillInDataDefault public and use that.</p>", "author": "karthikbalasub", "createdAt": "2020-08-10T18:36:06Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    if (dataWithDefault.size() == 1)\n+    {\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        dataWithDefault.put(memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjM3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026378", "bodyText": "Method consolidated", "author": "BrianPin", "createdAt": "2020-08-12T06:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDc3OA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -176,15 +176,6 @@ public class ResponseUtils\n     return fillInDataDefault(dataSchema, data);\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n-  {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n-  }\n-\n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n   {\n     RestResponseBuilder builder = new RestResponseBuilder()\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -94,86 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    switch (schema.getType())\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      case RECORD:\n-        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-      case TYPEREF:\n-        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-      case MAP:\n-        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-      case UNION:\n-        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-      case ARRAY:\n-        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-      default:\n-        return dataWithoutDefault;\n-    }\n-  }\n-\n-  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n-  {\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n-  {\n-    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "url": "https://github.com/linkedin/rest.li/commit/fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "message": "address performance related comment", "committedDate": "2020-08-12T06:00:04Z", "type": "forcePushed"}, {"oid": "9dd9423bea7d526770ed897fd0be455f4de070cf", "url": "https://github.com/linkedin/rest.li/commit/9dd9423bea7d526770ed897fd0be455f4de070cf", "message": "address performance related comment", "committedDate": "2020-08-12T06:15:00Z", "type": "forcePushed"}, {"oid": "bbc6a802bd24b4fcb42c11eea1dd6f82a652b9dd", "url": "https://github.com/linkedin/rest.li/commit/bbc6a802bd24b4fcb42c11eea1dd6f82a652b9dd", "message": "Update change log", "committedDate": "2020-08-17T16:45:40Z", "type": "forcePushed"}, {"oid": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "url": "https://github.com/linkedin/rest.li/commit/a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "message": "Use dataMap clone instead of putWithoutChecking to reduce performance impact", "committedDate": "2020-08-18T06:29:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5Njc5MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r472396791", "body": "add javadoc here", "bodyText": "add javadoc here", "bodyHTML": "<p dir=\"auto\">add javadoc here</p>", "author": "aman1309", "createdAt": "2020-08-18T18:26:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,93 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)", "originalCommit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,6 +93,11 @@ public class ResponseUtils\n     }\n   }\n \n+  /**\n+   * @param schema schema for the companion data map\n+   * @param dataWithoutDefault data map that is response for a restli request\n+   * @return data object that filled in with default values on the field with default value set on the schema\n+   */\n   public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     try\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NzQ4Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r472397483", "body": "change scope to private. not required to be exposed outside. same for other methods", "bodyText": "change scope to private. not required to be exposed outside. same for other methods", "bodyHTML": "<p dir=\"auto\">change scope to private. not required to be exposed outside. same for other methods</p>", "author": "aman1309", "createdAt": "2020-08-18T18:27:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,93 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    try\n+    {\n+      switch (schema.getType())\n+      {\n+        case RECORD:\n+          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case TYPEREF:\n+          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+        case MAP:\n+          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case UNION:\n+          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case ARRAY:\n+          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+        default:\n+          return dataWithoutDefault;\n+      }\n+    }\n+    catch (CloneNotSupportedException ex)\n+    {\n+      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException", "originalCommit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -119,7 +124,7 @@ public class ResponseUtils\n     }\n   }\n \n-  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n+  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n   {\n     DataMap dataWithDefault = dataMap.clone();\n     for (RecordDataSchema.Field field : schema.getFields())\n", "next_change": {"commit": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f002ec9fe..c0315b651 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,96 +90,18 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * @param schema schema for the companion data map\n-   * @param dataWithoutDefault data map that is response for a restli request\n-   * @return data object that filled in with default values on the field with default value set on the schema\n-   */\n-  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n   {\n-    try\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n     {\n-      switch (schema.getType())\n+      if (!dataMap.containsKey(field.getName()))\n       {\n-        case RECORD:\n-          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case TYPEREF:\n-          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n-        case MAP:\n-          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case UNION:\n-          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n-        case ARRAY:\n-          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n-        default:\n-          return dataWithoutDefault;\n-      }\n-    }\n-    catch (CloneNotSupportedException ex)\n-    {\n-      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n-    }\n-  }\n-\n-  private static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (RecordDataSchema.Field field : schema.getFields())\n-    {\n-      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-      {\n-        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n-      }\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataSchema valueSchema = schema.getValues();\n-    DataMap dataWithDefault = dataMap.clone();\n-    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n-    {\n-      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n-    }\n-    return dataWithDefault;\n-  }\n-\n-  private static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n-  {\n-    DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList(dataList.size());\n-    for (Object o : dataList)\n-    {\n-      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n-    }\n-    return dataListWithDefault;\n-  }\n-\n-  private static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap) throws CloneNotSupportedException\n-  {\n-    DataMap dataWithDefault = dataMap.clone();\n-    if (dataWithDefault.size() == 1)\n-    {\n-      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n-      {\n-        String memberTypeKey = entry.getKey();\n-        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n-        if (memberDataSchema == null)\n+        if (field.getDefault() != null)\n         {\n-          return dataWithDefault;\n+          dataMap.put(field.getName(), field.getDefault());\n         }\n-        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n       }\n     }\n-    return dataWithDefault;\n-  }\n-\n-  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n-  {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c0315b651..4607a3bbd 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n", "next_change": {"commit": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4607a3bbd..200ab2553 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n", "next_change": {"commit": "4bd6141324db1856d9abee232d5b74cb99ff7365", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 200ab2553..61bc02b3e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -91,48 +92,87 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n+          {\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            {\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n+            }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (field.getDefault() != null)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n             }\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 61bc02b3e..a426b7e20 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -120,59 +139,48 @@ public class ResponseUtils\n         {\n           if (dataDefaultFilled.containsKey(field.getName()))\n           {\n-            DataMap fieldDefault = (DataMap) field.getDefault();\n-            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n-            if (fieldDataAssigned != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n-            else if (fieldDefault != null)\n-            {\n-              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDefault);\n-              dataDefaultFilled.put(field.getName(), fieldFilled);\n-            }\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n           else if (field.getDefault() != null)\n           {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n           }\n         }\n         else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n-          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n-          {\n-            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                (DataMap) dataDefaultFilled.get(field.getName())));\n-          }\n-          else if (field.getDefault() != null)\n+          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n+          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n+          if (!dataDefaultFilled.containsKey(field.getName()))\n           {\n-            if (dereferencedDataSchema instanceof RecordDataSchema)\n+            if (dereferencedSchema instanceof RecordDataSchema)\n             {\n-              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n-                  (DataMap) field.getDefault()));\n+              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n+              if (fieldDataMapWithDefault.size() > 0)\n+              {\n+                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n+              }\n             }\n             else\n             {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n+              if (field.getDefault() != null)\n+              {\n+                dataDefaultFilled.put(field.getName(), field.getDefault());\n+              }\n             }\n           }\n         }\n-        else // primitive | complex data schemas\n+        else // primitive | complex data schemas of this field in the record\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n           {\n-            if (field.getDefault() != null)\n-            {\n-              dataDefaultFilled.put(field.getName(), field.getDefault());\n-            }\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n-      return dataDefaultFilled;\n     }\n-    return dataMap;\n+    return dataDefaultFilled;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "b555a312099de17a5117f0cd2e5f048d494830d0", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex a426b7e20..e0a97a94f 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "436bab3e63d7c17615c4feccb732259825cc08b5", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e0a97a94f..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -96,96 +94,86 @@ public class ResponseUtils\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-    dataWithDefault.putAll(dataMap);\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        CheckedUtil.putWithoutChecking(dataWithDefault, field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n   }\n \n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    for (Map.Entry<String, Object> entry : dataMap.entrySet())\n+    {\n+      CheckedUtil.putWithoutChecking(dataWithDefault, entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n   public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n   {\n     DataSchema itemDataSchema = schema.getItems();\n-    DataList dataListWithDefault = new DataList();\n+    DataList dataListWithDefault = new DataList(dataList.size());\n     for (Object o : dataList)\n     {\n-      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n-      }\n-      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n-      }\n-      else\n-      {\n-        dataListWithDefault.add(o);\n-      }\n+      CheckedUtil.addWithoutChecking(dataListWithDefault, fillInDataDefault(itemDataSchema, o));\n     }\n     return dataListWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n   {\n-    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      DataMap dataMap = (DataMap) data;\n-      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n-    }\n-    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n-    {\n-      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    CheckedUtil.putAllWithoutChecking(dataWithDefault, dataMap);\n+    if (dataWithDefault.size() == 1)\n     {\n-      return data;\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        CheckedUtil.putWithoutChecking(dataWithDefault, memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n     }\n+    return dataWithDefault;\n   }\n \n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n   {\n-    if (dataSchema.getType() == DataSchema.Type.RECORD)\n-    {\n-      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n-    }\n-    return dataMap;\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n", "next_change": {"commit": "e0d533df508a3a213cf4b1909c9100e751792a60", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 4e77376db..c55fdba05 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -170,7 +174,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": {"commit": "c2fb120145b0af84c49c14771a7aaf137955bc97", "changed_code": [{"header": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n", "chunk": "@@ -174,7 +179,7 @@ public class ResponseUtils\n     return dataWithDefault;\n   }\n \n-  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n+  private static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data) throws CloneNotSupportedException\n   {\n     DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n     return fillInDataDefault(dataSchema, data);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "url": "https://github.com/linkedin/rest.li/commit/409ed62fb17a48648aa502cedf9973ea7b76bb46", "message": "address comment on method scope", "committedDate": "2020-08-21T07:53:44Z", "type": "forcePushed"}, {"oid": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "url": "https://github.com/linkedin/rest.li/commit/307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "url": "https://github.com/linkedin/rest.li/commit/b73b3e314542d4801b66365db7e3367b3fc8fbb1", "message": "Address Aman's comment about recursive resolve default values for record and fix the query key for this feature", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "url": "https://github.com/linkedin/rest.li/commit/9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "message": "Address comment: integration test and recursive resolve and typeref test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "c68a4a87545db83506676ee251b9631b5c18b917", "url": "https://github.com/linkedin/rest.li/commit/c68a4a87545db83506676ee251b9631b5c18b917", "message": "Fix integration test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "4bd6141324db1856d9abee232d5b74cb99ff7365", "url": "https://github.com/linkedin/rest.li/commit/4bd6141324db1856d9abee232d5b74cb99ff7365", "message": "Address Karthiks comment about design", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "8f8eed14e7352cf0964a7881964cf4bfcbdbe88e", "url": "https://github.com/linkedin/rest.li/commit/8f8eed14e7352cf0964a7881964cf4bfcbdbe88e", "message": "fix test failure in TestResourceSchemaCollection", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "3dcb85552f3653b177932480593368e1aa1a835a", "url": "https://github.com/linkedin/rest.li/commit/3dcb85552f3653b177932480593368e1aa1a835a", "message": "address Evan's comment regarding placeholder class in test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "url": "https://github.com/linkedin/rest.li/commit/bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "message": "address Karthiks comment about right place to fill in default, also review the logic of filling defaults", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "url": "https://github.com/linkedin/rest.li/commit/3e82f796f7b91e25261d42a3479f2cfbfc2be202", "message": "address Evan naming comments", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "4047975c79b41cf1457725b38e511ef8e4bfc405", "url": "https://github.com/linkedin/rest.li/commit/4047975c79b41cf1457725b38e511ef8e4bfc405", "message": "Add function mock to address test regressions caused by the new method of resource context", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "url": "https://github.com/linkedin/rest.li/commit/15b992d6f281f0b4dde00e80f157a253d892b1d5", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "url": "https://github.com/linkedin/rest.li/commit/a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "message": "Add server config logic in code", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "b555a312099de17a5117f0cd2e5f048d494830d0", "url": "https://github.com/linkedin/rest.li/commit/b555a312099de17a5117f0cd2e5f048d494830d0", "message": "Address comment for clarity", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "793f6419fdfe8446341a5df1782dc58bff3a6e30", "url": "https://github.com/linkedin/rest.li/commit/793f6419fdfe8446341a5df1782dc58bff3a6e30", "message": "add union method and re-org test cases", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "58e8ea8272b72fc5d4084422122e9be77ebcfa86", "url": "https://github.com/linkedin/rest.li/commit/58e8ea8272b72fc5d4084422122e9be77ebcfa86", "message": "address Aman javadoc comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "ecd3ddcfdc82367b38f81384e25aede4b06a5171", "url": "https://github.com/linkedin/rest.li/commit/ecd3ddcfdc82367b38f81384e25aede4b06a5171", "message": "update changelog.md", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "8f39f3c1023fd79c185e53636c412e3d30947827", "url": "https://github.com/linkedin/rest.li/commit/8f39f3c1023fd79c185e53636c412e3d30947827", "message": "Fix typo", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "08362edd6ff6eadc2ca3c2c41a7bbff24aca00b4", "url": "https://github.com/linkedin/rest.li/commit/08362edd6ff6eadc2ca3c2c41a7bbff24aca00b4", "message": "Address logic simplification comment and case renaming comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "436bab3e63d7c17615c4feccb732259825cc08b5", "url": "https://github.com/linkedin/rest.li/commit/436bab3e63d7c17615c4feccb732259825cc08b5", "message": "address performance related comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "2ead1d477885929de308e25a636119f9fe069b13", "url": "https://github.com/linkedin/rest.li/commit/2ead1d477885929de308e25a636119f9fe069b13", "message": "Update change log", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "9572e80c471f843034f97a31b79ed3bf8c335b22", "url": "https://github.com/linkedin/rest.li/commit/9572e80c471f843034f97a31b79ed3bf8c335b22", "message": "Fix version string", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "e0d533df508a3a213cf4b1909c9100e751792a60", "url": "https://github.com/linkedin/rest.li/commit/e0d533df508a3a213cf4b1909c9100e751792a60", "message": "Use dataMap clone instead of putWithoutChecking to reduce performance impact", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "c2fb120145b0af84c49c14771a7aaf137955bc97", "url": "https://github.com/linkedin/rest.li/commit/c2fb120145b0af84c49c14771a7aaf137955bc97", "message": "address comment on method scope", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "566703eb6c3bfde63d344ce8f2b149e22b0ff1e1", "url": "https://github.com/linkedin/rest.li/commit/566703eb6c3bfde63d344ce8f2b149e22b0ff1e1", "message": "Advance version in change log", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "883b9665a463ea86ff0571d6944024f832977cd8", "url": "https://github.com/linkedin/rest.li/commit/883b9665a463ea86ff0571d6944024f832977cd8", "message": "Update change log", "committedDate": "2020-08-24T07:46:04Z", "type": "commit"}, {"oid": "883b9665a463ea86ff0571d6944024f832977cd8", "url": "https://github.com/linkedin/rest.li/commit/883b9665a463ea86ff0571d6944024f832977cd8", "message": "Update change log", "committedDate": "2020-08-24T07:46:04Z", "type": "forcePushed"}, {"oid": "6c33c62d0ba896a583459a000e1fd088042bb016", "url": "https://github.com/linkedin/rest.li/commit/6c33c62d0ba896a583459a000e1fd088042bb016", "message": "Fix merge error on changelog", "committedDate": "2020-08-24T15:46:11Z", "type": "commit"}]}