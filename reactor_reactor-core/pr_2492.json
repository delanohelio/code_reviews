{"pr_number": 2492, "pr_title": "fix #2269 Add test util to capture logs in early-established loggers", "pr_author": "ericbottard", "pr_createdAt": "2020-11-17T16:27:04Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2492", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzODUzNQ==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525938535", "body": "since we don't need `classWithLogger` I'd remove that parameter here and in `resetAppender`. The class is public but in the /test sourceset so this shouldn't be an issue. (although the end goal is to make this part of `reactor-test` prod sourceset)", "bodyText": "since we don't need classWithLogger I'd remove that parameter here and in resetAppender. The class is public but in the /test sourceset so this shouldn't be an issue. (although the end goal is to make this part of reactor-test prod sourceset)", "bodyHTML": "<p dir=\"auto\">since we don't need <code>classWithLogger</code> I'd remove that parameter here and in <code>resetAppender</code>. The class is public but in the /test sourceset so this shouldn't be an issue. (although the end goal is to make this part of <code>reactor-test</code> prod sourceset)</p>", "author": "simonbasle", "createdAt": "2020-11-18T09:32:21Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk2MDExOA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525960118", "bodyText": "I think there is still value to provide a TestLogger as opposed to letting the method create one internally and return it. see comment about tuning logging levels.", "author": "simonbasle", "createdAt": "2020-11-18T10:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzODUzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex cf778e04e..775ef65cd 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -3,28 +3,31 @@ package reactor.test;\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.util.function.Function;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n import reactor.test.util.TestLogger;\n import reactor.util.Logger;\n import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tprivate static TestLogger testLogger;\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n \t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n+\tpublic static void resetAdditionalLogger() {\n \t\tLoggerUtils.testLogger = null;\n \t}\n \n-\tpublic static void installQueryableLogger() {\n-\t\tLoggers.resetLoggerFactory();\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {\n \t\ttry {\n \t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n \t\t\tlfField.setAccessible(true);\n", "next_change": {"commit": "6673eaff689fb0adaa08bf125e6819b09cf87ba5", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nsimilarity index 92%\nrename from reactor-core/src/test/java/reactor/test/LoggerUtils.java\nrename to reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nindex 775ef65cd..0f0f58170 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n", "chunk": "@@ -1,31 +1,30 @@\n-package reactor.test;\n+package reactor.test.util;\n \n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.function.Function;\n \n-import reactor.test.util.TestLogger;\n import reactor.util.Logger;\n import reactor.util.Loggers;\n \n+/**\n+ * This class eases testing interested in what reactor classes emit using {@link Logger loggers}.\n+ *\n+ * @author Eric Bottard\n+ */\n public class LoggerUtils {\n \tprivate static Logger testLogger;\n \n-\tpublic static void installAdditionalLogger(Logger testLogger) {\n-\t\tLoggerUtils.testLogger = testLogger;\n-\t}\n-\n-\tpublic static void resetAdditionalLogger() {\n-\t\tLoggerUtils.testLogger = null;\n-\t}\n-\n \t/**\n \t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n \t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n \t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n \t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n \t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t *\n+\t * <p>This method should be called very early in the application/tests lifecycle, before reactor classes have created\n+\t * their loggers.</p>\n \t */\n \tpublic static void setupDivertingLoggerFactory() {\n \t\ttry {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0NjEwNA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525946104", "body": "rather than using reflexion maybe we should look into making `Loggers` return the previous factory ? or at least a `Function<String, Logger> getCurrentFactory()` getter?", "bodyText": "rather than using reflexion maybe we should look into making Loggers return the previous factory ? or at least a Function<String, Logger> getCurrentFactory() getter?", "bodyHTML": "<p dir=\"auto\">rather than using reflexion maybe we should look into making <code>Loggers</code> return the previous factory ? or at least a <code>Function&lt;String, Logger&gt; getCurrentFactory()</code> getter?</p>", "author": "simonbasle", "createdAt": "2020-11-18T09:43:45Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex cf778e04e..775ef65cd 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -3,28 +3,31 @@ package reactor.test;\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.util.function.Function;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n import reactor.test.util.TestLogger;\n import reactor.util.Logger;\n import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tprivate static TestLogger testLogger;\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n \t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n+\tpublic static void resetAdditionalLogger() {\n \t\tLoggerUtils.testLogger = null;\n \t}\n \n-\tpublic static void installQueryableLogger() {\n-\t\tLoggers.resetLoggerFactory();\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {\n \t\ttry {\n \t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n \t\t\tlfField.setAccessible(true);\n", "next_change": {"commit": "6673eaff689fb0adaa08bf125e6819b09cf87ba5", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nsimilarity index 92%\nrename from reactor-core/src/test/java/reactor/test/LoggerUtils.java\nrename to reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nindex 775ef65cd..0f0f58170 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n", "chunk": "@@ -1,31 +1,30 @@\n-package reactor.test;\n+package reactor.test.util;\n \n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.function.Function;\n \n-import reactor.test.util.TestLogger;\n import reactor.util.Logger;\n import reactor.util.Loggers;\n \n+/**\n+ * This class eases testing interested in what reactor classes emit using {@link Logger loggers}.\n+ *\n+ * @author Eric Bottard\n+ */\n public class LoggerUtils {\n \tprivate static Logger testLogger;\n \n-\tpublic static void installAdditionalLogger(Logger testLogger) {\n-\t\tLoggerUtils.testLogger = testLogger;\n-\t}\n-\n-\tpublic static void resetAdditionalLogger() {\n-\t\tLoggerUtils.testLogger = null;\n-\t}\n-\n \t/**\n \t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n \t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n \t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n \t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n \t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t *\n+\t * <p>This method should be called very early in the application/tests lifecycle, before reactor classes have created\n+\t * their loggers.</p>\n \t */\n \tpublic static void setupDivertingLoggerFactory() {\n \t\ttry {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NDUwNg==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525954506", "body": "another interesting feature that this opens up is to \"force\" a logging level via the `TestLogger`. This can be done in a separate issue, but if `TestLogger` was to have configurable loglevel, `isXxxEnabled` here could be an OR combination of the delegate and the root `TestLogger`. A special `TestLogger` subclass for the `DivertingLogger` could even have a `Map<String, LogLevel>` internally, to selectively filter out logs from some sources.", "bodyText": "another interesting feature that this opens up is to \"force\" a logging level via the TestLogger. This can be done in a separate issue, but if TestLogger was to have configurable loglevel, isXxxEnabled here could be an OR combination of the delegate and the root TestLogger. A special TestLogger subclass for the DivertingLogger could even have a Map<String, LogLevel> internally, to selectively filter out logs from some sources.", "bodyHTML": "<p dir=\"auto\">another interesting feature that this opens up is to \"force\" a logging level via the <code>TestLogger</code>. This can be done in a separate issue, but if <code>TestLogger</code> was to have configurable loglevel, <code>isXxxEnabled</code> here could be an OR combination of the delegate and the root <code>TestLogger</code>. A special <code>TestLogger</code> subclass for the <code>DivertingLogger</code> could even have a <code>Map&lt;String, LogLevel&gt;</code> internally, to selectively filter out logs from some sources.</p>", "author": "simonbasle", "createdAt": "2020-11-18T09:55:48Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled();", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex cf778e04e..775ef65cd 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -62,7 +68,7 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled();\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n", "next_change": {"commit": "8da2efa9b2ad130fcaabfae6bee541e01dc9ada9", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nsimilarity index 60%\nrename from reactor-core/src/test/java/reactor/test/LoggerUtils.java\nrename to reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nindex 775ef65cd..9ddfa93a6 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n", "chunk": "@@ -68,145 +78,165 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isTraceEnabled() || (logger != null && logger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(msg);\n \t\t\t}\n \t\t\tdelegate.trace(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(format, arguments);\n \t\t\t}\n \t\t\tdelegate.trace(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(msg, t);\n \t\t\t}\n \t\t\tdelegate.trace(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isDebugEnabled() {\n-\t\t\treturn delegate.isDebugEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isDebugEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isDebugEnabled() || (logger != null && logger.isDebugEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(msg);\n \t\t\t}\n \t\t\tdelegate.debug(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(format, arguments);\n \t\t\t}\n \t\t\tdelegate.debug(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(msg, t);\n \t\t\t}\n \t\t\tdelegate.debug(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isInfoEnabled() {\n-\t\t\treturn delegate.isInfoEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isInfoEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isInfoEnabled() || (logger != null && logger.isInfoEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(msg);\n \t\t\t}\n \t\t\tdelegate.info(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(format, arguments);\n \t\t\t}\n \t\t\tdelegate.info(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(msg, t);\n \t\t\t}\n \t\t\tdelegate.info(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isWarnEnabled() {\n-\t\t\treturn delegate.isWarnEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isWarnEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isWarnEnabled() || (logger != null && logger.isWarnEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(msg);\n \t\t\t}\n \t\t\tdelegate.warn(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(format, arguments);\n \t\t\t}\n \t\t\tdelegate.warn(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(msg, t);\n \t\t\t}\n \t\t\tdelegate.warn(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isErrorEnabled() {\n-\t\t\treturn delegate.isErrorEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isErrorEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isErrorEnabled() || (logger != null && logger.isErrorEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(msg);\n \t\t\t}\n \t\t\tdelegate.error(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(format, arguments);\n \t\t\t}\n \t\t\tdelegate.error(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(msg, t);\n \t\t\t}\n \t\t\tdelegate.error(msg, t);\n \t\t}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTIzOA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525955238", "body": "maybe add a global parameter along `testLogger` to decide whether or not the `delegate` should also receive log instructions", "bodyText": "maybe add a global parameter along testLogger to decide whether or not the delegate should also receive log instructions", "bodyHTML": "<p dir=\"auto\">maybe add a global parameter along <code>testLogger</code> to decide whether or not the <code>delegate</code> should also receive log instructions</p>", "author": "simonbasle", "createdAt": "2020-11-18T09:56:52Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,208 @@\n package reactor.test;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n import ch.qos.logback.classic.spi.ILoggingEvent;\n import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static TestLogger testLogger;\n \n \tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n \tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled();\n \t\t}\n \n \t\t@Override\n-\t\tprotected void append(ILoggingEvent eventObject) {\n-\t\t\tif (eventObject.getLevel() == Level.ERROR) {\n-\t\t\t\ttestLogger.error(eventObject.getFormattedMessage()\n-\t\t\t\t                            .concat(\"\\n\")\n-\t\t\t\t                            .concat(throwableProxyConverter.convert(eventObject)));\n+\t\tpublic void trace(String msg) {\n+\t\t\tif (LoggerUtils.testLogger != null) {\n+\t\t\t\tLoggerUtils.testLogger.trace(msg);\n+\t\t\t}\n+\t\t\tdelegate.trace(msg);", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMjE0Nw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527022147", "bodyText": "defering this until somebody actually \"complains\" about the double output", "author": "simonbasle", "createdAt": "2020-11-19T16:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTIzOA=="}], "type": "inlineReview", "revised_code": {"commit": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex cf778e04e..775ef65cd 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -62,7 +68,7 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled();\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n", "next_change": {"commit": "8da2efa9b2ad130fcaabfae6bee541e01dc9ada9", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nsimilarity index 60%\nrename from reactor-core/src/test/java/reactor/test/LoggerUtils.java\nrename to reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nindex 775ef65cd..9ddfa93a6 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n", "chunk": "@@ -68,145 +78,165 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isTraceEnabled() || (logger != null && logger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(msg);\n \t\t\t}\n \t\t\tdelegate.trace(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(format, arguments);\n \t\t\t}\n \t\t\tdelegate.trace(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(msg, t);\n \t\t\t}\n \t\t\tdelegate.trace(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isDebugEnabled() {\n-\t\t\treturn delegate.isDebugEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isDebugEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isDebugEnabled() || (logger != null && logger.isDebugEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(msg);\n \t\t\t}\n \t\t\tdelegate.debug(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(format, arguments);\n \t\t\t}\n \t\t\tdelegate.debug(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(msg, t);\n \t\t\t}\n \t\t\tdelegate.debug(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isInfoEnabled() {\n-\t\t\treturn delegate.isInfoEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isInfoEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isInfoEnabled() || (logger != null && logger.isInfoEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(msg);\n \t\t\t}\n \t\t\tdelegate.info(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(format, arguments);\n \t\t\t}\n \t\t\tdelegate.info(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(msg, t);\n \t\t\t}\n \t\t\tdelegate.info(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isWarnEnabled() {\n-\t\t\treturn delegate.isWarnEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isWarnEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isWarnEnabled() || (logger != null && logger.isWarnEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(msg);\n \t\t\t}\n \t\t\tdelegate.warn(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(format, arguments);\n \t\t\t}\n \t\t\tdelegate.warn(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(msg, t);\n \t\t\t}\n \t\t\tdelegate.warn(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isErrorEnabled() {\n-\t\t\treturn delegate.isErrorEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isErrorEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isErrorEnabled() || (logger != null && logger.isErrorEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(msg);\n \t\t\t}\n \t\t\tdelegate.error(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(format, arguments);\n \t\t\t}\n \t\t\tdelegate.error(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(msg, t);\n \t\t\t}\n \t\t\tdelegate.error(msg, t);\n \t\t}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1NTU0OQ==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525955549", "body": "yeah this is dead code, but it should be done in a separate PR", "bodyText": "yeah this is dead code, but it should be done in a separate PR", "bodyHTML": "<p dir=\"auto\">yeah this is dead code, but it should be done in a separate PR</p>", "author": "simonbasle", "createdAt": "2020-11-18T09:57:16Z", "path": "reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java", "diffHunk": "@@ -440,40 +440,6 @@ public I next() {\n \t\t}\n \t}\n \n-\tfinal <S extends OperatorScenario<I, PI, O, PO>> void forEachScenario(List<S> scenarios,", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "13e5e6cd17c6318fe9c5fc917ef4e923f1f6a635", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java b/reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java\nindex eb79bb8a7..fb70941d3 100644\n--- a/reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java\n+++ b/reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java\n", "chunk": "@@ -440,6 +440,40 @@ public abstract class BaseOperatorTest<I, PI extends Publisher<? extends I>, O,\n \t\t}\n \t}\n \n+\tfinal <S extends OperatorScenario<I, PI, O, PO>> void forEachScenario(List<S> scenarios,\n+\t\t\tConsumer<S> test) {\n+\t\tfor (S scenario : scenarios) {\n+\t\t\tif (scenario == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\ttest.accept(scenario);\n+\t\t\t}\n+\t\t\tcatch (Error | RuntimeException e) {\n+\t\t\t\tif (scenario.description != null) {\n+\t\t\t\t\te.addSuppressed(new Exception(scenario.description, scenario.stack));\n+\t\t\t\t}\n+\t\t\t\tif (scenario.stack != null) {\n+\t\t\t\t\te.addSuppressed(scenario.stack);\n+\t\t\t\t}\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\tcatch (Throwable e) {\n+\t\t\t\tif (scenario.description != null) {\n+\t\t\t\t\te.addSuppressed(new Exception(scenario.description, scenario.stack));\n+\t\t\t\t}\n+\t\t\t\tif (scenario.stack != null) {\n+\t\t\t\t\te.addSuppressed(scenario.stack);\n+\t\t\t\t}\n+\t\t\t\tthrow Exceptions.bubble(e);\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tReactorTestExecutionListener.reset();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tabstract PI hide(PI input);\n \n \tfinal StepVerifier.Step<O> inputHidden(OperatorScenario<I, PI, O, PO> scenario) {\n", "next_change": {"commit": "f46191d8c10dc93c048ffc12a5cf747d51e02d26", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java b/reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java\nindex fb70941d3..00cfc9d00 100644\n--- a/reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java\n+++ b/reactor-core/src/test/java/reactor/test/publisher/BaseOperatorTest.java\n", "chunk": "@@ -468,9 +468,6 @@ public abstract class BaseOperatorTest<I, PI extends Publisher<? extends I>, O,\n \t\t\t\t}\n \t\t\t\tthrow Exceptions.bubble(e);\n \t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tReactorTestExecutionListener.reset();\n-\t\t\t}\n \t\t}\n \t}\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1OTA0MA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525959040", "body": "why removing the `final`s in this file ?", "bodyText": "why removing the finals in this file ?", "bodyHTML": "<p dir=\"auto\">why removing the <code>final</code>s in this file ?</p>", "author": "simonbasle", "createdAt": "2020-11-18T10:02:13Z", "path": "reactor-core/src/main/java/reactor/util/Loggers.java", "diffHunk": "@@ -64,7 +64,7 @@\n \t * @see #useConsoleLoggers()\n \t * @see #useVerboseConsoleLoggers()\n \t */\n-\tpublic static final void resetLoggerFactory() {\n+\tpublic static void resetLoggerFactory() {", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk1OTM3Nw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r525959377", "body": "(need a TODO to complete this test, no assertion)", "bodyText": "(need a TODO to complete this test, no assertion)", "bodyHTML": "<p dir=\"auto\">(need a TODO to complete this test, no assertion)</p>", "author": "simonbasle", "createdAt": "2020-11-18T10:02:47Z", "path": "reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java", "diffHunk": "@@ -972,4 +972,11 @@ public void reportThrowInSubscribeWithFuseableErrorResumed() {\n \n \t\tassertSubscriber.assertNoError().awaitAndAssertNextValues(123);\n \t}\n+\n+\t@Test\n+\tpublic void onDiscardCallbackErrorsLog() {\n+\t\tContext context = Operators.enableOnDiscard(Context.empty(), t -> {throw new RuntimeException(\"Boom\");});\n+\t\tOperators.onDiscard(\"Foo\", context);\n+", "originalCommit": "065378d00adcd05262bafbdf6ed6ad8cdd5e094c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "509283403d1874fef538136638cb40a6d6a990b9", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java b/reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java\nindex 3668fec25..c9db42580 100644\n--- a/reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java\n+++ b/reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java\n", "chunk": "@@ -976,7 +978,14 @@ public class OperatorsTest {\n \t@Test\n \tpublic void onDiscardCallbackErrorsLog() {\n \t\tContext context = Operators.enableOnDiscard(Context.empty(), t -> {throw new RuntimeException(\"Boom\");});\n-\t\tOperators.onDiscard(\"Foo\", context);\n \n+\t\tTestLogger testLogger = new TestLogger();\n+\t\tLoggerUtils.installAdditionalLogger(testLogger);\n+\t\ttry {\n+\t\t\tOperators.onDiscard(\"Foo\", context);\n+\t\t\tassertThat(testLogger.getErrContent()).contains(\"Error in discard hook - java.lang.RuntimeException: Boom\");\n+\t\t} finally {\n+\t\t\tLoggerUtils.resetAdditionalLogger();\n+\t\t}\n \t}\n }\n", "next_change": {"commit": "669d7847c8ebce0632f6ebc52d18e9d0fc3708dd", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java b/reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java\nindex c9db42580..d780efde1 100644\n--- a/reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java\n+++ b/reactor-core/src/test/java/reactor/core/publisher/OperatorsTest.java\n", "chunk": "@@ -980,12 +978,12 @@ public class OperatorsTest {\n \t\tContext context = Operators.enableOnDiscard(Context.empty(), t -> {throw new RuntimeException(\"Boom\");});\n \n \t\tTestLogger testLogger = new TestLogger();\n-\t\tLoggerUtils.installAdditionalLogger(testLogger);\n+\t\tLoggerUtils.enableCaptureWith(testLogger);\n \t\ttry {\n \t\t\tOperators.onDiscard(\"Foo\", context);\n \t\t\tassertThat(testLogger.getErrContent()).contains(\"Error in discard hook - java.lang.RuntimeException: Boom\");\n \t\t} finally {\n-\t\t\tLoggerUtils.resetAdditionalLogger();\n+\t\t\tLoggerUtils.disableCapture();\n \t\t}\n \t}\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc1NzQ2OA==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526757468", "body": "for the condition, capture the `testLogger` into a local variable (the `testLogger` could be nulled out between the `!= null` test and the `isTraceEnabled()` call)", "bodyText": "for the condition, capture the testLogger into a local variable (the testLogger could be nulled out between the != null test and the isTraceEnabled() call)", "bodyHTML": "<p dir=\"auto\">for the condition, capture the <code>testLogger</code> into a local variable (the <code>testLogger</code> could be nulled out between the <code>!= null</code> test and the <code>isTraceEnabled()</code> call)</p>", "author": "simonbasle", "createdAt": "2020-11-19T10:36:24Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -62,7 +68,7 @@ public String getName() {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled();\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());", "originalCommit": "3786997bbe39d8b08ad707c7669133b5a4c0be16", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "13e5e6cd17c6318fe9c5fc917ef4e923f1f6a635", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex 775ef65cd..cf778e04e 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -68,7 +62,7 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n+\t\t\treturn delegate.isTraceEnabled();\n \t\t}\n \n \t\t@Override\n", "next_change": {"commit": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex cf778e04e..775ef65cd 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -62,7 +68,7 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled();\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n", "next_change": {"commit": "8da2efa9b2ad130fcaabfae6bee541e01dc9ada9", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nsimilarity index 60%\nrename from reactor-core/src/test/java/reactor/test/LoggerUtils.java\nrename to reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nindex 775ef65cd..9ddfa93a6 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n", "chunk": "@@ -68,145 +78,165 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isTraceEnabled() || (logger != null && logger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(msg);\n \t\t\t}\n \t\t\tdelegate.trace(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(format, arguments);\n \t\t\t}\n \t\t\tdelegate.trace(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(msg, t);\n \t\t\t}\n \t\t\tdelegate.trace(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isDebugEnabled() {\n-\t\t\treturn delegate.isDebugEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isDebugEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isDebugEnabled() || (logger != null && logger.isDebugEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(msg);\n \t\t\t}\n \t\t\tdelegate.debug(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(format, arguments);\n \t\t\t}\n \t\t\tdelegate.debug(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(msg, t);\n \t\t\t}\n \t\t\tdelegate.debug(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isInfoEnabled() {\n-\t\t\treturn delegate.isInfoEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isInfoEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isInfoEnabled() || (logger != null && logger.isInfoEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(msg);\n \t\t\t}\n \t\t\tdelegate.info(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(format, arguments);\n \t\t\t}\n \t\t\tdelegate.info(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(msg, t);\n \t\t\t}\n \t\t\tdelegate.info(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isWarnEnabled() {\n-\t\t\treturn delegate.isWarnEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isWarnEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isWarnEnabled() || (logger != null && logger.isWarnEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(msg);\n \t\t\t}\n \t\t\tdelegate.warn(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(format, arguments);\n \t\t\t}\n \t\t\tdelegate.warn(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(msg, t);\n \t\t\t}\n \t\t\tdelegate.warn(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isErrorEnabled() {\n-\t\t\treturn delegate.isErrorEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isErrorEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isErrorEnabled() || (logger != null && logger.isErrorEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(msg);\n \t\t\t}\n \t\t\tdelegate.error(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(format, arguments);\n \t\t\t}\n \t\t\tdelegate.error(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(msg, t);\n \t\t\t}\n \t\t\tdelegate.error(msg, t);\n \t\t}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NDM2Mw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526764363", "body": "same comment as above about `testLogger` capture", "bodyText": "same comment as above about testLogger capture", "bodyHTML": "<p dir=\"auto\">same comment as above about <code>testLogger</code> capture</p>", "author": "simonbasle", "createdAt": "2020-11-19T10:47:09Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,214 @@\n package reactor.test;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\tpublic static void resetAdditionalLogger() {\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {\n+\t\ttry {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\tObject factoryObject = lfField.get(Loggers.class);\n+\t\t\tMethod factoryMethod = factoryObject.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\tfactoryMethod.setAccessible(true);\n+\n+\t\t\tLoggers.useCustomLoggers(category -> {\n+\t\t\t\ttry {\n+\t\t\t\t\tLogger original = (Logger) factoryMethod.invoke(factoryObject, category);\n+\t\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t\t}\n+\t\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n \t\t}\n \t}\n \n-\tstatic class TestAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {\n+\t/**\n+\t * A Logger that behaves like its {@link #delegate} but also logs to {@link LoggerUtils#testLogger} if it is set.\n+\t */\n+\tprivate static class DivertingLogger implements reactor.util.Logger {\n+\n+\t\tprivate final reactor.util.Logger delegate;\n \n-\t\tprivate final TestLogger testLogger;\n-\t\tprivate final ThrowableProxyConverter throwableProxyConverter = new ThrowableProxyConverter();\n+\t\tprivate DivertingLogger(Logger delegate) {\n+\t\t\tthis.delegate = delegate;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn delegate.getName();\n+\t\t}\n \n-\t\tTestAppender(TestLogger testLogger) {\n-\t\t\tthis.testLogger = testLogger;\n+\t\t@Override\n+\t\tpublic boolean isTraceEnabled() {\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n-\t\tprotected void append(ILoggingEvent eventObject) {\n-\t\t\tif (eventObject.getLevel() == Level.ERROR) {\n-\t\t\t\ttestLogger.error(eventObject.getFormattedMessage()\n-\t\t\t\t                            .concat(\"\\n\")\n-\t\t\t\t                            .concat(throwableProxyConverter.convert(eventObject)));\n+\t\tpublic void trace(String msg) {\n+\t\t\tif (LoggerUtils.testLogger != null) {", "originalCommit": "3786997bbe39d8b08ad707c7669133b5a4c0be16", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "13e5e6cd17c6318fe9c5fc917ef4e923f1f6a635", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex 775ef65cd..cf778e04e 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -68,7 +62,7 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n+\t\t\treturn delegate.isTraceEnabled();\n \t\t}\n \n \t\t@Override\n", "next_change": {"commit": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex cf778e04e..775ef65cd 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -62,7 +68,7 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled();\n+\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n", "next_change": {"commit": "8da2efa9b2ad130fcaabfae6bee541e01dc9ada9", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nsimilarity index 60%\nrename from reactor-core/src/test/java/reactor/test/LoggerUtils.java\nrename to reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nindex 775ef65cd..9ddfa93a6 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n", "chunk": "@@ -68,145 +78,165 @@ public class LoggerUtils {\n \n \t\t@Override\n \t\tpublic boolean isTraceEnabled() {\n-\t\t\treturn delegate.isTraceEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isTraceEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isTraceEnabled() || (logger != null && logger.isTraceEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(msg);\n \t\t\t}\n \t\t\tdelegate.trace(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(format, arguments);\n \t\t\t}\n \t\t\tdelegate.trace(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void trace(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.trace(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.trace(msg, t);\n \t\t\t}\n \t\t\tdelegate.trace(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isDebugEnabled() {\n-\t\t\treturn delegate.isDebugEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isDebugEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isDebugEnabled() || (logger != null && logger.isDebugEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(msg);\n \t\t\t}\n \t\t\tdelegate.debug(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(format, arguments);\n \t\t\t}\n \t\t\tdelegate.debug(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void debug(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.debug(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.debug(msg, t);\n \t\t\t}\n \t\t\tdelegate.debug(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isInfoEnabled() {\n-\t\t\treturn delegate.isInfoEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isInfoEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isInfoEnabled() || (logger != null && logger.isInfoEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(msg);\n \t\t\t}\n \t\t\tdelegate.info(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(format, arguments);\n \t\t\t}\n \t\t\tdelegate.info(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void info(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.info(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.info(msg, t);\n \t\t\t}\n \t\t\tdelegate.info(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isWarnEnabled() {\n-\t\t\treturn delegate.isWarnEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isWarnEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isWarnEnabled() || (logger != null && logger.isWarnEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(msg);\n \t\t\t}\n \t\t\tdelegate.warn(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(format, arguments);\n \t\t\t}\n \t\t\tdelegate.warn(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void warn(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.warn(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.warn(msg, t);\n \t\t\t}\n \t\t\tdelegate.warn(msg, t);\n \t\t}\n \n \t\t@Override\n \t\tpublic boolean isErrorEnabled() {\n-\t\t\treturn delegate.isErrorEnabled() || (LoggerUtils.testLogger != null && LoggerUtils.testLogger.isErrorEnabled());\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\treturn delegate.isErrorEnabled() || (logger != null && logger.isErrorEnabled());\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String msg) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(msg);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(msg);\n \t\t\t}\n \t\t\tdelegate.error(msg);\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String format, Object... arguments) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(format, arguments);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(format, arguments);\n \t\t\t}\n \t\t\tdelegate.error(format, arguments);\n \t\t}\n \n \t\t@Override\n \t\tpublic void error(String msg, Throwable t) {\n-\t\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\t\tLoggerUtils.testLogger.error(msg, t);\n+\t\t\tLogger logger = LoggerUtils.testLogger;\n+\t\t\tif (logger != null) {\n+\t\t\t\tlogger.error(msg, t);\n \t\t\t}\n \t\t\tdelegate.error(msg, t);\n \t\t}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc2NTQxNw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r526765417", "body": "I'm on the fence about the method actually setting up the logger factory, vs returning a \"factory\" (as a `Function`) to pass to `Loggers.useCustomLoggers`.", "bodyText": "I'm on the fence about the method actually setting up the logger factory, vs returning a \"factory\" (as a Function) to pass to Loggers.useCustomLoggers.", "bodyHTML": "<p dir=\"auto\">I'm on the fence about the method actually setting up the logger factory, vs returning a \"factory\" (as a <code>Function</code>) to pass to <code>Loggers.useCustomLoggers</code>.</p>", "author": "simonbasle", "createdAt": "2020-11-19T10:48:43Z", "path": "reactor-core/src/test/java/reactor/test/LoggerUtils.java", "diffHunk": "@@ -1,59 +1,214 @@\n package reactor.test;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.Logger;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n-import org.slf4j.LoggerFactory;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n import reactor.test.util.TestLogger;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tstatic final String TEST_APPENDER_NAME = \"TestAppender\";\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tTestAppender appender = new TestAppender(testLogger);\n-\t\t\tappender.start();\n-\t\t\tlogbackLogger.addAppender(appender);\n-\t\t}\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n+\t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n-\t\torg.slf4j.Logger slf4jLogger = LoggerFactory.getLogger(classWithLogger);\n-\t\tif (slf4jLogger instanceof Logger) {\n-\t\t\tLogger logbackLogger = (Logger) slf4jLogger;\n-\t\t\tlogbackLogger.detachAppender(TEST_APPENDER_NAME);\n+\tpublic static void resetAdditionalLogger() {\n+\t\tLoggerUtils.testLogger = null;\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {", "originalCommit": "3786997bbe39d8b08ad707c7669133b5a4c0be16", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "13e5e6cd17c6318fe9c5fc917ef4e923f1f6a635", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex 775ef65cd..cf778e04e 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -3,31 +3,28 @@ package reactor.test;\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n-import java.util.function.Function;\n \n+import ch.qos.logback.classic.Level;\n+import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n+import ch.qos.logback.classic.spi.ILoggingEvent;\n+import ch.qos.logback.core.UnsynchronizedAppenderBase;\n import reactor.test.util.TestLogger;\n import reactor.util.Logger;\n import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tprivate static Logger testLogger;\n+\tprivate static TestLogger testLogger;\n \n-\tpublic static void installAdditionalLogger(Logger testLogger) {\n+\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n \t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAdditionalLogger() {\n+\tpublic static void resetAppender(Class<?> classWithLogger) {\n \t\tLoggerUtils.testLogger = null;\n \t}\n \n-\t/**\n-\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n-\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n-\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n-\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n-\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n-\t */\n-\tpublic static void setupDivertingLoggerFactory() {\n+\tpublic static void installQueryableLogger() {\n+\t\tLoggers.resetLoggerFactory();\n \t\ttry {\n \t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n \t\t\tlfField.setAccessible(true);\n", "next_change": {"commit": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\nindex cf778e04e..775ef65cd 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n", "chunk": "@@ -3,28 +3,31 @@ package reactor.test;\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.util.function.Function;\n \n-import ch.qos.logback.classic.Level;\n-import ch.qos.logback.classic.pattern.ThrowableProxyConverter;\n-import ch.qos.logback.classic.spi.ILoggingEvent;\n-import ch.qos.logback.core.UnsynchronizedAppenderBase;\n import reactor.test.util.TestLogger;\n import reactor.util.Logger;\n import reactor.util.Loggers;\n \n public class LoggerUtils {\n-\tprivate static TestLogger testLogger;\n+\tprivate static Logger testLogger;\n \n-\tpublic static void addAppender(TestLogger testLogger, Class<?> classWithLogger) {\n+\tpublic static void installAdditionalLogger(Logger testLogger) {\n \t\tLoggerUtils.testLogger = testLogger;\n \t}\n \n-\tpublic static void resetAppender(Class<?> classWithLogger) {\n+\tpublic static void resetAdditionalLogger() {\n \t\tLoggerUtils.testLogger = null;\n \t}\n \n-\tpublic static void installQueryableLogger() {\n-\t\tLoggers.resetLoggerFactory();\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t */\n+\tpublic static void setupDivertingLoggerFactory() {\n \t\ttry {\n \t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n \t\t\tlfField.setAccessible(true);\n", "next_change": {"commit": "6673eaff689fb0adaa08bf125e6819b09cf87ba5", "changed_code": [{"header": "diff --git a/reactor-core/src/test/java/reactor/test/LoggerUtils.java b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nsimilarity index 92%\nrename from reactor-core/src/test/java/reactor/test/LoggerUtils.java\nrename to reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nindex 775ef65cd..0f0f58170 100644\n--- a/reactor-core/src/test/java/reactor/test/LoggerUtils.java\n+++ b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n", "chunk": "@@ -1,31 +1,30 @@\n-package reactor.test;\n+package reactor.test.util;\n \n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.function.Function;\n \n-import reactor.test.util.TestLogger;\n import reactor.util.Logger;\n import reactor.util.Loggers;\n \n+/**\n+ * This class eases testing interested in what reactor classes emit using {@link Logger loggers}.\n+ *\n+ * @author Eric Bottard\n+ */\n public class LoggerUtils {\n \tprivate static Logger testLogger;\n \n-\tpublic static void installAdditionalLogger(Logger testLogger) {\n-\t\tLoggerUtils.testLogger = testLogger;\n-\t}\n-\n-\tpublic static void resetAdditionalLogger() {\n-\t\tLoggerUtils.testLogger = null;\n-\t}\n-\n \t/**\n \t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n \t * original logging framework used by reactor, but also use the logger set via {@link #installAdditionalLogger(Logger)}, irrespective\n \t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n \t * logged by reactor will pass a {@link TestLogger} instance to {@link #installAdditionalLogger(Logger)}, trigger the operation\n \t * under scrutiny, assert the logger contents and reset state by calling {@link #resetAdditionalLogger()}.\n+\t *\n+\t * <p>This method should be called very early in the application/tests lifecycle, before reactor classes have created\n+\t * their loggers.</p>\n \t */\n \tpublic static void setupDivertingLoggerFactory() {\n \t\ttry {\n", "next_change": null}]}}]}}]}}, {"oid": "13e5e6cd17c6318fe9c5fc917ef4e923f1f6a635", "url": "https://github.com/reactor/reactor-core/commit/13e5e6cd17c6318fe9c5fc917ef4e923f1f6a635", "message": "fix #2269 Introduce an early override of loggers in tests", "committedDate": "2020-11-19T11:36:03Z", "type": "commit"}, {"oid": "cb1f11c4a980bf472b03baf551a874ba9bed3565", "url": "https://github.com/reactor/reactor-core/commit/cb1f11c4a980bf472b03baf551a874ba9bed3565", "message": "Use better names for LoggerUtils methods.", "committedDate": "2020-11-19T11:37:10Z", "type": "commit"}, {"oid": "b72e68c3e7e1a8ce9b4871f8fd0a21526e017600", "url": "https://github.com/reactor/reactor-core/commit/b72e68c3e7e1a8ce9b4871f8fd0a21526e017600", "message": "Warn on non-balanced calls", "committedDate": "2020-11-19T11:37:10Z", "type": "commit"}, {"oid": "6673eaff689fb0adaa08bf125e6819b09cf87ba5", "url": "https://github.com/reactor/reactor-core/commit/6673eaff689fb0adaa08bf125e6819b09cf87ba5", "message": "Move TestUtils into reactor-test production code", "committedDate": "2020-11-19T11:37:11Z", "type": "commit"}, {"oid": "509283403d1874fef538136638cb40a6d6a990b9", "url": "https://github.com/reactor/reactor-core/commit/509283403d1874fef538136638cb40a6d6a990b9", "message": "Finish test for Operators.onDiscard()", "committedDate": "2020-11-19T11:37:11Z", "type": "commit"}, {"oid": "8da2efa9b2ad130fcaabfae6bee541e01dc9ada9", "url": "https://github.com/reactor/reactor-core/commit/8da2efa9b2ad130fcaabfae6bee541e01dc9ada9", "message": "Capture logger variable to protect against it being nulled in a race", "committedDate": "2020-11-19T11:37:11Z", "type": "commit"}, {"oid": "669d7847c8ebce0632f6ebc52d18e9d0fc3708dd", "url": "https://github.com/reactor/reactor-core/commit/669d7847c8ebce0632f6ebc52d18e9d0fc3708dd", "message": "Rename methods", "committedDate": "2020-11-19T13:45:05Z", "type": "commit"}, {"oid": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "url": "https://github.com/reactor/reactor-core/commit/a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "message": "Add tests for LoggerUtils", "committedDate": "2020-11-19T15:12:13Z", "type": "commit"}, {"oid": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "url": "https://github.com/reactor/reactor-core/commit/a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "message": "Add tests for LoggerUtils", "committedDate": "2020-11-19T15:12:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxNTkwMw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527015903", "body": "still needs to remove the call to old `reset()` method in `BaseOperatorTest`", "bodyText": "still needs to remove the call to old reset() method in BaseOperatorTest", "bodyHTML": "<p dir=\"auto\">still needs to remove the call to old <code>reset()</code> method in <code>BaseOperatorTest</code></p>", "author": "simonbasle", "createdAt": "2020-11-19T16:18:09Z", "path": "reactor-core/src/test/java/reactor/ReactorTestExecutionListener.java", "diffHunk": "@@ -24,10 +25,21 @@\n import reactor.core.publisher.Hooks;\n import reactor.core.scheduler.Schedulers;\n import reactor.test.AssertionsUtils;\n+import reactor.test.util.LoggerUtils;\n+import reactor.util.Logger;\n \n+/**\n+ * A custom TestExecutionListener that helps with tests in reactor:<ul>\n+ *     <li>resets {@link Hooks} once a test is finished, making sure no dirty state remains,</li>\n+ *     <li>resets {@link Schedulers} related infrastructure, making sure no dirty state remains,</li>\n+ *     <li>installs custom assertJ {@link Representation} for some of reactor types,</li>\n+ *     <li>installs a custom {@link Logger} factory <strong>very</strong> early in the suite lifecycle, so that loggers\n+ *     in reactor (which are typically static members initialized early) can be diverted and asserted in tests.</li>\n+ * </ul>\n+ */\n public class ReactorTestExecutionListener implements TestExecutionListener {\n \n-\tpublic static void reset() {\n+\tprivate static void resetHooksAndSchedulers() {", "originalCommit": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMDA4Mw==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527020083", "body": "nitpick: I'd put the static methods above both static inner classes, and add basic documentation", "bodyText": "nitpick: I'd put the static methods above both static inner classes, and add basic documentation", "bodyHTML": "<p dir=\"auto\">nitpick: I'd put the static methods above both static inner classes, and add basic documentation</p>", "author": "simonbasle", "createdAt": "2020-11-19T16:23:44Z", "path": "reactor-test/src/main/java/reactor/test/util/LoggerUtils.java", "diffHunk": "@@ -0,0 +1,281 @@\n+package reactor.test.util;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.function.Function;\n+\n+import reactor.core.Disposable;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n+\n+/**\n+ * This class eases testing interested in what reactor classes emit using {@link Logger loggers}.\n+ *\n+ * @author Eric Bottard\n+ */\n+public final class LoggerUtils {\n+\tprivate static Logger testLogger;\n+\n+\tprivate LoggerUtils() {\n+\t}\n+\n+\t/**\n+\t * Sets a {@link Loggers#useCustomLoggers(Function) logger factory} that will return loggers that not only use the\n+\t * original logging framework used by reactor, but also use the logger set via {@link #enableCaptureWith(Logger)}, irrespective\n+\t * of its name or how it was obtained. The expectation here is that tests that want to assess that something is\n+\t * logged by reactor will pass a {@link TestLogger} instance to {@link #enableCaptureWith(Logger)}, trigger the operation\n+\t * under scrutiny, assert the logger contents and reset state by calling {@link #disableCapture()}.\n+\t *\n+\t * <p>This method should be called very early in the application/tests lifecycle, before reactor classes have created\n+\t * their loggers.</p>\n+\t *\n+\t * @return a disposable that re-installs the original factory when disposed\n+\t */\n+\tpublic static Disposable useCurrentLoggersWithCapture() {\n+\t\ttry {\n+\t\t\tCapturingFactory capturingFactory = new CapturingFactory();\n+\t\t\tLoggers.useCustomLoggers(capturingFactory);\n+\t\t\treturn capturingFactory;\n+\t\t}\n+\t\tcatch (NoSuchFieldException | IllegalAccessException | NoSuchMethodException e) {\n+\t\t\tthrow new RuntimeException(\"Could not install custom logger\", e);\n+\t\t}\n+\t}\n+\n+\tprivate static class CapturingFactory implements Function<String, Logger>, Disposable {\n+\n+\t\tprivate final Method originalFactoryMethod;\n+\n+\t\tprivate final Object orginalFactory;\n+\n+\t\tprivate CapturingFactory() throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException {\n+\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\tlfField.setAccessible(true);\n+\t\t\torginalFactory = lfField.get(Loggers.class);\n+\t\t\toriginalFactoryMethod = orginalFactory.getClass().getMethod(\"getLogger\", String.class);\n+\t\t\toriginalFactoryMethod.setAccessible(true);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Logger apply(String category) {\n+\t\t\ttry {\n+\t\t\t\tLogger original = (Logger) originalFactoryMethod.invoke(orginalFactory, category);\n+\t\t\t\treturn new DivertingLogger(original);\n+\t\t\t}\n+\t\t\tcatch (IllegalAccessException | InvocationTargetException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void dispose() {\n+\t\t\ttry {\n+\t\t\t\tField lfField = Loggers.class.getDeclaredField(\"LOGGER_FACTORY\");\n+\t\t\t\tlfField.setAccessible(true);\n+\t\t\t\tObject o = lfField.get(Loggers.class);\n+\n+\t\t\t\tif (!(Loggers.getLogger(LoggerUtils.class) instanceof DivertingLogger)) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Expected the current factory to be \" + this + \", found \" + o + \" instead\");\n+\t\t\t\t}\n+\t\t\t\tlfField.set(Loggers.class, orginalFactory);\n+\t\t\t}\n+\t\t\tcatch (NoSuchFieldException | IllegalAccessException e) {\n+\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static void enableCaptureWith(Logger testLogger) {", "originalCommit": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f46191d8c10dc93c048ffc12a5cf747d51e02d26", "changed_code": [{"header": "diff --git a/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\nindex c1863e546..2f416eb43 100644\n--- a/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n+++ b/reactor-test/src/main/java/reactor/test/util/LoggerUtils.java\n", "chunk": "@@ -86,17 +106,6 @@ public final class LoggerUtils {\n \t\t}\n \t}\n \n-\tpublic static void enableCaptureWith(Logger testLogger) {\n-\t\tif (LoggerUtils.testLogger != null) {\n-\t\t\tthrow new IllegalStateException(\"A logger was already set, maybe from a previous run. Don't forget to call resetAdditionalLogger()\");\n-\t\t}\n-\t\tLoggerUtils.testLogger = testLogger;\n-\t}\n-\n-\tpublic static void disableCapture() {\n-\t\tLoggerUtils.testLogger = null;\n-\t}\n-\n \t/**\n \t * A Logger that behaves like its {@link #delegate} but also logs to {@link LoggerUtils#testLogger} if it is set.\n \t */\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMTQxNg==", "url": "https://github.com/reactor/reactor-core/pull/2492#discussion_r527021416", "body": "the message should be asserted", "bodyText": "the message should be asserted", "bodyHTML": "<p dir=\"auto\">the message should be asserted</p>", "author": "simonbasle", "createdAt": "2020-11-19T16:25:22Z", "path": "reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package reactor.test.util;\n+\n+import org.junit.jupiter.api.Test;\n+import reactor.core.Disposable;\n+import reactor.util.Logger;\n+import reactor.util.Loggers;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+\n+class LoggerUtilsTest {\n+\n+\t@Test\n+\tvoid installsFactory() {\n+\t\tDisposable disposable = LoggerUtils.useCurrentLoggersWithCapture();\n+\t\tTestLogger testLogger = new TestLogger();\n+\t\ttry {\n+\t\t\tLogger frameworkLogger = Loggers.getLogger(\"category\"); // simulates an early creation of a logger\n+\n+\t\t\tLoggerUtils.enableCaptureWith(testLogger);\n+\t\t\tframeworkLogger.debug(\"Look ma!, I'm debugging!\");\n+\t\t\tassertThat(testLogger.getOutContent()).contains(\"Look ma!, I'm debugging!\");\n+\t\t\tLoggerUtils.disableCapture();\n+\t\t\tframeworkLogger.debug(\"This won't be captured\");\n+\t\t\tassertThat(testLogger.getOutContent()).doesNotContain(\"This won't be captured\");\n+\t\t} finally {\n+\t\t\tdisposable.dispose();\n+\n+\t\t\t// The following tests that once disposed, capturing is no longer in effect\n+\t\t\tLoggerUtils.enableCaptureWith(testLogger);\n+\t\t\tLogger otherLogger = Loggers.getLogger(\"another\");\n+\t\t\totherLogger.debug(\"This won't be captured either\");\n+\t\t\tassertThat(testLogger.getOutContent()).doesNotContain(\"This won't be captured either\");\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid disposeOnlyUninstallsItelf() {\n+\t\tDisposable disposable = LoggerUtils.useCurrentLoggersWithCapture();\n+\t\tassertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> {\n+\t\t\tLoggers.resetLoggerFactory(); // Overwrites our custom logger\n+\t\t\tdisposable.dispose();\n+\t\t});", "originalCommit": "a37d55852eef6a2a7f143fba29baf35ec1d68a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f46191d8c10dc93c048ffc12a5cf747d51e02d26", "changed_code": [{"header": "diff --git a/reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java b/reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java\nindex c51aff8ed..935a4b3dc 100644\n--- a/reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java\n+++ b/reactor-test/src/test/java/reactor/test/util/LoggerUtilsTest.java\n", "chunk": "@@ -55,6 +55,7 @@ class LoggerUtilsTest {\n \t\tassertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -> {\n \t\t\tLoggers.resetLoggerFactory(); // Overwrites our custom logger\n \t\t\tdisposable.dispose();\n-\t\t});\n+\t\t})\n+\t\t.withMessageContaining(\"Expected the current factory to be \" + LoggerUtils.class.getName() + \"$\");\n \t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}, {"oid": "f46191d8c10dc93c048ffc12a5cf747d51e02d26", "url": "https://github.com/reactor/reactor-core/commit/f46191d8c10dc93c048ffc12a5cf747d51e02d26", "message": "Address review comments", "committedDate": "2020-11-20T09:20:45Z", "type": "commit"}]}