{"pr_number": 2412, "pr_title": "Fix concurrent terminal signal detection in `SerializedManySink`", "pr_author": "bsideup", "pr_createdAt": "2020-10-02T15:23:07Z", "pr_url": "https://github.com/reactor/reactor-core/pull/2412", "timeline": [{"oid": "bced94e098012b0a0180e17f6e4cff28742756ff", "url": "https://github.com/reactor/reactor-core/commit/bced94e098012b0a0180e17f6e4cff28742756ff", "message": "Fix onNext/termination race in `SerializedManySink`", "committedDate": "2020-10-02T15:22:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5MTE2Nw==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r498891167", "body": "note to reviewers:\r\n\r\nlazy write should(?) be fine here because only the current thread really cares about the value", "bodyText": "note to reviewers:\nlazy write should(?) be fine here because only the current thread really cares about the value", "bodyHTML": "<p dir=\"auto\">note to reviewers:</p>\n<p dir=\"auto\">lazy write should(?) be fine here because only the current thread really cares about the value</p>", "author": "bsideup", "createdAt": "2020-10-02T15:25:10Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -78,16 +77,25 @@ public void emitComplete() {\n \n \t@Override\n \tpublic final Emission tryEmitComplete() {\n-\t\tif (done) {\n-\t\t\treturn Sinks.Emission.FAIL_TERMINATED;\n+\t\tThread currentTread = Thread.currentThread();\n+\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n+\t\t\tLOCKED_AT.lazySet(this, currentTread);", "originalCommit": "bced94e098012b0a0180e17f6e4cff28742756ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2OTk0NQ==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r499469945", "bodyText": "as discussed offband, would actually benefit from a detailed comment because lazySet has subtle implications.\nthe winning thread A update could be invisible to thread B performing LOCKED_AT.get below, but that is ok as long as the conditional is != currentThread. What can happen at the get:\n\nthe A update is visible \u2705\nthe A update is not visible, null is seen so a FAIL is still triggered \u2705\nthe A update is not visible, C is seen (any other old winning thread) so a FAIL is still triggered \u2705\n\nBut having an outdated B value is not possible because to reach that point, since we're in thread B, it must have executed the compareAndSet which would have loaded the update from A.", "author": "simonbasle", "createdAt": "2020-10-05T09:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5MTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5MjcwNw==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r498892707", "body": "description should be `onNext after onComplete`", "bodyText": "description should be onNext after onComplete", "bodyHTML": "<p dir=\"auto\">description should be <code>onNext after onComplete</code></p>", "author": "simonbasle", "createdAt": "2020-10-02T15:27:45Z", "path": "reactor-core/src/jcstress/java/reactor/core/publisher/SerializedManySinkStressTest.java", "diffHunk": "@@ -63,12 +63,38 @@ public void arbiter(LLI_Result r) {\n \t\t}\n \t}\n \n+\t@JCStressTest\n+\t@Outcome(id = {\"OK, FAIL_NON_SERIALIZED, 0\"}, expect = ACCEPTABLE, desc = \"onNext wins\")\n+\t@Outcome(id = {\"FAIL_NON_SERIALIZED, OK, 1\"}, expect = ACCEPTABLE, desc = \"onComplete wins\")\n+\t@Outcome(id = {\"FAIL_TERMINATED, OK, 1\"}, expect = ACCEPTABLE, desc = \"onNext after onComplete\")\n+\t@Outcome(id = {\"OK, OK, 1\"}, expect = ACCEPTABLE, desc = \"onComplete after onComplete\")", "originalCommit": "bced94e098012b0a0180e17f6e4cff28742756ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NDI4MA==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r498894280", "body": "the `sink` is always `Scannable` so `Scannable.from(sink)` could be turned into `sink` as a polish", "bodyText": "the sink is always Scannable so Scannable.from(sink) could be turned into sink as a polish", "bodyHTML": "<p dir=\"auto\">the <code>sink</code> is always <code>Scannable</code> so <code>Scannable.from(sink)</code> could be turned into <code>sink</code> as a polish</p>", "author": "simonbasle", "createdAt": "2020-10-02T15:30:25Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -164,35 +179,31 @@ public void emitNext(T value) {\n \t@Override\n \tpublic final Emission tryEmitNext(T t) {\n \t\tObjects.requireNonNull(t, \"t is null in sink.next(t)\");\n-\t\tif (done) {\n-\t\t\treturn Sinks.Emission.FAIL_TERMINATED;\n+\n+\t\tThread currentTread = Thread.currentThread();\n+\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n+\t\t\tLOCKED_AT.lazySet(this, currentTread);\n \t\t}\n-\t\tThread currentThread = Thread.currentThread();\n-\t\tThread lockedAt = LOCKED_AT.get(this);\n-\t\tif (lockedAt != null) {\n-\t\t\tif (lockedAt != currentThread) {\n+\t\telse {\n+\t\t\tif (LOCKED_AT.get(this) != currentTread) {\n \t\t\t\treturn Emission.FAIL_NON_SERIALIZED;\n \t\t\t}\n-\t\t}\n-\t\telse if (!LOCKED_AT.compareAndSet(this, null, currentThread)) {\n-\t\t\treturn Emission.FAIL_NON_SERIALIZED;\n+\t\t\tWIP.incrementAndGet(this);\n \t\t}\n \n-\t\tEmission emission = sink.tryEmitNext(t);\n-\t\tLOCKED_AT.compareAndSet(this, currentThread, null);\n-\t\treturn emission;\n+\t\ttry {\n+\t\t\treturn sink.tryEmitNext(t);\n+\t\t}\n+\t\tfinally {\n+\t\t\tif (WIP.decrementAndGet(this) == 0) {\n+\t\t\t\tLOCKED_AT.compareAndSet(this, currentTread, null);\n+\t\t\t}\n+\t\t}\n \t}\n \n \t@Override\n \t@Nullable\n \tpublic Object scanUnsafe(Attr key) {\n-\t\tif (key == Attr.ERROR) {\n-\t\t\treturn error;\n-\t\t}\n-\t\tif (key == Attr.TERMINATED) {\n-\t\t\treturn done;\n-\t\t}\n-\n \t\treturn Scannable.from(sink).scanUnsafe(key);", "originalCommit": "bced94e098012b0a0180e17f6e4cff28742756ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NjAzMA==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r498896030", "body": "I know I said that one wasn't probably useful offband, but while reviewing I thought about one benefit: it allows a more meaningful error code to be returned before checking for unsynchronized access: we _can_ relax on the serialized access condition if we know that the sink is terminated anyway (since fail fast to `FAIL_TERMINATED` wouldn't result in any spec violation downstream).", "bodyText": "I know I said that one wasn't probably useful offband, but while reviewing I thought about one benefit: it allows a more meaningful error code to be returned before checking for unsynchronized access: we can relax on the serialized access condition if we know that the sink is terminated anyway (since fail fast to FAIL_TERMINATED wouldn't result in any spec violation downstream).", "bodyHTML": "<p dir=\"auto\">I know I said that one wasn't probably useful offband, but while reviewing I thought about one benefit: it allows a more meaningful error code to be returned before checking for unsynchronized access: we <em>can</em> relax on the serialized access condition if we know that the sink is terminated anyway (since fail fast to <code>FAIL_TERMINATED</code> wouldn't result in any spec violation downstream).</p>", "author": "simonbasle", "createdAt": "2020-10-02T15:33:29Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -34,18 +35,16 @@\n \tfinal Many<T>       sink;\n \tfinal ContextHolder contextHolder;\n \n-\tvolatile     Throwable                                                  error;\n+\tvolatile int wip;\n \t@SuppressWarnings(\"rawtypes\")\n-\tstatic final AtomicReferenceFieldUpdater<SerializedManySink, Throwable> ERROR =\n-\t\t\tAtomicReferenceFieldUpdater.newUpdater(SerializedManySink.class, Throwable.class, \"error\");\n+\tstatic final AtomicIntegerFieldUpdater<SerializedManySink> WIP =\n+\t\t\tAtomicIntegerFieldUpdater.newUpdater(SerializedManySink.class, \"wip\");\n \n \tvolatile Thread lockedAt;\n \t@SuppressWarnings(\"rawtypes\")\n \tstatic final AtomicReferenceFieldUpdater<SerializedManySink, Thread> LOCKED_AT =\n \t\t\tAtomicReferenceFieldUpdater.newUpdater(SerializedManySink.class, Thread.class, \"lockedAt\");\n \n-\tvolatile boolean done;", "originalCommit": "bced94e098012b0a0180e17f6e4cff28742756ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ1MDY5NQ==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r499450695", "bodyText": "We could, but I had a feeling that it overcomplicates the implementation and preferred to stick to as trivial implementation as possible. Also, failing fast would hide the fact of a non-serialized access that is very racy and should ideally be detected ASAP with an increased chance of being triggered from tests. WDYT?", "author": "bsideup", "createdAt": "2020-10-05T09:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NjAzMA=="}], "type": "inlineReview"}, {"oid": "c7194f71071273690d3bbbd31316946178ee3193", "url": "https://github.com/reactor/reactor-core/commit/c7194f71071273690d3bbbd31316946178ee3193", "message": "Review fixes", "committedDate": "2020-10-05T09:09:53Z", "type": "commit"}, {"oid": "a470fbdd1f4cb27dcaae34aa40d3aaa35e877649", "url": "https://github.com/reactor/reactor-core/commit/a470fbdd1f4cb27dcaae34aa40d3aaa35e877649", "message": "extract `tryAcquire`, add a comment on `lazySet`", "committedDate": "2020-10-05T09:41:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ3ODIyOA==", "url": "https://github.com/reactor/reactor-core/pull/2412#discussion_r499478228", "body": "```suggestion\r\n\t\t\t// lazySet in thread A here is ok because:\r\n\t\t\t// 1. initial state is `null`\r\n\t\t\t// 2. `LOCKED_AT.get(this) != currentThread` from a different thread B could see outdated null or an outdated old thread\r\n\t\t\t// 3. but that old thread cannot be B: since we're in thread B, it must have executed the compareAndSet which would have loaded the update from A\r\n\t\t\t// 4. Seeing `null` or `C` is equivalent from seeing `A` from the perspective of the condition (`!= currentThread` is still true in all three cases)\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t// lazySet here, because:\n          \n          \n            \n            \t\t\t// 1. initial state is `null`\n          \n          \n            \n            \t\t\t// 2. `LOCKED_AT.get(this) != currentThread` from the next branch will either see null or an outdated old thread\n          \n          \n            \n            \t\t\t// 3. The only possibility to make the condition pass is to read it from the current thread that already has the value cached\n          \n          \n            \n            \t\t\t// lazySet in thread A here is ok because:\n          \n          \n            \n            \t\t\t// 1. initial state is `null`\n          \n          \n            \n            \t\t\t// 2. `LOCKED_AT.get(this) != currentThread` from a different thread B could see outdated null or an outdated old thread\n          \n          \n            \n            \t\t\t// 3. but that old thread cannot be B: since we're in thread B, it must have executed the compareAndSet which would have loaded the update from A\n          \n          \n            \n            \t\t\t// 4. Seeing `null` or `C` is equivalent from seeing `A` from the perspective of the condition (`!= currentThread` is still true in all three cases)", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> lazySet here, because:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> 1. initial state is `null`</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> 2. `LOCKED_AT.get(this) != currentThread` from the next branch will either see null or an outdated old thread</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> 3. The only possibility to make the condition pass is to read it from the current thread that already has the value cached</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> lazySet in thread A here is ok because:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> 1. initial state is `null`</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> 2. `LOCKED_AT.get(this) != currentThread` from a different thread B could see outdated null or an outdated old thread</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> 3. but that old thread cannot be B: since we're in thread B, it must have executed the compareAndSet which would have loaded the update from A</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t\t\t<span class=\"pl-c\"><span class=\"pl-c\">//</span> 4. Seeing `null` or `C` is equivalent from seeing `A` from the perspective of the condition (`!= currentThread` is still true in all three cases)</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "simonbasle", "createdAt": "2020-10-05T09:53:38Z", "path": "reactor-core/src/main/java/reactor/core/publisher/SinksSpecs.java", "diffHunk": "@@ -180,27 +168,38 @@ public void emitNext(T value) {\n \tpublic final Emission tryEmitNext(T t) {\n \t\tObjects.requireNonNull(t, \"t is null in sink.next(t)\");\n \n-\t\tThread currentTread = Thread.currentThread();\n-\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n-\t\t\tLOCKED_AT.lazySet(this, currentTread);\n-\t\t}\n-\t\telse {\n-\t\t\tif (LOCKED_AT.get(this) != currentTread) {\n-\t\t\t\treturn Emission.FAIL_NON_SERIALIZED;\n-\t\t\t}\n-\t\t\tWIP.incrementAndGet(this);\n+\t\tThread currentThread = Thread.currentThread();\n+\t\tif (!tryAcquire(currentThread)) {\n+\t\t\treturn Emission.FAIL_NON_SERIALIZED;\n \t\t}\n \n \t\ttry {\n \t\t\treturn sink.tryEmitNext(t);\n \t\t}\n \t\tfinally {\n \t\t\tif (WIP.decrementAndGet(this) == 0) {\n-\t\t\t\tLOCKED_AT.compareAndSet(this, currentTread, null);\n+\t\t\t\tLOCKED_AT.compareAndSet(this, currentThread, null);\n \t\t\t}\n \t\t}\n \t}\n \n+\tprivate boolean tryAcquire(Thread currentThread) {\n+\t\tif (WIP.get(this) == 0 && WIP.compareAndSet(this, 0, 1)) {\n+\t\t\t// lazySet here, because:\n+\t\t\t// 1. initial state is `null`\n+\t\t\t// 2. `LOCKED_AT.get(this) != currentThread` from the next branch will either see null or an outdated old thread\n+\t\t\t// 3. The only possibility to make the condition pass is to read it from the current thread that already has the value cached", "originalCommit": "a470fbdd1f4cb27dcaae34aa40d3aaa35e877649", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6cb6e571c36cf91f315254b1fb4a403fa3312298", "url": "https://github.com/reactor/reactor-core/commit/6cb6e571c36cf91f315254b1fb4a403fa3312298", "message": "update the comment", "committedDate": "2020-10-05T10:09:44Z", "type": "commit"}]}