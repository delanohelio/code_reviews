{"pr_number": 24057, "pr_title": "Add lang-lib methods to improve JSON compatibility", "pr_author": "dulajdilshan", "pr_createdAt": "2020-06-13T08:42:56Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439732108", "body": "I don't think this is where we should change. IMO we should do something like https://github.com/ballerina-platform/ballerina-lang/blob/master/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L64 because\r\n\r\n1. there may be other non-array member string values that will not get changed to BString if we change only here.\r\n\r\nFor example, the following might fail\r\n```ballerina\r\npublic function main() {\r\n    string st = \"\\\"hello\\\"\";\r\n    string j = <string> st.fromJsonString();\r\n}\r\n```\r\n\r\n2. On paths where `changeForBString` is already called and there are arrays present we'll be calling this method twice unnecessarily.\r\n\r\ne.g., https://github.com/ballerina-platform/ballerina-lang/blob/8077e15459944ea37f0c4a73d99bad2da6fe288f/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L95", "bodyText": "I don't think this is where we should change. IMO we should do something like https://github.com/ballerina-platform/ballerina-lang/blob/master/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L64 because\n\nthere may be other non-array member string values that will not get changed to BString if we change only here.\n\nFor example, the following might fail\npublic function main() {\n    string st = \"\\\"hello\\\"\";\n    string j = <string> st.fromJsonString();\n}\n\nOn paths where changeForBString is already called and there are arrays present we'll be calling this method twice unnecessarily.\n\ne.g., \n  \n    \n      ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java\n    \n    \n         Line 95\n      in\n      8077e15\n    \n    \n    \n    \n\n        \n          \n           return changeForBString(jsonObj);", "bodyHTML": "<p dir=\"auto\">I don't think this is where we should change. IMO we should do something like <a href=\"https://github.com/ballerina-platform/ballerina-lang/blob/master/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L64\">https://github.com/ballerina-platform/ballerina-lang/blob/master/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L64</a> because</p>\n<ol dir=\"auto\">\n<li>there may be other non-array member string values that will not get changed to BString if we change only here.</li>\n</ol>\n<p dir=\"auto\">For example, the following might fail</p>\n<div class=\"highlight highlight-source-ballerina position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public function main() {\n    string st = &quot;\\&quot;hello\\&quot;&quot;;\n    string j = &lt;string&gt; st.fromJsonString();\n}\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">function</span> main() {\n    <span class=\"pl-c1\">string</span> st <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-cce\">\\\"</span>hello<span class=\"pl-cce\">\\\"</span><span class=\"pl-pds\">\"</span></span>;\n    <span class=\"pl-c1\">string</span> j <span class=\"pl-k\">=</span> <span class=\"pl-k\">&lt;</span><span class=\"pl-c1\">string</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-smi\">st</span>.<span class=\"pl-en\">fromJsonString</span>();\n}</pre></div>\n<ol start=\"2\" dir=\"auto\">\n<li>On paths where <code>changeForBString</code> is already called and there are arrays present we'll be calling this method twice unnecessarily.</li>\n</ol>\n<p dir=\"auto\">e.g., <div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/ballerina-platform/ballerina-lang/blob/8077e15459944ea37f0c4a73d99bad2da6fe288f/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L95\">ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n         Line 95\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/ballerina-platform/ballerina-lang/commit/8077e15459944ea37f0c4a73d99bad2da6fe288f\">8077e15</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L95\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"95\"></td>\n          <td id=\"LC95\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">return</span> changeForBString(jsonObj); </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>", "author": "MaryamZi", "createdAt": "2020-06-13T11:32:20Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java", "diffHunk": "@@ -687,7 +687,7 @@ public State transition(StateMachine sm, char[] buff, int i, int count) throws J\n                     ch = buff[i];\n                     sm.processLocation(ch);\n                     if (ch == sm.currentQuoteChar) {\n-                        ((ArrayValue) sm.currentJsonNode).append(sm.value());\n+                        ((ArrayValue) sm.currentJsonNode).append(changeForBString(sm.value()));", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDA3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440370076", "bodyText": "Got it. Solved", "author": "dulajdilshan", "createdAt": "2020-06-15T18:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439739524", "body": "Please check the following example.\r\n\r\n```ballerina\r\npublic function main() {\r\n    map<int> m = {a: 1, b: 2};\r\n    map<json> mj = <map<json>> m.toJson();\r\n\r\n    mj[\"c\"] = \"non-int json\";\r\n}\r\n```\r\n\r\nThis currently fails with\r\n\r\n```cmd\r\n$ ballerina run xyz.bal\r\nCompiling source\r\n        xyz.bal\r\nRunning executables\r\n\r\nerror: {ballerina/lang.map}InherentTypeViolation message=invalid map insertion: expected value of type 'int', found 'string'\r\n        at xyz:main(xyz.bal:5)\r\n```", "bodyText": "Please check the following example.\npublic function main() {\n    map<int> m = {a: 1, b: 2};\n    map<json> mj = <map<json>> m.toJson();\n\n    mj[\"c\"] = \"non-int json\";\n}\nThis currently fails with\n$ ballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.map}InherentTypeViolation message=invalid map insertion: expected value of type 'int', found 'string'\n        at xyz:main(xyz.bal:5)", "bodyHTML": "<p dir=\"auto\">Please check the following example.</p>\n<div class=\"highlight highlight-source-ballerina position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public function main() {\n    map&lt;int&gt; m = {a: 1, b: 2};\n    map&lt;json&gt; mj = &lt;map&lt;json&gt;&gt; m.toJson();\n\n    mj[&quot;c&quot;] = &quot;non-int json&quot;;\n}\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">function</span> main() {\n    <span class=\"pl-k\">map</span><span class=\"pl-k\">&lt;</span><span class=\"pl-c1\">int</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-smi\">m</span> <span class=\"pl-k\">=</span> {<span class=\"pl-smi\">a</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">1</span>, <span class=\"pl-smi\">b</span><span class=\"pl-k\">:</span> <span class=\"pl-c1\">2</span>};\n    <span class=\"pl-k\">map</span><span class=\"pl-k\">&lt;</span><span class=\"pl-c1\">json</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-smi\">mj</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">map</span><span class=\"pl-k\">&lt;</span><span class=\"pl-c1\">json</span><span class=\"pl-k\">&gt;&gt;</span> <span class=\"pl-smi\">m</span>.<span class=\"pl-en\">toJson</span>();\n\n    <span class=\"pl-smi\">mj</span>[<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>c<span class=\"pl-pds\">\"</span></span>] <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>non-int json<span class=\"pl-pds\">\"</span></span>;\n}</pre></div>\n<p dir=\"auto\">This currently fails with</p>\n<div class=\"highlight highlight-source-batchfile position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"$ ballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.map}InherentTypeViolation message=invalid map insertion: expected value of type 'int', found 'string'\n        at xyz:main(xyz.bal:5)\"><pre>$ ballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.map}InherentTypeViolation message=invalid map insertion: expected value of <span class=\"pl-k\">type</span> 'int', found 'string'\n        <span class=\"pl-k\">at</span> xyz:main(xyz.bal:5)</pre></div>", "author": "MaryamZi", "createdAt": "2020-06-13T13:30:08Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!TypeChecker.checkIsLikeType(value, targetJsonType, true)) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, strand);\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+                }\n+                return newMap;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5MDY2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440590665", "bodyText": "Solved", "author": "dulajdilshan", "createdAt": "2020-06-16T05:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439760353", "body": "Double check this error message format. AFAIK, the convention is to prefix the reason with the module. But I can see that some of the `lang.value` functions have used this format. Let's check with the others and verify.", "bodyText": "Double check this error message format. AFAIK, the convention is to prefix the reason with the module. But I can see that some of the lang.value functions have used this format. Let's check with the others and verify.", "bodyHTML": "<p dir=\"auto\">Double check this error message format. AFAIK, the convention is to prefix the reason with the module. But I can see that some of the <code>lang.value</code> functions have used this format. Let's check with the others and verify.</p>", "author": "pubudu91", "createdAt": "2020-06-13T18:48:04Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;\n+        }\n+        Reader reader = new StringReader(str);\n+        try {\n+            Object jsonFromString = JSONParser.parse(reader);\n+            return FromJsonWithType.fromJsonWithType(strand, jsonFromString, t);\n+        } catch (BallerinaException e) {\n+            return BallerinaErrors.createError(\"{ballerina}FromJsonStringWithTypeError\", e.getMessage());", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5MDU5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440590595", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-06-16T05:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw=="}], "type": "inlineReview"}, {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "message": "Allow more tests", "committedDate": "2020-06-15T17:21:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440438566", "body": "Why are we trying to convert it to an XML value if there aren't any convertible types? Consider the following example,\r\n```ballerina\r\nimport ballerina/io;\r\n\r\npublic function main() {\r\n    string foo = \"Foo\";\r\n    var v = foo.fromJsonWithType(int);\r\n    io:println(v);\r\n}\r\n```\r\nThe above fails with the following panic:\r\n```\r\nerror {ballerina/lang.typedesc}ConversionError message='string' value cannot be converted to 'int': failed to parse xml: Unexpected character 'F' (code 70) in prolog; expected '<'\r\n at [row,col {unknown-source}]: [1,1]\r\n```\r\nIt says `string` value cannot be converted to `int` but then has an XML parsing error as well. ", "bodyText": "Why are we trying to convert it to an XML value if there aren't any convertible types? Consider the following example,\nimport ballerina/io;\n\npublic function main() {\n    string foo = \"Foo\";\n    var v = foo.fromJsonWithType(int);\n    io:println(v);\n}\nThe above fails with the following panic:\nerror {ballerina/lang.typedesc}ConversionError message='string' value cannot be converted to 'int': failed to parse xml: Unexpected character 'F' (code 70) in prolog; expected '<'\n at [row,col {unknown-source}]: [1,1]\n\nIt says string value cannot be converted to int but then has an XML parsing error as well.", "bodyHTML": "<p dir=\"auto\">Why are we trying to convert it to an XML value if there aren't any convertible types? Consider the following example,</p>\n<div class=\"highlight highlight-source-ballerina position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import ballerina/io;\n\npublic function main() {\n    string foo = &quot;Foo&quot;;\n    var v = foo.fromJsonWithType(int);\n    io:println(v);\n}\"><pre><span class=\"pl-k\">import</span> <span class=\"pl-smi\">ballerina</span>/<span class=\"pl-smi\">io</span>;\n\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">function</span> main() {\n    <span class=\"pl-c1\">string</span> foo <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Foo<span class=\"pl-pds\">\"</span></span>;\n    <span class=\"pl-c1\">var</span> v <span class=\"pl-k\">=</span> <span class=\"pl-smi\">foo</span>.<span class=\"pl-en\">fromJsonWithType</span>(<span class=\"pl-c1\">int</span>);\n    <span class=\"pl-smi\">io</span><span class=\"pl-k\">:</span><span class=\"pl-en\">println</span>(<span class=\"pl-v\">v</span>);\n}</pre></div>\n<p dir=\"auto\">The above fails with the following panic:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"error {ballerina/lang.typedesc}ConversionError message='string' value cannot be converted to 'int': failed to parse xml: Unexpected character 'F' (code 70) in prolog; expected '&lt;'\n at [row,col {unknown-source}]: [1,1]\"><pre><code>error {ballerina/lang.typedesc}ConversionError message='string' value cannot be converted to 'int': failed to parse xml: Unexpected character 'F' (code 70) in prolog; expected '&lt;'\n at [row,col {unknown-source}]: [1,1]\n</code></pre></div>\n<p dir=\"auto\">It says <code>string</code> value cannot be converted to <code>int</code> but then has an XML parsing error as well.</p>", "author": "pubudu91", "createdAt": "2020-06-15T20:49:42Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }", "originalCommit": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzYwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440597605", "bodyText": "The spec says that fromJsonWithType should do the inverse of the toJson which converts xml into a  string.\nSo, fromJsonWithType should be able to convert an appropriate string to an xml.\nChanging the behaviour of TypeConverter.getConvertibleTypes() to support this would also work, but will affect cloneWithType method and future methods to be implemented (if there are)\nI'll fix showing xml conversion error", "author": "dulajdilshan", "createdAt": "2020-06-16T05:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5OTM1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440599353", "bodyText": "Yeah, it doesn't make sense to try and convert to XML if I didn't specify an XML typedesc", "author": "pubudu91", "createdAt": "2020-06-16T05:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjMwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440602304", "bodyText": "Yeah. Thanks!", "author": "dulajdilshan", "createdAt": "2020-06-16T05:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}], "type": "inlineReview"}, {"oid": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0f7f31f56391c00bca0e631d0db24e25c803ff64", "message": "Fix showing XML conversion error in other string type related conversions", "committedDate": "2020-06-16T05:46:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440607832", "body": "Shall we add an upper bound for the subtypes as well for the following? If we add another `anydata` type, this will break.\r\n```\r\ntargetType.getTag() >= TypeTags.XML_ELEMENT_TAG\r\n```", "bodyText": "Shall we add an upper bound for the subtypes as well for the following? If we add another anydata type, this will break.\ntargetType.getTag() >= TypeTags.XML_ELEMENT_TAG", "bodyHTML": "<p dir=\"auto\">Shall we add an upper bound for the subtypes as well for the following? If we add another <code>anydata</code> type, this will break.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"targetType.getTag() &gt;= TypeTags.XML_ELEMENT_TAG\n\"><pre><code>targetType.getTag() &gt;= TypeTags.XML_ELEMENT_TAG\n</code></pre></div>", "author": "pubudu91", "createdAt": "2020-06-16T06:12:37Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {", "originalCommit": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTU0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611548", "bodyText": "okay", "author": "dulajdilshan", "createdAt": "2020-06-16T06:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTkxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611918", "body": "Since this array type is not going to change, how about adding it to `BTypes`, instead of creating a new JSON array type each time?", "bodyText": "Since this array type is not going to change, how about adding it to BTypes, instead of creating a new JSON array type each time?", "bodyHTML": "<p dir=\"auto\">Since this array type is not going to change, how about adding it to <code>BTypes</code>, instead of creating a new JSON array type each time?</p>", "author": "pubudu91", "createdAt": "2020-06-16T06:23:22Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, t, strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "originalCommit": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440630740", "body": "This should be thrown right? Since the signature of `toJson()` is `json`", "bodyText": "This should be thrown right? Since the signature of toJson() is json", "bodyHTML": "<p dir=\"auto\">This should be thrown right? Since the signature of <code>toJson()</code> is <code>json</code></p>", "author": "pubudu91", "createdAt": "2020-06-16T07:07:36Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!isConvertibleToJson(value, new ArrayList<>())) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    return createConversionError(value, targetType, e.getMessage());", "originalCommit": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc1ODc0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440758745", "bodyText": "Ack. Thanks", "author": "dulajdilshan", "createdAt": "2020-06-16T10:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA=="}], "type": "inlineReview"}, {"oid": "a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "message": "Change error message in 'fromJsonStringWithType' langlib method", "committedDate": "2020-06-16T14:03:37Z", "type": "forcePushed"}, {"oid": "6a2f3b589925768e932552b23987b87aed442edb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6a2f3b589925768e932552b23987b87aed442edb", "message": "Disable langlib value tests", "committedDate": "2020-06-16T20:31:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjYyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443446629", "body": "Should return", "bodyText": "Should return", "bodyHTML": "<p dir=\"auto\">Should return</p>", "author": "dulajdilshan", "createdAt": "2020-06-22T09:55:39Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NzI0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443447246", "body": "no need isambiguity", "bodyText": "no need isambiguity", "bodyHTML": "<p dir=\"auto\">no need isambiguity</p>", "author": "dulajdilshan", "createdAt": "2020-06-22T09:56:44Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2Njg4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443466883", "body": "Error put as a cause", "bodyText": "Error put as a cause", "bodyHTML": "<p dir=\"auto\">Error put as a cause</p>", "author": "dulajdilshan", "createdAt": "2020-06-22T10:34:00Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        // handle string (xml as string) to xml conversion\n+        if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                ((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG && matchingType.getTag() <= TypeTags.XML_TEXT_TAG)\n+                        || matchingType.getTag() == TypeTags.XML_TAG)) {\n+            try {\n+                return XMLFactory.parse(((StringValue) value).getValue());", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b0073636ea0493ddb1d44e18b2afa599d563946a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0073636ea0493ddb1d44e18b2afa599d563946a", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions", "committedDate": "2020-06-30T06:24:32Z", "type": "forcePushed"}, {"oid": "aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "message": "Fix error in the value lib test", "committedDate": "2020-06-30T08:40:24Z", "type": "forcePushed"}, {"oid": "39bbe770806904ada758446ee80c9df6cfeed410", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39bbe770806904ada758446ee80c9df6cfeed410", "message": "Fix error in the value lib test", "committedDate": "2020-06-30T08:56:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449571794", "body": "Can't we do something like\r\n\r\n```suggestion\r\n                BString strVal = StringUtils.fromString(\r\n                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));\r\n                jsonObject.put(StringUtils.fromString(name), strVal);\r\n```\r\ninstead?\r\n\r\nLet's also remove commented out code.", "bodyText": "Can't we do something like\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Object val = record.get(key);\n          \n          \n            \n                            BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n          \n            \n            //                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n          \n          \n            \n                            BString strVal = StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n      \n    \n    \n  \n\ninstead?\nLet's also remove commented out code.", "bodyHTML": "<p dir=\"auto\">Can't we do something like</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-smi\">Object</span> val <span class=\"pl-k\">=</span> record<span class=\"pl-k\">.</span>get(key);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-smi\">BString</span> strVal <span class=\"pl-k\">=</span> <span class=\"pl-smi\">org.ballerinalang.jvm<span class=\"pl-k\">.</span>StringUtils</span><span class=\"pl-k\">.</span>fromString(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        <span class=\"pl-smi\">org.ballerinalang.jvm.values.utils<span class=\"pl-k\">.</span>StringUtils</span><span class=\"pl-k\">.</span>getStringValue(val));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                jsonObject<span class=\"pl-k\">.</span>put(<span class=\"pl-smi\">StringUtils</span><span class=\"pl-k\">.</span>fromString(name), strVal);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-c\"><span class=\"pl-c\">//</span>                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-smi\">BString</span> strVal <span class=\"pl-k\">=</span> <span class=\"pl-smi\">StringUtils</span><span class=\"pl-k\">.</span>fromString(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-smi\">org.ballerinalang.jvm.values.utils<span class=\"pl-k\">.</span>StringUtils</span><span class=\"pl-k\">.</span>getStringValue(record<span class=\"pl-k\">.</span>get(key)));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                jsonObject<span class=\"pl-k\">.</span>put(<span class=\"pl-smi\">StringUtils</span><span class=\"pl-k\">.</span>fromString(name), strVal);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">instead?</p>\n<p dir=\"auto\">Let's also remove commented out code.</p>", "author": "MaryamZi", "createdAt": "2020-07-03T13:00:51Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,11 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                Object val = record.get(key);\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n+                jsonObject.put(StringUtils.fromString(name), strVal);\n+//                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1MjE4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451352184", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T07:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449645751", "body": "In this value type check, we check for simple basic types and string right? Since they are always `json`, wondering if we can skip the next line and directly return true.", "bodyText": "In this value type check, we check for simple basic types and string right? Since they are always json, wondering if we can skip the next line and directly return true.", "bodyHTML": "<p dir=\"auto\">In this value type check, we check for simple basic types and string right? Since they are always <code>json</code>, wondering if we can skip the next line and directly return true.</p>", "author": "MaryamZi", "createdAt": "2020-07-03T16:01:49Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -343,6 +343,56 @@ public static boolean isSameType(BType sourceType, BType targetType) {\n         return false;\n     }\n \n+    public static boolean isConvertibleToJson(Object sourceValue, List<TypeValuePair> unresolvedValues) {\n+\n+        BType sourceType = TypeChecker.getType(sourceValue);\n+\n+        if (TypeChecker.checkIsLikeType(sourceValue, BTypes.typeJSON, true)) {\n+            return true;\n+        }\n+\n+        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+            ArrayValue source = (ArrayValue) sourceValue;\n+            BType elementType = ((BArrayType) source.getType()).getElementType();\n+            if (BTypes.isValueType(elementType)) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NDAzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451354038", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T07:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659754", "body": "Do we need this `isConvertibleToJson` check at all? `toJson` can only be called on `anydata` values right? And unless they have cycles (which seems to be checked independent of this check), it is pretty much guaranteed that they can be converted to `json`? \r\n\r\nhttps://github.com/ballerina-platform/ballerina-lang/blob/39bbe770806904ada758446ee80c9df6cfeed410/langlib/lang.value/src/main/ballerina/src/lang.value/value.bal#L133", "bodyText": "Do we need this isConvertibleToJson check at all? toJson can only be called on anydata values right? And unless they have cycles (which seems to be checked independent of this check), it is pretty much guaranteed that they can be converted to json?\n\n  \n    \n      ballerina-lang/langlib/lang.value/src/main/ballerina/src/lang.value/value.bal\n    \n    \n         Line 133\n      in\n      39bbe77\n    \n    \n    \n    \n\n        \n          \n           public function toJson(anydata v) returns json = external;", "bodyHTML": "<p dir=\"auto\">Do we need this <code>isConvertibleToJson</code> check at all? <code>toJson</code> can only be called on <code>anydata</code> values right? And unless they have cycles (which seems to be checked independent of this check), it is pretty much guaranteed that they can be converted to <code>json</code>?</p>\n<p dir=\"auto\"><div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/ballerina-platform/ballerina-lang/blob/39bbe770806904ada758446ee80c9df6cfeed410/langlib/lang.value/src/main/ballerina/src/lang.value/value.bal#L133\">ballerina-lang/langlib/lang.value/src/main/ballerina/src/lang.value/value.bal</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n         Line 133\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/ballerina-platform/ballerina-lang/commit/39bbe770806904ada758446ee80c9df6cfeed410\">39bbe77</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L133\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"133\"></td>\n          <td id=\"LC133\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">public</span> <span class=\"pl-k\">function</span> toJson(<span class=\"pl-k\">anydata</span> <span class=\"pl-v\">v</span>) <span class=\"pl-k\">returns</span> <span class=\"pl-c1\">json</span> <span class=\"pl-k\">=</span> external; </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>", "author": "MaryamZi", "createdAt": "2020-07-03T16:55:56Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1MzQyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451753425", "bodyText": "Ack. Thanks", "author": "dulajdilshan", "createdAt": "2020-07-08T18:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659900", "body": "```suggestion\r\n        try {\r\n            return convert(value, BTypes.typeJSON, new ArrayList<>(), strand);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BType targetJsonType = BTypes.typeJSON;\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, targetJsonType, new ArrayList<>(), strand);\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, BTypes.typeJSON, new ArrayList<>(), strand);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi\">BType</span> targetJsonType <span class=\"pl-k\">=</span> <span class=\"pl-smi\">BTypes</span><span class=\"pl-k\">.</span>typeJSON;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">try</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">return</span> convert(value, targetJsonType, <span class=\"pl-k\">new</span> <span class=\"pl-k\">ArrayList&lt;&gt;</span>(), strand);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">try</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">return</span> convert(value, <span class=\"pl-smi\">BTypes</span><span class=\"pl-k\">.</span>typeJSON, <span class=\"pl-k\">new</span> <span class=\"pl-k\">ArrayList&lt;&gt;</span>(), strand);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "MaryamZi", "createdAt": "2020-07-03T16:56:38Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NjQ3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451356473", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449660321", "body": "Isn't the target type always `json`? Makes this check always true right?", "bodyText": "Isn't the target type always json? Makes this check always true right?", "bodyHTML": "<p dir=\"auto\">Isn't the target type always <code>json</code>? Makes this check always true right?</p>", "author": "MaryamZi", "createdAt": "2020-07-03T16:58:33Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzYyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451363622", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449666019", "body": "Once we remove `error` from `anydata`, we won't reach here right? For the time-being I think we can panic if reach here.", "bodyText": "Once we remove error from anydata, we won't reach here right? For the time-being I think we can panic if reach here.", "bodyHTML": "<p dir=\"auto\">Once we remove <code>error</code> from <code>anydata</code>, we won't reach here right? For the time-being I think we can panic if reach here.</p>", "author": "MaryamZi", "createdAt": "2020-07-03T17:26:08Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNzYwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451937606", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-09T03:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449667453", "body": "We get here only for simple basic types and string, and we don't have to do any conversions here right?\r\n\r\nIMO, we can move this to after the null check and remove this here.", "bodyText": "We get here only for simple basic types and string, and we don't have to do any conversions here right?\nIMO, we can move this to after the null check and remove this here.", "bodyHTML": "<p dir=\"auto\">We get here only for simple basic types and string, and we don't have to do any conversions here right?</p>\n<p dir=\"auto\">IMO, we can move this to after the null check and remove this here.</p>", "author": "MaryamZi", "createdAt": "2020-07-03T17:33:10Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODE4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668188", "bodyText": "Also, assuming this is for simple basic types, they are always JSON. So we don't have to check getConvertibleTypes.", "author": "MaryamZi", "createdAt": "2020-07-03T17:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0MTMwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r452241304", "bodyText": "Changed.", "author": "dulajdilshan", "createdAt": "2020-07-09T14:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668578", "body": "`targetType` is always `map<json>` right? We can have a constant/final variable for the type in this class or BTypes, or move the type creation to within this method.", "bodyText": "targetType is always map<json> right? We can have a constant/final variable for the type in this class or BTypes, or move the type creation to within this method.", "bodyHTML": "<p dir=\"auto\"><code>targetType</code> is always <code>map&lt;json&gt;</code> right? We can have a constant/final variable for the type in this class or BTypes, or move the type creation to within this method.</p>", "author": "MaryamZi", "createdAt": "2020-07-03T17:39:03Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTcwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451761706", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T18:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668902", "body": "We should have extracted this out to a variable. But then again since this is always `json`, we can use the JSON type in BTypes.", "bodyText": "We should have extracted this out to a variable. But then again since this is always json, we can use the JSON type in BTypes.", "bodyHTML": "<p dir=\"auto\">We should have extracted this out to a variable. But then again since this is always <code>json</code>, we can use the JSON type in BTypes.</p>", "author": "MaryamZi", "createdAt": "2020-07-03T17:40:49Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU2MDEyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451560124", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669406", "body": "Can't we use `BTypes.typeJsonArray` you've introduced? ", "bodyText": "Can't we use BTypes.typeJsonArray you've introduced?", "bodyHTML": "<p dir=\"auto\">Can't we use <code>BTypes.typeJsonArray</code> you've introduced?</p>", "author": "MaryamZi", "createdAt": "2020-07-03T17:43:31Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1Nzk4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451557980", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669545", "body": "We don't need a separate method for this right?", "bodyText": "We don't need a separate method for this right?", "bodyHTML": "<p dir=\"auto\">We don't need a separate method for this right?</p>", "author": "MaryamZi", "createdAt": "2020-07-03T17:44:16Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));\n+        for (int i = 0; i < array.size(); i++) {\n+            Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, strand);\n+            newArray.add(i, newValue);\n+        }\n+        return newArray;\n+    }\n+\n+    private static void putToMap(MapValue<BString, Object> map, Map.Entry entry, BType fieldType,", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1Nzc5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451557790", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449673862", "body": "```suggestion\r\n@Test\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Test(enabled = true)\n          \n          \n            \n            @Test", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"pl-k\">@Test</span><span class=\"x x-first\">(</span><span class=\"pl-c1 x\">enabled</span><span class=\"x\"> </span><span class=\"pl-k x\">=</span><span class=\"x\"> </span><span class=\"pl-c1 x\">true</span><span class=\"x x-last\">)</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"><span class=\"pl-k\">@Test</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "MaryamZi", "createdAt": "2020-07-03T18:06:36Z", "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "diffHunk": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0\n  */\n-@Test(enabled = false)\n+@Test(enabled = true)", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NzYzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449677634", "bodyText": "We can just remove (enabled = false). Please fix everywhere.", "author": "MaryamZi", "createdAt": "2020-07-03T18:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDY3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451850674", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T22:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449678223", "body": "Do we have to remove since we'll be creating a new list for each call to the method? Can you check others too.", "bodyText": "Do we have to remove since we'll be creating a new list for each call to the method? Can you check others too.", "bodyHTML": "<p dir=\"auto\">Do we have to remove since we'll be creating a new list for each call to the method? Can you check others too.</p>", "author": "MaryamZi", "createdAt": "2020-07-03T18:29:57Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4ODAzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451388031", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwODI0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451808244", "bodyText": "But, There can be situations like\npublic function main() {\n    json anObject = { name : \"anObject\", value : 10, sub : { subName : \"subObject\", subValue : 10 }};\n    string k = anObject.toJsonString();\n}\nif we remove this line :unresolvedValues.remove(typeValuePair); ,  10 will be duplicated inside unresolvedValues the fail. won't it?", "author": "dulajdilshan", "createdAt": "2020-07-08T20:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449681403", "body": "We need to consider maps also right? And arrays/tuples?", "bodyText": "We need to consider maps also right? And arrays/tuples?", "bodyHTML": "<p dir=\"auto\">We need to consider maps also right? And arrays/tuples?</p>", "author": "MaryamZi", "createdAt": "2020-07-03T18:47:41Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MTI0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451371240", "bodyText": "They were caught in this method call in line: 310\nTypeConverter.getConvertibleTypes(value, targetType)", "author": "dulajdilshan", "createdAt": "2020-07-08T08:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw=="}], "type": "inlineReview"}, {"oid": "4eab681541972b946f574cd3232aae86a19cb817", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4eab681541972b946f574cd3232aae86a19cb817", "message": "Do requested changes", "committedDate": "2020-07-08T23:16:23Z", "type": "forcePushed"}, {"oid": "2a31013c144b3612838e874c86d65cdfd2702d49", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a31013c144b3612838e874c86d65cdfd2702d49", "message": "Do requested changes", "committedDate": "2020-07-09T01:05:22Z", "type": "forcePushed"}, {"oid": "69a619558a21aedaa2ac5727653f1b03e548c99e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/69a619558a21aedaa2ac5727653f1b03e548c99e", "message": "Add more tests", "committedDate": "2020-07-09T09:20:03Z", "type": "forcePushed"}, {"oid": "18319d65386ad7772f516aed1adbb4e5ba4896f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/18319d65386ad7772f516aed1adbb4e5ba4896f8", "message": "Add 'typeJsonArray' to BTypes", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "584d1f4f88a7748393c236a367567ccd4113b8b1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/584d1f4f88a7748393c236a367567ccd4113b8b1", "message": "Add 'fromJsonWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "826fdf23b9d3eef7d7907a51ea8c768e957779b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/826fdf23b9d3eef7d7907a51ea8c768e957779b2", "message": "Add 'fromJsonStringWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "08ec106ed797507f30ac84d2ddaabb73061138e2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/08ec106ed797507f30ac84d2ddaabb73061138e2", "message": "Add 'toJson' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "5a1a546bf0e5c85fcee5e882af47e2000976f9fc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5a1a546bf0e5c85fcee5e882af47e2000976f9fc", "message": "Allow \"toJsonString\" lanlib method to support for anydata type", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "e16087ac3c123daff005349f682b357e8413bb76", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e16087ac3c123daff005349f682b357e8413bb76", "message": "Fix String to BString casting error", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "7102f2b90bec1d8a9390d1ff8fafb1fc7ab3ad72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7102f2b90bec1d8a9390d1ff8fafb1fc7ab3ad72", "message": "Add test cases", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "5e950db86a85c766a500ff5549178165b5365e5d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5e950db86a85c766a500ff5549178165b5365e5d", "message": "Fix failing completion tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "2b83515421b45e1e7d1b55aa65ed8409494cfeca", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2b83515421b45e1e7d1b55aa65ed8409494cfeca", "message": "Order langlib function descriptions", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "bc38590c8df908dd7cf02cc1001c751330a02159", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc38590c8df908dd7cf02cc1001c751330a02159", "message": "Change error message in 'fromJsonStringWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "f34ad6fe935633d63c0a1756d276d4854db975cf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f34ad6fe935633d63c0a1756d276d4854db975cf", "message": "Add support for xml-typed fields in table to json conversion", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "c3d367ec5c9731c3200c4a7d8f36b58c2992d021", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3d367ec5c9731c3200c4a7d8f36b58c2992d021", "message": "Add json to table conversion in \"fromJsonWithType\" langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "4bdd9da0f1679bf81679e3ecea87298c3edb861c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4bdd9da0f1679bf81679e3ecea87298c3edb861c", "message": "Disable langlib value tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "1bd08e5009ef6242c30a5e58f947ae8f68f8f289", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1bd08e5009ef6242c30a5e58f947ae8f68f8f289", "message": "Fix 24247", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "1f0ac42e95261685d1ff9640a7e9840d94921fd4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f0ac42e95261685d1ff9640a7e9840d94921fd4", "message": "Fix errors in the langlib value tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2e69a1cd29698b34530672d87c94c48f962da06d", "message": "Add more tests", "committedDate": "2020-07-15T14:11:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455179945", "body": "This same method gets called for `jsonutils:fromTable` right? In that context, I am not sure if converting to string is the expected behaviour. I think what is expected is the result of applying `jsonutils:fromXML`. Shall we create an issue to track clarifying this with the stdlib team? \r\n\r\nI guess this is broken atm anyway, since `record.getStringValue(key)` is called for XML.", "bodyText": "This same method gets called for jsonutils:fromTable right? In that context, I am not sure if converting to string is the expected behaviour. I think what is expected is the result of applying jsonutils:fromXML. Shall we create an issue to track clarifying this with the stdlib team?\nI guess this is broken atm anyway, since record.getStringValue(key) is called for XML.", "bodyHTML": "<p dir=\"auto\">This same method gets called for <code>jsonutils:fromTable</code> right? In that context, I am not sure if converting to string is the expected behaviour. I think what is expected is the result of applying <code>jsonutils:fromXML</code>. Shall we create an issue to track clarifying this with the stdlib team?</p>\n<p dir=\"auto\">I guess this is broken atm anyway, since <code>record.getStringValue(key)</code> is called for XML.</p>", "author": "MaryamZi", "createdAt": "2020-07-15T16:32:09Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,9 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE4MDU1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455180559", "bodyText": "Checked with\nimport ballerina/jsonutils;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\npublic function main() {\n    table<Foo> tb = table [\n        {i: 1, x: xml `<foo>FOO</foo>`}\n    ];\n\n    json j = jsonutils:fromTable(tb);\n}\nFails with\n$ ballerina run qwe.bal \nCompiling source\n        qwe.bal\nRunning executables\n\nerror: java.lang.ClassCastException message=org.ballerinalang.jvm.values.XMLItem cannot be cast to org.ballerinalang.jvm.values.api.BString\n        at ballerina.0_5_0:externFromTable(jsonutils.bal:63)\n           ballerina.0_5_0:fromTable(jsonutils.bal:60)\n           qwe:main(qwe.bal:13)", "author": "MaryamZi", "createdAt": "2020-07-15T16:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455227341", "body": "`TypeConverter.getConvertibleTypes(value, targetType)` calls `isConvertibleToRecordType` with `isFromJson` set to `false` right?\r\n\r\nWhat if `targetType` is a union of two records, say `Foo|Bar`, and the value is convertible to `Foo` even when  `isFromJson` is `false` in `isConvertibleToRecordType`, but it is only convertible to `Bar` when `isFromJson` is true?\r\n\r\nSo IINM, from L273 when we reach here `convertibleTypes` will only have `Foo` and we return that in L301. But if we actually check `isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)` it'll evaluate to `true` for `Bar`, and there'll actually be 2 convertible types?", "bodyText": "TypeConverter.getConvertibleTypes(value, targetType) calls isConvertibleToRecordType with isFromJson set to false right?\nWhat if targetType is a union of two records, say Foo|Bar, and the value is convertible to Foo even when  isFromJson is false in isConvertibleToRecordType, but it is only convertible to Bar when isFromJson is true?\nSo IINM, from L273 when we reach here convertibleTypes will only have Foo and we return that in L301. But if we actually check isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues) it'll evaluate to true for Bar, and there'll actually be 2 convertible types?", "bodyHTML": "<p dir=\"auto\"><code>TypeConverter.getConvertibleTypes(value, targetType)</code> calls <code>isConvertibleToRecordType</code> with <code>isFromJson</code> set to <code>false</code> right?</p>\n<p dir=\"auto\">What if <code>targetType</code> is a union of two records, say <code>Foo|Bar</code>, and the value is convertible to <code>Foo</code> even when  <code>isFromJson</code> is <code>false</code> in <code>isConvertibleToRecordType</code>, but it is only convertible to <code>Bar</code> when <code>isFromJson</code> is true?</p>\n<p dir=\"auto\">So IINM, from L273 when we reach here <code>convertibleTypes</code> will only have <code>Foo</code> and we return that in L301. But if we actually check <code>isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)</code> it'll evaluate to <code>true</code> for <code>Bar</code>, and there'll actually be 2 convertible types?</p>", "author": "MaryamZi", "createdAt": "2020-07-15T17:40:53Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1NDI5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455254295", "bodyText": "For example\nimport ballerina/io;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\ntype Bar record {|\n    int i;\n    string x;\n|};\n\ntype FooBar Foo|Bar;\n\npublic function main() {\n    json j = {i: 1, x: \"<abc>ABC</abc>\"};\n\n    // No error.\n    io:println(j.fromJsonWithType(Foo)); // i=1 x=<abc>ABC</abc>\n    // No error.\n    io:println(j.fromJsonWithType(Bar)); // i=1 x=<abc>ABC</abc>\n\n    // Then this should be ambiguous?\n    io:println(j.fromJsonWithType(FooBar)); // i=1 x=<abc>ABC</abc>\n}", "author": "MaryamZi", "createdAt": "2020-07-15T18:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU4MDIzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455580233", "bodyText": "Shouldn't this be okay according to this ?\nLet's take this\n io:println(j.fromJsonWithType(FooBar));\nWhen we reach L273, convertibleTypes will have only have Bar.  isn't it?", "author": "dulajdilshan", "createdAt": "2020-07-16T07:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NDM2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455694367", "bodyText": "Ah, didn't know of the \"fromJsonWithType should only do something different from cloneWithType if cloneWithType would produce an error.\" part.\nYeah, this behaviour is correct then. Thanks!", "author": "MaryamZi", "createdAt": "2020-07-16T10:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455263978", "body": "Re: the constraint, the spec says\r\n\r\n> The type specified by a row-type-parameter must be a subtype of map<any|error>\r\n\r\nSo it is always a record or a map right? Do we need this check?", "bodyText": "Re: the constraint, the spec says\n\nThe type specified by a row-type-parameter must be a subtype of map<any|error>\n\nSo it is always a record or a map right? Do we need this check?", "bodyHTML": "<p dir=\"auto\">Re: the constraint, the spec says</p>\n<blockquote>\n<p dir=\"auto\">The type specified by a row-type-parameter must be a subtype of map&lt;any|error&gt;</p>\n</blockquote>\n<p dir=\"auto\">So it is always a record or a map right? Do we need this check?</p>", "author": "MaryamZi", "createdAt": "2020-07-15T18:41:07Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxMjg2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455612860", "bodyText": "I think yes. because  If I remove the above-mentioned check,\ntype TableString table<string>;\npublic function main() {\n    json j = [\n        \"cake\",\n        \"buscuit\"\n    ];\n    table<string>|error tabString = j.fromJsonWithType(TableString);\n}\nThis works without giving a prior error for table<string>", "author": "dulajdilshan", "createdAt": "2020-07-16T08:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455273802", "body": "Do we need this default case?", "bodyText": "Do we need this default case?", "bodyHTML": "<p dir=\"auto\">Do we need this default case?</p>", "author": "MaryamZi", "createdAt": "2020-07-15T18:58:22Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.XML_TAG:\n+                case TypeTags.XML_ELEMENT_TAG:\n+                case TypeTags.XML_COMMENT_TAG:\n+                case TypeTags.XML_PI_TAG:\n+                case TypeTags.XML_TEXT_TAG:\n+                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                default:\n+                    break;", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxNTQ0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455615446", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T08:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MDM1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455280352", "body": "The only difference in the if and else blocks is the method called right? The arguments are all the same? Instead of the `isFromJson` parameter can we not use something like a functional interface, which I believe is what @rdhananjaya also suggested once.", "bodyText": "The only difference in the if and else blocks is the method called right? The arguments are all the same? Instead of the isFromJson parameter can we not use something like a functional interface, which I believe is what @rdhananjaya also suggested once.", "bodyHTML": "<p dir=\"auto\">The only difference in the if and else blocks is the method called right? The arguments are all the same? Instead of the <code>isFromJson</code> parameter can we not use something like a functional interface, which I believe is what <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/rdhananjaya/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/rdhananjaya\">@rdhananjaya</a> also suggested once.</p>", "author": "MaryamZi", "createdAt": "2020-07-15T19:10:09Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -299,17 +337,33 @@ private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType\n             Map.Entry valueEntry = (Map.Entry) object;\n             String fieldName = valueEntry.getKey().toString();\n \n-            if (targetFieldTypes.containsKey(fieldName)) {\n-                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n-                                        unresolvedValues).size() != 1) {\n+            if (isFromJson) {\n+                if (targetFieldTypes.containsKey(fieldName)) {\n+                    if (getConvertibleTypesFromJson(valueEntry.getValue(), targetFieldTypes.get(fieldName),", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455291129", "body": "We need to check if the target type is nilable.\r\n\r\nThe folowing crashes.\r\n\r\n```ballerina\r\ntype IntMap map<int>;\r\n\r\npublic function main() {\r\n    string s = \"null\";\r\n\r\n    map<int> m = checkpanic s.fromJsonStringWithType(IntMap); // doesn't panic\r\n\r\n    int i = m.get(\"first\");\r\n}\r\n```\r\n\r\nThe get fails with an NPE in the internal log.\r\n```log\r\n[2020-07-16 00:57:59,786] SEVERE {b7a.log.crash} - null \r\njava.lang.NullPointerException\r\n\tat org.ballerinalang.langlib.map.Get.get(Get.java:45)\r\n\tat ballerina.lang_map.1_1_0.map.get(map.bal:51)\r\n\tat qwe.main(qwe.bal:8)\r\n\tat ___init.$lambda$main$(.)\r\n\tat org.ballerinalang.jvm.scheduling.SchedulerItem.execute(Scheduler.java:500)\r\n\tat org.ballerinalang.jvm.scheduling.Scheduler.run(Scheduler.java:276)\r\n\tat org.ballerinalang.jvm.scheduling.Scheduler.runSafely(Scheduler.java:244)\r\n\tat java.lang.Thread.run(Thread.java:745)\r\n```", "bodyText": "We need to check if the target type is nilable.\nThe folowing crashes.\ntype IntMap map<int>;\n\npublic function main() {\n    string s = \"null\";\n\n    map<int> m = checkpanic s.fromJsonStringWithType(IntMap); // doesn't panic\n\n    int i = m.get(\"first\");\n}\nThe get fails with an NPE in the internal log.\n[2020-07-16 00:57:59,786] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.ballerinalang.langlib.map.Get.get(Get.java:45)\n\tat ballerina.lang_map.1_1_0.map.get(map.bal:51)\n\tat qwe.main(qwe.bal:8)\n\tat ___init.$lambda$main$(.)\n\tat org.ballerinalang.jvm.scheduling.SchedulerItem.execute(Scheduler.java:500)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.run(Scheduler.java:276)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.runSafely(Scheduler.java:244)\n\tat java.lang.Thread.run(Thread.java:745)", "bodyHTML": "<p dir=\"auto\">We need to check if the target type is nilable.</p>\n<p dir=\"auto\">The folowing crashes.</p>\n<div class=\"highlight highlight-source-ballerina position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"type IntMap map&lt;int&gt;;\n\npublic function main() {\n    string s = &quot;null&quot;;\n\n    map&lt;int&gt; m = checkpanic s.fromJsonStringWithType(IntMap); // doesn't panic\n\n    int i = m.get(&quot;first&quot;);\n}\"><pre><span class=\"pl-k\">type</span> <span class=\"pl-en\">IntMap</span> <span class=\"pl-k\">map</span><span class=\"pl-k\">&lt;</span><span class=\"pl-c1\">int</span><span class=\"pl-k\">&gt;</span>;\n\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">function</span> main() {\n    <span class=\"pl-c1\">string</span> s <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>null<span class=\"pl-pds\">\"</span></span>;\n\n    <span class=\"pl-k\">map</span><span class=\"pl-k\">&lt;</span><span class=\"pl-c1\">int</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-smi\">m</span> <span class=\"pl-k\">=</span> <span class=\"pl-k\">checkpanic</span> <span class=\"pl-smi\">s</span>.<span class=\"pl-en\">fromJsonStringWithType</span>(<span class=\"pl-v\">IntMap</span>); <span class=\"pl-c\">// doesn't panic</span>\n\n    <span class=\"pl-c1\">int</span> i <span class=\"pl-k\">=</span> <span class=\"pl-smi\">m</span>.<span class=\"pl-en\">get</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>first<span class=\"pl-pds\">\"</span></span>);\n}</pre></div>\n<p dir=\"auto\">The get fails with an NPE in the internal log.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"[2020-07-16 00:57:59,786] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.ballerinalang.langlib.map.Get.get(Get.java:45)\n\tat ballerina.lang_map.1_1_0.map.get(map.bal:51)\n\tat qwe.main(qwe.bal:8)\n\tat ___init.$lambda$main$(.)\n\tat org.ballerinalang.jvm.scheduling.SchedulerItem.execute(Scheduler.java:500)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.run(Scheduler.java:276)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.runSafely(Scheduler.java:244)\n\tat java.lang.Thread.run(Thread.java:745)\"><pre lang=\"log\"><code>[2020-07-16 00:57:59,786] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.ballerinalang.langlib.map.Get.get(Get.java:45)\n\tat ballerina.lang_map.1_1_0.map.get(map.bal:51)\n\tat qwe.main(qwe.bal:8)\n\tat ___init.$lambda$main$(.)\n\tat org.ballerinalang.jvm.scheduling.SchedulerItem.execute(Scheduler.java:500)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.run(Scheduler.java:276)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.runSafely(Scheduler.java:244)\n\tat java.lang.Thread.run(Thread.java:745)\n</code></pre></div>", "author": "MaryamZi", "createdAt": "2020-07-15T19:29:32Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MjY0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455292649", "bodyText": "Do we need to special case \"null\" anyway? The JSONParser and FromJsonWithType.fromJsonWithType will handle this properly right?", "author": "MaryamZi", "createdAt": "2020-07-15T19:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUzODk4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455538980", "bodyText": "Ack.", "author": "dulajdilshan", "createdAt": "2020-07-16T06:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455296725", "body": "A `json` value can never hold an error. Do we need this case?", "bodyText": "A json value can never hold an error. Do we need this case?", "bodyHTML": "<p dir=\"auto\">A <code>json</code> value can never hold an error. Do we need this case?</p>", "author": "MaryamZi", "createdAt": "2020-07-15T19:40:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0MzUxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455543511", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T06:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455312848", "body": "Can't we use `org.ballerinalang.jvm.types.TypeTags#isXMLTypeTag` here instead?", "bodyText": "Can't we use org.ballerinalang.jvm.types.TypeTags#isXMLTypeTag here instead?", "bodyHTML": "<p dir=\"auto\">Can't we use <code>org.ballerinalang.jvm.types.TypeTags#isXMLTypeTag</code> here instead?</p>", "author": "MaryamZi", "createdAt": "2020-07-15T20:10:33Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1MDYyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455550623", "bodyText": "Sure", "author": "dulajdilshan", "createdAt": "2020-07-16T06:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455319249", "body": "We should move this out of the for loop, or we'll be extracting the constraint per entry.", "bodyText": "We should move this out of the for loop, or we'll be extracting the constraint per entry.", "bodyHTML": "<p dir=\"auto\">We should move this out of the for loop, or we'll be extracting the constraint per entry.</p>", "author": "MaryamZi", "createdAt": "2020-07-15T20:22:39Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NzE3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455557170", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T07:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455321052", "body": "This also we don't need right?", "bodyText": "This also we don't need right?", "bodyHTML": "<p dir=\"auto\">This also we don't need right?</p>", "author": "MaryamZi", "createdAt": "2020-07-15T20:26:01Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODQ5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618495", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T08:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455322784", "body": "Better to pass the `targetType` itself instead of `BTypes.typeJSON` since it could be `json & readonly`.", "bodyText": "Better to pass the targetType itself instead of BTypes.typeJSON since it could be json & readonly.", "bodyHTML": "<p dir=\"auto\">Better to pass the <code>targetType</code> itself instead of <code>BTypes.typeJSON</code> since it could be <code>json &amp; readonly</code>.</p>", "author": "MaryamZi", "createdAt": "2020-07-15T20:29:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwMjgwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455702807", "bodyText": "ok", "author": "dulajdilshan", "createdAt": "2020-07-16T10:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455323807", "body": "Why do we create a new type?", "bodyText": "Why do we create a new type?", "bodyHTML": "<p dir=\"auto\">Why do we create a new type?</p>", "author": "MaryamZi", "createdAt": "2020-07-15T20:31:12Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TABLE_TAG:\n+                BTableType tableType = (BTableType) targetType;\n+\n+                BTableType newTableType = new BTableType(tableType.getConstrainedType(),", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5OTc3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455699773", "bodyText": "Removed", "author": "dulajdilshan", "createdAt": "2020-07-16T10:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455336846", "body": "Do we ever reach here? All the numeric basic types are both `anydata` and `json`. So, I don't think you'll ever have to do a numeric conversion?", "bodyText": "Do we ever reach here? All the numeric basic types are both anydata and json. So, I don't think you'll ever have to do a numeric conversion?", "bodyHTML": "<p dir=\"auto\">Do we ever reach here? All the numeric basic types are both <code>anydata</code> and <code>json</code>. So, I don't think you'll ever have to do a numeric conversion?</p>", "author": "MaryamZi", "createdAt": "2020-07-15T20:55:57Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        try {\n+            return convert(value, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, jsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcxNzE5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455717199", "bodyText": "Got it", "author": "dulajdilshan", "createdAt": "2020-07-16T11:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455609729", "body": "Do we need this null check here? `t` can never be `null` right?", "bodyText": "Do we need this null check here? t can never be null right?", "bodyHTML": "<p dir=\"auto\">Do we need this null check here? <code>t</code> can never be <code>null</code> right?</p>", "author": "pubudu91", "createdAt": "2020-07-16T08:20:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcyMTMxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455721314", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T11:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618694", "body": "Is there a need to pass both `t` and `describingType`?", "bodyText": "Is there a need to pass both t and describingType?", "bodyHTML": "<p dir=\"auto\">Is there a need to pass both <code>t</code> and <code>describingType</code>?</p>", "author": "pubudu91", "createdAt": "2020-07-16T08:34:41Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc3Nzg5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455777894", "bodyText": "I followed the same implementation as in the cloneWithType.\nconvert method is get called later. Sometimes, t and targetType both are  needed", "author": "dulajdilshan", "createdAt": "2020-07-16T13:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1ODE2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455858166", "bodyText": "My point was if you have t, you can always get the type from it. Anyways, not a major issue. Just gives the impression that target type can be some other type than what's described by t", "author": "pubudu91", "createdAt": "2020-07-16T15:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA=="}], "type": "inlineReview"}, {"oid": "32a33fc1798b697a55693b80a4d948526e932ea9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/32a33fc1798b697a55693b80a4d948526e932ea9", "message": "Add fromJsonWIthType negative test", "committedDate": "2020-07-16T13:46:28Z", "type": "commit"}, {"oid": "e5430d4b59f2b4c5b8f768ef7a246d15c0d2f23a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5430d4b59f2b4c5b8f768ef7a246d15c0d2f23a", "message": "Refactor \"toJson\" according to the code review suggestions", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "470bf15ddd203933e41a785ab47c5c4be4ddd678", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/470bf15ddd203933e41a785ab47c5c4be4ddd678", "message": "Add value lang lib error message string", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "7e5fbfb2ec384f5722593f972780e362dce450d2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e5fbfb2ec384f5722593f972780e362dce450d2", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "f6adcd93547a952d138340eb1aa45e035622e6a9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6adcd93547a952d138340eb1aa45e035622e6a9", "message": "Fix error in the value lib test", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "c7fb4adc13cf293ae82c9a318bf9c26eecca8b12", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c7fb4adc13cf293ae82c9a318bf9c26eecca8b12", "message": "Do requested changes", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "558fb27f777cd1fb6fcf5f4d87aab7aac6f0b630", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/558fb27f777cd1fb6fcf5f4d87aab7aac6f0b630", "message": "Remove isConvertibleToJson method in TypeChecker", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "04214fd7fd9ee8ac827123d407fa1c629fff0730", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/04214fd7fd9ee8ac827123d407fa1c629fff0730", "message": "Add more tests", "committedDate": "2020-07-16T13:46:30Z", "type": "commit"}, {"oid": "de711a0900748c01d3b478823bc6f073b2a2a285", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de711a0900748c01d3b478823bc6f073b2a2a285", "message": "Change according to the suggestions", "committedDate": "2020-07-16T13:46:30Z", "type": "forcePushed"}, {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/344e13a81c953c6fc2e2b7af0d156eba0227532d", "message": "Change according to the suggestions", "committedDate": "2020-07-16T14:22:18Z", "type": "commit"}, {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/344e13a81c953c6fc2e2b7af0d156eba0227532d", "message": "Change according to the suggestions", "committedDate": "2020-07-16T14:22:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MTIyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455861225", "body": "I think what @MaryamZi meant was to simply pass `str` to the JSON parser without special casing \"null\". ", "bodyText": "I think what @MaryamZi meant was to simply pass str to the JSON parser without special casing \"null\".", "bodyHTML": "<p dir=\"auto\">I think what <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MaryamZi/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MaryamZi\">@MaryamZi</a> meant was to simply pass <code>str</code> to the JSON parser without special casing \"null\".</p>", "author": "pubudu91", "createdAt": "2020-07-16T15:10:12Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        try {\n+            if (str.equals(\"null\")) {\n+                return FromJsonWithType.fromJsonWithType(strand, null, t);", "originalCommit": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}