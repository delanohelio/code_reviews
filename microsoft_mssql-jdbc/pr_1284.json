{"pr_number": 1284, "pr_title": "Feature | client certificate authentication", "pr_author": "peterbae", "pr_createdAt": "2020-03-16T19:36:51Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1284", "timeline": [{"oid": "c97b863c95385bdcd1afc897ef39cbebaf495578", "url": "https://github.com/microsoft/mssql-jdbc/commit/c97b863c95385bdcd1afc897ef39cbebaf495578", "message": "Fix AEv2 tests exclude for reqExternalSetup and cleanup (#1247)", "committedDate": "2020-02-05T19:03:48Z", "type": "commit"}, {"oid": "54b5a194e5d46552419c86e0d1f8c800f42d3de8", "url": "https://github.com/microsoft/mssql-jdbc/commit/54b5a194e5d46552419c86e0d1f8c800f42d3de8", "message": "Fix | Add null check for getObject() with LocalTime and LocalDate (#1250)", "committedDate": "2020-02-08T00:19:05Z", "type": "commit"}, {"oid": "672b7d67caae75250c53f82a760e8d3880e62a37", "url": "https://github.com/microsoft/mssql-jdbc/commit/672b7d67caae75250c53f82a760e8d3880e62a37", "message": "added all AKV tests to use reqExternalSetup tag so they will be skipped by default (#1254)\n\n* skip AKV test properly\r\n\r\n* removed enclave properties string to failed errors as enclave tests could be skipped", "committedDate": "2020-02-10T19:04:22Z", "type": "commit"}, {"oid": "f006c4eb7daf92211d90bdb5f0c088eb50969914", "url": "https://github.com/microsoft/mssql-jdbc/commit/f006c4eb7daf92211d90bdb5f0c088eb50969914", "message": "Added new Azure endpoints to the list of trusted endpoints (#1264)", "committedDate": "2020-02-24T20:22:09Z", "type": "commit"}, {"oid": "5f33c574906313ecd45694a9e3638d12c23bf837", "url": "https://github.com/microsoft/mssql-jdbc/commit/5f33c574906313ecd45694a9e3638d12c23bf837", "message": "Release | Changes for 8.2.1 HotFix release (#1260)", "committedDate": "2020-02-24T20:31:36Z", "type": "commit"}, {"oid": "10f973767ce0f6e6c2cbf9b2432f93e00f899883", "url": "https://github.com/microsoft/mssql-jdbc/commit/10f973767ce0f6e6c2cbf9b2432f93e00f899883", "message": "Sync master with dev for 8.2.1 Release", "committedDate": "2020-02-27T20:58:49Z", "type": "commit"}, {"oid": "77d25cb6b8729b98d3605b11681f319c9a75e951", "url": "https://github.com/microsoft/mssql-jdbc/commit/77d25cb6b8729b98d3605b11681f319c9a75e951", "message": "Release | 8.3.0-SNAPSHOT", "committedDate": "2020-02-27T21:28:10Z", "type": "commit"}, {"oid": "166add5529f1af3c17fe2dfa160f61bd3ef7dece", "url": "https://github.com/microsoft/mssql-jdbc/commit/166add5529f1af3c17fe2dfa160f61bd3ef7dece", "message": "Sync dev with master for 8.2.1 Release", "committedDate": "2020-02-27T21:29:07Z", "type": "commit"}, {"oid": "3346b3a17f92d6ad2c9ddd3593f04d52e6ed65cd", "url": "https://github.com/microsoft/mssql-jdbc/commit/3346b3a17f92d6ad2c9ddd3593f04d52e6ed65cd", "message": "Release | Add snapshot to pom file", "committedDate": "2020-02-27T22:47:48Z", "type": "commit"}, {"oid": "bef72c52169edd02f7794ace32a684be1e4c0a7f", "url": "https://github.com/microsoft/mssql-jdbc/commit/bef72c52169edd02f7794ace32a684be1e4c0a7f", "message": "Release | Update version to 8.3.0-SNAPSHOT", "committedDate": "2020-02-28T00:14:23Z", "type": "commit"}, {"oid": "560be4ce0675adb7b2826220977bf85aa87d63d3", "url": "https://github.com/microsoft/mssql-jdbc/commit/560be4ce0675adb7b2826220977bf85aa87d63d3", "message": "initial stuff", "committedDate": "2020-03-04T20:40:23Z", "type": "commit"}, {"oid": "bcc4a03b4433bb32bce008464ec438030b9d8abf", "url": "https://github.com/microsoft/mssql-jdbc/commit/bcc4a03b4433bb32bce008464ec438030b9d8abf", "message": "Merge branch 'dev' of https://github.com/Microsoft/mssql-jdbc into clientcertauth", "committedDate": "2020-03-09T20:43:21Z", "type": "commit"}, {"oid": "2508f53e3bd79be0de1cba07d9bc6da529d3258c", "url": "https://github.com/microsoft/mssql-jdbc/commit/2508f53e3bd79be0de1cba07d9bc6da529d3258c", "message": "Add support for PKCS8 and PKCS1 private keys", "committedDate": "2020-03-10T16:37:21Z", "type": "commit"}, {"oid": "15293afaecf17371b1a9016875d0684c14c15b00", "url": "https://github.com/microsoft/mssql-jdbc/commit/15293afaecf17371b1a9016875d0684c14c15b00", "message": "Remove imports", "committedDate": "2020-03-10T16:41:36Z", "type": "commit"}, {"oid": "e1e7c428bdb5211113e4329f76aae9f70c390f16", "url": "https://github.com/microsoft/mssql-jdbc/commit/e1e7c428bdb5211113e4329f76aae9f70c390f16", "message": "Remove imports from iobuffer", "committedDate": "2020-03-10T16:41:55Z", "type": "commit"}, {"oid": "9d2013654ce486e6f899d8b74965006eedbbdd44", "url": "https://github.com/microsoft/mssql-jdbc/commit/9d2013654ce486e6f899d8b74965006eedbbdd44", "message": "more import cleanup", "committedDate": "2020-03-10T16:42:25Z", "type": "commit"}, {"oid": "e2d5f88f7aeccd7ace88fb5261e2feb36ebc97e5", "url": "https://github.com/microsoft/mssql-jdbc/commit/e2d5f88f7aeccd7ace88fb5261e2feb36ebc97e5", "message": "Merge pull request #11 from rene-ye/clientcertauth\n\nAdd support for PKCS8 and PKCS1 private keys", "committedDate": "2020-03-10T16:43:20Z", "type": "commit"}, {"oid": "fa15950f8424791d9551ee3e51956d88d167c0f4", "url": "https://github.com/microsoft/mssql-jdbc/commit/fa15950f8424791d9551ee3e51956d88d167c0f4", "message": "change logic for decryptprovider", "committedDate": "2020-03-10T16:45:10Z", "type": "commit"}, {"oid": "45a7a259820dff620773f496e7289326d7b82abe", "url": "https://github.com/microsoft/mssql-jdbc/commit/45a7a259820dff620773f496e7289326d7b82abe", "message": "Add PVK support", "committedDate": "2020-03-10T17:06:52Z", "type": "commit"}, {"oid": "b51d9b9a4b1578d5d945b0c51c11501dafcc4fad", "url": "https://github.com/microsoft/mssql-jdbc/commit/b51d9b9a4b1578d5d945b0c51c11501dafcc4fad", "message": "changes", "committedDate": "2020-03-10T17:07:21Z", "type": "commit"}, {"oid": "a743065132e87a02b954cbfbbbe8362041afe9aa", "url": "https://github.com/microsoft/mssql-jdbc/commit/a743065132e87a02b954cbfbbbe8362041afe9aa", "message": "Merge branch 'clientcertauth' of https://github.com/peterbae/mssql-jdbc into clientcertauth", "committedDate": "2020-03-10T17:08:14Z", "type": "commit"}, {"oid": "13db00239144c5d9e019284c08ae5cead5ef716d", "url": "https://github.com/microsoft/mssql-jdbc/commit/13db00239144c5d9e019284c08ae5cead5ef716d", "message": "Merge pull request #12 from rene-ye/clientcertauth\n\nchange logic for decryptprovider", "committedDate": "2020-03-10T17:11:08Z", "type": "commit"}, {"oid": "fb19534292ca0da882ef3c2c407a3f801ee6497d", "url": "https://github.com/microsoft/mssql-jdbc/commit/fb19534292ca0da882ef3c2c407a3f801ee6497d", "message": "hw", "committedDate": "2020-03-12T19:52:37Z", "type": "commit"}, {"oid": "f94a3da0859a8186fe1a6020c75cfc75fcfaa926", "url": "https://github.com/microsoft/mssql-jdbc/commit/f94a3da0859a8186fe1a6020c75cfc75fcfaa926", "message": "Merge pull request #13 from rene-ye/clientcertauth\n\nhw", "committedDate": "2020-03-12T20:00:04Z", "type": "commit"}, {"oid": "3f5a9585835875481f7d41acdd06a0fd359776cb", "url": "https://github.com/microsoft/mssql-jdbc/commit/3f5a9585835875481f7d41acdd06a0fd359776cb", "message": "initial changes", "committedDate": "2020-03-16T16:46:23Z", "type": "commit"}, {"oid": "58fb495ae8fd93c4a0d95559d420b89f9258a92e", "url": "https://github.com/microsoft/mssql-jdbc/commit/58fb495ae8fd93c4a0d95559d420b89f9258a92e", "message": "update", "committedDate": "2020-03-16T19:20:53Z", "type": "commit"}, {"oid": "e521b6000f5fcbd2c31787274685503c26d42168", "url": "https://github.com/microsoft/mssql-jdbc/commit/e521b6000f5fcbd2c31787274685503c26d42168", "message": "try", "committedDate": "2020-03-16T19:33:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4OTkzNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393289934", "body": "Can \"PKCS12\" be turned into a constant string? Or is there a constant in JDK that can be used instead? ", "bodyText": "Can \"PKCS12\" be turned into a constant string? Or is there a constant in JDK that can be used instead?", "bodyHTML": "<p dir=\"auto\">Can \"PKCS12\" be turned into a constant string? Or is there a constant in JDK that can be used instead?</p>", "author": "saurabh500", "createdAt": "2020-03-16T20:25:02Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.Security;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMTE4MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398001181", "bodyText": "Will do.", "author": "peterbae", "createdAt": "2020-03-25T16:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4OTkzNA=="}], "type": "inlineReview", "revised_code": {"commit": "bae1e045e5ba01f8e13898f3c0a4cd9de21f42ba", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 018814d2..c1623bb6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -51,226 +49,246 @@ import org.bouncycastle.openssl.PEMParser;\n import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\n \n-\n final class SQLServerCertificateUtils {\n \n-    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\n-            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n-        if (keyPath != null && keyPath.length() > 0) {\n-            return readPKCS8Certificate(certPath, keyPath, keyPassword);\n-        } else {\n-            return readPKCS12Certificate(certPath, keyPassword);\n-        }\n-    }\n-\n-    private static KeyManager[] readPKCS12Certificate(String certPath,\n-            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\n-        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\n-        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n-        keyManagerFactory.init(keystore, keyPassword.toCharArray());\n-        return keyManagerFactory.getKeyManagers();\n-    }\n-\n-    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\n-            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n-        Certificate clientCertificate = loadCertificate(certPath);\n-        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n-\n-        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n-        keyStore.load(null, null);\n-        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-                new Certificate[] {clientCertificate});\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-        kmf.init(keyStore, keyPassword.toCharArray());\n-        return kmf.getKeyManagers();\n-    }\n-\n-    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-        InputStream certstream = fileToStream(certificatePem);\n-        return certificateFactory.generateCertificate(certstream);\n-    }\n-\n-    // PKCS#8 format\n-    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-    // PKCS#1 format\n-    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-    // PVK format\n-    private static final long PVK_MAGIC = 0xB0B5F11EL;\n-    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n-    private static final String RC4_ALG = \"RC4\";\n-    private static final String RSA_ALG = \"RSA\";\n-\n-    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n-            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n-        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-            return loadPrivateKeyFromPKCS8(privateKeyPem);\n-        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-        } else {\n-            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-        }\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPKCS8(\n-            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\n-        key = key.replaceAll(\"\\\\s\", \"\");\n-        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\n-\n-        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n-            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        try {\n-            Security.addProvider(new BouncyCastleProvider());\n-        } catch (SecurityException se) {\n-            // fall through, provider already loaded\n-        }\n-        PEMParser pemParser = null;\n-        try {\n-            pemParser = new PEMParser(new StringReader(key));\n-            Object object = pemParser.readObject();\n-            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n-            KeyPair kp;\n-            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n-                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n-                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n-            } else {\n-                kp = converter.getKeyPair((PEMKeyPair) object);\n-            }\n-            return kp.getPrivate();\n-        } finally {\n-            pemParser.close();\n-        }\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\n-            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\n-        File f = new File(keyPath);\n-        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n-        try (FileInputStream in = new FileInputStream(f)) {\n-            in.getChannel().read(buffer);\n-            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n-\n-            long magic = buffer.getInt() & 0xFFFFFFFFL;\n-            if (PVK_MAGIC != magic) {\n-                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n-                        \"\", false);\n-            }\n-\n-            buffer.position(buffer.position() + 8); // skip reserved and keytype\n-            boolean encrypted = buffer.getInt() != 0;\n-            int saltLength = buffer.getInt();\n-            int keyLength = buffer.getInt();\n-            byte[] salt = new byte[saltLength];\n-            buffer.get(salt);\n-\n-            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n-\n-            byte[] key = new byte[keyLength - 8];\n-            buffer.get(key);\n-\n-            if (encrypted) {\n-                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n-                digest.update(salt);\n-                if (keyPass != null) {\n-                    digest.update(keyPass.getBytes());\n-                }\n-                byte[] hash = digest.digest();\n-                key = getSecretKeyFromHash(key, hash);\n-            }\n-\n-            ByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-            keyBuff.position(RSA2_MAGIC.length); // skip the header\n-\n-            int byteLength = keyBuff.getInt() / 8;\n-            BigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-            BigInteger modulus = getBigInteger(keyBuff, byteLength);\n-            BigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n-\n-            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n-                    prime2, primeExponent1, primeExponent2, crtCoefficient);\n-            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-            return factory.generatePrivate(spec);\n-        }\n-    }\n-\n-    private static boolean startsWithMagic(byte[] b) {\n-        for (int i = 0; i < 4; i++) {\n-            if (b[i] != RSA2_MAGIC[i])\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    private static byte[] getSecretKeyFromHash(byte[] originalKey,\n-            byte[] keyHash) throws GeneralSecurityException, SQLServerException {\n-        SecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-        byte[] decoded = decryptSecretKey(strongKey, originalKey);\n-        if (startsWithMagic(decoded)) {\n-            return decoded;\n-        }\n-\n-        // Couldn't find magic due to padding, trim the key\n-        Arrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n-        SecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-        decoded = decryptSecretKey(weakKey, originalKey);\n-        if (startsWithMagic(decoded)) {\n-            return decoded;\n-        }\n-\n-        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n-                false);\n-        return null;\n-    }\n-\n-    private static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n-        Cipher cipher = Cipher.getInstance(key.getAlgorithm());\n-        cipher.init(Cipher.DECRYPT_MODE, key);\n-        return cipher.doFinal(encoded);\n-    }\n-\n-    private static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n-        // Add an extra bit for signum\n-        byte[] array = new byte[length + 1];\n-        // Need to reverse the buffer because our buffer was set to Little Endian\n-        for (int i = 0; i < length; i++) {\n-            array[array.length - 1 - i] = buffer.get();\n-        }\n-        return new BigInteger(array);\n-    }\n-\n-    private static InputStream fileToStream(String fname) throws IOException {\n-        FileInputStream fis = null;\n-        DataInputStream dis = null;\n-        try {\n-            fis = new FileInputStream(fname);\n-            dis = new DataInputStream(fis);\n-            byte[] bytes = new byte[dis.available()];\n-            dis.readFully(bytes);\n-            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-            return bais;\n-        } finally {\n-            dis.close();\n-            fis.close();\n-        }\n-    }\n-\n-    private static String getStringFromFile(String filePath) throws IOException {\n-        return new String(Files.readAllBytes(Paths.get(filePath)));\n-    }\n+\tstatic KeyManager[] getKeyManagerFromFile(String certPath, String keyPath, String keyPassword)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tif (keyPath != null && keyPath.length() > 0) {\n+\t\t\treturn readPKCS8Certificate(certPath, keyPath, keyPassword);\n+\t\t} else {\n+\t\t\treturn readPKCS12Certificate(certPath, keyPassword);\n+\t\t}\n+\t}\n+\n+\t// PKCS#12 format\n+\tprivate static final String PKCS12_ALG = \"PKCS12\";\n+\t// PKCS#8 format\n+\tprivate static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n+\tprivate static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n+\t// PKCS#1 format\n+\tprivate static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n+\t// PVK format\n+\tprivate static final long PVK_MAGIC = 0xB0B5F11EL;\n+\tprivate static final byte[] RSA2_MAGIC = { 82, 83, 65, 50 };\n+\tprivate static final String RC4_ALG = \"RC4\";\n+\tprivate static final String RSA_ALG = \"RSA\";\n+\n+\tprivate static KeyManager[] readPKCS12Certificate(String certPath, String keyPassword)\n+\t\t\tthrows NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,\n+\t\t\tUnrecoverableKeyException, KeyStoreException {\n+\t\tKeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n+\t\tkeystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n+\t\tKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n+\t\tkeyManagerFactory.init(keystore, keyPassword.toCharArray());\n+\t\treturn keyManagerFactory.getKeyManagers();\n+\t}\n+\n+\tprivate static KeyManager[] readPKCS8Certificate(String certPath, String keyPath, String keyPassword)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tCertificate clientCertificate = loadCertificate(certPath);\n+\t\tPrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n+\n+\t\tKeyStore keyStore = KeyStore.getInstance(\"JKS\");\n+\t\tkeyStore.load(null, null);\n+\t\tkeyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n+\t\tkeyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n+\t\t\t\tnew Certificate[] { clientCertificate });\n+\n+\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+\t\tkmf.init(keyStore, keyPassword.toCharArray());\n+\t\treturn kmf.getKeyManagers();\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPKCS8(String key)\n+\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\t\tStringBuilder sb = new StringBuilder(key);\n+\t\tdeleteFirst(sb, PEM_PRIVATE_START);\n+\t\tdeleteFirst(sb, PEM_PRIVATE_END);\n+\t\treplaceAll(sb, \"\\\\s\", \"\");\n+\t\tbyte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n+\n+\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+\t\treturn factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n+\t}\n+\n+\tprivate static void deleteFirst(StringBuilder sb, String str) {\n+\t\tint i = sb.indexOf(str);\n+\t\tif (i != -1) {\n+\t\t\tsb.delete(i, i + str.length());\n+\t\t}\n+\t}\n+\n+\tprivate static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+\t\tint index = sb.indexOf(oldStr);\n+\t\twhile (index != -1) {\n+\t\t\tsb.replace(index, index + oldStr.length(), newStr);\n+\t\t\tindex += newStr.length();\n+\t\t\tindex = sb.indexOf(oldStr, index);\n+\t\t}\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPKCS1(String key, String keyPass)\n+\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\t\ttry {\n+\t\t\tSQLServerBouncyCastleLoader.loadBouncyCastle();\n+\t\t} catch (SecurityException se) {\n+\t\t\t// fall through, provider already loaded\n+\t\t}\n+\t\tPEMParser pemParser = null;\n+\t\ttry {\n+\t\t\tpemParser = new PEMParser(new StringReader(key));\n+\t\t\tObject object = pemParser.readObject();\n+\t\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n+\t\t\tKeyPair kp;\n+\t\t\tif (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n+\t\t\t\tPEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n+\t\t\t\tkp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n+\t\t\t} else {\n+\t\t\t\tkp = converter.getKeyPair((PEMKeyPair) object);\n+\t\t\t}\n+\t\t\treturn kp.getPrivate();\n+\t\t} finally {\n+\t\t\tpemParser.close();\n+\t\t}\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPVK(String keyPath, String keyPass)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tFile f = new File(keyPath);\n+\t\tByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n+\t\ttry (FileInputStream in = new FileInputStream(f)) {\n+\t\t\tin.getChannel().read(buffer);\n+\t\t\tbuffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n+\n+\t\t\tlong magic = buffer.getInt() & 0xFFFFFFFFL;\n+\t\t\tif (PVK_MAGIC != magic) {\n+\t\t\t\tSQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n+\t\t\t\t\t\t\"\", false);\n+\t\t\t}\n+\n+\t\t\tbuffer.position(buffer.position() + 8); // skip reserved and keytype\n+\t\t\tboolean encrypted = buffer.getInt() != 0;\n+\t\t\tint saltLength = buffer.getInt();\n+\t\t\tint keyLength = buffer.getInt();\n+\t\t\tbyte[] salt = new byte[saltLength];\n+\t\t\tbuffer.get(salt);\n+\n+\t\t\tbuffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n+\n+\t\t\tbyte[] key = new byte[keyLength - 8];\n+\t\t\tbuffer.get(key);\n+\n+\t\t\tif (encrypted) {\n+\t\t\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n+\t\t\t\tdigest.update(salt);\n+\t\t\t\tif (keyPass != null) {\n+\t\t\t\t\tdigest.update(keyPass.getBytes());\n+\t\t\t\t}\n+\t\t\t\tbyte[] hash = digest.digest();\n+\t\t\t\tkey = getSecretKeyFromHash(key, hash);\n+\t\t\t}\n+\n+\t\t\tByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+\t\t\tkeyBuff.position(RSA2_MAGIC.length); // skip the header\n+\n+\t\t\tint byteLength = keyBuff.getInt() / 8;\n+\t\t\tBigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n+\t\t\tBigInteger modulus = getBigInteger(keyBuff, byteLength);\n+\t\t\tBigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n+\n+\t\t\tRSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n+\t\t\t\t\tprime2, primeExponent1, primeExponent2, crtCoefficient);\n+\t\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+\t\t\treturn factory.generatePrivate(spec);\n+\t\t}\n+\t}\n+\n+\tprivate static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+\t\tCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n+\t\tInputStream certstream = fileToStream(certificatePem);\n+\t\treturn certificateFactory.generateCertificate(certstream);\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKey(String privateKeyPemPath, String privateKeyPassword)\n+\t\t\tthrows GeneralSecurityException, IOException, SQLServerException {\n+\t\tString privateKeyPem = getStringFromFile(privateKeyPemPath);\n+\n+\t\tif (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n+\t\t\treturn loadPrivateKeyFromPKCS8(privateKeyPem);\n+\t\t} else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n+\t\t\treturn loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n+\t\t} else {\n+\t\t\treturn loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n+\t\t}\n+\t}\n+\n+\tprivate static boolean startsWithMagic(byte[] b) {\n+\t\tfor (int i = 0; i < RSA2_MAGIC.length; i++) {\n+\t\t\tif (b[i] != RSA2_MAGIC[i])\n+\t\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static byte[] getSecretKeyFromHash(byte[] originalKey, byte[] keyHash)\n+\t\t\tthrows GeneralSecurityException, SQLServerException {\n+\t\tSecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+\t\tbyte[] decoded = decryptSecretKey(strongKey, originalKey);\n+\t\tif (startsWithMagic(decoded)) {\n+\t\t\treturn decoded;\n+\t\t}\n+\n+\t\t// Couldn't find magic due to padding, trim the key\n+\t\tArrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n+\t\tSecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+\t\tdecoded = decryptSecretKey(weakKey, originalKey);\n+\t\tif (startsWithMagic(decoded)) {\n+\t\t\treturn decoded;\n+\t\t}\n+\n+\t\tSQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n+\t\t\t\tfalse);\n+\t\treturn null;\n+\t}\n+\n+\tprivate static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n+\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n+\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n+\t\treturn cipher.doFinal(encoded);\n+\t}\n+\n+\tprivate static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n+\t\t// Add an extra bit for signum\n+\t\tbyte[] array = new byte[length + 1];\n+\t\t// Need to reverse the buffer because our buffer was set to Little Endian\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tarray[array.length - 1 - i] = buffer.get();\n+\t\t}\n+\t\treturn new BigInteger(array);\n+\t}\n+\n+\tprivate static InputStream fileToStream(String fname) throws IOException {\n+\t\tFileInputStream fis = null;\n+\t\tDataInputStream dis = null;\n+\t\ttry {\n+\t\t\tfis = new FileInputStream(fname);\n+\t\t\tdis = new DataInputStream(fis);\n+\t\t\tbyte[] bytes = new byte[dis.available()];\n+\t\t\tdis.readFully(bytes);\n+\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+\t\t\treturn bais;\n+\t\t} finally {\n+\t\t\tdis.close();\n+\t\t\tfis.close();\n+\t\t}\n+\t}\n+\n+\tprivate static String getStringFromFile(String filePath) throws IOException {\n+\t\treturn new String(Files.readAllBytes(Paths.get(filePath)));\n+\t}\n }\n", "next_change": {"commit": "bee991c2d4f6dc729c23fe62b50cb5cae59b72f9", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex c1623bb6..b4028250 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -49,246 +49,250 @@ import org.bouncycastle.openssl.PEMParser;\n import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\n \n+\n final class SQLServerCertificateUtils {\n \n-\tstatic KeyManager[] getKeyManagerFromFile(String certPath, String keyPath, String keyPassword)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tif (keyPath != null && keyPath.length() > 0) {\n-\t\t\treturn readPKCS8Certificate(certPath, keyPath, keyPassword);\n-\t\t} else {\n-\t\t\treturn readPKCS12Certificate(certPath, keyPassword);\n-\t\t}\n-\t}\n-\n-\t// PKCS#12 format\n-\tprivate static final String PKCS12_ALG = \"PKCS12\";\n-\t// PKCS#8 format\n-\tprivate static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-\tprivate static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-\t// PKCS#1 format\n-\tprivate static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-\t// PVK format\n-\tprivate static final long PVK_MAGIC = 0xB0B5F11EL;\n-\tprivate static final byte[] RSA2_MAGIC = { 82, 83, 65, 50 };\n-\tprivate static final String RC4_ALG = \"RC4\";\n-\tprivate static final String RSA_ALG = \"RSA\";\n-\n-\tprivate static KeyManager[] readPKCS12Certificate(String certPath, String keyPassword)\n-\t\t\tthrows NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,\n-\t\t\tUnrecoverableKeyException, KeyStoreException {\n-\t\tKeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n-\t\tkeystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n-\t\tKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n-\t\tkeyManagerFactory.init(keystore, keyPassword.toCharArray());\n-\t\treturn keyManagerFactory.getKeyManagers();\n-\t}\n-\n-\tprivate static KeyManager[] readPKCS8Certificate(String certPath, String keyPath, String keyPassword)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tCertificate clientCertificate = loadCertificate(certPath);\n-\t\tPrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n-\n-\t\tKeyStore keyStore = KeyStore.getInstance(\"JKS\");\n-\t\tkeyStore.load(null, null);\n-\t\tkeyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-\t\tkeyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-\t\t\t\tnew Certificate[] { clientCertificate });\n-\n-\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-\t\tkmf.init(keyStore, keyPassword.toCharArray());\n-\t\treturn kmf.getKeyManagers();\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPKCS8(String key)\n-\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-\t\tStringBuilder sb = new StringBuilder(key);\n-\t\tdeleteFirst(sb, PEM_PRIVATE_START);\n-\t\tdeleteFirst(sb, PEM_PRIVATE_END);\n-\t\treplaceAll(sb, \"\\\\s\", \"\");\n-\t\tbyte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n-\n-\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-\t\treturn factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n-\t}\n-\n-\tprivate static void deleteFirst(StringBuilder sb, String str) {\n-\t\tint i = sb.indexOf(str);\n-\t\tif (i != -1) {\n-\t\t\tsb.delete(i, i + str.length());\n-\t\t}\n-\t}\n-\n-\tprivate static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n-\t\tint index = sb.indexOf(oldStr);\n-\t\twhile (index != -1) {\n-\t\t\tsb.replace(index, index + oldStr.length(), newStr);\n-\t\t\tindex += newStr.length();\n-\t\t\tindex = sb.indexOf(oldStr, index);\n-\t\t}\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPKCS1(String key, String keyPass)\n-\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-\t\ttry {\n-\t\t\tSQLServerBouncyCastleLoader.loadBouncyCastle();\n-\t\t} catch (SecurityException se) {\n-\t\t\t// fall through, provider already loaded\n-\t\t}\n-\t\tPEMParser pemParser = null;\n-\t\ttry {\n-\t\t\tpemParser = new PEMParser(new StringReader(key));\n-\t\t\tObject object = pemParser.readObject();\n-\t\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n-\t\t\tKeyPair kp;\n-\t\t\tif (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n-\t\t\t\tPEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n-\t\t\t\tkp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n-\t\t\t} else {\n-\t\t\t\tkp = converter.getKeyPair((PEMKeyPair) object);\n-\t\t\t}\n-\t\t\treturn kp.getPrivate();\n-\t\t} finally {\n-\t\t\tpemParser.close();\n-\t\t}\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPVK(String keyPath, String keyPass)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tFile f = new File(keyPath);\n-\t\tByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n-\t\ttry (FileInputStream in = new FileInputStream(f)) {\n-\t\t\tin.getChannel().read(buffer);\n-\t\t\tbuffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n-\n-\t\t\tlong magic = buffer.getInt() & 0xFFFFFFFFL;\n-\t\t\tif (PVK_MAGIC != magic) {\n-\t\t\t\tSQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n-\t\t\t\t\t\t\"\", false);\n-\t\t\t}\n-\n-\t\t\tbuffer.position(buffer.position() + 8); // skip reserved and keytype\n-\t\t\tboolean encrypted = buffer.getInt() != 0;\n-\t\t\tint saltLength = buffer.getInt();\n-\t\t\tint keyLength = buffer.getInt();\n-\t\t\tbyte[] salt = new byte[saltLength];\n-\t\t\tbuffer.get(salt);\n-\n-\t\t\tbuffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n-\n-\t\t\tbyte[] key = new byte[keyLength - 8];\n-\t\t\tbuffer.get(key);\n-\n-\t\t\tif (encrypted) {\n-\t\t\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n-\t\t\t\tdigest.update(salt);\n-\t\t\t\tif (keyPass != null) {\n-\t\t\t\t\tdigest.update(keyPass.getBytes());\n-\t\t\t\t}\n-\t\t\t\tbyte[] hash = digest.digest();\n-\t\t\t\tkey = getSecretKeyFromHash(key, hash);\n-\t\t\t}\n-\n-\t\t\tByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-\t\t\tkeyBuff.position(RSA2_MAGIC.length); // skip the header\n-\n-\t\t\tint byteLength = keyBuff.getInt() / 8;\n-\t\t\tBigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-\t\t\tBigInteger modulus = getBigInteger(keyBuff, byteLength);\n-\t\t\tBigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n-\n-\t\t\tRSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n-\t\t\t\t\tprime2, primeExponent1, primeExponent2, crtCoefficient);\n-\t\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-\t\t\treturn factory.generatePrivate(spec);\n-\t\t}\n-\t}\n-\n-\tprivate static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-\t\tCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-\t\tInputStream certstream = fileToStream(certificatePem);\n-\t\treturn certificateFactory.generateCertificate(certstream);\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKey(String privateKeyPemPath, String privateKeyPassword)\n-\t\t\tthrows GeneralSecurityException, IOException, SQLServerException {\n-\t\tString privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-\t\tif (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-\t\t\treturn loadPrivateKeyFromPKCS8(privateKeyPem);\n-\t\t} else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-\t\t\treturn loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-\t\t} else {\n-\t\t\treturn loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-\t\t}\n-\t}\n-\n-\tprivate static boolean startsWithMagic(byte[] b) {\n-\t\tfor (int i = 0; i < RSA2_MAGIC.length; i++) {\n-\t\t\tif (b[i] != RSA2_MAGIC[i])\n-\t\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tprivate static byte[] getSecretKeyFromHash(byte[] originalKey, byte[] keyHash)\n-\t\t\tthrows GeneralSecurityException, SQLServerException {\n-\t\tSecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-\t\tbyte[] decoded = decryptSecretKey(strongKey, originalKey);\n-\t\tif (startsWithMagic(decoded)) {\n-\t\t\treturn decoded;\n-\t\t}\n-\n-\t\t// Couldn't find magic due to padding, trim the key\n-\t\tArrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n-\t\tSecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-\t\tdecoded = decryptSecretKey(weakKey, originalKey);\n-\t\tif (startsWithMagic(decoded)) {\n-\t\t\treturn decoded;\n-\t\t}\n-\n-\t\tSQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n-\t\t\t\tfalse);\n-\t\treturn null;\n-\t}\n-\n-\tprivate static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n-\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n-\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n-\t\treturn cipher.doFinal(encoded);\n-\t}\n-\n-\tprivate static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n-\t\t// Add an extra bit for signum\n-\t\tbyte[] array = new byte[length + 1];\n-\t\t// Need to reverse the buffer because our buffer was set to Little Endian\n-\t\tfor (int i = 0; i < length; i++) {\n-\t\t\tarray[array.length - 1 - i] = buffer.get();\n-\t\t}\n-\t\treturn new BigInteger(array);\n-\t}\n-\n-\tprivate static InputStream fileToStream(String fname) throws IOException {\n-\t\tFileInputStream fis = null;\n-\t\tDataInputStream dis = null;\n-\t\ttry {\n-\t\t\tfis = new FileInputStream(fname);\n-\t\t\tdis = new DataInputStream(fis);\n-\t\t\tbyte[] bytes = new byte[dis.available()];\n-\t\t\tdis.readFully(bytes);\n-\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-\t\t\treturn bais;\n-\t\t} finally {\n-\t\t\tdis.close();\n-\t\t\tfis.close();\n-\t\t}\n-\t}\n-\n-\tprivate static String getStringFromFile(String filePath) throws IOException {\n-\t\treturn new String(Files.readAllBytes(Paths.get(filePath)));\n-\t}\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n+        if (keyPath != null && keyPath.length() > 0) {\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\n+        } else {\n+            return readPKCS12Certificate(certPath, keyPassword);\n+        }\n+    }\n+\n+    // PKCS#12 format\n+    private static final String PKCS12_ALG = \"PKCS12\";\n+    private static final String SUN_X_509 = \"SunX509\";\n+    // PKCS#8 format\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n+    private static final String JAVA_KEY_STORE = \"JKS\";\n+    private static final String CLIENT_CERT = \"client-cert\";\n+    private static final String CLIENT_KEY = \"client-key\";\n+    // PKCS#1 format\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n+    // PVK format\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n+    private static final String RC4_ALG = \"RC4\";\n+    private static final String RSA_ALG = \"RSA\";\n+\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\n+        KeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(SUN_X_509);\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\n+        return keyManagerFactory.getKeyManagers();\n+    }\n+\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n+        Certificate clientCertificate = loadCertificate(certPath);\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n+\n+        KeyStore keyStore = KeyStore.getInstance(JAVA_KEY_STORE);\n+        keyStore.load(null, null);\n+        keyStore.setCertificateEntry(CLIENT_CERT, clientCertificate);\n+        keyStore.setKeyEntry(CLIENT_KEY, privateKey, keyPassword.toCharArray(), new Certificate[] {clientCertificate});\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+        kmf.init(keyStore, keyPassword.toCharArray());\n+        return kmf.getKeyManagers();\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        StringBuilder sb = new StringBuilder(key);\n+        deleteFirst(sb, PEM_PRIVATE_START);\n+        deleteFirst(sb, PEM_PRIVATE_END);\n+        replaceAll(sb, \"\\\\s\", \"\");\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n+\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n+    }\n+\n+    private static void deleteFirst(StringBuilder sb, String str) {\n+        int i = sb.indexOf(str);\n+        if (i != -1) {\n+            sb.delete(i, i + str.length());\n+        }\n+    }\n+\n+    private static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+        int index = sb.indexOf(oldStr);\n+        while (index != -1) {\n+            sb.replace(index, index + oldStr.length(), newStr);\n+            index += newStr.length();\n+            index = sb.indexOf(oldStr, index);\n+        }\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        PEMParser pemParser = null;\n+        try {\n+            pemParser = new PEMParser(new StringReader(key));\n+        } catch (Exception e) {\n+            SQLServerBouncyCastleLoader.loadBouncyCastle();\n+            pemParser = new PEMParser(new StringReader(key));\n+        }\n+\n+        try {\n+            Object object = pemParser.readObject();\n+            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n+            KeyPair kp;\n+            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n+                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n+                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n+            } else {\n+                kp = converter.getKeyPair((PEMKeyPair) object);\n+            }\n+            return kp.getPrivate();\n+        } finally {\n+            pemParser.close();\n+        }\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\n+            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\n+        File f = new File(keyPath);\n+        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n+        try (FileInputStream in = new FileInputStream(f)) {\n+            in.getChannel().read(buffer);\n+            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n+\n+            long magic = buffer.getInt() & 0xFFFFFFFFL;\n+            if (PVK_MAGIC != magic) {\n+                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n+                        \"\", false);\n+            }\n+\n+            buffer.position(buffer.position() + 8); // skip reserved and keytype\n+            boolean encrypted = buffer.getInt() != 0;\n+            int saltLength = buffer.getInt();\n+            int keyLength = buffer.getInt();\n+            byte[] salt = new byte[saltLength];\n+            buffer.get(salt);\n+\n+            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n+\n+            byte[] key = new byte[keyLength - 8];\n+            buffer.get(key);\n+\n+            if (encrypted) {\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n+                digest.update(salt);\n+                if (keyPass != null) {\n+                    digest.update(keyPass.getBytes());\n+                }\n+                byte[] hash = digest.digest();\n+                key = getSecretKeyFromHash(key, hash);\n+            }\n+\n+            ByteBuffer buff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+            buff.position(RSA2_MAGIC.length); // skip the header\n+\n+            int byteLength = buff.getInt() / 8;\n+            BigInteger publicExponent = BigInteger.valueOf(buff.getInt());\n+            BigInteger modulus = getBigInteger(buff, byteLength);\n+            BigInteger prime1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger prime2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger crtCoefficient = getBigInteger(buff, byteLength / 2);\n+            BigInteger privateExponent = getBigInteger(buff, byteLength);\n+\n+            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n+                    prime2, primeExponent1, primeExponent2, crtCoefficient);\n+            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+            return factory.generatePrivate(spec);\n+        }\n+    }\n+\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n+        InputStream certstream = fileToStream(certificatePem);\n+        return certificateFactory.generateCertificate(certstream);\n+    }\n+\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n+\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n+        } else {\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n+        }\n+    }\n+\n+    private static boolean startsWithMagic(byte[] b) {\n+        for (int i = 0; i < RSA2_MAGIC.length; i++) {\n+            if (b[i] != RSA2_MAGIC[i])\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    private static byte[] getSecretKeyFromHash(byte[] originalKey,\n+            byte[] keyHash) throws GeneralSecurityException, SQLServerException {\n+        SecretKey key = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+        byte[] decrypted = decryptSecretKey(key, originalKey);\n+        if (startsWithMagic(decrypted)) {\n+            return decrypted;\n+        }\n+\n+        // Couldn't find magic due to padding, trim the key\n+        Arrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n+        key = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+        decrypted = decryptSecretKey(key, originalKey);\n+        if (startsWithMagic(decrypted)) {\n+            return decrypted;\n+        }\n+\n+        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n+                false);\n+        return null;\n+    }\n+\n+    private static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n+        Cipher cipher = Cipher.getInstance(key.getAlgorithm());\n+        cipher.init(Cipher.DECRYPT_MODE, key);\n+        return cipher.doFinal(encoded);\n+    }\n+\n+    private static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n+        // Add an extra bit for signum\n+        byte[] array = new byte[length + 1];\n+        // Write in reverse because our buffer was set to Little Endian\n+        for (int i = 0; i < length; i++) {\n+            array[array.length - 1 - i] = buffer.get();\n+        }\n+        return new BigInteger(array);\n+    }\n+\n+    private static InputStream fileToStream(String fname) throws IOException {\n+        FileInputStream fis = null;\n+        DataInputStream dis = null;\n+        try {\n+            fis = new FileInputStream(fname);\n+            dis = new DataInputStream(fis);\n+            byte[] bytes = new byte[dis.available()];\n+            dis.readFully(bytes);\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            return bais;\n+        } finally {\n+            dis.close();\n+            fis.close();\n+        }\n+    }\n+\n+    private static String getStringFromFile(String filePath) throws IOException {\n+        return new String(Files.readAllBytes(Paths.get(filePath)));\n+    }\n }\n", "next_change": {"commit": "c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex b4028250..535b413e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -287,8 +289,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "898feca0c08f251d3d9d43789f16b506240e5a03", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 535b413e..4122ce2c 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -289,12 +278,8 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            if (null != dis) {\n-                dis.close();\n-            }\n-            if (null != fis) {\n-                fis.close();\n-            }\n+            dis.close();\n+            fis.close();\n         }\n     }\n \n", "next_change": {"commit": "ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 4122ce2c..d8778a28 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -278,8 +279,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "198b97d76a99f8353c01bf53e356797c520339b3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex d8778a28..d817f872 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -279,12 +277,8 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            if (null != dis) {\n-                dis.close();\n-            }\n-            if (null != fis) {\n-                fis.close();\n-            }\n+            dis.close();\n+            fis.close();\n         }\n     }\n \n", "next_change": {"commit": "13b27a4ec2358b73d1c7c79a01fca38a0f3f0e6b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex d817f872..d8778a28 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -277,8 +279,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTA5Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393291092", "body": "Is it possible to use the StringBuilder to do these manipulations on the key? \r\nThe current code will create new instances of String since String is immutable. Can we optimize a bit for memory? ", "bodyText": "Is it possible to use the StringBuilder to do these manipulations on the key?\nThe current code will create new instances of String since String is immutable. Can we optimize a bit for memory?", "bodyHTML": "<p dir=\"auto\">Is it possible to use the StringBuilder to do these manipulations on the key?<br>\nThe current code will create new instances of String since String is immutable. Can we optimize a bit for memory?</p>", "author": "saurabh500", "createdAt": "2020-03-16T20:27:35Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.Security;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r\n+                new Certificate[] {clientCertificate});\r\n+\r\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n+        kmf.init(keyStore, keyPassword.toCharArray());\r\n+        return kmf.getKeyManagers();\r\n+    }\r\n+\r\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\r\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\r\n+        InputStream certstream = fileToStream(certificatePem);\r\n+        return certificateFactory.generateCertificate(certstream);\r\n+    }\r\n+\r\n+    // PKCS#8 format\r\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\r\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\r\n+    // PKCS#1 format\r\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\r\n+    // PVK format\r\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\r\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\r\n+    private static final String RC4_ALG = \"RC4\";\r\n+    private static final String RSA_ALG = \"RSA\";\r\n+\r\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\r\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\r\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\r\n+\r\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\r\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\r\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\r\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\r\n+        } else {\r\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\r\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\r", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bae1e045e5ba01f8e13898f3c0a4cd9de21f42ba", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 018814d2..c1623bb6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -51,226 +49,246 @@ import org.bouncycastle.openssl.PEMParser;\n import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\n \n-\n final class SQLServerCertificateUtils {\n \n-    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\n-            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n-        if (keyPath != null && keyPath.length() > 0) {\n-            return readPKCS8Certificate(certPath, keyPath, keyPassword);\n-        } else {\n-            return readPKCS12Certificate(certPath, keyPassword);\n-        }\n-    }\n-\n-    private static KeyManager[] readPKCS12Certificate(String certPath,\n-            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\n-        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\n-        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n-        keyManagerFactory.init(keystore, keyPassword.toCharArray());\n-        return keyManagerFactory.getKeyManagers();\n-    }\n-\n-    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\n-            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n-        Certificate clientCertificate = loadCertificate(certPath);\n-        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n-\n-        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n-        keyStore.load(null, null);\n-        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-                new Certificate[] {clientCertificate});\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-        kmf.init(keyStore, keyPassword.toCharArray());\n-        return kmf.getKeyManagers();\n-    }\n-\n-    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-        InputStream certstream = fileToStream(certificatePem);\n-        return certificateFactory.generateCertificate(certstream);\n-    }\n-\n-    // PKCS#8 format\n-    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-    // PKCS#1 format\n-    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-    // PVK format\n-    private static final long PVK_MAGIC = 0xB0B5F11EL;\n-    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n-    private static final String RC4_ALG = \"RC4\";\n-    private static final String RSA_ALG = \"RSA\";\n-\n-    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n-            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n-        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-            return loadPrivateKeyFromPKCS8(privateKeyPem);\n-        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-        } else {\n-            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-        }\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPKCS8(\n-            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\n-        key = key.replaceAll(\"\\\\s\", \"\");\n-        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\n-\n-        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n-            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        try {\n-            Security.addProvider(new BouncyCastleProvider());\n-        } catch (SecurityException se) {\n-            // fall through, provider already loaded\n-        }\n-        PEMParser pemParser = null;\n-        try {\n-            pemParser = new PEMParser(new StringReader(key));\n-            Object object = pemParser.readObject();\n-            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n-            KeyPair kp;\n-            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n-                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n-                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n-            } else {\n-                kp = converter.getKeyPair((PEMKeyPair) object);\n-            }\n-            return kp.getPrivate();\n-        } finally {\n-            pemParser.close();\n-        }\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\n-            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\n-        File f = new File(keyPath);\n-        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n-        try (FileInputStream in = new FileInputStream(f)) {\n-            in.getChannel().read(buffer);\n-            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n-\n-            long magic = buffer.getInt() & 0xFFFFFFFFL;\n-            if (PVK_MAGIC != magic) {\n-                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n-                        \"\", false);\n-            }\n-\n-            buffer.position(buffer.position() + 8); // skip reserved and keytype\n-            boolean encrypted = buffer.getInt() != 0;\n-            int saltLength = buffer.getInt();\n-            int keyLength = buffer.getInt();\n-            byte[] salt = new byte[saltLength];\n-            buffer.get(salt);\n-\n-            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n-\n-            byte[] key = new byte[keyLength - 8];\n-            buffer.get(key);\n-\n-            if (encrypted) {\n-                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n-                digest.update(salt);\n-                if (keyPass != null) {\n-                    digest.update(keyPass.getBytes());\n-                }\n-                byte[] hash = digest.digest();\n-                key = getSecretKeyFromHash(key, hash);\n-            }\n-\n-            ByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-            keyBuff.position(RSA2_MAGIC.length); // skip the header\n-\n-            int byteLength = keyBuff.getInt() / 8;\n-            BigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-            BigInteger modulus = getBigInteger(keyBuff, byteLength);\n-            BigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n-\n-            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n-                    prime2, primeExponent1, primeExponent2, crtCoefficient);\n-            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-            return factory.generatePrivate(spec);\n-        }\n-    }\n-\n-    private static boolean startsWithMagic(byte[] b) {\n-        for (int i = 0; i < 4; i++) {\n-            if (b[i] != RSA2_MAGIC[i])\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    private static byte[] getSecretKeyFromHash(byte[] originalKey,\n-            byte[] keyHash) throws GeneralSecurityException, SQLServerException {\n-        SecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-        byte[] decoded = decryptSecretKey(strongKey, originalKey);\n-        if (startsWithMagic(decoded)) {\n-            return decoded;\n-        }\n-\n-        // Couldn't find magic due to padding, trim the key\n-        Arrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n-        SecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-        decoded = decryptSecretKey(weakKey, originalKey);\n-        if (startsWithMagic(decoded)) {\n-            return decoded;\n-        }\n-\n-        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n-                false);\n-        return null;\n-    }\n-\n-    private static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n-        Cipher cipher = Cipher.getInstance(key.getAlgorithm());\n-        cipher.init(Cipher.DECRYPT_MODE, key);\n-        return cipher.doFinal(encoded);\n-    }\n-\n-    private static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n-        // Add an extra bit for signum\n-        byte[] array = new byte[length + 1];\n-        // Need to reverse the buffer because our buffer was set to Little Endian\n-        for (int i = 0; i < length; i++) {\n-            array[array.length - 1 - i] = buffer.get();\n-        }\n-        return new BigInteger(array);\n-    }\n-\n-    private static InputStream fileToStream(String fname) throws IOException {\n-        FileInputStream fis = null;\n-        DataInputStream dis = null;\n-        try {\n-            fis = new FileInputStream(fname);\n-            dis = new DataInputStream(fis);\n-            byte[] bytes = new byte[dis.available()];\n-            dis.readFully(bytes);\n-            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-            return bais;\n-        } finally {\n-            dis.close();\n-            fis.close();\n-        }\n-    }\n-\n-    private static String getStringFromFile(String filePath) throws IOException {\n-        return new String(Files.readAllBytes(Paths.get(filePath)));\n-    }\n+\tstatic KeyManager[] getKeyManagerFromFile(String certPath, String keyPath, String keyPassword)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tif (keyPath != null && keyPath.length() > 0) {\n+\t\t\treturn readPKCS8Certificate(certPath, keyPath, keyPassword);\n+\t\t} else {\n+\t\t\treturn readPKCS12Certificate(certPath, keyPassword);\n+\t\t}\n+\t}\n+\n+\t// PKCS#12 format\n+\tprivate static final String PKCS12_ALG = \"PKCS12\";\n+\t// PKCS#8 format\n+\tprivate static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n+\tprivate static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n+\t// PKCS#1 format\n+\tprivate static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n+\t// PVK format\n+\tprivate static final long PVK_MAGIC = 0xB0B5F11EL;\n+\tprivate static final byte[] RSA2_MAGIC = { 82, 83, 65, 50 };\n+\tprivate static final String RC4_ALG = \"RC4\";\n+\tprivate static final String RSA_ALG = \"RSA\";\n+\n+\tprivate static KeyManager[] readPKCS12Certificate(String certPath, String keyPassword)\n+\t\t\tthrows NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,\n+\t\t\tUnrecoverableKeyException, KeyStoreException {\n+\t\tKeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n+\t\tkeystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n+\t\tKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n+\t\tkeyManagerFactory.init(keystore, keyPassword.toCharArray());\n+\t\treturn keyManagerFactory.getKeyManagers();\n+\t}\n+\n+\tprivate static KeyManager[] readPKCS8Certificate(String certPath, String keyPath, String keyPassword)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tCertificate clientCertificate = loadCertificate(certPath);\n+\t\tPrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n+\n+\t\tKeyStore keyStore = KeyStore.getInstance(\"JKS\");\n+\t\tkeyStore.load(null, null);\n+\t\tkeyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n+\t\tkeyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n+\t\t\t\tnew Certificate[] { clientCertificate });\n+\n+\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+\t\tkmf.init(keyStore, keyPassword.toCharArray());\n+\t\treturn kmf.getKeyManagers();\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPKCS8(String key)\n+\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\t\tStringBuilder sb = new StringBuilder(key);\n+\t\tdeleteFirst(sb, PEM_PRIVATE_START);\n+\t\tdeleteFirst(sb, PEM_PRIVATE_END);\n+\t\treplaceAll(sb, \"\\\\s\", \"\");\n+\t\tbyte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n+\n+\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+\t\treturn factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n+\t}\n+\n+\tprivate static void deleteFirst(StringBuilder sb, String str) {\n+\t\tint i = sb.indexOf(str);\n+\t\tif (i != -1) {\n+\t\t\tsb.delete(i, i + str.length());\n+\t\t}\n+\t}\n+\n+\tprivate static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+\t\tint index = sb.indexOf(oldStr);\n+\t\twhile (index != -1) {\n+\t\t\tsb.replace(index, index + oldStr.length(), newStr);\n+\t\t\tindex += newStr.length();\n+\t\t\tindex = sb.indexOf(oldStr, index);\n+\t\t}\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPKCS1(String key, String keyPass)\n+\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\t\ttry {\n+\t\t\tSQLServerBouncyCastleLoader.loadBouncyCastle();\n+\t\t} catch (SecurityException se) {\n+\t\t\t// fall through, provider already loaded\n+\t\t}\n+\t\tPEMParser pemParser = null;\n+\t\ttry {\n+\t\t\tpemParser = new PEMParser(new StringReader(key));\n+\t\t\tObject object = pemParser.readObject();\n+\t\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n+\t\t\tKeyPair kp;\n+\t\t\tif (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n+\t\t\t\tPEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n+\t\t\t\tkp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n+\t\t\t} else {\n+\t\t\t\tkp = converter.getKeyPair((PEMKeyPair) object);\n+\t\t\t}\n+\t\t\treturn kp.getPrivate();\n+\t\t} finally {\n+\t\t\tpemParser.close();\n+\t\t}\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPVK(String keyPath, String keyPass)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tFile f = new File(keyPath);\n+\t\tByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n+\t\ttry (FileInputStream in = new FileInputStream(f)) {\n+\t\t\tin.getChannel().read(buffer);\n+\t\t\tbuffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n+\n+\t\t\tlong magic = buffer.getInt() & 0xFFFFFFFFL;\n+\t\t\tif (PVK_MAGIC != magic) {\n+\t\t\t\tSQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n+\t\t\t\t\t\t\"\", false);\n+\t\t\t}\n+\n+\t\t\tbuffer.position(buffer.position() + 8); // skip reserved and keytype\n+\t\t\tboolean encrypted = buffer.getInt() != 0;\n+\t\t\tint saltLength = buffer.getInt();\n+\t\t\tint keyLength = buffer.getInt();\n+\t\t\tbyte[] salt = new byte[saltLength];\n+\t\t\tbuffer.get(salt);\n+\n+\t\t\tbuffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n+\n+\t\t\tbyte[] key = new byte[keyLength - 8];\n+\t\t\tbuffer.get(key);\n+\n+\t\t\tif (encrypted) {\n+\t\t\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n+\t\t\t\tdigest.update(salt);\n+\t\t\t\tif (keyPass != null) {\n+\t\t\t\t\tdigest.update(keyPass.getBytes());\n+\t\t\t\t}\n+\t\t\t\tbyte[] hash = digest.digest();\n+\t\t\t\tkey = getSecretKeyFromHash(key, hash);\n+\t\t\t}\n+\n+\t\t\tByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+\t\t\tkeyBuff.position(RSA2_MAGIC.length); // skip the header\n+\n+\t\t\tint byteLength = keyBuff.getInt() / 8;\n+\t\t\tBigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n+\t\t\tBigInteger modulus = getBigInteger(keyBuff, byteLength);\n+\t\t\tBigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n+\n+\t\t\tRSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n+\t\t\t\t\tprime2, primeExponent1, primeExponent2, crtCoefficient);\n+\t\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+\t\t\treturn factory.generatePrivate(spec);\n+\t\t}\n+\t}\n+\n+\tprivate static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+\t\tCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n+\t\tInputStream certstream = fileToStream(certificatePem);\n+\t\treturn certificateFactory.generateCertificate(certstream);\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKey(String privateKeyPemPath, String privateKeyPassword)\n+\t\t\tthrows GeneralSecurityException, IOException, SQLServerException {\n+\t\tString privateKeyPem = getStringFromFile(privateKeyPemPath);\n+\n+\t\tif (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n+\t\t\treturn loadPrivateKeyFromPKCS8(privateKeyPem);\n+\t\t} else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n+\t\t\treturn loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n+\t\t} else {\n+\t\t\treturn loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n+\t\t}\n+\t}\n+\n+\tprivate static boolean startsWithMagic(byte[] b) {\n+\t\tfor (int i = 0; i < RSA2_MAGIC.length; i++) {\n+\t\t\tif (b[i] != RSA2_MAGIC[i])\n+\t\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static byte[] getSecretKeyFromHash(byte[] originalKey, byte[] keyHash)\n+\t\t\tthrows GeneralSecurityException, SQLServerException {\n+\t\tSecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+\t\tbyte[] decoded = decryptSecretKey(strongKey, originalKey);\n+\t\tif (startsWithMagic(decoded)) {\n+\t\t\treturn decoded;\n+\t\t}\n+\n+\t\t// Couldn't find magic due to padding, trim the key\n+\t\tArrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n+\t\tSecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+\t\tdecoded = decryptSecretKey(weakKey, originalKey);\n+\t\tif (startsWithMagic(decoded)) {\n+\t\t\treturn decoded;\n+\t\t}\n+\n+\t\tSQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n+\t\t\t\tfalse);\n+\t\treturn null;\n+\t}\n+\n+\tprivate static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n+\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n+\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n+\t\treturn cipher.doFinal(encoded);\n+\t}\n+\n+\tprivate static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n+\t\t// Add an extra bit for signum\n+\t\tbyte[] array = new byte[length + 1];\n+\t\t// Need to reverse the buffer because our buffer was set to Little Endian\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tarray[array.length - 1 - i] = buffer.get();\n+\t\t}\n+\t\treturn new BigInteger(array);\n+\t}\n+\n+\tprivate static InputStream fileToStream(String fname) throws IOException {\n+\t\tFileInputStream fis = null;\n+\t\tDataInputStream dis = null;\n+\t\ttry {\n+\t\t\tfis = new FileInputStream(fname);\n+\t\t\tdis = new DataInputStream(fis);\n+\t\t\tbyte[] bytes = new byte[dis.available()];\n+\t\t\tdis.readFully(bytes);\n+\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+\t\t\treturn bais;\n+\t\t} finally {\n+\t\t\tdis.close();\n+\t\t\tfis.close();\n+\t\t}\n+\t}\n+\n+\tprivate static String getStringFromFile(String filePath) throws IOException {\n+\t\treturn new String(Files.readAllBytes(Paths.get(filePath)));\n+\t}\n }\n", "next_change": {"commit": "bee991c2d4f6dc729c23fe62b50cb5cae59b72f9", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex c1623bb6..b4028250 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -49,246 +49,250 @@ import org.bouncycastle.openssl.PEMParser;\n import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\n \n+\n final class SQLServerCertificateUtils {\n \n-\tstatic KeyManager[] getKeyManagerFromFile(String certPath, String keyPath, String keyPassword)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tif (keyPath != null && keyPath.length() > 0) {\n-\t\t\treturn readPKCS8Certificate(certPath, keyPath, keyPassword);\n-\t\t} else {\n-\t\t\treturn readPKCS12Certificate(certPath, keyPassword);\n-\t\t}\n-\t}\n-\n-\t// PKCS#12 format\n-\tprivate static final String PKCS12_ALG = \"PKCS12\";\n-\t// PKCS#8 format\n-\tprivate static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-\tprivate static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-\t// PKCS#1 format\n-\tprivate static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-\t// PVK format\n-\tprivate static final long PVK_MAGIC = 0xB0B5F11EL;\n-\tprivate static final byte[] RSA2_MAGIC = { 82, 83, 65, 50 };\n-\tprivate static final String RC4_ALG = \"RC4\";\n-\tprivate static final String RSA_ALG = \"RSA\";\n-\n-\tprivate static KeyManager[] readPKCS12Certificate(String certPath, String keyPassword)\n-\t\t\tthrows NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,\n-\t\t\tUnrecoverableKeyException, KeyStoreException {\n-\t\tKeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n-\t\tkeystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n-\t\tKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n-\t\tkeyManagerFactory.init(keystore, keyPassword.toCharArray());\n-\t\treturn keyManagerFactory.getKeyManagers();\n-\t}\n-\n-\tprivate static KeyManager[] readPKCS8Certificate(String certPath, String keyPath, String keyPassword)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tCertificate clientCertificate = loadCertificate(certPath);\n-\t\tPrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n-\n-\t\tKeyStore keyStore = KeyStore.getInstance(\"JKS\");\n-\t\tkeyStore.load(null, null);\n-\t\tkeyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-\t\tkeyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-\t\t\t\tnew Certificate[] { clientCertificate });\n-\n-\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-\t\tkmf.init(keyStore, keyPassword.toCharArray());\n-\t\treturn kmf.getKeyManagers();\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPKCS8(String key)\n-\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-\t\tStringBuilder sb = new StringBuilder(key);\n-\t\tdeleteFirst(sb, PEM_PRIVATE_START);\n-\t\tdeleteFirst(sb, PEM_PRIVATE_END);\n-\t\treplaceAll(sb, \"\\\\s\", \"\");\n-\t\tbyte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n-\n-\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-\t\treturn factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n-\t}\n-\n-\tprivate static void deleteFirst(StringBuilder sb, String str) {\n-\t\tint i = sb.indexOf(str);\n-\t\tif (i != -1) {\n-\t\t\tsb.delete(i, i + str.length());\n-\t\t}\n-\t}\n-\n-\tprivate static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n-\t\tint index = sb.indexOf(oldStr);\n-\t\twhile (index != -1) {\n-\t\t\tsb.replace(index, index + oldStr.length(), newStr);\n-\t\t\tindex += newStr.length();\n-\t\t\tindex = sb.indexOf(oldStr, index);\n-\t\t}\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPKCS1(String key, String keyPass)\n-\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-\t\ttry {\n-\t\t\tSQLServerBouncyCastleLoader.loadBouncyCastle();\n-\t\t} catch (SecurityException se) {\n-\t\t\t// fall through, provider already loaded\n-\t\t}\n-\t\tPEMParser pemParser = null;\n-\t\ttry {\n-\t\t\tpemParser = new PEMParser(new StringReader(key));\n-\t\t\tObject object = pemParser.readObject();\n-\t\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n-\t\t\tKeyPair kp;\n-\t\t\tif (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n-\t\t\t\tPEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n-\t\t\t\tkp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n-\t\t\t} else {\n-\t\t\t\tkp = converter.getKeyPair((PEMKeyPair) object);\n-\t\t\t}\n-\t\t\treturn kp.getPrivate();\n-\t\t} finally {\n-\t\t\tpemParser.close();\n-\t\t}\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPVK(String keyPath, String keyPass)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tFile f = new File(keyPath);\n-\t\tByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n-\t\ttry (FileInputStream in = new FileInputStream(f)) {\n-\t\t\tin.getChannel().read(buffer);\n-\t\t\tbuffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n-\n-\t\t\tlong magic = buffer.getInt() & 0xFFFFFFFFL;\n-\t\t\tif (PVK_MAGIC != magic) {\n-\t\t\t\tSQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n-\t\t\t\t\t\t\"\", false);\n-\t\t\t}\n-\n-\t\t\tbuffer.position(buffer.position() + 8); // skip reserved and keytype\n-\t\t\tboolean encrypted = buffer.getInt() != 0;\n-\t\t\tint saltLength = buffer.getInt();\n-\t\t\tint keyLength = buffer.getInt();\n-\t\t\tbyte[] salt = new byte[saltLength];\n-\t\t\tbuffer.get(salt);\n-\n-\t\t\tbuffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n-\n-\t\t\tbyte[] key = new byte[keyLength - 8];\n-\t\t\tbuffer.get(key);\n-\n-\t\t\tif (encrypted) {\n-\t\t\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n-\t\t\t\tdigest.update(salt);\n-\t\t\t\tif (keyPass != null) {\n-\t\t\t\t\tdigest.update(keyPass.getBytes());\n-\t\t\t\t}\n-\t\t\t\tbyte[] hash = digest.digest();\n-\t\t\t\tkey = getSecretKeyFromHash(key, hash);\n-\t\t\t}\n-\n-\t\t\tByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-\t\t\tkeyBuff.position(RSA2_MAGIC.length); // skip the header\n-\n-\t\t\tint byteLength = keyBuff.getInt() / 8;\n-\t\t\tBigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-\t\t\tBigInteger modulus = getBigInteger(keyBuff, byteLength);\n-\t\t\tBigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n-\n-\t\t\tRSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n-\t\t\t\t\tprime2, primeExponent1, primeExponent2, crtCoefficient);\n-\t\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-\t\t\treturn factory.generatePrivate(spec);\n-\t\t}\n-\t}\n-\n-\tprivate static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-\t\tCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-\t\tInputStream certstream = fileToStream(certificatePem);\n-\t\treturn certificateFactory.generateCertificate(certstream);\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKey(String privateKeyPemPath, String privateKeyPassword)\n-\t\t\tthrows GeneralSecurityException, IOException, SQLServerException {\n-\t\tString privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-\t\tif (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-\t\t\treturn loadPrivateKeyFromPKCS8(privateKeyPem);\n-\t\t} else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-\t\t\treturn loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-\t\t} else {\n-\t\t\treturn loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-\t\t}\n-\t}\n-\n-\tprivate static boolean startsWithMagic(byte[] b) {\n-\t\tfor (int i = 0; i < RSA2_MAGIC.length; i++) {\n-\t\t\tif (b[i] != RSA2_MAGIC[i])\n-\t\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tprivate static byte[] getSecretKeyFromHash(byte[] originalKey, byte[] keyHash)\n-\t\t\tthrows GeneralSecurityException, SQLServerException {\n-\t\tSecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-\t\tbyte[] decoded = decryptSecretKey(strongKey, originalKey);\n-\t\tif (startsWithMagic(decoded)) {\n-\t\t\treturn decoded;\n-\t\t}\n-\n-\t\t// Couldn't find magic due to padding, trim the key\n-\t\tArrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n-\t\tSecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-\t\tdecoded = decryptSecretKey(weakKey, originalKey);\n-\t\tif (startsWithMagic(decoded)) {\n-\t\t\treturn decoded;\n-\t\t}\n-\n-\t\tSQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n-\t\t\t\tfalse);\n-\t\treturn null;\n-\t}\n-\n-\tprivate static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n-\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n-\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n-\t\treturn cipher.doFinal(encoded);\n-\t}\n-\n-\tprivate static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n-\t\t// Add an extra bit for signum\n-\t\tbyte[] array = new byte[length + 1];\n-\t\t// Need to reverse the buffer because our buffer was set to Little Endian\n-\t\tfor (int i = 0; i < length; i++) {\n-\t\t\tarray[array.length - 1 - i] = buffer.get();\n-\t\t}\n-\t\treturn new BigInteger(array);\n-\t}\n-\n-\tprivate static InputStream fileToStream(String fname) throws IOException {\n-\t\tFileInputStream fis = null;\n-\t\tDataInputStream dis = null;\n-\t\ttry {\n-\t\t\tfis = new FileInputStream(fname);\n-\t\t\tdis = new DataInputStream(fis);\n-\t\t\tbyte[] bytes = new byte[dis.available()];\n-\t\t\tdis.readFully(bytes);\n-\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-\t\t\treturn bais;\n-\t\t} finally {\n-\t\t\tdis.close();\n-\t\t\tfis.close();\n-\t\t}\n-\t}\n-\n-\tprivate static String getStringFromFile(String filePath) throws IOException {\n-\t\treturn new String(Files.readAllBytes(Paths.get(filePath)));\n-\t}\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n+        if (keyPath != null && keyPath.length() > 0) {\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\n+        } else {\n+            return readPKCS12Certificate(certPath, keyPassword);\n+        }\n+    }\n+\n+    // PKCS#12 format\n+    private static final String PKCS12_ALG = \"PKCS12\";\n+    private static final String SUN_X_509 = \"SunX509\";\n+    // PKCS#8 format\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n+    private static final String JAVA_KEY_STORE = \"JKS\";\n+    private static final String CLIENT_CERT = \"client-cert\";\n+    private static final String CLIENT_KEY = \"client-key\";\n+    // PKCS#1 format\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n+    // PVK format\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n+    private static final String RC4_ALG = \"RC4\";\n+    private static final String RSA_ALG = \"RSA\";\n+\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\n+        KeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(SUN_X_509);\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\n+        return keyManagerFactory.getKeyManagers();\n+    }\n+\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n+        Certificate clientCertificate = loadCertificate(certPath);\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n+\n+        KeyStore keyStore = KeyStore.getInstance(JAVA_KEY_STORE);\n+        keyStore.load(null, null);\n+        keyStore.setCertificateEntry(CLIENT_CERT, clientCertificate);\n+        keyStore.setKeyEntry(CLIENT_KEY, privateKey, keyPassword.toCharArray(), new Certificate[] {clientCertificate});\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+        kmf.init(keyStore, keyPassword.toCharArray());\n+        return kmf.getKeyManagers();\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        StringBuilder sb = new StringBuilder(key);\n+        deleteFirst(sb, PEM_PRIVATE_START);\n+        deleteFirst(sb, PEM_PRIVATE_END);\n+        replaceAll(sb, \"\\\\s\", \"\");\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n+\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n+    }\n+\n+    private static void deleteFirst(StringBuilder sb, String str) {\n+        int i = sb.indexOf(str);\n+        if (i != -1) {\n+            sb.delete(i, i + str.length());\n+        }\n+    }\n+\n+    private static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+        int index = sb.indexOf(oldStr);\n+        while (index != -1) {\n+            sb.replace(index, index + oldStr.length(), newStr);\n+            index += newStr.length();\n+            index = sb.indexOf(oldStr, index);\n+        }\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        PEMParser pemParser = null;\n+        try {\n+            pemParser = new PEMParser(new StringReader(key));\n+        } catch (Exception e) {\n+            SQLServerBouncyCastleLoader.loadBouncyCastle();\n+            pemParser = new PEMParser(new StringReader(key));\n+        }\n+\n+        try {\n+            Object object = pemParser.readObject();\n+            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n+            KeyPair kp;\n+            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n+                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n+                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n+            } else {\n+                kp = converter.getKeyPair((PEMKeyPair) object);\n+            }\n+            return kp.getPrivate();\n+        } finally {\n+            pemParser.close();\n+        }\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\n+            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\n+        File f = new File(keyPath);\n+        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n+        try (FileInputStream in = new FileInputStream(f)) {\n+            in.getChannel().read(buffer);\n+            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n+\n+            long magic = buffer.getInt() & 0xFFFFFFFFL;\n+            if (PVK_MAGIC != magic) {\n+                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n+                        \"\", false);\n+            }\n+\n+            buffer.position(buffer.position() + 8); // skip reserved and keytype\n+            boolean encrypted = buffer.getInt() != 0;\n+            int saltLength = buffer.getInt();\n+            int keyLength = buffer.getInt();\n+            byte[] salt = new byte[saltLength];\n+            buffer.get(salt);\n+\n+            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n+\n+            byte[] key = new byte[keyLength - 8];\n+            buffer.get(key);\n+\n+            if (encrypted) {\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n+                digest.update(salt);\n+                if (keyPass != null) {\n+                    digest.update(keyPass.getBytes());\n+                }\n+                byte[] hash = digest.digest();\n+                key = getSecretKeyFromHash(key, hash);\n+            }\n+\n+            ByteBuffer buff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+            buff.position(RSA2_MAGIC.length); // skip the header\n+\n+            int byteLength = buff.getInt() / 8;\n+            BigInteger publicExponent = BigInteger.valueOf(buff.getInt());\n+            BigInteger modulus = getBigInteger(buff, byteLength);\n+            BigInteger prime1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger prime2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger crtCoefficient = getBigInteger(buff, byteLength / 2);\n+            BigInteger privateExponent = getBigInteger(buff, byteLength);\n+\n+            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n+                    prime2, primeExponent1, primeExponent2, crtCoefficient);\n+            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+            return factory.generatePrivate(spec);\n+        }\n+    }\n+\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n+        InputStream certstream = fileToStream(certificatePem);\n+        return certificateFactory.generateCertificate(certstream);\n+    }\n+\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n+\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n+        } else {\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n+        }\n+    }\n+\n+    private static boolean startsWithMagic(byte[] b) {\n+        for (int i = 0; i < RSA2_MAGIC.length; i++) {\n+            if (b[i] != RSA2_MAGIC[i])\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    private static byte[] getSecretKeyFromHash(byte[] originalKey,\n+            byte[] keyHash) throws GeneralSecurityException, SQLServerException {\n+        SecretKey key = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+        byte[] decrypted = decryptSecretKey(key, originalKey);\n+        if (startsWithMagic(decrypted)) {\n+            return decrypted;\n+        }\n+\n+        // Couldn't find magic due to padding, trim the key\n+        Arrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n+        key = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+        decrypted = decryptSecretKey(key, originalKey);\n+        if (startsWithMagic(decrypted)) {\n+            return decrypted;\n+        }\n+\n+        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n+                false);\n+        return null;\n+    }\n+\n+    private static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n+        Cipher cipher = Cipher.getInstance(key.getAlgorithm());\n+        cipher.init(Cipher.DECRYPT_MODE, key);\n+        return cipher.doFinal(encoded);\n+    }\n+\n+    private static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n+        // Add an extra bit for signum\n+        byte[] array = new byte[length + 1];\n+        // Write in reverse because our buffer was set to Little Endian\n+        for (int i = 0; i < length; i++) {\n+            array[array.length - 1 - i] = buffer.get();\n+        }\n+        return new BigInteger(array);\n+    }\n+\n+    private static InputStream fileToStream(String fname) throws IOException {\n+        FileInputStream fis = null;\n+        DataInputStream dis = null;\n+        try {\n+            fis = new FileInputStream(fname);\n+            dis = new DataInputStream(fis);\n+            byte[] bytes = new byte[dis.available()];\n+            dis.readFully(bytes);\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            return bais;\n+        } finally {\n+            dis.close();\n+            fis.close();\n+        }\n+    }\n+\n+    private static String getStringFromFile(String filePath) throws IOException {\n+        return new String(Files.readAllBytes(Paths.get(filePath)));\n+    }\n }\n", "next_change": {"commit": "c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex b4028250..535b413e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -287,8 +289,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "898feca0c08f251d3d9d43789f16b506240e5a03", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 535b413e..4122ce2c 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -289,12 +278,8 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            if (null != dis) {\n-                dis.close();\n-            }\n-            if (null != fis) {\n-                fis.close();\n-            }\n+            dis.close();\n+            fis.close();\n         }\n     }\n \n", "next_change": {"commit": "ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 4122ce2c..d8778a28 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -278,8 +279,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "198b97d76a99f8353c01bf53e356797c520339b3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex d8778a28..d817f872 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -279,12 +277,8 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            if (null != dis) {\n-                dis.close();\n-            }\n-            if (null != fis) {\n-                fis.close();\n-            }\n+            dis.close();\n+            fis.close();\n         }\n     }\n \n", "next_change": {"commit": "13b27a4ec2358b73d1c7c79a01fca38a0f3f0e6b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex d817f872..d8778a28 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -277,8 +279,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTM4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393291389", "body": "Instead of relying on empty exception handling, is there a way to check if the provider is loaded, and use that ? ", "bodyText": "Instead of relying on empty exception handling, is there a way to check if the provider is loaded, and use that ?", "bodyHTML": "<p dir=\"auto\">Instead of relying on empty exception handling, is there a way to check if the provider is loaded, and use that ?</p>", "author": "saurabh500", "createdAt": "2020-03-16T20:28:14Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.Security;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r\n+                new Certificate[] {clientCertificate});\r\n+\r\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n+        kmf.init(keyStore, keyPassword.toCharArray());\r\n+        return kmf.getKeyManagers();\r\n+    }\r\n+\r\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\r\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\r\n+        InputStream certstream = fileToStream(certificatePem);\r\n+        return certificateFactory.generateCertificate(certstream);\r\n+    }\r\n+\r\n+    // PKCS#8 format\r\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\r\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\r\n+    // PKCS#1 format\r\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\r\n+    // PVK format\r\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\r\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\r\n+    private static final String RC4_ALG = \"RC4\";\r\n+    private static final String RSA_ALG = \"RSA\";\r\n+\r\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\r\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\r\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\r\n+\r\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\r\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\r\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\r\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\r\n+        } else {\r\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\r\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\r\n+        key = key.replaceAll(\"\\\\s\", \"\");\r\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\r\n+\r\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\r\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\r\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        try {\r\n+            Security.addProvider(new BouncyCastleProvider());\r\n+        } catch (SecurityException se) {\r\n+            // fall through, provider already loaded\r", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAyNzY1Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398027653", "bodyText": "Hi @saurabh500, in my opinion this is the best way to handle loading this dependency. The empty catch is there in case the user has loaded BouncyCastle themselves, and this is more efficient and reliable then trying to determine whether they've loaded BC or not.", "author": "rene-ye", "createdAt": "2020-03-25T17:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk4NzUxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398987517", "bodyText": "SecurityException is thrown if a security manager exists and its method denies access to add a new provider. So there can be multiple reasons why this exception is thrown, not only when the provider exists.\nWhy is this approach better than just checking if provider is loaded using Security.getProvider(name)?", "author": "ulvii", "createdAt": "2020-03-27T01:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTM4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e36be2b40b0d14ca94689870b6995136511985ef", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 018814d2..7493ef06 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -131,7 +129,7 @@ final class SQLServerCertificateUtils {\n     private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n             String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n         try {\n-            Security.addProvider(new BouncyCastleProvider());\n+            SQLServerBouncyCastleLoader.loadBouncyCastle();\n         } catch (SecurityException se) {\n             // fall through, provider already loaded\n         }\n", "next_change": {"commit": "bae1e045e5ba01f8e13898f3c0a4cd9de21f42ba", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 7493ef06..c1623bb6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -49,226 +49,246 @@ import org.bouncycastle.openssl.PEMParser;\n import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\n \n-\n final class SQLServerCertificateUtils {\n \n-    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\n-            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n-        if (keyPath != null && keyPath.length() > 0) {\n-            return readPKCS8Certificate(certPath, keyPath, keyPassword);\n-        } else {\n-            return readPKCS12Certificate(certPath, keyPassword);\n-        }\n-    }\n-\n-    private static KeyManager[] readPKCS12Certificate(String certPath,\n-            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\n-        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\n-        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n-        keyManagerFactory.init(keystore, keyPassword.toCharArray());\n-        return keyManagerFactory.getKeyManagers();\n-    }\n-\n-    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\n-            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n-        Certificate clientCertificate = loadCertificate(certPath);\n-        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n-\n-        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n-        keyStore.load(null, null);\n-        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-                new Certificate[] {clientCertificate});\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-        kmf.init(keyStore, keyPassword.toCharArray());\n-        return kmf.getKeyManagers();\n-    }\n-\n-    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-        InputStream certstream = fileToStream(certificatePem);\n-        return certificateFactory.generateCertificate(certstream);\n-    }\n-\n-    // PKCS#8 format\n-    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-    // PKCS#1 format\n-    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-    // PVK format\n-    private static final long PVK_MAGIC = 0xB0B5F11EL;\n-    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n-    private static final String RC4_ALG = \"RC4\";\n-    private static final String RSA_ALG = \"RSA\";\n-\n-    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n-            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n-        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-            return loadPrivateKeyFromPKCS8(privateKeyPem);\n-        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-        } else {\n-            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-        }\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPKCS8(\n-            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\n-        key = key.replaceAll(\"\\\\s\", \"\");\n-        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\n-\n-        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n-            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        try {\n-            SQLServerBouncyCastleLoader.loadBouncyCastle();\n-        } catch (SecurityException se) {\n-            // fall through, provider already loaded\n-        }\n-        PEMParser pemParser = null;\n-        try {\n-            pemParser = new PEMParser(new StringReader(key));\n-            Object object = pemParser.readObject();\n-            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n-            KeyPair kp;\n-            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n-                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n-                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n-            } else {\n-                kp = converter.getKeyPair((PEMKeyPair) object);\n-            }\n-            return kp.getPrivate();\n-        } finally {\n-            pemParser.close();\n-        }\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\n-            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\n-        File f = new File(keyPath);\n-        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n-        try (FileInputStream in = new FileInputStream(f)) {\n-            in.getChannel().read(buffer);\n-            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n-\n-            long magic = buffer.getInt() & 0xFFFFFFFFL;\n-            if (PVK_MAGIC != magic) {\n-                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n-                        \"\", false);\n-            }\n-\n-            buffer.position(buffer.position() + 8); // skip reserved and keytype\n-            boolean encrypted = buffer.getInt() != 0;\n-            int saltLength = buffer.getInt();\n-            int keyLength = buffer.getInt();\n-            byte[] salt = new byte[saltLength];\n-            buffer.get(salt);\n-\n-            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n-\n-            byte[] key = new byte[keyLength - 8];\n-            buffer.get(key);\n-\n-            if (encrypted) {\n-                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n-                digest.update(salt);\n-                if (keyPass != null) {\n-                    digest.update(keyPass.getBytes());\n-                }\n-                byte[] hash = digest.digest();\n-                key = getSecretKeyFromHash(key, hash);\n-            }\n-\n-            ByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-            keyBuff.position(RSA2_MAGIC.length); // skip the header\n-\n-            int byteLength = keyBuff.getInt() / 8;\n-            BigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-            BigInteger modulus = getBigInteger(keyBuff, byteLength);\n-            BigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n-\n-            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n-                    prime2, primeExponent1, primeExponent2, crtCoefficient);\n-            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-            return factory.generatePrivate(spec);\n-        }\n-    }\n-\n-    private static boolean startsWithMagic(byte[] b) {\n-        for (int i = 0; i < 4; i++) {\n-            if (b[i] != RSA2_MAGIC[i])\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    private static byte[] getSecretKeyFromHash(byte[] originalKey,\n-            byte[] keyHash) throws GeneralSecurityException, SQLServerException {\n-        SecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-        byte[] decoded = decryptSecretKey(strongKey, originalKey);\n-        if (startsWithMagic(decoded)) {\n-            return decoded;\n-        }\n-\n-        // Couldn't find magic due to padding, trim the key\n-        Arrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n-        SecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-        decoded = decryptSecretKey(weakKey, originalKey);\n-        if (startsWithMagic(decoded)) {\n-            return decoded;\n-        }\n-\n-        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n-                false);\n-        return null;\n-    }\n-\n-    private static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n-        Cipher cipher = Cipher.getInstance(key.getAlgorithm());\n-        cipher.init(Cipher.DECRYPT_MODE, key);\n-        return cipher.doFinal(encoded);\n-    }\n-\n-    private static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n-        // Add an extra bit for signum\n-        byte[] array = new byte[length + 1];\n-        // Need to reverse the buffer because our buffer was set to Little Endian\n-        for (int i = 0; i < length; i++) {\n-            array[array.length - 1 - i] = buffer.get();\n-        }\n-        return new BigInteger(array);\n-    }\n-\n-    private static InputStream fileToStream(String fname) throws IOException {\n-        FileInputStream fis = null;\n-        DataInputStream dis = null;\n-        try {\n-            fis = new FileInputStream(fname);\n-            dis = new DataInputStream(fis);\n-            byte[] bytes = new byte[dis.available()];\n-            dis.readFully(bytes);\n-            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-            return bais;\n-        } finally {\n-            dis.close();\n-            fis.close();\n-        }\n-    }\n-\n-    private static String getStringFromFile(String filePath) throws IOException {\n-        return new String(Files.readAllBytes(Paths.get(filePath)));\n-    }\n+\tstatic KeyManager[] getKeyManagerFromFile(String certPath, String keyPath, String keyPassword)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tif (keyPath != null && keyPath.length() > 0) {\n+\t\t\treturn readPKCS8Certificate(certPath, keyPath, keyPassword);\n+\t\t} else {\n+\t\t\treturn readPKCS12Certificate(certPath, keyPassword);\n+\t\t}\n+\t}\n+\n+\t// PKCS#12 format\n+\tprivate static final String PKCS12_ALG = \"PKCS12\";\n+\t// PKCS#8 format\n+\tprivate static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n+\tprivate static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n+\t// PKCS#1 format\n+\tprivate static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n+\t// PVK format\n+\tprivate static final long PVK_MAGIC = 0xB0B5F11EL;\n+\tprivate static final byte[] RSA2_MAGIC = { 82, 83, 65, 50 };\n+\tprivate static final String RC4_ALG = \"RC4\";\n+\tprivate static final String RSA_ALG = \"RSA\";\n+\n+\tprivate static KeyManager[] readPKCS12Certificate(String certPath, String keyPassword)\n+\t\t\tthrows NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,\n+\t\t\tUnrecoverableKeyException, KeyStoreException {\n+\t\tKeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n+\t\tkeystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n+\t\tKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n+\t\tkeyManagerFactory.init(keystore, keyPassword.toCharArray());\n+\t\treturn keyManagerFactory.getKeyManagers();\n+\t}\n+\n+\tprivate static KeyManager[] readPKCS8Certificate(String certPath, String keyPath, String keyPassword)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tCertificate clientCertificate = loadCertificate(certPath);\n+\t\tPrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n+\n+\t\tKeyStore keyStore = KeyStore.getInstance(\"JKS\");\n+\t\tkeyStore.load(null, null);\n+\t\tkeyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n+\t\tkeyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n+\t\t\t\tnew Certificate[] { clientCertificate });\n+\n+\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+\t\tkmf.init(keyStore, keyPassword.toCharArray());\n+\t\treturn kmf.getKeyManagers();\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPKCS8(String key)\n+\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\t\tStringBuilder sb = new StringBuilder(key);\n+\t\tdeleteFirst(sb, PEM_PRIVATE_START);\n+\t\tdeleteFirst(sb, PEM_PRIVATE_END);\n+\t\treplaceAll(sb, \"\\\\s\", \"\");\n+\t\tbyte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n+\n+\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+\t\treturn factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n+\t}\n+\n+\tprivate static void deleteFirst(StringBuilder sb, String str) {\n+\t\tint i = sb.indexOf(str);\n+\t\tif (i != -1) {\n+\t\t\tsb.delete(i, i + str.length());\n+\t\t}\n+\t}\n+\n+\tprivate static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+\t\tint index = sb.indexOf(oldStr);\n+\t\twhile (index != -1) {\n+\t\t\tsb.replace(index, index + oldStr.length(), newStr);\n+\t\t\tindex += newStr.length();\n+\t\t\tindex = sb.indexOf(oldStr, index);\n+\t\t}\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPKCS1(String key, String keyPass)\n+\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\t\ttry {\n+\t\t\tSQLServerBouncyCastleLoader.loadBouncyCastle();\n+\t\t} catch (SecurityException se) {\n+\t\t\t// fall through, provider already loaded\n+\t\t}\n+\t\tPEMParser pemParser = null;\n+\t\ttry {\n+\t\t\tpemParser = new PEMParser(new StringReader(key));\n+\t\t\tObject object = pemParser.readObject();\n+\t\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n+\t\t\tKeyPair kp;\n+\t\t\tif (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n+\t\t\t\tPEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n+\t\t\t\tkp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n+\t\t\t} else {\n+\t\t\t\tkp = converter.getKeyPair((PEMKeyPair) object);\n+\t\t\t}\n+\t\t\treturn kp.getPrivate();\n+\t\t} finally {\n+\t\t\tpemParser.close();\n+\t\t}\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPVK(String keyPath, String keyPass)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tFile f = new File(keyPath);\n+\t\tByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n+\t\ttry (FileInputStream in = new FileInputStream(f)) {\n+\t\t\tin.getChannel().read(buffer);\n+\t\t\tbuffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n+\n+\t\t\tlong magic = buffer.getInt() & 0xFFFFFFFFL;\n+\t\t\tif (PVK_MAGIC != magic) {\n+\t\t\t\tSQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n+\t\t\t\t\t\t\"\", false);\n+\t\t\t}\n+\n+\t\t\tbuffer.position(buffer.position() + 8); // skip reserved and keytype\n+\t\t\tboolean encrypted = buffer.getInt() != 0;\n+\t\t\tint saltLength = buffer.getInt();\n+\t\t\tint keyLength = buffer.getInt();\n+\t\t\tbyte[] salt = new byte[saltLength];\n+\t\t\tbuffer.get(salt);\n+\n+\t\t\tbuffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n+\n+\t\t\tbyte[] key = new byte[keyLength - 8];\n+\t\t\tbuffer.get(key);\n+\n+\t\t\tif (encrypted) {\n+\t\t\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n+\t\t\t\tdigest.update(salt);\n+\t\t\t\tif (keyPass != null) {\n+\t\t\t\t\tdigest.update(keyPass.getBytes());\n+\t\t\t\t}\n+\t\t\t\tbyte[] hash = digest.digest();\n+\t\t\t\tkey = getSecretKeyFromHash(key, hash);\n+\t\t\t}\n+\n+\t\t\tByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+\t\t\tkeyBuff.position(RSA2_MAGIC.length); // skip the header\n+\n+\t\t\tint byteLength = keyBuff.getInt() / 8;\n+\t\t\tBigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n+\t\t\tBigInteger modulus = getBigInteger(keyBuff, byteLength);\n+\t\t\tBigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n+\n+\t\t\tRSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n+\t\t\t\t\tprime2, primeExponent1, primeExponent2, crtCoefficient);\n+\t\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+\t\t\treturn factory.generatePrivate(spec);\n+\t\t}\n+\t}\n+\n+\tprivate static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+\t\tCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n+\t\tInputStream certstream = fileToStream(certificatePem);\n+\t\treturn certificateFactory.generateCertificate(certstream);\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKey(String privateKeyPemPath, String privateKeyPassword)\n+\t\t\tthrows GeneralSecurityException, IOException, SQLServerException {\n+\t\tString privateKeyPem = getStringFromFile(privateKeyPemPath);\n+\n+\t\tif (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n+\t\t\treturn loadPrivateKeyFromPKCS8(privateKeyPem);\n+\t\t} else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n+\t\t\treturn loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n+\t\t} else {\n+\t\t\treturn loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n+\t\t}\n+\t}\n+\n+\tprivate static boolean startsWithMagic(byte[] b) {\n+\t\tfor (int i = 0; i < RSA2_MAGIC.length; i++) {\n+\t\t\tif (b[i] != RSA2_MAGIC[i])\n+\t\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static byte[] getSecretKeyFromHash(byte[] originalKey, byte[] keyHash)\n+\t\t\tthrows GeneralSecurityException, SQLServerException {\n+\t\tSecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+\t\tbyte[] decoded = decryptSecretKey(strongKey, originalKey);\n+\t\tif (startsWithMagic(decoded)) {\n+\t\t\treturn decoded;\n+\t\t}\n+\n+\t\t// Couldn't find magic due to padding, trim the key\n+\t\tArrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n+\t\tSecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+\t\tdecoded = decryptSecretKey(weakKey, originalKey);\n+\t\tif (startsWithMagic(decoded)) {\n+\t\t\treturn decoded;\n+\t\t}\n+\n+\t\tSQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n+\t\t\t\tfalse);\n+\t\treturn null;\n+\t}\n+\n+\tprivate static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n+\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n+\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n+\t\treturn cipher.doFinal(encoded);\n+\t}\n+\n+\tprivate static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n+\t\t// Add an extra bit for signum\n+\t\tbyte[] array = new byte[length + 1];\n+\t\t// Need to reverse the buffer because our buffer was set to Little Endian\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tarray[array.length - 1 - i] = buffer.get();\n+\t\t}\n+\t\treturn new BigInteger(array);\n+\t}\n+\n+\tprivate static InputStream fileToStream(String fname) throws IOException {\n+\t\tFileInputStream fis = null;\n+\t\tDataInputStream dis = null;\n+\t\ttry {\n+\t\t\tfis = new FileInputStream(fname);\n+\t\t\tdis = new DataInputStream(fis);\n+\t\t\tbyte[] bytes = new byte[dis.available()];\n+\t\t\tdis.readFully(bytes);\n+\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+\t\t\treturn bais;\n+\t\t} finally {\n+\t\t\tdis.close();\n+\t\t\tfis.close();\n+\t\t}\n+\t}\n+\n+\tprivate static String getStringFromFile(String filePath) throws IOException {\n+\t\treturn new String(Files.readAllBytes(Paths.get(filePath)));\n+\t}\n }\n", "next_change": {"commit": "bee991c2d4f6dc729c23fe62b50cb5cae59b72f9", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex c1623bb6..b4028250 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -49,246 +49,250 @@ import org.bouncycastle.openssl.PEMParser;\n import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\n \n+\n final class SQLServerCertificateUtils {\n \n-\tstatic KeyManager[] getKeyManagerFromFile(String certPath, String keyPath, String keyPassword)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tif (keyPath != null && keyPath.length() > 0) {\n-\t\t\treturn readPKCS8Certificate(certPath, keyPath, keyPassword);\n-\t\t} else {\n-\t\t\treturn readPKCS12Certificate(certPath, keyPassword);\n-\t\t}\n-\t}\n-\n-\t// PKCS#12 format\n-\tprivate static final String PKCS12_ALG = \"PKCS12\";\n-\t// PKCS#8 format\n-\tprivate static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-\tprivate static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-\t// PKCS#1 format\n-\tprivate static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-\t// PVK format\n-\tprivate static final long PVK_MAGIC = 0xB0B5F11EL;\n-\tprivate static final byte[] RSA2_MAGIC = { 82, 83, 65, 50 };\n-\tprivate static final String RC4_ALG = \"RC4\";\n-\tprivate static final String RSA_ALG = \"RSA\";\n-\n-\tprivate static KeyManager[] readPKCS12Certificate(String certPath, String keyPassword)\n-\t\t\tthrows NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,\n-\t\t\tUnrecoverableKeyException, KeyStoreException {\n-\t\tKeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n-\t\tkeystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n-\t\tKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n-\t\tkeyManagerFactory.init(keystore, keyPassword.toCharArray());\n-\t\treturn keyManagerFactory.getKeyManagers();\n-\t}\n-\n-\tprivate static KeyManager[] readPKCS8Certificate(String certPath, String keyPath, String keyPassword)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tCertificate clientCertificate = loadCertificate(certPath);\n-\t\tPrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n-\n-\t\tKeyStore keyStore = KeyStore.getInstance(\"JKS\");\n-\t\tkeyStore.load(null, null);\n-\t\tkeyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-\t\tkeyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-\t\t\t\tnew Certificate[] { clientCertificate });\n-\n-\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-\t\tkmf.init(keyStore, keyPassword.toCharArray());\n-\t\treturn kmf.getKeyManagers();\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPKCS8(String key)\n-\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-\t\tStringBuilder sb = new StringBuilder(key);\n-\t\tdeleteFirst(sb, PEM_PRIVATE_START);\n-\t\tdeleteFirst(sb, PEM_PRIVATE_END);\n-\t\treplaceAll(sb, \"\\\\s\", \"\");\n-\t\tbyte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n-\n-\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-\t\treturn factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n-\t}\n-\n-\tprivate static void deleteFirst(StringBuilder sb, String str) {\n-\t\tint i = sb.indexOf(str);\n-\t\tif (i != -1) {\n-\t\t\tsb.delete(i, i + str.length());\n-\t\t}\n-\t}\n-\n-\tprivate static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n-\t\tint index = sb.indexOf(oldStr);\n-\t\twhile (index != -1) {\n-\t\t\tsb.replace(index, index + oldStr.length(), newStr);\n-\t\t\tindex += newStr.length();\n-\t\t\tindex = sb.indexOf(oldStr, index);\n-\t\t}\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPKCS1(String key, String keyPass)\n-\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-\t\ttry {\n-\t\t\tSQLServerBouncyCastleLoader.loadBouncyCastle();\n-\t\t} catch (SecurityException se) {\n-\t\t\t// fall through, provider already loaded\n-\t\t}\n-\t\tPEMParser pemParser = null;\n-\t\ttry {\n-\t\t\tpemParser = new PEMParser(new StringReader(key));\n-\t\t\tObject object = pemParser.readObject();\n-\t\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n-\t\t\tKeyPair kp;\n-\t\t\tif (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n-\t\t\t\tPEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n-\t\t\t\tkp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n-\t\t\t} else {\n-\t\t\t\tkp = converter.getKeyPair((PEMKeyPair) object);\n-\t\t\t}\n-\t\t\treturn kp.getPrivate();\n-\t\t} finally {\n-\t\t\tpemParser.close();\n-\t\t}\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPVK(String keyPath, String keyPass)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tFile f = new File(keyPath);\n-\t\tByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n-\t\ttry (FileInputStream in = new FileInputStream(f)) {\n-\t\t\tin.getChannel().read(buffer);\n-\t\t\tbuffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n-\n-\t\t\tlong magic = buffer.getInt() & 0xFFFFFFFFL;\n-\t\t\tif (PVK_MAGIC != magic) {\n-\t\t\t\tSQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n-\t\t\t\t\t\t\"\", false);\n-\t\t\t}\n-\n-\t\t\tbuffer.position(buffer.position() + 8); // skip reserved and keytype\n-\t\t\tboolean encrypted = buffer.getInt() != 0;\n-\t\t\tint saltLength = buffer.getInt();\n-\t\t\tint keyLength = buffer.getInt();\n-\t\t\tbyte[] salt = new byte[saltLength];\n-\t\t\tbuffer.get(salt);\n-\n-\t\t\tbuffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n-\n-\t\t\tbyte[] key = new byte[keyLength - 8];\n-\t\t\tbuffer.get(key);\n-\n-\t\t\tif (encrypted) {\n-\t\t\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n-\t\t\t\tdigest.update(salt);\n-\t\t\t\tif (keyPass != null) {\n-\t\t\t\t\tdigest.update(keyPass.getBytes());\n-\t\t\t\t}\n-\t\t\t\tbyte[] hash = digest.digest();\n-\t\t\t\tkey = getSecretKeyFromHash(key, hash);\n-\t\t\t}\n-\n-\t\t\tByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-\t\t\tkeyBuff.position(RSA2_MAGIC.length); // skip the header\n-\n-\t\t\tint byteLength = keyBuff.getInt() / 8;\n-\t\t\tBigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-\t\t\tBigInteger modulus = getBigInteger(keyBuff, byteLength);\n-\t\t\tBigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n-\n-\t\t\tRSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n-\t\t\t\t\tprime2, primeExponent1, primeExponent2, crtCoefficient);\n-\t\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-\t\t\treturn factory.generatePrivate(spec);\n-\t\t}\n-\t}\n-\n-\tprivate static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-\t\tCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-\t\tInputStream certstream = fileToStream(certificatePem);\n-\t\treturn certificateFactory.generateCertificate(certstream);\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKey(String privateKeyPemPath, String privateKeyPassword)\n-\t\t\tthrows GeneralSecurityException, IOException, SQLServerException {\n-\t\tString privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-\t\tif (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-\t\t\treturn loadPrivateKeyFromPKCS8(privateKeyPem);\n-\t\t} else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-\t\t\treturn loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-\t\t} else {\n-\t\t\treturn loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-\t\t}\n-\t}\n-\n-\tprivate static boolean startsWithMagic(byte[] b) {\n-\t\tfor (int i = 0; i < RSA2_MAGIC.length; i++) {\n-\t\t\tif (b[i] != RSA2_MAGIC[i])\n-\t\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tprivate static byte[] getSecretKeyFromHash(byte[] originalKey, byte[] keyHash)\n-\t\t\tthrows GeneralSecurityException, SQLServerException {\n-\t\tSecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-\t\tbyte[] decoded = decryptSecretKey(strongKey, originalKey);\n-\t\tif (startsWithMagic(decoded)) {\n-\t\t\treturn decoded;\n-\t\t}\n-\n-\t\t// Couldn't find magic due to padding, trim the key\n-\t\tArrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n-\t\tSecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-\t\tdecoded = decryptSecretKey(weakKey, originalKey);\n-\t\tif (startsWithMagic(decoded)) {\n-\t\t\treturn decoded;\n-\t\t}\n-\n-\t\tSQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n-\t\t\t\tfalse);\n-\t\treturn null;\n-\t}\n-\n-\tprivate static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n-\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n-\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n-\t\treturn cipher.doFinal(encoded);\n-\t}\n-\n-\tprivate static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n-\t\t// Add an extra bit for signum\n-\t\tbyte[] array = new byte[length + 1];\n-\t\t// Need to reverse the buffer because our buffer was set to Little Endian\n-\t\tfor (int i = 0; i < length; i++) {\n-\t\t\tarray[array.length - 1 - i] = buffer.get();\n-\t\t}\n-\t\treturn new BigInteger(array);\n-\t}\n-\n-\tprivate static InputStream fileToStream(String fname) throws IOException {\n-\t\tFileInputStream fis = null;\n-\t\tDataInputStream dis = null;\n-\t\ttry {\n-\t\t\tfis = new FileInputStream(fname);\n-\t\t\tdis = new DataInputStream(fis);\n-\t\t\tbyte[] bytes = new byte[dis.available()];\n-\t\t\tdis.readFully(bytes);\n-\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-\t\t\treturn bais;\n-\t\t} finally {\n-\t\t\tdis.close();\n-\t\t\tfis.close();\n-\t\t}\n-\t}\n-\n-\tprivate static String getStringFromFile(String filePath) throws IOException {\n-\t\treturn new String(Files.readAllBytes(Paths.get(filePath)));\n-\t}\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n+        if (keyPath != null && keyPath.length() > 0) {\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\n+        } else {\n+            return readPKCS12Certificate(certPath, keyPassword);\n+        }\n+    }\n+\n+    // PKCS#12 format\n+    private static final String PKCS12_ALG = \"PKCS12\";\n+    private static final String SUN_X_509 = \"SunX509\";\n+    // PKCS#8 format\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n+    private static final String JAVA_KEY_STORE = \"JKS\";\n+    private static final String CLIENT_CERT = \"client-cert\";\n+    private static final String CLIENT_KEY = \"client-key\";\n+    // PKCS#1 format\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n+    // PVK format\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n+    private static final String RC4_ALG = \"RC4\";\n+    private static final String RSA_ALG = \"RSA\";\n+\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\n+        KeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(SUN_X_509);\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\n+        return keyManagerFactory.getKeyManagers();\n+    }\n+\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n+        Certificate clientCertificate = loadCertificate(certPath);\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n+\n+        KeyStore keyStore = KeyStore.getInstance(JAVA_KEY_STORE);\n+        keyStore.load(null, null);\n+        keyStore.setCertificateEntry(CLIENT_CERT, clientCertificate);\n+        keyStore.setKeyEntry(CLIENT_KEY, privateKey, keyPassword.toCharArray(), new Certificate[] {clientCertificate});\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+        kmf.init(keyStore, keyPassword.toCharArray());\n+        return kmf.getKeyManagers();\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        StringBuilder sb = new StringBuilder(key);\n+        deleteFirst(sb, PEM_PRIVATE_START);\n+        deleteFirst(sb, PEM_PRIVATE_END);\n+        replaceAll(sb, \"\\\\s\", \"\");\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n+\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n+    }\n+\n+    private static void deleteFirst(StringBuilder sb, String str) {\n+        int i = sb.indexOf(str);\n+        if (i != -1) {\n+            sb.delete(i, i + str.length());\n+        }\n+    }\n+\n+    private static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+        int index = sb.indexOf(oldStr);\n+        while (index != -1) {\n+            sb.replace(index, index + oldStr.length(), newStr);\n+            index += newStr.length();\n+            index = sb.indexOf(oldStr, index);\n+        }\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        PEMParser pemParser = null;\n+        try {\n+            pemParser = new PEMParser(new StringReader(key));\n+        } catch (Exception e) {\n+            SQLServerBouncyCastleLoader.loadBouncyCastle();\n+            pemParser = new PEMParser(new StringReader(key));\n+        }\n+\n+        try {\n+            Object object = pemParser.readObject();\n+            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n+            KeyPair kp;\n+            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n+                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n+                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n+            } else {\n+                kp = converter.getKeyPair((PEMKeyPair) object);\n+            }\n+            return kp.getPrivate();\n+        } finally {\n+            pemParser.close();\n+        }\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\n+            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\n+        File f = new File(keyPath);\n+        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n+        try (FileInputStream in = new FileInputStream(f)) {\n+            in.getChannel().read(buffer);\n+            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n+\n+            long magic = buffer.getInt() & 0xFFFFFFFFL;\n+            if (PVK_MAGIC != magic) {\n+                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n+                        \"\", false);\n+            }\n+\n+            buffer.position(buffer.position() + 8); // skip reserved and keytype\n+            boolean encrypted = buffer.getInt() != 0;\n+            int saltLength = buffer.getInt();\n+            int keyLength = buffer.getInt();\n+            byte[] salt = new byte[saltLength];\n+            buffer.get(salt);\n+\n+            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n+\n+            byte[] key = new byte[keyLength - 8];\n+            buffer.get(key);\n+\n+            if (encrypted) {\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n+                digest.update(salt);\n+                if (keyPass != null) {\n+                    digest.update(keyPass.getBytes());\n+                }\n+                byte[] hash = digest.digest();\n+                key = getSecretKeyFromHash(key, hash);\n+            }\n+\n+            ByteBuffer buff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+            buff.position(RSA2_MAGIC.length); // skip the header\n+\n+            int byteLength = buff.getInt() / 8;\n+            BigInteger publicExponent = BigInteger.valueOf(buff.getInt());\n+            BigInteger modulus = getBigInteger(buff, byteLength);\n+            BigInteger prime1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger prime2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger crtCoefficient = getBigInteger(buff, byteLength / 2);\n+            BigInteger privateExponent = getBigInteger(buff, byteLength);\n+\n+            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n+                    prime2, primeExponent1, primeExponent2, crtCoefficient);\n+            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+            return factory.generatePrivate(spec);\n+        }\n+    }\n+\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n+        InputStream certstream = fileToStream(certificatePem);\n+        return certificateFactory.generateCertificate(certstream);\n+    }\n+\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n+\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n+        } else {\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n+        }\n+    }\n+\n+    private static boolean startsWithMagic(byte[] b) {\n+        for (int i = 0; i < RSA2_MAGIC.length; i++) {\n+            if (b[i] != RSA2_MAGIC[i])\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    private static byte[] getSecretKeyFromHash(byte[] originalKey,\n+            byte[] keyHash) throws GeneralSecurityException, SQLServerException {\n+        SecretKey key = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+        byte[] decrypted = decryptSecretKey(key, originalKey);\n+        if (startsWithMagic(decrypted)) {\n+            return decrypted;\n+        }\n+\n+        // Couldn't find magic due to padding, trim the key\n+        Arrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n+        key = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+        decrypted = decryptSecretKey(key, originalKey);\n+        if (startsWithMagic(decrypted)) {\n+            return decrypted;\n+        }\n+\n+        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n+                false);\n+        return null;\n+    }\n+\n+    private static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n+        Cipher cipher = Cipher.getInstance(key.getAlgorithm());\n+        cipher.init(Cipher.DECRYPT_MODE, key);\n+        return cipher.doFinal(encoded);\n+    }\n+\n+    private static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n+        // Add an extra bit for signum\n+        byte[] array = new byte[length + 1];\n+        // Write in reverse because our buffer was set to Little Endian\n+        for (int i = 0; i < length; i++) {\n+            array[array.length - 1 - i] = buffer.get();\n+        }\n+        return new BigInteger(array);\n+    }\n+\n+    private static InputStream fileToStream(String fname) throws IOException {\n+        FileInputStream fis = null;\n+        DataInputStream dis = null;\n+        try {\n+            fis = new FileInputStream(fname);\n+            dis = new DataInputStream(fis);\n+            byte[] bytes = new byte[dis.available()];\n+            dis.readFully(bytes);\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            return bais;\n+        } finally {\n+            dis.close();\n+            fis.close();\n+        }\n+    }\n+\n+    private static String getStringFromFile(String filePath) throws IOException {\n+        return new String(Files.readAllBytes(Paths.get(filePath)));\n+    }\n }\n", "next_change": {"commit": "c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex b4028250..535b413e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -287,8 +289,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "898feca0c08f251d3d9d43789f16b506240e5a03", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 535b413e..4122ce2c 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -289,12 +278,8 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            if (null != dis) {\n-                dis.close();\n-            }\n-            if (null != fis) {\n-                fis.close();\n-            }\n+            dis.close();\n+            fis.close();\n         }\n     }\n \n", "next_change": {"commit": "ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 4122ce2c..d8778a28 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -278,8 +279,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "198b97d76a99f8353c01bf53e356797c520339b3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex d8778a28..d817f872 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -279,12 +277,8 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            if (null != dis) {\n-                dis.close();\n-            }\n-            if (null != fis) {\n-                fis.close();\n-            }\n+            dis.close();\n+            fis.close();\n         }\n     }\n \n", "next_change": {"commit": "13b27a4ec2358b73d1c7c79a01fca38a0f3f0e6b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex d817f872..d8778a28 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -277,8 +279,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTkzNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393291937", "body": "Magic number 4. can you create a constant out of it?", "bodyText": "Magic number 4. can you create a constant out of it?", "bodyHTML": "<p dir=\"auto\">Magic number 4. can you create a constant out of it?</p>", "author": "saurabh500", "createdAt": "2020-03-16T20:29:29Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.Security;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r\n+                new Certificate[] {clientCertificate});\r\n+\r\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n+        kmf.init(keyStore, keyPassword.toCharArray());\r\n+        return kmf.getKeyManagers();\r\n+    }\r\n+\r\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\r\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\r\n+        InputStream certstream = fileToStream(certificatePem);\r\n+        return certificateFactory.generateCertificate(certstream);\r\n+    }\r\n+\r\n+    // PKCS#8 format\r\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\r\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\r\n+    // PKCS#1 format\r\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\r\n+    // PVK format\r\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\r\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\r\n+    private static final String RC4_ALG = \"RC4\";\r\n+    private static final String RSA_ALG = \"RSA\";\r\n+\r\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\r\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\r\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\r\n+\r\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\r\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\r\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\r\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\r\n+        } else {\r\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\r\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\r\n+        key = key.replaceAll(\"\\\\s\", \"\");\r\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\r\n+\r\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\r\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\r\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        try {\r\n+            Security.addProvider(new BouncyCastleProvider());\r\n+        } catch (SecurityException se) {\r\n+            // fall through, provider already loaded\r\n+        }\r\n+        PEMParser pemParser = null;\r\n+        try {\r\n+            pemParser = new PEMParser(new StringReader(key));\r\n+            Object object = pemParser.readObject();\r\n+            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\r\n+            KeyPair kp;\r\n+            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\r\n+                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\r\n+                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\r\n+            } else {\r\n+                kp = converter.getKeyPair((PEMKeyPair) object);\r\n+            }\r\n+            return kp.getPrivate();\r\n+        } finally {\r\n+            pemParser.close();\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\r\n+            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        File f = new File(keyPath);\r\n+        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\r\n+        try (FileInputStream in = new FileInputStream(f)) {\r\n+            in.getChannel().read(buffer);\r\n+            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\r\n+\r\n+            long magic = buffer.getInt() & 0xFFFFFFFFL;\r\n+            if (PVK_MAGIC != magic) {\r\n+                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\r\n+                        \"\", false);\r\n+            }\r\n+\r\n+            buffer.position(buffer.position() + 8); // skip reserved and keytype\r\n+            boolean encrypted = buffer.getInt() != 0;\r\n+            int saltLength = buffer.getInt();\r\n+            int keyLength = buffer.getInt();\r\n+            byte[] salt = new byte[saltLength];\r\n+            buffer.get(salt);\r\n+\r\n+            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\r\n+\r\n+            byte[] key = new byte[keyLength - 8];\r\n+            buffer.get(key);\r\n+\r\n+            if (encrypted) {\r\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\r\n+                digest.update(salt);\r\n+                if (keyPass != null) {\r\n+                    digest.update(keyPass.getBytes());\r\n+                }\r\n+                byte[] hash = digest.digest();\r\n+                key = getSecretKeyFromHash(key, hash);\r\n+            }\r\n+\r\n+            ByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\r\n+            keyBuff.position(RSA2_MAGIC.length); // skip the header\r\n+\r\n+            int byteLength = keyBuff.getInt() / 8;\r\n+            BigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\r\n+            BigInteger modulus = getBigInteger(keyBuff, byteLength);\r\n+            BigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger privateExponent = getBigInteger(keyBuff, byteLength);\r\n+\r\n+            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\r\n+                    prime2, primeExponent1, primeExponent2, crtCoefficient);\r\n+            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\r\n+            return factory.generatePrivate(spec);\r\n+        }\r\n+    }\r\n+\r\n+    private static boolean startsWithMagic(byte[] b) {\r\n+        for (int i = 0; i < 4; i++) {\r", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bae1e045e5ba01f8e13898f3c0a4cd9de21f42ba", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 018814d2..c1623bb6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -51,226 +49,246 @@ import org.bouncycastle.openssl.PEMParser;\n import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\n \n-\n final class SQLServerCertificateUtils {\n \n-    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\n-            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n-        if (keyPath != null && keyPath.length() > 0) {\n-            return readPKCS8Certificate(certPath, keyPath, keyPassword);\n-        } else {\n-            return readPKCS12Certificate(certPath, keyPassword);\n-        }\n-    }\n-\n-    private static KeyManager[] readPKCS12Certificate(String certPath,\n-            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\n-        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\n-        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n-        keyManagerFactory.init(keystore, keyPassword.toCharArray());\n-        return keyManagerFactory.getKeyManagers();\n-    }\n-\n-    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\n-            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n-        Certificate clientCertificate = loadCertificate(certPath);\n-        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n-\n-        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n-        keyStore.load(null, null);\n-        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-                new Certificate[] {clientCertificate});\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-        kmf.init(keyStore, keyPassword.toCharArray());\n-        return kmf.getKeyManagers();\n-    }\n-\n-    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-        InputStream certstream = fileToStream(certificatePem);\n-        return certificateFactory.generateCertificate(certstream);\n-    }\n-\n-    // PKCS#8 format\n-    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-    // PKCS#1 format\n-    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-    // PVK format\n-    private static final long PVK_MAGIC = 0xB0B5F11EL;\n-    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n-    private static final String RC4_ALG = \"RC4\";\n-    private static final String RSA_ALG = \"RSA\";\n-\n-    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n-            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n-        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-            return loadPrivateKeyFromPKCS8(privateKeyPem);\n-        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-        } else {\n-            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-        }\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPKCS8(\n-            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\n-        key = key.replaceAll(\"\\\\s\", \"\");\n-        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\n-\n-        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n-            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        try {\n-            Security.addProvider(new BouncyCastleProvider());\n-        } catch (SecurityException se) {\n-            // fall through, provider already loaded\n-        }\n-        PEMParser pemParser = null;\n-        try {\n-            pemParser = new PEMParser(new StringReader(key));\n-            Object object = pemParser.readObject();\n-            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n-            KeyPair kp;\n-            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n-                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n-                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n-            } else {\n-                kp = converter.getKeyPair((PEMKeyPair) object);\n-            }\n-            return kp.getPrivate();\n-        } finally {\n-            pemParser.close();\n-        }\n-    }\n-\n-    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\n-            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\n-        File f = new File(keyPath);\n-        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n-        try (FileInputStream in = new FileInputStream(f)) {\n-            in.getChannel().read(buffer);\n-            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n-\n-            long magic = buffer.getInt() & 0xFFFFFFFFL;\n-            if (PVK_MAGIC != magic) {\n-                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n-                        \"\", false);\n-            }\n-\n-            buffer.position(buffer.position() + 8); // skip reserved and keytype\n-            boolean encrypted = buffer.getInt() != 0;\n-            int saltLength = buffer.getInt();\n-            int keyLength = buffer.getInt();\n-            byte[] salt = new byte[saltLength];\n-            buffer.get(salt);\n-\n-            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n-\n-            byte[] key = new byte[keyLength - 8];\n-            buffer.get(key);\n-\n-            if (encrypted) {\n-                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n-                digest.update(salt);\n-                if (keyPass != null) {\n-                    digest.update(keyPass.getBytes());\n-                }\n-                byte[] hash = digest.digest();\n-                key = getSecretKeyFromHash(key, hash);\n-            }\n-\n-            ByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-            keyBuff.position(RSA2_MAGIC.length); // skip the header\n-\n-            int byteLength = keyBuff.getInt() / 8;\n-            BigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-            BigInteger modulus = getBigInteger(keyBuff, byteLength);\n-            BigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n-\n-            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n-                    prime2, primeExponent1, primeExponent2, crtCoefficient);\n-            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-            return factory.generatePrivate(spec);\n-        }\n-    }\n-\n-    private static boolean startsWithMagic(byte[] b) {\n-        for (int i = 0; i < 4; i++) {\n-            if (b[i] != RSA2_MAGIC[i])\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    private static byte[] getSecretKeyFromHash(byte[] originalKey,\n-            byte[] keyHash) throws GeneralSecurityException, SQLServerException {\n-        SecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-        byte[] decoded = decryptSecretKey(strongKey, originalKey);\n-        if (startsWithMagic(decoded)) {\n-            return decoded;\n-        }\n-\n-        // Couldn't find magic due to padding, trim the key\n-        Arrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n-        SecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-        decoded = decryptSecretKey(weakKey, originalKey);\n-        if (startsWithMagic(decoded)) {\n-            return decoded;\n-        }\n-\n-        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n-                false);\n-        return null;\n-    }\n-\n-    private static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n-        Cipher cipher = Cipher.getInstance(key.getAlgorithm());\n-        cipher.init(Cipher.DECRYPT_MODE, key);\n-        return cipher.doFinal(encoded);\n-    }\n-\n-    private static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n-        // Add an extra bit for signum\n-        byte[] array = new byte[length + 1];\n-        // Need to reverse the buffer because our buffer was set to Little Endian\n-        for (int i = 0; i < length; i++) {\n-            array[array.length - 1 - i] = buffer.get();\n-        }\n-        return new BigInteger(array);\n-    }\n-\n-    private static InputStream fileToStream(String fname) throws IOException {\n-        FileInputStream fis = null;\n-        DataInputStream dis = null;\n-        try {\n-            fis = new FileInputStream(fname);\n-            dis = new DataInputStream(fis);\n-            byte[] bytes = new byte[dis.available()];\n-            dis.readFully(bytes);\n-            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-            return bais;\n-        } finally {\n-            dis.close();\n-            fis.close();\n-        }\n-    }\n-\n-    private static String getStringFromFile(String filePath) throws IOException {\n-        return new String(Files.readAllBytes(Paths.get(filePath)));\n-    }\n+\tstatic KeyManager[] getKeyManagerFromFile(String certPath, String keyPath, String keyPassword)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tif (keyPath != null && keyPath.length() > 0) {\n+\t\t\treturn readPKCS8Certificate(certPath, keyPath, keyPassword);\n+\t\t} else {\n+\t\t\treturn readPKCS12Certificate(certPath, keyPassword);\n+\t\t}\n+\t}\n+\n+\t// PKCS#12 format\n+\tprivate static final String PKCS12_ALG = \"PKCS12\";\n+\t// PKCS#8 format\n+\tprivate static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n+\tprivate static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n+\t// PKCS#1 format\n+\tprivate static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n+\t// PVK format\n+\tprivate static final long PVK_MAGIC = 0xB0B5F11EL;\n+\tprivate static final byte[] RSA2_MAGIC = { 82, 83, 65, 50 };\n+\tprivate static final String RC4_ALG = \"RC4\";\n+\tprivate static final String RSA_ALG = \"RSA\";\n+\n+\tprivate static KeyManager[] readPKCS12Certificate(String certPath, String keyPassword)\n+\t\t\tthrows NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,\n+\t\t\tUnrecoverableKeyException, KeyStoreException {\n+\t\tKeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n+\t\tkeystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n+\t\tKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n+\t\tkeyManagerFactory.init(keystore, keyPassword.toCharArray());\n+\t\treturn keyManagerFactory.getKeyManagers();\n+\t}\n+\n+\tprivate static KeyManager[] readPKCS8Certificate(String certPath, String keyPath, String keyPassword)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tCertificate clientCertificate = loadCertificate(certPath);\n+\t\tPrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n+\n+\t\tKeyStore keyStore = KeyStore.getInstance(\"JKS\");\n+\t\tkeyStore.load(null, null);\n+\t\tkeyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n+\t\tkeyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n+\t\t\t\tnew Certificate[] { clientCertificate });\n+\n+\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+\t\tkmf.init(keyStore, keyPassword.toCharArray());\n+\t\treturn kmf.getKeyManagers();\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPKCS8(String key)\n+\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\t\tStringBuilder sb = new StringBuilder(key);\n+\t\tdeleteFirst(sb, PEM_PRIVATE_START);\n+\t\tdeleteFirst(sb, PEM_PRIVATE_END);\n+\t\treplaceAll(sb, \"\\\\s\", \"\");\n+\t\tbyte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n+\n+\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+\t\treturn factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n+\t}\n+\n+\tprivate static void deleteFirst(StringBuilder sb, String str) {\n+\t\tint i = sb.indexOf(str);\n+\t\tif (i != -1) {\n+\t\t\tsb.delete(i, i + str.length());\n+\t\t}\n+\t}\n+\n+\tprivate static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+\t\tint index = sb.indexOf(oldStr);\n+\t\twhile (index != -1) {\n+\t\t\tsb.replace(index, index + oldStr.length(), newStr);\n+\t\t\tindex += newStr.length();\n+\t\t\tindex = sb.indexOf(oldStr, index);\n+\t\t}\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPKCS1(String key, String keyPass)\n+\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+\t\ttry {\n+\t\t\tSQLServerBouncyCastleLoader.loadBouncyCastle();\n+\t\t} catch (SecurityException se) {\n+\t\t\t// fall through, provider already loaded\n+\t\t}\n+\t\tPEMParser pemParser = null;\n+\t\ttry {\n+\t\t\tpemParser = new PEMParser(new StringReader(key));\n+\t\t\tObject object = pemParser.readObject();\n+\t\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n+\t\t\tKeyPair kp;\n+\t\t\tif (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n+\t\t\t\tPEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n+\t\t\t\tkp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n+\t\t\t} else {\n+\t\t\t\tkp = converter.getKeyPair((PEMKeyPair) object);\n+\t\t\t}\n+\t\t\treturn kp.getPrivate();\n+\t\t} finally {\n+\t\t\tpemParser.close();\n+\t\t}\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKeyFromPVK(String keyPath, String keyPass)\n+\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n+\t\tFile f = new File(keyPath);\n+\t\tByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n+\t\ttry (FileInputStream in = new FileInputStream(f)) {\n+\t\t\tin.getChannel().read(buffer);\n+\t\t\tbuffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n+\n+\t\t\tlong magic = buffer.getInt() & 0xFFFFFFFFL;\n+\t\t\tif (PVK_MAGIC != magic) {\n+\t\t\t\tSQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n+\t\t\t\t\t\t\"\", false);\n+\t\t\t}\n+\n+\t\t\tbuffer.position(buffer.position() + 8); // skip reserved and keytype\n+\t\t\tboolean encrypted = buffer.getInt() != 0;\n+\t\t\tint saltLength = buffer.getInt();\n+\t\t\tint keyLength = buffer.getInt();\n+\t\t\tbyte[] salt = new byte[saltLength];\n+\t\t\tbuffer.get(salt);\n+\n+\t\t\tbuffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n+\n+\t\t\tbyte[] key = new byte[keyLength - 8];\n+\t\t\tbuffer.get(key);\n+\n+\t\t\tif (encrypted) {\n+\t\t\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n+\t\t\t\tdigest.update(salt);\n+\t\t\t\tif (keyPass != null) {\n+\t\t\t\t\tdigest.update(keyPass.getBytes());\n+\t\t\t\t}\n+\t\t\t\tbyte[] hash = digest.digest();\n+\t\t\t\tkey = getSecretKeyFromHash(key, hash);\n+\t\t\t}\n+\n+\t\t\tByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+\t\t\tkeyBuff.position(RSA2_MAGIC.length); // skip the header\n+\n+\t\t\tint byteLength = keyBuff.getInt() / 8;\n+\t\t\tBigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n+\t\t\tBigInteger modulus = getBigInteger(keyBuff, byteLength);\n+\t\t\tBigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n+\t\t\tBigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n+\n+\t\t\tRSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n+\t\t\t\t\tprime2, primeExponent1, primeExponent2, crtCoefficient);\n+\t\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+\t\t\treturn factory.generatePrivate(spec);\n+\t\t}\n+\t}\n+\n+\tprivate static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+\t\tCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n+\t\tInputStream certstream = fileToStream(certificatePem);\n+\t\treturn certificateFactory.generateCertificate(certstream);\n+\t}\n+\n+\tprivate static PrivateKey loadPrivateKey(String privateKeyPemPath, String privateKeyPassword)\n+\t\t\tthrows GeneralSecurityException, IOException, SQLServerException {\n+\t\tString privateKeyPem = getStringFromFile(privateKeyPemPath);\n+\n+\t\tif (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n+\t\t\treturn loadPrivateKeyFromPKCS8(privateKeyPem);\n+\t\t} else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n+\t\t\treturn loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n+\t\t} else {\n+\t\t\treturn loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n+\t\t}\n+\t}\n+\n+\tprivate static boolean startsWithMagic(byte[] b) {\n+\t\tfor (int i = 0; i < RSA2_MAGIC.length; i++) {\n+\t\t\tif (b[i] != RSA2_MAGIC[i])\n+\t\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static byte[] getSecretKeyFromHash(byte[] originalKey, byte[] keyHash)\n+\t\t\tthrows GeneralSecurityException, SQLServerException {\n+\t\tSecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+\t\tbyte[] decoded = decryptSecretKey(strongKey, originalKey);\n+\t\tif (startsWithMagic(decoded)) {\n+\t\t\treturn decoded;\n+\t\t}\n+\n+\t\t// Couldn't find magic due to padding, trim the key\n+\t\tArrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n+\t\tSecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+\t\tdecoded = decryptSecretKey(weakKey, originalKey);\n+\t\tif (startsWithMagic(decoded)) {\n+\t\t\treturn decoded;\n+\t\t}\n+\n+\t\tSQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n+\t\t\t\tfalse);\n+\t\treturn null;\n+\t}\n+\n+\tprivate static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n+\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n+\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n+\t\treturn cipher.doFinal(encoded);\n+\t}\n+\n+\tprivate static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n+\t\t// Add an extra bit for signum\n+\t\tbyte[] array = new byte[length + 1];\n+\t\t// Need to reverse the buffer because our buffer was set to Little Endian\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\tarray[array.length - 1 - i] = buffer.get();\n+\t\t}\n+\t\treturn new BigInteger(array);\n+\t}\n+\n+\tprivate static InputStream fileToStream(String fname) throws IOException {\n+\t\tFileInputStream fis = null;\n+\t\tDataInputStream dis = null;\n+\t\ttry {\n+\t\t\tfis = new FileInputStream(fname);\n+\t\t\tdis = new DataInputStream(fis);\n+\t\t\tbyte[] bytes = new byte[dis.available()];\n+\t\t\tdis.readFully(bytes);\n+\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+\t\t\treturn bais;\n+\t\t} finally {\n+\t\t\tdis.close();\n+\t\t\tfis.close();\n+\t\t}\n+\t}\n+\n+\tprivate static String getStringFromFile(String filePath) throws IOException {\n+\t\treturn new String(Files.readAllBytes(Paths.get(filePath)));\n+\t}\n }\n", "next_change": {"commit": "bee991c2d4f6dc729c23fe62b50cb5cae59b72f9", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex c1623bb6..b4028250 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -49,246 +49,250 @@ import org.bouncycastle.openssl.PEMParser;\n import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\n \n+\n final class SQLServerCertificateUtils {\n \n-\tstatic KeyManager[] getKeyManagerFromFile(String certPath, String keyPath, String keyPassword)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tif (keyPath != null && keyPath.length() > 0) {\n-\t\t\treturn readPKCS8Certificate(certPath, keyPath, keyPassword);\n-\t\t} else {\n-\t\t\treturn readPKCS12Certificate(certPath, keyPassword);\n-\t\t}\n-\t}\n-\n-\t// PKCS#12 format\n-\tprivate static final String PKCS12_ALG = \"PKCS12\";\n-\t// PKCS#8 format\n-\tprivate static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-\tprivate static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-\t// PKCS#1 format\n-\tprivate static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-\t// PVK format\n-\tprivate static final long PVK_MAGIC = 0xB0B5F11EL;\n-\tprivate static final byte[] RSA2_MAGIC = { 82, 83, 65, 50 };\n-\tprivate static final String RC4_ALG = \"RC4\";\n-\tprivate static final String RSA_ALG = \"RSA\";\n-\n-\tprivate static KeyManager[] readPKCS12Certificate(String certPath, String keyPassword)\n-\t\t\tthrows NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,\n-\t\t\tUnrecoverableKeyException, KeyStoreException {\n-\t\tKeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n-\t\tkeystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n-\t\tKeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\n-\t\tkeyManagerFactory.init(keystore, keyPassword.toCharArray());\n-\t\treturn keyManagerFactory.getKeyManagers();\n-\t}\n-\n-\tprivate static KeyManager[] readPKCS8Certificate(String certPath, String keyPath, String keyPassword)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tCertificate clientCertificate = loadCertificate(certPath);\n-\t\tPrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n-\n-\t\tKeyStore keyStore = KeyStore.getInstance(\"JKS\");\n-\t\tkeyStore.load(null, null);\n-\t\tkeyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-\t\tkeyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-\t\t\t\tnew Certificate[] { clientCertificate });\n-\n-\t\tKeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-\t\tkmf.init(keyStore, keyPassword.toCharArray());\n-\t\treturn kmf.getKeyManagers();\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPKCS8(String key)\n-\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-\t\tStringBuilder sb = new StringBuilder(key);\n-\t\tdeleteFirst(sb, PEM_PRIVATE_START);\n-\t\tdeleteFirst(sb, PEM_PRIVATE_END);\n-\t\treplaceAll(sb, \"\\\\s\", \"\");\n-\t\tbyte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n-\n-\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-\t\treturn factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n-\t}\n-\n-\tprivate static void deleteFirst(StringBuilder sb, String str) {\n-\t\tint i = sb.indexOf(str);\n-\t\tif (i != -1) {\n-\t\t\tsb.delete(i, i + str.length());\n-\t\t}\n-\t}\n-\n-\tprivate static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n-\t\tint index = sb.indexOf(oldStr);\n-\t\twhile (index != -1) {\n-\t\t\tsb.replace(index, index + oldStr.length(), newStr);\n-\t\t\tindex += newStr.length();\n-\t\t\tindex = sb.indexOf(oldStr, index);\n-\t\t}\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPKCS1(String key, String keyPass)\n-\t\t\tthrows IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-\t\ttry {\n-\t\t\tSQLServerBouncyCastleLoader.loadBouncyCastle();\n-\t\t} catch (SecurityException se) {\n-\t\t\t// fall through, provider already loaded\n-\t\t}\n-\t\tPEMParser pemParser = null;\n-\t\ttry {\n-\t\t\tpemParser = new PEMParser(new StringReader(key));\n-\t\t\tObject object = pemParser.readObject();\n-\t\t\tJcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n-\t\t\tKeyPair kp;\n-\t\t\tif (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n-\t\t\t\tPEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n-\t\t\t\tkp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n-\t\t\t} else {\n-\t\t\t\tkp = converter.getKeyPair((PEMKeyPair) object);\n-\t\t\t}\n-\t\t\treturn kp.getPrivate();\n-\t\t} finally {\n-\t\t\tpemParser.close();\n-\t\t}\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKeyFromPVK(String keyPath, String keyPass)\n-\t\t\tthrows IOException, GeneralSecurityException, SQLServerException {\n-\t\tFile f = new File(keyPath);\n-\t\tByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n-\t\ttry (FileInputStream in = new FileInputStream(f)) {\n-\t\t\tin.getChannel().read(buffer);\n-\t\t\tbuffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n-\n-\t\t\tlong magic = buffer.getInt() & 0xFFFFFFFFL;\n-\t\t\tif (PVK_MAGIC != magic) {\n-\t\t\t\tSQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n-\t\t\t\t\t\t\"\", false);\n-\t\t\t}\n-\n-\t\t\tbuffer.position(buffer.position() + 8); // skip reserved and keytype\n-\t\t\tboolean encrypted = buffer.getInt() != 0;\n-\t\t\tint saltLength = buffer.getInt();\n-\t\t\tint keyLength = buffer.getInt();\n-\t\t\tbyte[] salt = new byte[saltLength];\n-\t\t\tbuffer.get(salt);\n-\n-\t\t\tbuffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n-\n-\t\t\tbyte[] key = new byte[keyLength - 8];\n-\t\t\tbuffer.get(key);\n-\n-\t\t\tif (encrypted) {\n-\t\t\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n-\t\t\t\tdigest.update(salt);\n-\t\t\t\tif (keyPass != null) {\n-\t\t\t\t\tdigest.update(keyPass.getBytes());\n-\t\t\t\t}\n-\t\t\t\tbyte[] hash = digest.digest();\n-\t\t\t\tkey = getSecretKeyFromHash(key, hash);\n-\t\t\t}\n-\n-\t\t\tByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-\t\t\tkeyBuff.position(RSA2_MAGIC.length); // skip the header\n-\n-\t\t\tint byteLength = keyBuff.getInt() / 8;\n-\t\t\tBigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-\t\t\tBigInteger modulus = getBigInteger(keyBuff, byteLength);\n-\t\t\tBigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-\t\t\tBigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n-\n-\t\t\tRSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n-\t\t\t\t\tprime2, primeExponent1, primeExponent2, crtCoefficient);\n-\t\t\tKeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n-\t\t\treturn factory.generatePrivate(spec);\n-\t\t}\n-\t}\n-\n-\tprivate static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-\t\tCertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-\t\tInputStream certstream = fileToStream(certificatePem);\n-\t\treturn certificateFactory.generateCertificate(certstream);\n-\t}\n-\n-\tprivate static PrivateKey loadPrivateKey(String privateKeyPemPath, String privateKeyPassword)\n-\t\t\tthrows GeneralSecurityException, IOException, SQLServerException {\n-\t\tString privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-\t\tif (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-\t\t\treturn loadPrivateKeyFromPKCS8(privateKeyPem);\n-\t\t} else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-\t\t\treturn loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-\t\t} else {\n-\t\t\treturn loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-\t\t}\n-\t}\n-\n-\tprivate static boolean startsWithMagic(byte[] b) {\n-\t\tfor (int i = 0; i < RSA2_MAGIC.length; i++) {\n-\t\t\tif (b[i] != RSA2_MAGIC[i])\n-\t\t\t\treturn false;\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\tprivate static byte[] getSecretKeyFromHash(byte[] originalKey, byte[] keyHash)\n-\t\t\tthrows GeneralSecurityException, SQLServerException {\n-\t\tSecretKey strongKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-\t\tbyte[] decoded = decryptSecretKey(strongKey, originalKey);\n-\t\tif (startsWithMagic(decoded)) {\n-\t\t\treturn decoded;\n-\t\t}\n-\n-\t\t// Couldn't find magic due to padding, trim the key\n-\t\tArrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n-\t\tSecretKey weakKey = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n-\t\tdecoded = decryptSecretKey(weakKey, originalKey);\n-\t\tif (startsWithMagic(decoded)) {\n-\t\t\treturn decoded;\n-\t\t}\n-\n-\t\tSQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n-\t\t\t\tfalse);\n-\t\treturn null;\n-\t}\n-\n-\tprivate static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n-\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n-\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n-\t\treturn cipher.doFinal(encoded);\n-\t}\n-\n-\tprivate static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n-\t\t// Add an extra bit for signum\n-\t\tbyte[] array = new byte[length + 1];\n-\t\t// Need to reverse the buffer because our buffer was set to Little Endian\n-\t\tfor (int i = 0; i < length; i++) {\n-\t\t\tarray[array.length - 1 - i] = buffer.get();\n-\t\t}\n-\t\treturn new BigInteger(array);\n-\t}\n-\n-\tprivate static InputStream fileToStream(String fname) throws IOException {\n-\t\tFileInputStream fis = null;\n-\t\tDataInputStream dis = null;\n-\t\ttry {\n-\t\t\tfis = new FileInputStream(fname);\n-\t\t\tdis = new DataInputStream(fis);\n-\t\t\tbyte[] bytes = new byte[dis.available()];\n-\t\t\tdis.readFully(bytes);\n-\t\t\tByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n-\t\t\treturn bais;\n-\t\t} finally {\n-\t\t\tdis.close();\n-\t\t\tfis.close();\n-\t\t}\n-\t}\n-\n-\tprivate static String getStringFromFile(String filePath) throws IOException {\n-\t\treturn new String(Files.readAllBytes(Paths.get(filePath)));\n-\t}\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n+        if (keyPath != null && keyPath.length() > 0) {\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\n+        } else {\n+            return readPKCS12Certificate(certPath, keyPassword);\n+        }\n+    }\n+\n+    // PKCS#12 format\n+    private static final String PKCS12_ALG = \"PKCS12\";\n+    private static final String SUN_X_509 = \"SunX509\";\n+    // PKCS#8 format\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n+    private static final String JAVA_KEY_STORE = \"JKS\";\n+    private static final String CLIENT_CERT = \"client-cert\";\n+    private static final String CLIENT_KEY = \"client-key\";\n+    // PKCS#1 format\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n+    // PVK format\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n+    private static final String RC4_ALG = \"RC4\";\n+    private static final String RSA_ALG = \"RSA\";\n+\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\n+        KeyStore keystore = KeyStore.getInstance(PKCS12_ALG);\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(SUN_X_509);\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\n+        return keyManagerFactory.getKeyManagers();\n+    }\n+\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\n+        Certificate clientCertificate = loadCertificate(certPath);\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n+\n+        KeyStore keyStore = KeyStore.getInstance(JAVA_KEY_STORE);\n+        keyStore.load(null, null);\n+        keyStore.setCertificateEntry(CLIENT_CERT, clientCertificate);\n+        keyStore.setKeyEntry(CLIENT_KEY, privateKey, keyPassword.toCharArray(), new Certificate[] {clientCertificate});\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+        kmf.init(keyStore, keyPassword.toCharArray());\n+        return kmf.getKeyManagers();\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        StringBuilder sb = new StringBuilder(key);\n+        deleteFirst(sb, PEM_PRIVATE_START);\n+        deleteFirst(sb, PEM_PRIVATE_END);\n+        replaceAll(sb, \"\\\\s\", \"\");\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n+\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n+    }\n+\n+    private static void deleteFirst(StringBuilder sb, String str) {\n+        int i = sb.indexOf(str);\n+        if (i != -1) {\n+            sb.delete(i, i + str.length());\n+        }\n+    }\n+\n+    private static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+        int index = sb.indexOf(oldStr);\n+        while (index != -1) {\n+            sb.replace(index, index + oldStr.length(), newStr);\n+            index += newStr.length();\n+            index = sb.indexOf(oldStr, index);\n+        }\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        PEMParser pemParser = null;\n+        try {\n+            pemParser = new PEMParser(new StringReader(key));\n+        } catch (Exception e) {\n+            SQLServerBouncyCastleLoader.loadBouncyCastle();\n+            pemParser = new PEMParser(new StringReader(key));\n+        }\n+\n+        try {\n+            Object object = pemParser.readObject();\n+            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n+            KeyPair kp;\n+            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\n+                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\n+                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\n+            } else {\n+                kp = converter.getKeyPair((PEMKeyPair) object);\n+            }\n+            return kp.getPrivate();\n+        } finally {\n+            pemParser.close();\n+        }\n+    }\n+\n+    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\n+            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\n+        File f = new File(keyPath);\n+        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\n+        try (FileInputStream in = new FileInputStream(f)) {\n+            in.getChannel().read(buffer);\n+            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\n+\n+            long magic = buffer.getInt() & 0xFFFFFFFFL;\n+            if (PVK_MAGIC != magic) {\n+                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\n+                        \"\", false);\n+            }\n+\n+            buffer.position(buffer.position() + 8); // skip reserved and keytype\n+            boolean encrypted = buffer.getInt() != 0;\n+            int saltLength = buffer.getInt();\n+            int keyLength = buffer.getInt();\n+            byte[] salt = new byte[saltLength];\n+            buffer.get(salt);\n+\n+            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\n+\n+            byte[] key = new byte[keyLength - 8];\n+            buffer.get(key);\n+\n+            if (encrypted) {\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n+                digest.update(salt);\n+                if (keyPass != null) {\n+                    digest.update(keyPass.getBytes());\n+                }\n+                byte[] hash = digest.digest();\n+                key = getSecretKeyFromHash(key, hash);\n+            }\n+\n+            ByteBuffer buff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+            buff.position(RSA2_MAGIC.length); // skip the header\n+\n+            int byteLength = buff.getInt() / 8;\n+            BigInteger publicExponent = BigInteger.valueOf(buff.getInt());\n+            BigInteger modulus = getBigInteger(buff, byteLength);\n+            BigInteger prime1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger prime2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger crtCoefficient = getBigInteger(buff, byteLength / 2);\n+            BigInteger privateExponent = getBigInteger(buff, byteLength);\n+\n+            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n+                    prime2, primeExponent1, primeExponent2, crtCoefficient);\n+            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n+            return factory.generatePrivate(spec);\n+        }\n+    }\n+\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n+        InputStream certstream = fileToStream(certificatePem);\n+        return certificateFactory.generateCertificate(certstream);\n+    }\n+\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n+\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n+        } else {\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n+        }\n+    }\n+\n+    private static boolean startsWithMagic(byte[] b) {\n+        for (int i = 0; i < RSA2_MAGIC.length; i++) {\n+            if (b[i] != RSA2_MAGIC[i])\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    private static byte[] getSecretKeyFromHash(byte[] originalKey,\n+            byte[] keyHash) throws GeneralSecurityException, SQLServerException {\n+        SecretKey key = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+        byte[] decrypted = decryptSecretKey(key, originalKey);\n+        if (startsWithMagic(decrypted)) {\n+            return decrypted;\n+        }\n+\n+        // Couldn't find magic due to padding, trim the key\n+        Arrays.fill(keyHash, 5, keyHash.length, (byte) 0);\n+        key = new SecretKeySpec(keyHash, 0, 16, RC4_ALG);\n+        decrypted = decryptSecretKey(key, originalKey);\n+        if (startsWithMagic(decrypted)) {\n+            return decrypted;\n+        }\n+\n+        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource(\"R_pvkParseError\"), \"\",\n+                false);\n+        return null;\n+    }\n+\n+    private static byte[] decryptSecretKey(SecretKey key, byte[] encoded) throws GeneralSecurityException {\n+        Cipher cipher = Cipher.getInstance(key.getAlgorithm());\n+        cipher.init(Cipher.DECRYPT_MODE, key);\n+        return cipher.doFinal(encoded);\n+    }\n+\n+    private static BigInteger getBigInteger(ByteBuffer buffer, int length) {\n+        // Add an extra bit for signum\n+        byte[] array = new byte[length + 1];\n+        // Write in reverse because our buffer was set to Little Endian\n+        for (int i = 0; i < length; i++) {\n+            array[array.length - 1 - i] = buffer.get();\n+        }\n+        return new BigInteger(array);\n+    }\n+\n+    private static InputStream fileToStream(String fname) throws IOException {\n+        FileInputStream fis = null;\n+        DataInputStream dis = null;\n+        try {\n+            fis = new FileInputStream(fname);\n+            dis = new DataInputStream(fis);\n+            byte[] bytes = new byte[dis.available()];\n+            dis.readFully(bytes);\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            return bais;\n+        } finally {\n+            dis.close();\n+            fis.close();\n+        }\n+    }\n+\n+    private static String getStringFromFile(String filePath) throws IOException {\n+        return new String(Files.readAllBytes(Paths.get(filePath)));\n+    }\n }\n", "next_change": {"commit": "c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex b4028250..535b413e 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -287,8 +289,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "898feca0c08f251d3d9d43789f16b506240e5a03", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 535b413e..4122ce2c 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -289,12 +278,8 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            if (null != dis) {\n-                dis.close();\n-            }\n-            if (null != fis) {\n-                fis.close();\n-            }\n+            dis.close();\n+            fis.close();\n         }\n     }\n \n", "next_change": {"commit": "ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 4122ce2c..d8778a28 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -278,8 +279,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": {"commit": "198b97d76a99f8353c01bf53e356797c520339b3", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex d8778a28..d817f872 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -279,12 +277,8 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            if (null != dis) {\n-                dis.close();\n-            }\n-            if (null != fis) {\n-                fis.close();\n-            }\n+            dis.close();\n+            fis.close();\n         }\n     }\n \n", "next_change": {"commit": "13b27a4ec2358b73d1c7c79a01fca38a0f3f0e6b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex d817f872..d8778a28 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -277,8 +279,12 @@ final class SQLServerCertificateUtils {\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             return bais;\n         } finally {\n-            dis.close();\n-            fis.close();\n+            if (null != dis) {\n+                dis.close();\n+            }\n+            if (null != fis) {\n+                fis.close();\n+            }\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"oid": "e36be2b40b0d14ca94689870b6995136511985ef", "url": "https://github.com/microsoft/mssql-jdbc/commit/e36be2b40b0d14ca94689870b6995136511985ef", "message": "statically load BC", "committedDate": "2020-03-16T20:39:13Z", "type": "commit"}, {"oid": "32ed914a84c1a51a049a472b09b42ef6cf3d2b14", "url": "https://github.com/microsoft/mssql-jdbc/commit/32ed914a84c1a51a049a472b09b42ef6cf3d2b14", "message": "update test", "committedDate": "2020-03-16T22:06:34Z", "type": "commit"}, {"oid": "fd353311e0994f478517e6ec811edb254a3bbd0e", "url": "https://github.com/microsoft/mssql-jdbc/commit/fd353311e0994f478517e6ec811edb254a3bbd0e", "message": "format", "committedDate": "2020-03-16T23:33:25Z", "type": "commit"}, {"oid": "ceca02beb53b3c5c8f9b7bb8d9ca152f1e060957", "url": "https://github.com/microsoft/mssql-jdbc/commit/ceca02beb53b3c5c8f9b7bb8d9ca152f1e060957", "message": "update test", "committedDate": "2020-03-17T19:59:13Z", "type": "commit"}, {"oid": "e4621c879bb6bea6ec9b3151e0579b45feb012ae", "url": "https://github.com/microsoft/mssql-jdbc/commit/e4621c879bb6bea6ec9b3151e0579b45feb012ae", "message": "add null check", "committedDate": "2020-03-18T17:58:49Z", "type": "commit"}, {"oid": "565c16d5063bb3140e5a6beb6980a76de03c4b79", "url": "https://github.com/microsoft/mssql-jdbc/commit/565c16d5063bb3140e5a6beb6980a76de03c4b79", "message": "logic change", "committedDate": "2020-03-18T20:53:27Z", "type": "commit"}, {"oid": "db3d040b41d3fe44a60a096076941919244a5dd0", "url": "https://github.com/microsoft/mssql-jdbc/commit/db3d040b41d3fe44a60a096076941919244a5dd0", "message": "test change", "committedDate": "2020-03-18T23:08:16Z", "type": "commit"}, {"oid": "e802213277d0e443fc327c946954a0e75a48e806", "url": "https://github.com/microsoft/mssql-jdbc/commit/e802213277d0e443fc327c946954a0e75a48e806", "message": "test update", "committedDate": "2020-03-20T15:33:09Z", "type": "commit"}, {"oid": "bae1e045e5ba01f8e13898f3c0a4cd9de21f42ba", "url": "https://github.com/microsoft/mssql-jdbc/commit/bae1e045e5ba01f8e13898f3c0a4cd9de21f42ba", "message": "Fix some issues", "committedDate": "2020-03-20T16:16:33Z", "type": "commit"}, {"oid": "bee991c2d4f6dc729c23fe62b50cb5cae59b72f9", "url": "https://github.com/microsoft/mssql-jdbc/commit/bee991c2d4f6dc729c23fe62b50cb5cae59b72f9", "message": "Add resources", "committedDate": "2020-03-20T16:34:46Z", "type": "commit"}, {"oid": "a791523ad7b63679dbdf3ca60bf6dd2df148fc77", "url": "https://github.com/microsoft/mssql-jdbc/commit/a791523ad7b63679dbdf3ca60bf6dd2df148fc77", "message": "Merge branch 'clientcertauth' of https://github.com/peterbae/mssql-jdbc into clientcertauth\n\n# Conflicts:\n#\tsrc/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "committedDate": "2020-03-20T16:44:29Z", "type": "commit"}, {"oid": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "url": "https://github.com/microsoft/mssql-jdbc/commit/887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "message": "Merge branch 'dev' of https://github.com/Microsoft/mssql-jdbc into clientcertauth", "committedDate": "2020-03-20T20:25:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MjM1OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397652358", "body": "are these tabs?", "bodyText": "are these tabs?", "bodyHTML": "<p dir=\"auto\">are these tabs?</p>", "author": "lilgreenbird", "createdAt": "2020-03-25T07:30:04Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1774,13 +1782,31 @@ else if (con.getTrustManagerClass() != null) {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n-            sslContext = SSLContext.getInstance(sslProtocol);\n-            sslContextProvider = sslContext.getProvider();\n+            if (null != clientCertificate) {\n+                try {\n+                    KeyManager[] km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n+                            clientKeyPassword);\n+                    \n+                    sslContext = SSLContext.getInstance(sslProtocol);\n+                    sslContextProvider = sslContext.getProvider();\n \n-            if (logger.isLoggable(Level.FINEST))\n-                logger.finest(toString() + \" Initializing SSL context\");\n+                    if (logger.isLoggable(Level.FINEST))\n+                        logger.finest(toString() + \" Initializing SSL context\");", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMDc1Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398000752", "bodyText": "Will fix.", "author": "peterbae", "createdAt": "2020-03-25T16:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MjM1OA=="}], "type": "inlineReview", "revised_code": {"commit": "a426136032358d95011cf8ebbf3783732c95cfb9", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 00171c5a..44a41dff 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1786,7 +1786,7 @@ final class TDSChannel implements Serializable {\n                 try {\n                     KeyManager[] km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n                             clientKeyPassword);\n-                    \n+\n                     sslContext = SSLContext.getInstance(sslProtocol);\n                     sslContextProvider = sslContext.getProvider();\n \n", "next_change": {"commit": "c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 44a41dff..5fe80247 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1794,7 +1794,7 @@ final class TDSChannel implements Serializable {\n                         logger.finest(toString() + \" Initializing SSL context\");\n \n                     sslContext.init(km, tm, null);\n-                } catch (NullPointerException | FileNotFoundException e) {\n+                } catch (FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n", "next_change": {"commit": "898feca0c08f251d3d9d43789f16b506240e5a03", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 5fe80247..44a41dff 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1794,7 +1794,7 @@ final class TDSChannel implements Serializable {\n                         logger.finest(toString() + \" Initializing SSL context\");\n \n                     sslContext.init(km, tm, null);\n-                } catch (FileNotFoundException e) {\n+                } catch (NullPointerException | FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n", "next_change": {"commit": "ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 44a41dff..5fe80247 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1794,7 +1794,7 @@ final class TDSChannel implements Serializable {\n                         logger.finest(toString() + \" Initializing SSL context\");\n \n                     sslContext.init(km, tm, null);\n-                } catch (NullPointerException | FileNotFoundException e) {\n+                } catch (FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n", "next_change": {"commit": "7482c8eaec3d09783646262216dceb77d0b6740b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 5fe80247..cf46e4af 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1782,31 +1782,24 @@ final class TDSChannel implements Serializable {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n+            KeyManager[] km = null;\n             if (null != clientCertificate) {\n                 try {\n-                    KeyManager[] km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n+                    km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n                             clientKeyPassword);\n-\n-                    sslContext = SSLContext.getInstance(sslProtocol);\n-                    sslContextProvider = sslContext.getProvider();\n-\n-                    if (logger.isLoggable(Level.FINEST))\n-                        logger.finest(toString() + \" Initializing SSL context\");\n-\n-                    sslContext.init(km, tm, null);\n                 } catch (FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n-            } else {\n-                sslContext = SSLContext.getInstance(sslProtocol);\n-                sslContextProvider = sslContext.getProvider();\n+            }\n+            \n+            sslContext = SSLContext.getInstance(sslProtocol);\n+            sslContextProvider = sslContext.getProvider();\n \n-                if (logger.isLoggable(Level.FINEST))\n-                    logger.finest(toString() + \" Initializing SSL context\");\n+            if (logger.isLoggable(Level.FINEST))\n+                logger.finest(toString() + \" Initializing SSL context\");\n \n-                sslContext.init(null, tm, null);\n-            }\n+            sslContext.init(km, tm, null);\n \n             // Got the SSL context. Now create an SSL socket over our own proxy socket\n             // which we can toggle between TDS-encapsulated and raw communications.\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MzM0Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397653342", "body": "should we have this? we don't usually have getters for passwords", "bodyText": "should we have this? we don't usually have getters for passwords", "bodyHTML": "<p dir=\"auto\">should we have this? we don't usually have getters for passwords</p>", "author": "lilgreenbird", "createdAt": "2020-03-25T07:32:46Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -903,5 +903,50 @@\n      *        Enclave attestation protocol.\n      */\n     void setEnclaveAttestationProtocol(String protocol);\n+    \n+    /**\n+     * Returns client certificate path for client certificate authentication.\n+     * \n+     * @return Client certificate path.\n+     */\n+    String getClientCertificate();\n+\n+    /**\n+     * Sets client certificate path for client certificate authentication.\n+     * \n+     * @param certPath\n+     *        Client certificate path.\n+     */\n+    void setClientCertificate(String certPath);\n+    \n+    /**\n+     * Returns Private key file path for client certificate authentication.\n+     * \n+     * @return Private key file path.\n+     */\n+    String getClientKey();\n+\n+    /**\n+     * Sets Private key file path for client certificate authentication.\n+     * \n+     * @param keyPath\n+     *        Private key file path.\n+     */\n+    void setClientKey(String keyPath);\n+    \n+    /**\n+     * Returns the password to be used for Private key provided by the user for client certificate authentication.\n+     * \n+     * @return Private key password.\n+     */\n+    String getClientKeyPassword();", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMDkyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398000926", "bodyText": "Good point, I'll remove this one.", "author": "peterbae", "createdAt": "2020-03-25T16:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MzM0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a426136032358d95011cf8ebbf3783732c95cfb9", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\nindex ee581fca..7690092a 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java\n", "chunk": "@@ -933,13 +933,6 @@ public interface ISQLServerDataSource extends javax.sql.CommonDataSource {\n      *        Private key file path.\n      */\n     void setClientKey(String keyPath);\n-    \n-    /**\n-     * Returns the password to be used for Private key provided by the user for client certificate authentication.\n-     * \n-     * @return Private key password.\n-     */\n-    String getClientKeyPassword();\n \n     /**\n      * Sets the password to be used for Private key provided by the user for client certificate authentication.\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1Njc4OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397656788", "body": "are these hardcoded aliases defined in the specs? can we define them somewhere else?", "bodyText": "are these hardcoded aliases defined in the specs? can we define them somewhere else?", "bodyHTML": "<p dir=\"auto\">are these hardcoded aliases defined in the specs? can we define them somewhere else?</p>", "author": "lilgreenbird", "createdAt": "2020-03-25T07:41:30Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f64828f3b3c985cd0fa46195704a91fe5795417d", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 7493ef06..ae4f74f5 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -75,64 +92,52 @@ final class SQLServerCertificateUtils {\n         Certificate clientCertificate = loadCertificate(certPath);\n         PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\n \n-        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\n+        KeyStore keyStore = KeyStore.getInstance(JAVA_KEY_STORE);\n         keyStore.load(null, null);\n-        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\n-        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\n-                new Certificate[] {clientCertificate});\n+        keyStore.setCertificateEntry(CLIENT_CERT, clientCertificate);\n+        keyStore.setKeyEntry(CLIENT_KEY, privateKey, keyPassword.toCharArray(), new Certificate[] {clientCertificate});\n \n         KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n         kmf.init(keyStore, keyPassword.toCharArray());\n         return kmf.getKeyManagers();\n     }\n \n-    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n-        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n-        InputStream certstream = fileToStream(certificatePem);\n-        return certificateFactory.generateCertificate(certstream);\n-    }\n-\n-    // PKCS#8 format\n-    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\n-    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\n-    // PKCS#1 format\n-    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\n-    // PVK format\n-    private static final long PVK_MAGIC = 0xB0B5F11EL;\n-    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\n-    private static final String RC4_ALG = \"RC4\";\n-    private static final String RSA_ALG = \"RSA\";\n-\n-    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\n-            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\n-        String privateKeyPem = getStringFromFile(privateKeyPemPath);\n-\n-        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\n-            return loadPrivateKeyFromPKCS8(privateKeyPem);\n-        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\n-            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\n-        } else {\n-            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\n-        }\n-    }\n-\n     private static PrivateKey loadPrivateKeyFromPKCS8(\n             String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\n-        key = key.replaceAll(\"\\\\s\", \"\");\n-        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\n+        StringBuilder sb = new StringBuilder(key);\n+        deleteFirst(sb, PEM_PRIVATE_START);\n+        deleteFirst(sb, PEM_PRIVATE_END);\n+        replaceAll(sb, \"\\\\s\", \"\");\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(sb.toString());\n \n         KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\n         return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\n     }\n \n+    private static void deleteFirst(StringBuilder sb, String str) {\n+        int i = sb.indexOf(str);\n+        if (i != -1) {\n+            sb.delete(i, i + str.length());\n+        }\n+    }\n+\n+    private static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n+        int index = sb.indexOf(oldStr);\n+        while (index != -1) {\n+            sb.replace(index, index + oldStr.length(), newStr);\n+            index += newStr.length();\n+            index = sb.indexOf(oldStr, index);\n+        }\n+    }\n+\n     private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n             String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n         try {\n             SQLServerBouncyCastleLoader.loadBouncyCastle();\n-        } catch (SecurityException se) {\n+        } catch (SecurityException e) {\n             // fall through, provider already loaded\n         }\n+\n         PEMParser pemParser = null;\n         try {\n             pemParser = new PEMParser(new StringReader(key));\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex ae4f74f5..51ec6c5d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -121,23 +120,9 @@ final class SQLServerCertificateUtils {\n         }\n     }\n \n-    private static void replaceAll(StringBuilder sb, String oldStr, String newStr) {\n-        int index = sb.indexOf(oldStr);\n-        while (index != -1) {\n-            sb.replace(index, index + oldStr.length(), newStr);\n-            index += newStr.length();\n-            index = sb.indexOf(oldStr, index);\n-        }\n-    }\n-\n     private static PrivateKey loadPrivateKeyFromPKCS1(String key,\n             String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n-        try {\n-            SQLServerBouncyCastleLoader.loadBouncyCastle();\n-        } catch (SecurityException e) {\n-            // fall through, provider already loaded\n-        }\n-\n+        SQLServerBouncyCastleLoader.loadBouncyCastle();\n         PEMParser pemParser = null;\n         try {\n             pemParser = new PEMParser(new StringReader(key));\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1ODYyOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397658629", "body": "null !=", "bodyText": "null !=", "bodyHTML": "<p dir=\"auto\">null !=</p>", "author": "lilgreenbird", "createdAt": "2020-03-25T07:46:08Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r\n+                new Certificate[] {clientCertificate});\r\n+\r\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n+        kmf.init(keyStore, keyPassword.toCharArray());\r\n+        return kmf.getKeyManagers();\r\n+    }\r\n+\r\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\r\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\r\n+        InputStream certstream = fileToStream(certificatePem);\r\n+        return certificateFactory.generateCertificate(certstream);\r\n+    }\r\n+\r\n+    // PKCS#8 format\r\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\r\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\r\n+    // PKCS#1 format\r\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\r\n+    // PVK format\r\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\r\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\r\n+    private static final String RC4_ALG = \"RC4\";\r\n+    private static final String RSA_ALG = \"RSA\";\r\n+\r\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\r\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\r\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\r\n+\r\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\r\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\r\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\r\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\r\n+        } else {\r\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\r\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\r\n+        key = key.replaceAll(\"\\\\s\", \"\");\r\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\r\n+\r\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\r\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\r\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        try {\r\n+            SQLServerBouncyCastleLoader.loadBouncyCastle();\r\n+        } catch (SecurityException se) {\r\n+            // fall through, provider already loaded\r\n+        }\r\n+        PEMParser pemParser = null;\r\n+        try {\r\n+            pemParser = new PEMParser(new StringReader(key));\r\n+            Object object = pemParser.readObject();\r\n+            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\r\n+            KeyPair kp;\r\n+            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\r\n+                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\r\n+                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\r\n+            } else {\r\n+                kp = converter.getKeyPair((PEMKeyPair) object);\r\n+            }\r\n+            return kp.getPrivate();\r\n+        } finally {\r\n+            pemParser.close();\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\r\n+            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        File f = new File(keyPath);\r\n+        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\r\n+        try (FileInputStream in = new FileInputStream(f)) {\r\n+            in.getChannel().read(buffer);\r\n+            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\r\n+\r\n+            long magic = buffer.getInt() & 0xFFFFFFFFL;\r\n+            if (PVK_MAGIC != magic) {\r\n+                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\r\n+                        \"\", false);\r\n+            }\r\n+\r\n+            buffer.position(buffer.position() + 8); // skip reserved and keytype\r\n+            boolean encrypted = buffer.getInt() != 0;\r\n+            int saltLength = buffer.getInt();\r\n+            int keyLength = buffer.getInt();\r\n+            byte[] salt = new byte[saltLength];\r\n+            buffer.get(salt);\r\n+\r\n+            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\r\n+\r\n+            byte[] key = new byte[keyLength - 8];\r\n+            buffer.get(key);\r\n+\r\n+            if (encrypted) {\r\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\r\n+                digest.update(salt);\r\n+                if (keyPass != null) {\r", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a426136032358d95011cf8ebbf3783732c95cfb9", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 7493ef06..51c9f0a0 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -180,25 +185,25 @@ final class SQLServerCertificateUtils {\n             if (encrypted) {\n                 MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                 digest.update(salt);\n-                if (keyPass != null) {\n+                if (null != keyPass) {\n                     digest.update(keyPass.getBytes());\n                 }\n                 byte[] hash = digest.digest();\n                 key = getSecretKeyFromHash(key, hash);\n             }\n \n-            ByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n-            keyBuff.position(RSA2_MAGIC.length); // skip the header\n+            ByteBuffer buff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\n+            buff.position(RSA2_MAGIC.length); // skip the header\n \n-            int byteLength = keyBuff.getInt() / 8;\n-            BigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\n-            BigInteger modulus = getBigInteger(keyBuff, byteLength);\n-            BigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\n-            BigInteger privateExponent = getBigInteger(keyBuff, byteLength);\n+            int byteLength = buff.getInt() / 8;\n+            BigInteger publicExponent = BigInteger.valueOf(buff.getInt());\n+            BigInteger modulus = getBigInteger(buff, byteLength);\n+            BigInteger prime1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger prime2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent1 = getBigInteger(buff, byteLength / 2);\n+            BigInteger primeExponent2 = getBigInteger(buff, byteLength / 2);\n+            BigInteger crtCoefficient = getBigInteger(buff, byteLength / 2);\n+            BigInteger privateExponent = getBigInteger(buff, byteLength);\n \n             RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\n                     prime2, primeExponent1, primeExponent2, crtCoefficient);\n", "next_change": {"commit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 51c9f0a0..6269c9a6 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -212,7 +208,7 @@ final class SQLServerCertificateUtils {\n         }\n     }\n \n-    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException, SQLServerException {\n         CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n         InputStream certstream = fileToStream(certificatePem);\n         return certificateFactory.generateCertificate(certstream);\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 6269c9a6..51ec6c5d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -208,7 +199,7 @@ final class SQLServerCertificateUtils {\n         }\n     }\n \n-    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException, SQLServerException {\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n         CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n         InputStream certstream = fileToStream(certificatePem);\n         return certificateFactory.generateCertificate(certstream);\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\nindex 51ec6c5d..45d68e88 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java\n", "chunk": "@@ -199,7 +203,7 @@ final class SQLServerCertificateUtils {\n         }\n     }\n \n-    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException, SQLServerException {\n         CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\n         InputStream certstream = fileToStream(certificatePem);\n         return certificateFactory.generateCertificate(certstream);\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1OTUyMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397659520", "body": "null == \r\nmultiple occurences", "bodyText": "null ==\nmultiple occurences", "bodyHTML": "<p dir=\"auto\">null ==<br>\nmultiple occurences</p>", "author": "lilgreenbird", "createdAt": "2020-03-25T07:48:14Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -4960,7 +4985,7 @@ final boolean complete(LogonCommand logonCommand, TDSReader tdsReader) throws SQ\n                 + 4; // AE is always on;\n \n         // only add lengths of password and username if not using SSPI or requesting federated authentication info\n-        if (!integratedSecurity && !(federatedAuthenticationInfoRequested || federatedAuthenticationRequested)) {\n+        if (!integratedSecurity && !(federatedAuthenticationInfoRequested || federatedAuthenticationRequested) && clientCertificate == null) {", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a426136032358d95011cf8ebbf3783732c95cfb9", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 0ba2c366..5bde5bb3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -4985,7 +4985,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                 + 4; // AE is always on;\n \n         // only add lengths of password and username if not using SSPI or requesting federated authentication info\n-        if (!integratedSecurity && !(federatedAuthenticationInfoRequested || federatedAuthenticationRequested) && clientCertificate == null) {\n+        if (!integratedSecurity && !(federatedAuthenticationInfoRequested || federatedAuthenticationRequested) && null == clientCertificate) {\n             len = len + passwordLen + userBytes.length;\n         }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MDkyMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397660920", "body": "no test for datasource getters and setters\r\nI think you also need to update AbstractTest.updateDataSource()", "bodyText": "no test for datasource getters and setters\nI think you also need to update AbstractTest.updateDataSource()", "bodyHTML": "<p dir=\"auto\">no test for datasource getters and setters<br>\nI think you also need to update AbstractTest.updateDataSource()</p>", "author": "lilgreenbird", "createdAt": "2020-03-25T07:51:36Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pkcs8Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs8.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs8EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxEncrytedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\r\n+                + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pvkTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\r\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCert() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\r\n+                + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCertPassword() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\r\n+                + \"clientKeyPassword=invalid_password;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\r\n+        }\r\n+    }\r\n+}\r", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAyNjczNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398026737", "bodyText": "Thanks. I added a test for data source.", "author": "peterbae", "createdAt": "2020-03-25T17:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MDkyMA=="}], "type": "inlineReview", "revised_code": {"commit": "a426136032358d95011cf8ebbf3783732c95cfb9", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 1cc293a5..8892d268 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -130,4 +131,19 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n+    \n+    @Test\n+    public void testDataSource() throws Exception {\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n+        SQLServerDataSource dsLocal = new SQLServerDataSource();\n+        AbstractTest.updateDataSource(conStr, dsLocal);\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        }\n+    }\n }\n", "next_change": {"commit": "898feca0c08f251d3d9d43789f16b506240e5a03", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 8892d268..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -146,4 +146,27 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n             assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n+\n+    \n+    @Test\n+    public void testEncryptTrusted() throws Exception {\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            rs.next();\n+            assertTrue(rs.getBoolean(1));\n+        }\n+    }\n+\n+    @Test\n+    public void testEncryptUntrusted() throws Exception {\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            rs.next();\n+            assertTrue(rs.getBoolean(1));\n+        }\n+    }\n }\n", "next_change": {"commit": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..fac0d6c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -147,24 +206,35 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "49ed48782f1538717321a73656dbfd475b08ed6e", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex fac0d6c9..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -231,7 +217,8 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n         String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt\n                     .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex acf746d0..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -37,191 +36,135 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n-    static final String PEM_SUFFIX = \".pem;\";\n-    static final String CER_SUFFIX = \".cer;\";\n-    static final String PVK_SUFFIX = \".pvk;\";\n-\n-    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n-    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n-    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n-    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n-    static final String PFX_KEY_SUFFIX = \".pfx;\";\n-    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n-                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n+                + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PVK private key.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n-                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n-            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate password provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature using a data source.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testDataSource() throws Exception {\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(connectionString, dsLocal);\n-        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n-        dsLocal.setClientKey(\n-                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n-        dsLocal.setClientKeyPassword(clientKeyPassword);\n-\n-        try (Connection conn = dsLocal.getConnection()) {\n-            assertTrue(conn.isValid(1));\n+        AbstractTest.updateDataSource(conStr, dsLocal);\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on, untrusted.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n-                + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,135 +37,191 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n-                + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n+                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PVK private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n-                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n+                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n+\n+        try (Connection conn = dsLocal.getConnection()) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MTg3MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397661871", "body": "? why are we only checking if it contains the string Microsoft?", "bodyText": "? why are we only checking if it contains the string Microsoft?", "bodyHTML": "<p dir=\"auto\">? why are we only checking if it contains the string Microsoft?</p>", "author": "lilgreenbird", "createdAt": "2020-03-25T07:53:48Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMzI1OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398003259", "bodyText": "Well...it can check any part of the string that @@Version will return. I just decided to use the keyword microsoft.", "author": "peterbae", "createdAt": "2020-03-25T16:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MTg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5MjUxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398992511", "bodyText": "I would suggest to use the existing conn.isValid(timeout); API.", "author": "ulvii", "createdAt": "2020-03-27T01:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MTg3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 1cc293a5..fac0d6c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -35,21 +36,42 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n             assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n", "next_change": {"commit": "51596474568003c5aa7754b7b76711f336505c3a", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex fac0d6c9..e77fdf24 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -73,9 +72,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n                 + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n", "next_change": {"commit": "5d223e039cc99f41f4e6abff9566a6db7e550535", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex e77fdf24..c40fc7c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -71,7 +71,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n     public void pkcs1EncryptedTest() throws Exception {\n         String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n                 + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n             assertTrue(conn.isValid(1));\n         }\n     }\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex c40fc7c9..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -37,189 +36,135 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n-    static final String PEM_SUFFIX = \".pem;\";\n-    static final String CER_SUFFIX = \".cer;\";\n-    static final String PVK_SUFFIX = \".pvk;\";\n-\n-    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n-    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n-    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n-    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n-    static final String PFX_KEY_SUFFIX = \".pfx;\";\n-    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n-                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n+                + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PVK private key.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n-                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n-            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate password provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature using a data source.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n-\n-        try (Connection conn = dsLocal.getConnection()) {\n-            assertTrue(conn.isValid(1));\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on, untrusted.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,135 +37,191 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n-                + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n+                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PVK private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n-                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n+                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n+\n+        try (Connection conn = dsLocal.getConnection()) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "f64828f3b3c985cd0fa46195704a91fe5795417d", "url": "https://github.com/microsoft/mssql-jdbc/commit/f64828f3b3c985cd0fa46195704a91fe5795417d", "message": "Merge pull request #14 from rene-ye/clientcertauth\n\nClientcertauth", "committedDate": "2020-03-25T16:46:04Z", "type": "commit"}, {"oid": "a426136032358d95011cf8ebbf3783732c95cfb9", "url": "https://github.com/microsoft/mssql-jdbc/commit/a426136032358d95011cf8ebbf3783732c95cfb9", "message": "test update", "committedDate": "2020-03-25T17:08:04Z", "type": "commit"}, {"oid": "6b42090b39b132a39df29e97d134f563afb8dd59", "url": "https://github.com/microsoft/mssql-jdbc/commit/6b42090b39b132a39df29e97d134f563afb8dd59", "message": "disable clientcertauth on CI", "committedDate": "2020-03-25T19:35:45Z", "type": "commit"}, {"oid": "de3f1755cbf15c9f18dc31a8214907438c906e4b", "url": "https://github.com/microsoft/mssql-jdbc/commit/de3f1755cbf15c9f18dc31a8214907438c906e4b", "message": "make it optional", "committedDate": "2020-03-25T21:31:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2MzcyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398263726", "body": "Catching NullPointerException ???", "bodyText": "Catching NullPointerException ???", "bodyHTML": "<p dir=\"auto\">Catching NullPointerException ???</p>", "author": "ulvii", "createdAt": "2020-03-26T01:18:30Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1774,13 +1782,31 @@ else if (con.getTrustManagerClass() != null) {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n-            sslContext = SSLContext.getInstance(sslProtocol);\n-            sslContextProvider = sslContext.getProvider();\n+            if (null != clientCertificate) {\n+                try {\n+                    KeyManager[] km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n+                            clientKeyPassword);\n \n-            if (logger.isLoggable(Level.FINEST))\n-                logger.finest(toString() + \" Initializing SSL context\");\n+                    sslContext = SSLContext.getInstance(sslProtocol);\n+                    sslContextProvider = sslContext.getProvider();\n+\n+                    if (logger.isLoggable(Level.FINEST))\n+                        logger.finest(toString() + \" Initializing SSL context\");\n+\n+                    sslContext.init(km, tm, null);\n+                } catch (NullPointerException | FileNotFoundException e) {", "originalCommit": "de3f1755cbf15c9f18dc31a8214907438c906e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODczODU5OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398738598", "bodyText": "We forgot to remove this exception, I've added null checks in the finally blocks inside the SQLServerCertificateUtils.java. We shouldn't need to catch NPE.", "author": "peterbae", "createdAt": "2020-03-26T17:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2MzcyNg=="}], "type": "inlineReview", "revised_code": {"commit": "c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 44a41dff..5fe80247 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1794,7 +1794,7 @@ final class TDSChannel implements Serializable {\n                         logger.finest(toString() + \" Initializing SSL context\");\n \n                     sslContext.init(km, tm, null);\n-                } catch (NullPointerException | FileNotFoundException e) {\n+                } catch (FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n", "next_change": {"commit": "898feca0c08f251d3d9d43789f16b506240e5a03", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 5fe80247..44a41dff 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1794,7 +1794,7 @@ final class TDSChannel implements Serializable {\n                         logger.finest(toString() + \" Initializing SSL context\");\n \n                     sslContext.init(km, tm, null);\n-                } catch (FileNotFoundException e) {\n+                } catch (NullPointerException | FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n", "next_change": {"commit": "ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 44a41dff..5fe80247 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1794,7 +1794,7 @@ final class TDSChannel implements Serializable {\n                         logger.finest(toString() + \" Initializing SSL context\");\n \n                     sslContext.init(km, tm, null);\n-                } catch (NullPointerException | FileNotFoundException e) {\n+                } catch (FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n", "next_change": {"commit": "7482c8eaec3d09783646262216dceb77d0b6740b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 5fe80247..cf46e4af 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1782,31 +1782,24 @@ final class TDSChannel implements Serializable {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n+            KeyManager[] km = null;\n             if (null != clientCertificate) {\n                 try {\n-                    KeyManager[] km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n+                    km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n                             clientKeyPassword);\n-\n-                    sslContext = SSLContext.getInstance(sslProtocol);\n-                    sslContextProvider = sslContext.getProvider();\n-\n-                    if (logger.isLoggable(Level.FINEST))\n-                        logger.finest(toString() + \" Initializing SSL context\");\n-\n-                    sslContext.init(km, tm, null);\n                 } catch (FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n-            } else {\n-                sslContext = SSLContext.getInstance(sslProtocol);\n-                sslContextProvider = sslContext.getProvider();\n+            }\n+            \n+            sslContext = SSLContext.getInstance(sslProtocol);\n+            sslContextProvider = sslContext.getProvider();\n \n-                if (logger.isLoggable(Level.FINEST))\n-                    logger.finest(toString() + \" Initializing SSL context\");\n+            if (logger.isLoggable(Level.FINEST))\n+                logger.finest(toString() + \" Initializing SSL context\");\n \n-                sslContext.init(null, tm, null);\n-            }\n+            sslContext.init(km, tm, null);\n \n             // Got the SSL context. Now create an SSL socket over our own proxy socket\n             // which we can toggle between TDS-encapsulated and raw communications.\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2NDg2Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398264863", "body": "The code in if/else are almost the same. You just need to initialize `km` to `null` and have `km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,clientKeyPassword);` inside if block.", "bodyText": "The code in if/else are almost the same. You just need to initialize km to null and have km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,clientKeyPassword); inside if block.", "bodyHTML": "<p dir=\"auto\">The code in if/else are almost the same. You just need to initialize <code>km</code> to <code>null</code> and have <code>km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,clientKeyPassword);</code> inside if block.</p>", "author": "ulvii", "createdAt": "2020-03-26T01:22:51Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1774,13 +1782,31 @@ else if (con.getTrustManagerClass() != null) {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n-            sslContext = SSLContext.getInstance(sslProtocol);\n-            sslContextProvider = sslContext.getProvider();\n+            if (null != clientCertificate) {", "originalCommit": "de3f1755cbf15c9f18dc31a8214907438c906e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1NTIzNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398755236", "bodyText": "thanks. done", "author": "peterbae", "createdAt": "2020-03-26T17:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2NDg2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7482c8eaec3d09783646262216dceb77d0b6740b", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 44a41dff..cf46e4af 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1782,31 +1782,24 @@ final class TDSChannel implements Serializable {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n+            KeyManager[] km = null;\n             if (null != clientCertificate) {\n                 try {\n-                    KeyManager[] km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n+                    km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n                             clientKeyPassword);\n-\n-                    sslContext = SSLContext.getInstance(sslProtocol);\n-                    sslContextProvider = sslContext.getProvider();\n-\n-                    if (logger.isLoggable(Level.FINEST))\n-                        logger.finest(toString() + \" Initializing SSL context\");\n-\n-                    sslContext.init(km, tm, null);\n-                } catch (NullPointerException | FileNotFoundException e) {\n+                } catch (FileNotFoundException e) {\n                     String strError = SQLServerException.getErrString(\"R_clientCertError\");\n                     throw new SQLServerException(strError, null, 0, null);\n                 }\n-            } else {\n-                sslContext = SSLContext.getInstance(sslProtocol);\n-                sslContextProvider = sslContext.getProvider();\n+            }\n+            \n+            sslContext = SSLContext.getInstance(sslProtocol);\n+            sslContextProvider = sslContext.getProvider();\n \n-                if (logger.isLoggable(Level.FINEST))\n-                    logger.finest(toString() + \" Initializing SSL context\");\n+            if (logger.isLoggable(Level.FINEST))\n+                logger.finest(toString() + \" Initializing SSL context\");\n \n-                sslContext.init(null, tm, null);\n-            }\n+            sslContext.init(km, tm, null);\n \n             // Got the SSL context. Now create an SSL socket over our own proxy socket\n             // which we can toggle between TDS-encapsulated and raw communications.\n", "next_change": null}]}}, {"oid": "c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "url": "https://github.com/microsoft/mssql-jdbc/commit/c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "message": "add null check", "committedDate": "2020-03-26T17:02:13Z", "type": "commit"}, {"oid": "898feca0c08f251d3d9d43789f16b506240e5a03", "url": "https://github.com/microsoft/mssql-jdbc/commit/898feca0c08f251d3d9d43789f16b506240e5a03", "message": "Fix pkcs8 and add tests", "committedDate": "2020-03-26T17:04:14Z", "type": "commit"}, {"oid": "85a8ad8bd83f301ff7521ad4ac128c30e4a4b4ee", "url": "https://github.com/microsoft/mssql-jdbc/commit/85a8ad8bd83f301ff7521ad4ac128c30e4a4b4ee", "message": "Remove uneeded import", "committedDate": "2020-03-26T17:06:13Z", "type": "commit"}, {"oid": "ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "url": "https://github.com/microsoft/mssql-jdbc/commit/ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "message": "Merge pull request #15 from rene-ye/clientcertauth\n\nFix pkcs8 and add tests", "committedDate": "2020-03-26T17:07:59Z", "type": "commit"}, {"oid": "7482c8eaec3d09783646262216dceb77d0b6740b", "url": "https://github.com/microsoft/mssql-jdbc/commit/7482c8eaec3d09783646262216dceb77d0b6740b", "message": "changes", "committedDate": "2020-03-26T17:26:06Z", "type": "commit"}, {"oid": "198b97d76a99f8353c01bf53e356797c520339b3", "url": "https://github.com/microsoft/mssql-jdbc/commit/198b97d76a99f8353c01bf53e356797c520339b3", "message": "Make some changes", "committedDate": "2020-03-26T17:31:18Z", "type": "commit"}, {"oid": "13b27a4ec2358b73d1c7c79a01fca38a0f3f0e6b", "url": "https://github.com/microsoft/mssql-jdbc/commit/13b27a4ec2358b73d1c7c79a01fca38a0f3f0e6b", "message": "Merge branch 'clientcertauth' of https://github.com/peterbae/mssql-jdbc into clientcertauth\n\n# Conflicts:\n#\tsrc/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "committedDate": "2020-03-26T17:34:34Z", "type": "commit"}, {"oid": "b7a6f9b8a349681e740a6e9f01207cf276a8d0b4", "url": "https://github.com/microsoft/mssql-jdbc/commit/b7a6f9b8a349681e740a6e9f01207cf276a8d0b4", "message": "Add file not found catching", "committedDate": "2020-03-26T17:37:39Z", "type": "commit"}, {"oid": "15ada35398836d584d706a620e9bc0d397f87630", "url": "https://github.com/microsoft/mssql-jdbc/commit/15ada35398836d584d706a620e9bc0d397f87630", "message": "Merge pull request #16 from rene-ye/clientcertauth\n\nClientcertauth", "committedDate": "2020-03-26T17:45:15Z", "type": "commit"}, {"oid": "a4868fecda835757ed2ac1c7affca641c02945f8", "url": "https://github.com/microsoft/mssql-jdbc/commit/a4868fecda835757ed2ac1c7affca641c02945f8", "message": "test changes", "committedDate": "2020-03-26T21:43:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NDQzNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398954434", "body": "This exception should be handled from the method that reads from the file, not here. ", "bodyText": "This exception should be handled from the method that reads from the file, not here.", "bodyHTML": "<p dir=\"auto\">This exception should be handled from the method that reads from the file, not here.</p>", "author": "ulvii", "createdAt": "2020-03-26T23:37:44Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1880,6 +1891,8 @@ else if (con.getTrustManagerClass() != null) {\n                     && (SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(errMsg)\n                             || SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(causeErrMsg))) {\n                 con.terminate(SQLServerException.DRIVER_ERROR_INTERMITTENT_TLS_FAILED, form.format(msgArgs), e);\n+            } else if (e instanceof FileNotFoundException) {", "originalCommit": "a4868fecda835757ed2ac1c7affca641c02945f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1ODI3Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398958277", "bodyText": "ok, I've reverted it to the way it was being handled before.", "author": "peterbae", "createdAt": "2020-03-26T23:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NDQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "30b989dd92aa1781da43a6a4cc0fb279c62905a1", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 17e397b7..4e02bf5d 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1891,8 +1899,6 @@ final class TDSChannel implements Serializable {\n                     && (SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(errMsg)\n                             || SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(causeErrMsg))) {\n                 con.terminate(SQLServerException.DRIVER_ERROR_INTERMITTENT_TLS_FAILED, form.format(msgArgs), e);\n-            } else if (e instanceof FileNotFoundException) {\n-                throw new SQLServerException(SQLServerException.getErrString(\"R_clientCertError\"), null, 0, null);\n             } else {\n                 con.terminate(SQLServerException.DRIVER_ERROR_SSL_FAILED, form.format(msgArgs), e);\n             }\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 4e02bf5d..17e397b7 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1899,6 +1891,8 @@ final class TDSChannel implements Serializable {\n                     && (SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(errMsg)\n                             || SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(causeErrMsg))) {\n                 con.terminate(SQLServerException.DRIVER_ERROR_INTERMITTENT_TLS_FAILED, form.format(msgArgs), e);\n+            } else if (e instanceof FileNotFoundException) {\n+                throw new SQLServerException(SQLServerException.getErrString(\"R_clientCertError\"), null, 0, null);\n             } else {\n                 con.terminate(SQLServerException.DRIVER_ERROR_SSL_FAILED, form.format(msgArgs), e);\n             }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\nindex 17e397b7..b046a3e0 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java\n", "chunk": "@@ -1891,8 +1892,6 @@ final class TDSChannel implements Serializable {\n                     && (SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(errMsg)\n                             || SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(causeErrMsg))) {\n                 con.terminate(SQLServerException.DRIVER_ERROR_INTERMITTENT_TLS_FAILED, form.format(msgArgs), e);\n-            } else if (e instanceof FileNotFoundException) {\n-                throw new SQLServerException(SQLServerException.getErrString(\"R_clientCertError\"), null, 0, null);\n             } else {\n                 con.terminate(SQLServerException.DRIVER_ERROR_SSL_FAILED, form.format(msgArgs), e);\n             }\n", "next_change": null}]}}]}}]}}, {"oid": "30b989dd92aa1781da43a6a4cc0fb279c62905a1", "url": "https://github.com/microsoft/mssql-jdbc/commit/30b989dd92aa1781da43a6a4cc0fb279c62905a1", "message": "revert", "committedDate": "2020-03-26T23:49:12Z", "type": "commit"}, {"oid": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "url": "https://github.com/microsoft/mssql-jdbc/commit/6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "message": "handle exception", "committedDate": "2020-03-27T00:22:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk3ODMzMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398978333", "body": "Is this absolute path? Can applications also provide relative path?", "bodyText": "Is this absolute path? Can applications also provide relative path?", "bodyHTML": "<p dir=\"auto\">Is this absolute path? Can applications also provide relative path?</p>", "author": "ulvii", "createdAt": "2020-03-27T01:00:34Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1597,9 +1598,16 @@ private void validateServerNameInCertificate(X509Certificate cert) throws Certif\n      *        Server Host Name for SSL Handshake\n      * @param port\n      *        Server Port for SSL Handshake\n+     * @param clientCertificate\n+     *        Client certificate path", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NzIwMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399377200", "bodyText": "It accepts both relative and absolute path.", "author": "peterbae", "createdAt": "2020-03-27T16:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk3ODMzMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NDgwNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398994806", "body": "You can use `R_clientCertError` from SQLServerResource.", "bodyText": "You can use R_clientCertError from SQLServerResource.", "bodyHTML": "<p dir=\"auto\">You can use <code>R_clientCertError</code> from SQLServerResource.</p>", "author": "ulvii", "createdAt": "2020-03-27T02:04:14Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pkcs8Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs8.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs8EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxEncrytedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\r\n+                + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pvkTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\r\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCert() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\r\n+                + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM5ODY3OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399398679", "bodyText": "SQLServerResource is not visible in this package, we can just use the TestResource for test related texts.", "author": "peterbae", "createdAt": "2020-03-27T16:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NDgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQwMTI3Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399401272", "bodyText": "See SQLServerConnectionTest.executeInvalidFmt() for example use.\nassertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_invalidArgument\")));", "author": "ulvii", "createdAt": "2020-03-27T16:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NDgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQxMTg0OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399411848", "bodyText": "Thanks. done.", "author": "peterbae", "createdAt": "2020-03-27T17:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NDgwNg=="}], "type": "inlineReview", "revised_code": {"commit": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..fac0d6c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -112,34 +158,47 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n+\n         try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n", "next_change": {"commit": "51596474568003c5aa7754b7b76711f336505c3a", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex fac0d6c9..e77fdf24 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -200,9 +187,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         AbstractTest.updateDataSource(conStr, dsLocal);\n \n         try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n", "next_change": {"commit": "5d223e039cc99f41f4e6abff9566a6db7e550535", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex e77fdf24..c40fc7c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -186,7 +186,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+        try (Connection conn = dsLocal.getConnection()) {\n             assertTrue(conn.isValid(1));\n         }\n     }\n", "next_change": {"commit": "49ed48782f1538717321a73656dbfd475b08ed6e", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex c40fc7c9..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -180,11 +180,12 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n      */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n \n         try (Connection conn = dsLocal.getConnection()) {\n             assertTrue(conn.isValid(1));\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex acf746d0..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -37,191 +36,135 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n-    static final String PEM_SUFFIX = \".pem;\";\n-    static final String CER_SUFFIX = \".cer;\";\n-    static final String PVK_SUFFIX = \".pvk;\";\n-\n-    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n-    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n-    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n-    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n-    static final String PFX_KEY_SUFFIX = \".pfx;\";\n-    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n-                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n+                + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PVK private key.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n-                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n-            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate password provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature using a data source.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testDataSource() throws Exception {\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(connectionString, dsLocal);\n-        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n-        dsLocal.setClientKey(\n-                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n-        dsLocal.setClientKeyPassword(clientKeyPassword);\n-\n-        try (Connection conn = dsLocal.getConnection()) {\n-            assertTrue(conn.isValid(1));\n+        AbstractTest.updateDataSource(conStr, dsLocal);\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on, untrusted.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n-                + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,135 +37,191 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n-                + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n+                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PVK private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n-                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n+                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n+\n+        try (Connection conn = dsLocal.getConnection()) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NTIyOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398995229", "body": "We should not be hardcoding the file names like this. Please use config properties file and specify full file names in it.", "bodyText": "We should not be hardcoding the file names like this. Please use config properties file and specify full file names in it.", "bodyHTML": "<p dir=\"auto\">We should not be hardcoding the file names like this. Please use config properties file and specify full file names in it.</p>", "author": "ulvii", "createdAt": "2020-03-27T02:06:00Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4OTk1Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399389952", "bodyText": "Why do we need to use a config file? The user can only provide one connection property for clientCertificate, and that one property needs to be re-used multiple times for different private key formats. The hardcoded strings here are the formats for the names that the test has defined. I can turn these hardcoded strings into constants, but I wouldn't use a config file here.", "author": "peterbae", "createdAt": "2020-03-27T16:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NTIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..fac0d6c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,21 +36,42 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n             assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n", "next_change": {"commit": "51596474568003c5aa7754b7b76711f336505c3a", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex fac0d6c9..e77fdf24 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -73,9 +72,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n                 + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n", "next_change": {"commit": "5d223e039cc99f41f4e6abff9566a6db7e550535", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex e77fdf24..c40fc7c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -71,7 +71,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n     public void pkcs1EncryptedTest() throws Exception {\n         String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n                 + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n             assertTrue(conn.isValid(1));\n         }\n     }\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex c40fc7c9..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -37,189 +36,135 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n-    static final String PEM_SUFFIX = \".pem;\";\n-    static final String CER_SUFFIX = \".cer;\";\n-    static final String PVK_SUFFIX = \".pvk;\";\n-\n-    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n-    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n-    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n-    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n-    static final String PFX_KEY_SUFFIX = \".pfx;\";\n-    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n-                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n+                + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PVK private key.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n-                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n-            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate password provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature using a data source.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n-\n-        try (Connection conn = dsLocal.getConnection()) {\n-            assertTrue(conn.isValid(1));\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on, untrusted.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,135 +37,191 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n-                + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n+                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PVK private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n-                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n+                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n+\n+        try (Connection conn = dsLocal.getConnection()) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzMzNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398997337", "body": "Why aren't you using new DataSource APIs? setClientCertificate(), setClientKey(), setClientKeyPassword", "bodyText": "Why aren't you using new DataSource APIs? setClientCertificate(), setClientKey(), setClientKeyPassword", "bodyHTML": "<p dir=\"auto\">Why aren't you using new DataSource APIs? setClientCertificate(), setClientKey(), setClientKeyPassword</p>", "author": "ulvii", "createdAt": "2020-03-27T02:14:32Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pkcs8Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs8.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs8EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxEncrytedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\r\n+                + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pvkTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\r\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCert() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\r\n+                + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCertPassword() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\r\n+                + \"clientKeyPassword=invalid_password;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void testDataSource() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ4NTgyOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399485829", "bodyText": "done", "author": "peterbae", "createdAt": "2020-03-27T19:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzMzNw=="}], "type": "inlineReview", "revised_code": {"commit": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..fac0d6c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -112,34 +158,47 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n+\n         try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n", "next_change": {"commit": "51596474568003c5aa7754b7b76711f336505c3a", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex fac0d6c9..e77fdf24 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -200,9 +187,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         AbstractTest.updateDataSource(conStr, dsLocal);\n \n         try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n", "next_change": {"commit": "5d223e039cc99f41f4e6abff9566a6db7e550535", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex e77fdf24..c40fc7c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -186,7 +186,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+        try (Connection conn = dsLocal.getConnection()) {\n             assertTrue(conn.isValid(1));\n         }\n     }\n", "next_change": {"commit": "49ed48782f1538717321a73656dbfd475b08ed6e", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex c40fc7c9..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -180,11 +180,12 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n      */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n \n         try (Connection conn = dsLocal.getConnection()) {\n             assertTrue(conn.isValid(1));\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex acf746d0..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -37,191 +36,135 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n-    static final String PEM_SUFFIX = \".pem;\";\n-    static final String CER_SUFFIX = \".cer;\";\n-    static final String PVK_SUFFIX = \".pvk;\";\n-\n-    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n-    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n-    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n-    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n-    static final String PFX_KEY_SUFFIX = \".pfx;\";\n-    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n-                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n+                + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PVK private key.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n-                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n-            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate password provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature using a data source.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testDataSource() throws Exception {\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(connectionString, dsLocal);\n-        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n-        dsLocal.setClientKey(\n-                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n-        dsLocal.setClientKeyPassword(clientKeyPassword);\n-\n-        try (Connection conn = dsLocal.getConnection()) {\n-            assertTrue(conn.isValid(1));\n+        AbstractTest.updateDataSource(conStr, dsLocal);\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on, untrusted.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n-                + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,135 +37,191 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n-                + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n+                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PVK private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n-                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n+                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n+\n+        try (Connection conn = dsLocal.getConnection()) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzY0OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398997648", "body": "Use `R_pvkParseError` from SQLServerResource instead.", "bodyText": "Use R_pvkParseError from SQLServerResource instead.", "bodyHTML": "<p dir=\"auto\">Use <code>R_pvkParseError</code> from SQLServerResource instead.</p>", "author": "ulvii", "createdAt": "2020-03-27T02:15:51Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pkcs8Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs8.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs8EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxEncrytedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\r\n+                + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pvkTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\r\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCert() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\r\n+                + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCertPassword() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\r\n+                + \"clientKeyPassword=invalid_password;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMzQwMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399503400", "bodyText": "Why is this resolved?", "author": "ulvii", "createdAt": "2020-03-27T19:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwNDEzNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399504136", "bodyText": "For this error message, the error message isn't coming from the driver, it's coming from Java. So there's no SQLServerResource text to refer here.", "author": "peterbae", "createdAt": "2020-03-27T19:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzY0OA=="}], "type": "inlineReview", "revised_code": {"commit": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..fac0d6c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -112,34 +158,47 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n+\n         try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n", "next_change": {"commit": "51596474568003c5aa7754b7b76711f336505c3a", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex fac0d6c9..e77fdf24 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -200,9 +187,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         AbstractTest.updateDataSource(conStr, dsLocal);\n \n         try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n", "next_change": {"commit": "5d223e039cc99f41f4e6abff9566a6db7e550535", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex e77fdf24..c40fc7c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -186,7 +186,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+        try (Connection conn = dsLocal.getConnection()) {\n             assertTrue(conn.isValid(1));\n         }\n     }\n", "next_change": {"commit": "49ed48782f1538717321a73656dbfd475b08ed6e", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex c40fc7c9..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -180,11 +180,12 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n      */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-\n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n \n         try (Connection conn = dsLocal.getConnection()) {\n             assertTrue(conn.isValid(1));\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex acf746d0..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -37,191 +36,135 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n-    static final String PEM_SUFFIX = \".pem;\";\n-    static final String CER_SUFFIX = \".cer;\";\n-    static final String PVK_SUFFIX = \".pvk;\";\n-\n-    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n-    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n-    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n-    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n-    static final String PFX_KEY_SUFFIX = \".pfx;\";\n-    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n-                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n+                + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PVK private key.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n-                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n-            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate password provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature using a data source.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testDataSource() throws Exception {\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(connectionString, dsLocal);\n-        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n-        dsLocal.setClientKey(\n-                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n-        dsLocal.setClientKeyPassword(clientKeyPassword);\n-\n-        try (Connection conn = dsLocal.getConnection()) {\n-            assertTrue(conn.isValid(1));\n+        AbstractTest.updateDataSource(conStr, dsLocal);\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on, untrusted.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n-                + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,135 +37,191 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n-                + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n+                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PVK private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n-                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n+                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n+\n+        try (Connection conn = dsLocal.getConnection()) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MTMyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399051326", "body": "define this constant", "bodyText": "define this constant", "bodyHTML": "<p dir=\"auto\">define this constant</p>", "author": "lilgreenbird", "createdAt": "2020-03-27T06:02:37Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -2629,7 +2654,7 @@ void Prelogin(String serverName, int portNumber) throws SQLServerException {\n                 0, 0, 0, 0, 0, 0,\n \n                 // - Encryption -\n-                requestedEncryptionLevel,\n+                (null == clientCertificate) ? requestedEncryptionLevel : (byte) (requestedEncryptionLevel | (byte) 0x80),", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MDU2Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399380566", "bodyText": "done", "author": "peterbae", "createdAt": "2020-03-27T16:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MTMyNg=="}], "type": "inlineReview", "revised_code": {"commit": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 5bde5bb3..13f6e913 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -2654,7 +2654,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                 0, 0, 0, 0, 0, 0,\n \n                 // - Encryption -\n-                (null == clientCertificate) ? requestedEncryptionLevel : (byte) (requestedEncryptionLevel | (byte) 0x80),\n+                (null == clientCertificate) ? requestedEncryptionLevel : (byte) (requestedEncryptionLevel | TDS.ENCRYPT_CLIENT_CERT),\n \n                 // TRACEID Data Session (ClientConnectionId + ActivityId) - Initialize to 0\n                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 13f6e913..5bde5bb3 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -2654,7 +2654,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                 0, 0, 0, 0, 0, 0,\n \n                 // - Encryption -\n-                (null == clientCertificate) ? requestedEncryptionLevel : (byte) (requestedEncryptionLevel | TDS.ENCRYPT_CLIENT_CERT),\n+                (null == clientCertificate) ? requestedEncryptionLevel : (byte) (requestedEncryptionLevel | (byte) 0x80),\n \n                 // TRACEID Data Session (ClientConnectionId + ActivityId) - Initialize to 0\n                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\nindex 5bde5bb3..13f6e913 100644\n--- a/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n+++ b/src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java\n", "chunk": "@@ -2654,7 +2654,7 @@ public class SQLServerConnection implements ISQLServerConnection, java.io.Serial\n                 0, 0, 0, 0, 0, 0,\n \n                 // - Encryption -\n-                (null == clientCertificate) ? requestedEncryptionLevel : (byte) (requestedEncryptionLevel | (byte) 0x80),\n+                (null == clientCertificate) ? requestedEncryptionLevel : (byte) (requestedEncryptionLevel | TDS.ENCRYPT_CLIENT_CERT),\n \n                 // TRACEID Data Session (ClientConnectionId + ActivityId) - Initialize to 0\n                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MzEwMg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399053102", "body": "add description of what the tests are testing", "bodyText": "add description of what the tests are testing", "bodyHTML": "<p dir=\"auto\">add description of what the tests are testing</p>", "author": "lilgreenbird", "createdAt": "2020-03-27T06:09:40Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4NDAxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399384016", "bodyText": "done", "author": "peterbae", "createdAt": "2020-03-27T16:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MzEwMg=="}], "type": "inlineReview", "revised_code": {"commit": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..fac0d6c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,21 +36,42 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n             assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n             ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n             rs.next();\n", "next_change": {"commit": "51596474568003c5aa7754b7b76711f336505c3a", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex fac0d6c9..e77fdf24 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -73,9 +72,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n         String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n                 + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n", "next_change": {"commit": "5d223e039cc99f41f4e6abff9566a6db7e550535", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex e77fdf24..c40fc7c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -71,7 +71,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n     public void pkcs1EncryptedTest() throws Exception {\n         String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n                 + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n             assertTrue(conn.isValid(1));\n         }\n     }\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex c40fc7c9..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -37,189 +36,135 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n-    static final String PEM_SUFFIX = \".pem;\";\n-    static final String CER_SUFFIX = \".cer;\";\n-    static final String PVK_SUFFIX = \".pvk;\";\n-\n-    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n-    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n-    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n-    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n-    static final String PFX_KEY_SUFFIX = \".pfx;\";\n-    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n-                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n+                + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PVK private key.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n-                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n-            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate password provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature using a data source.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n-\n-        try (Connection conn = dsLocal.getConnection()) {\n-            assertTrue(conn.isValid(1));\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on, untrusted.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,135 +37,191 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n-                + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n+                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PVK private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n-                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n+                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n+\n+        try (Connection conn = dsLocal.getConnection()) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "url": "https://github.com/microsoft/mssql-jdbc/commit/b6d6b19d06e0001146924bdbfe135126b73c1a5f", "message": "comments", "committedDate": "2020-03-27T16:36:31Z", "type": "commit"}, {"oid": "51596474568003c5aa7754b7b76711f336505c3a", "url": "https://github.com/microsoft/mssql-jdbc/commit/51596474568003c5aa7754b7b76711f336505c3a", "message": "comments", "committedDate": "2020-03-27T17:02:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2ODYxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399468616", "body": "No need to create a statement", "bodyText": "No need to create a statement", "bodyHTML": "<p dir=\"auto\">No need to create a statement</p>", "author": "ulvii", "createdAt": "2020-03-27T18:40:37Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    static final String PEM_SUFFIX = \".pem;\";\r\n+    static final String CER_SUFFIX = \".cer;\";\r\n+    static final String PVK_SUFFIX = \".pvk;\";\r\n+\r\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\r\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\r\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\r\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\r\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\r\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\r\n+\r\n+    /**\r\n+     * Tests client certificate authentication feature with PKCS1 private key.\r\n+     * \r\n+     * @throws Exception\r\n+     */\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\r\n+                + clientKey + PKCS1_KEY_SUFFIX;\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            assertTrue(conn.isValid(1));\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\r\n+     * \r\n+     * @throws Exception\r\n+     */\r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\r\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r", "originalCommit": "51596474568003c5aa7754b7b76711f336505c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3Nzk1Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399477956", "bodyText": "Thanks, done.", "author": "peterbae", "createdAt": "2020-03-27T18:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2ODYxNg=="}], "type": "inlineReview", "revised_code": {"commit": "5d223e039cc99f41f4e6abff9566a6db7e550535", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex e77fdf24..c40fc7c9 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -71,7 +71,7 @@ public class ClientCertificateAuthenticationTest extends AbstractTest {\n     public void pkcs1EncryptedTest() throws Exception {\n         String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n                 + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n             assertTrue(conn.isValid(1));\n         }\n     }\n", "next_change": {"commit": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex c40fc7c9..079d42bd 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -37,189 +36,135 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n-    static final String PEM_SUFFIX = \".pem;\";\n-    static final String CER_SUFFIX = \".cer;\";\n-    static final String PVK_SUFFIX = \".pvk;\";\n-\n-    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n-    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n-    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n-    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n-    static final String PFX_KEY_SUFFIX = \".pfx;\";\n-    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n-                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n+                + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature with PVK private key.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n-                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-            assertTrue(conn.isValid(1));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n-            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with invalid certificate password provided.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+        } catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-\n-    /**\n-     * Tests client certificate authentication feature using a data source.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS1_KEY_SUFFIX;\n-\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs1.key;\";\n+        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n         AbstractTest.updateDataSource(conStr, dsLocal);\n-\n-        try (Connection conn = dsLocal.getConnection()) {\n-            assertTrue(conn.isValid(1));\n+        \n+        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n+            rs.next();\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on.\n-     * \n-     * @throws Exception\n-     */\n+    \n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n-    /**\n-     * Tests client certificate authentication feature with encryption turned on, untrusted.\n-     * \n-     * @throws Exception\n-     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n-                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n+                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt\n-                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": {"commit": "c347a2905d33172731871696989c790b62ca8596", "changed_code": [{"header": "diff --git a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\nindex 079d42bd..acf746d0 100644\n--- a/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n+++ b/src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java\n", "chunk": "@@ -36,135 +37,191 @@ import com.microsoft.sqlserver.testframework.Constants;\n @Tag(Constants.clientCertAuth)\n public class ClientCertificateAuthenticationTest extends AbstractTest {\n \n+    static final String PEM_SUFFIX = \".pem;\";\n+    static final String CER_SUFFIX = \".cer;\";\n+    static final String PVK_SUFFIX = \".pvk;\";\n+\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS1_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs1EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8Test() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PKCS8 private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pkcs8EncryptedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + ENCRYPTED_PKCS8_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX;\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with PFX private key that has been encrypted with a password.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pfxEncrytedTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\n-                + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + ENCRYPTED_PFX_KEY_SUFFIX\n+                + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature with PVK private key.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void pvkTest() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\n-                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + CER_SUFFIX + \"clientKey=\"\n+                + clientKey + PVK_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCert() throws Exception {\n         String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\n                 + \";\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n-            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n+            assertTrue(e.getCause().getMessage().matches(TestUtils.formatErrorMsg(\"R_clientCertError\")));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with invalid certificate password provided.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void invalidCertPassword() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PFX_KEY_SUFFIX\n                 + \"clientKeyPassword=invalid_password;\";\n-        try (Connection conn = DriverManager.getConnection(conStr)) {\n-        } catch (SQLServerException e) {\n+        try (Connection conn = DriverManager.getConnection(conStr)) {} catch (SQLServerException e) {\n             assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\n         }\n     }\n-    \n+\n+    /**\n+     * Tests client certificate authentication feature using a data source.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testDataSource() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs1.key;\";\n-        \n         SQLServerDataSource dsLocal = new SQLServerDataSource();\n-        AbstractTest.updateDataSource(conStr, dsLocal);\n-        \n-        try (Connection conn = dsLocal.getConnection(); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\n-            rs.next();\n-            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\n+        AbstractTest.updateDataSource(connectionString, dsLocal);\n+        dsLocal.setClientCertificate(clientCertificate + PEM_SUFFIX.substring(0, PEM_SUFFIX.length() - 1));\n+        dsLocal.setClientKey(\n+                clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX.substring(0, ENCRYPTED_PKCS1_KEY_SUFFIX.length() - 1));\n+        dsLocal.setClientKeyPassword(clientKeyPassword);\n+\n+        try (Connection conn = dsLocal.getConnection()) {\n+            assertTrue(conn.isValid(1));\n         }\n     }\n \n-    \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptTrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=true;\";\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=true;\";\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n     }\n \n+    /**\n+     * Tests client certificate authentication feature with encryption turned on, untrusted.\n+     * \n+     * @throws Exception\n+     */\n     @Test\n     public void testEncryptUntrusted() throws Exception {\n-        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\n-                + clientKey + \"-pkcs8.key;\" + \"encrypt=true;trustServerCertificate=false;trustStore=\" + trustStorePath;\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\n+                + clientKey + PKCS8_KEY_SUFFIX + \"encrypt=true;trustServerCertificate=false;trustStore=\"\n+                + trustStorePath;\n         try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\n-            ResultSet rs = stmt.executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n+            ResultSet rs = stmt\n+                    .executeQuery(\"SELECT encrypt_option FROM sys.dm_exec_connections WHERE session_id = @@SPID\");\n             rs.next();\n             assertTrue(rs.getBoolean(1));\n         }\n", "next_change": null}]}}]}}]}}, {"oid": "5d223e039cc99f41f4e6abff9566a6db7e550535", "url": "https://github.com/microsoft/mssql-jdbc/commit/5d223e039cc99f41f4e6abff9566a6db7e550535", "message": "dont need statements", "committedDate": "2020-03-27T18:58:00Z", "type": "commit"}, {"oid": "49ed48782f1538717321a73656dbfd475b08ed6e", "url": "https://github.com/microsoft/mssql-jdbc/commit/49ed48782f1538717321a73656dbfd475b08ed6e", "message": "use datasoure api", "committedDate": "2020-03-27T19:13:31Z", "type": "commit"}, {"oid": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "url": "https://github.com/microsoft/mssql-jdbc/commit/0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "message": "String match provider name", "committedDate": "2020-03-27T20:11:42Z", "type": "commit"}, {"oid": "c347a2905d33172731871696989c790b62ca8596", "url": "https://github.com/microsoft/mssql-jdbc/commit/c347a2905d33172731871696989c790b62ca8596", "message": "Merge pull request #17 from rene-ye/clientcertauth\n\nString match provider name", "committedDate": "2020-03-27T20:27:50Z", "type": "commit"}]}