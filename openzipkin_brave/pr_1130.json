{"pr_number": 1130, "pr_title": "Exposes Baggage Apis", "pr_author": "codefromthecrypt", "pr_createdAt": "2020-03-28T11:29:42Z", "pr_url": "https://github.com/openzipkin/brave/pull/1130", "timeline": [{"oid": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "url": "https://github.com/openzipkin/brave/commit/7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "message": "Exposes CorrelationField and ExtraField Apis\n\nThis completes the most common requests around correlation fields by\ngeneralizing code in support for correlation fields, both synchronizing\nto logging context and also propagation (extra fields).\n\nNotably, this allows you to not only define constants for the fields you\nwant, but also decide if they are permissible for correlation.\n\nEx.\n\n```java\n // configure the field, permitting it to be used in correlation contexts\n static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n\n // Allow logging patterns like %X{traceId} %X{bp}\n loggingContext = new Log4J2Context();\n\n decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n                                           .addField(BUSINESS_PROCESS).build();\n\n tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n                                                        .flushValuesToContext(loggingContext)\n                                                        .addField(BUSINESS_PROCESS)\n                                                        .build())\n               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n                                                                  .addScopeDecorator(decorator)\n                                                                  .build())\n\n // Assume runtime code looks like this\n @SendTo(SourceChannels.OUTPUT)\n public void timerMessageSource() {\n   BUSINESS_PROCESS.setValue(\"accounting\");\n   // The logging expression %{bp} will show \"accounting\" in businessCode()\n   businessCode();\n }\n```", "committedDate": "2020-03-29T07:44:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MjEzMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399762131", "body": "@jorgheymans  can you check this new type to see if it makes sense?", "bodyText": "@jorgheymans  can you check this new type to see if it makes sense?", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jorgheymans/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jorgheymans\">@jorgheymans</a>  can you check this new type to see if it makes sense?</p>", "author": "codefromthecrypt", "createdAt": "2020-03-29T08:04:33Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 1de5ecf94..494f7442d 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -15,9 +15,14 @@ package brave.propagation;\n \n import brave.internal.Nullable;\n import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.Set;\n \n+import static brave.propagation.CorrelationFields.validateName;\n import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n \n /**\n  * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 494f7442d..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -28,7 +28,7 @@ import static java.util.Arrays.asList;\n  * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n  * be no-op unless {@link ExtraFieldPropagation} is configured.\n  *\n- * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n  * propagate it through the trace:\n  * <pre>{@code\n  * // Configure your extra field\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MjQ2OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399762468", "body": "Random ideas spurred by the subtype builder pattern we came up with just as food for thought\r\n\r\n` B3Propagation.FACTORY.withExtraFields()`\r\n`B3Propagation.FACTORY.toBuilder().addExtraField(`", "bodyText": "Random ideas spurred by the subtype builder pattern we came up with just as food for thought\n B3Propagation.FACTORY.withExtraFields()\nB3Propagation.FACTORY.toBuilder().addExtraField(", "bodyHTML": "<p dir=\"auto\">Random ideas spurred by the subtype builder pattern we came up with just as food for thought</p>\n<p dir=\"auto\"><code> B3Propagation.FACTORY.withExtraFields()</code><br>\n<code>B3Propagation.FACTORY.toBuilder().addExtraField(</code></p>", "author": "anuraaga", "createdAt": "2020-03-29T08:08:16Z", "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -79,7 +80,8 @@ protected TraceContext newTraceContext(SamplingFlags flags) {\n       .build();\n \n   protected final Propagation.Factory propagationFactory =\n-    ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, EXTRA_KEY);\n+    ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NTExMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399785111", "bodyText": "thanks for the thought although I don't really want to couple propagation to this type yet..\nright now there's a generic list thing in the context also, so I don't want to conflate the two.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MjQ2OA=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave-tests/src/main/java/brave/test/ITRemote.java b/brave-tests/src/main/java/brave/test/ITRemote.java\nindex a94f37a1f..acba2270f 100644\n--- a/brave-tests/src/main/java/brave/test/ITRemote.java\n+++ b/brave-tests/src/main/java/brave/test/ITRemote.java\n", "chunk": "@@ -75,13 +75,11 @@ public abstract class ITRemote {\n \n   // field because this allows subclasses to initialize a field Tracing\n   protected final ThreadLocalCurrentTraceContext currentTraceContext =\n-    ThreadLocalCurrentTraceContext.newBuilder()\n-      .addScopeDecorator(strictScopeDecorator)\n-      .build();\n+    ThreadLocalCurrentTraceContext.newBuilder().addScopeDecorator(strictScopeDecorator).build();\n \n   protected final Propagation.Factory propagationFactory =\n-    ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n-      .addField(EXTRA_FIELD).build();\n+    BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+      .addField(BAGGAGE_FIELD).build();\n \n   protected Tracing tracing = tracingBuilder(Sampler.ALWAYS_SAMPLE).build();\n \n", "next_change": {"commit": "902eea9fe62f2a20be6a73ba005991ef400bf872", "changed_code": [{"header": "diff --git a/brave-tests/src/main/java/brave/test/ITRemote.java b/brave-tests/src/main/java/brave/test/ITRemote.java\nindex acba2270f..dedc4a690 100644\n--- a/brave-tests/src/main/java/brave/test/ITRemote.java\n+++ b/brave-tests/src/main/java/brave/test/ITRemote.java\n", "chunk": "@@ -71,11 +69,8 @@ public abstract class ITRemote {\n     return tracing.propagationFactory().decorate(result);\n   }\n \n-  final StrictScopeDecorator strictScopeDecorator = StrictScopeDecorator.create();\n-\n   // field because this allows subclasses to initialize a field Tracing\n-  protected final ThreadLocalCurrentTraceContext currentTraceContext =\n-    ThreadLocalCurrentTraceContext.newBuilder().addScopeDecorator(strictScopeDecorator).build();\n+  protected final StrictCurrentTraceContext currentTraceContext = new StrictCurrentTraceContext();\n \n   protected final Propagation.Factory propagationFactory =\n     BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n", "next_change": {"commit": "016837e22164c69eb416b1c29fbd59e962634024", "changed_code": [{"header": "diff --git a/brave-tests/src/main/java/brave/test/ITRemote.java b/brave-tests/src/main/java/brave/test/ITRemote.java\nindex dedc4a690..89013f4cf 100644\n--- a/brave-tests/src/main/java/brave/test/ITRemote.java\n+++ b/brave-tests/src/main/java/brave/test/ITRemote.java\n", "chunk": "@@ -74,7 +74,7 @@ public abstract class ITRemote {\n \n   protected final Propagation.Factory propagationFactory =\n     BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n-      .addField(BAGGAGE_FIELD).build();\n+      .addRemoteField(BAGGAGE_FIELD).build();\n \n   protected Tracing tracing = tracingBuilder(Sampler.ALWAYS_SAMPLE).build();\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MzU2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399763562", "body": "It's so unrelated to this PR that I can't even comment on the line \ud83d\ude04 \r\n\r\nBut since I happened to see it, to record it, in `putAllIfAbsent`, it's probably good to have `synchronized(this)` around the loop so 1) invocations of it are atomic, similar to `put` and 2) if `put` gets inlined the nested synchronization will go away and only happen once around the loop", "bodyText": "It's so unrelated to this PR that I can't even comment on the line \ud83d\ude04\nBut since I happened to see it, to record it, in putAllIfAbsent, it's probably good to have synchronized(this) around the loop so 1) invocations of it are atomic, similar to put and 2) if put gets inlined the nested synchronization will go away and only happen once around the loop", "bodyHTML": "<p dir=\"auto\">It's so unrelated to this PR that I can't even comment on the line <g-emoji class=\"g-emoji\" alias=\"smile\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f604.png\">\ud83d\ude04</g-emoji></p>\n<p dir=\"auto\">But since I happened to see it, to record it, in <code>putAllIfAbsent</code>, it's probably good to have <code>synchronized(this)</code> around the loop so 1) invocations of it are atomic, similar to <code>put</code> and 2) if <code>put</code> gets inlined the nested synchronization will go away and only happen once around the loop</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:18:44Z", "path": "brave/src/main/java/brave/internal/PredefinedPropagationFields.java", "diffHunk": "@@ -78,12 +78,12 @@ public String get(int index) {\n   }\n \n   public final void put(int index, String value) {\n-    if (index >= fieldNames.length) return;\n+    if (index >= names.length) return;\n \n     synchronized (this) {", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NTkxMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399785913", "bodyText": "drifted to ExtraFields but will comment now!\nputAllIfAbsent is protected and used before the input is returned anywhere. I'll add a javadoc comment. Regardless I made a path that doesn't synchronize even if it would be uncontended. Good idea.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2MzU2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/PredefinedPropagationFields.java b/brave/src/main/java/brave/propagation/ExtraFields.java\nsimilarity index 50%\nrename from brave/src/main/java/brave/internal/PredefinedPropagationFields.java\nrename to brave/src/main/java/brave/propagation/ExtraFields.java\nindex 16150d0be..d7782ca8a 100644\n--- a/brave/src/main/java/brave/internal/PredefinedPropagationFields.java\n+++ b/brave/src/main/java/brave/propagation/ExtraFields.java\n", "chunk": "@@ -77,42 +98,46 @@ public class PredefinedPropagationFields extends PropagationFields<String, Strin\n     return true;\n   }\n \n-  public final void put(int index, String value) {\n-    if (index >= names.length) return;\n+  protected final void put(int index, String value) {\n+    if (index >= fields.length) return;\n \n     synchronized (this) {\n-      String[] elements = values;\n-      if (elements == null) {\n-        elements = new String[names.length];\n-        elements[index] = value;\n-      } else if (value.equals(elements[index])) {\n-        return;\n-      } else { // this is the copy-on-write part\n-        elements = Arrays.copyOf(elements, elements.length);\n-        elements[index] = value;\n-      }\n-      values = elements;\n+      doPut(index, value);\n+    }\n+  }\n+\n+  void doPut(int index, String value) {\n+    String[] elements = values;\n+    if (elements == null) {\n+      elements = new String[fields.length];\n+      elements[index] = value;\n+    } else if (value.equals(elements[index])) {\n+      return;\n+    } else { // this is the copy-on-write part\n+      elements = Arrays.copyOf(elements, elements.length);\n+      elements[index] = value;\n     }\n+    values = elements;\n   }\n \n   @Override protected final void putAllIfAbsent(PropagationFields parent) {\n-    if (!(parent instanceof PredefinedPropagationFields)) return;\n-    PredefinedPropagationFields predefinedParent = (PredefinedPropagationFields) parent;\n+    if (!(parent instanceof ExtraFields)) return;\n+    ExtraFields predefinedParent = (ExtraFields) parent;\n     checkSameFields(predefinedParent);\n     String[] parentValues = predefinedParent.values;\n     if (parentValues == null) return;\n     for (int i = 0; i < parentValues.length; i++) {\n       if (parentValues[i] != null && get(i) == null) { // extracted wins vs parent\n-        put(i, parentValues[i]);\n+        doPut(i, parentValues[i]);\n       }\n     }\n   }\n \n-  void checkSameFields(PredefinedPropagationFields predefinedParent) {\n-    if (!Arrays.equals(names, predefinedParent.names)) {\n+  void checkSameFields(ExtraFields predefinedParent) {\n+    if (!Arrays.equals(fields, predefinedParent.fields)) {\n       throw new IllegalStateException(\n         String.format(\"Mixed name configuration unsupported: found %s, expected %s\",\n-          Arrays.toString(names), Arrays.toString(predefinedParent.names))\n+          Arrays.toString(fields), Arrays.toString(predefinedParent.fields))\n       );\n     }\n   }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2Mzc4Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399763783", "body": "Not exactly being able to parse this English, maybe something like `A field which will also be used in a correlation context such as MDC.`", "bodyText": "Not exactly being able to parse this English, maybe something like A field which will also be used in a correlation context such as MDC.", "bodyHTML": "<p dir=\"auto\">Not exactly being able to parse this English, maybe something like <code>A field which will also be used in a correlation context such as MDC.</code></p>", "author": "anuraaga", "createdAt": "2020-03-29T08:20:53Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NTk5OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399785998", "bodyText": "better thanks", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2Mzc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex 24df9ba5d..e69cabe8b 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -16,10 +16,16 @@ package brave.propagation;\n import brave.internal.Nullable;\n \n /**\n- * Defines a field handling in a correlation context such as MDC.\n+ * A field which are applied in a correlation context such as MDC via {@link\n+ * CorrelationFieldScopeDecorator}.\n  *\n- * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value\n- * comparison.\n+ * <p>Field updates only apply during {@linkplain CorrelationFieldScopeDecorator scope\n+ * decoration}. This means values set do not flush immediately to the underlying correlation context\n+ * by default. Rather, they are scheduled for the next scope operation. This is a way to control\n+ * overhead. Use the type {@link Flushable} to allow immediate updates.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement lower-case\n+ * {@link #name()} comparison.\n  *\n  * @see CorrelationFieldScopeDecorator\n  * @since 5.11\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex e69cabe8b..c665b39cc 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -22,7 +22,7 @@ import brave.internal.Nullable;\n  * <p>Field updates only apply during {@linkplain CorrelationFieldScopeDecorator scope\n  * decoration}. This means values set do not flush immediately to the underlying correlation context\n  * by default. Rather, they are scheduled for the next scope operation. This is a way to control\n- * overhead. Use the type {@link Flushable} to allow immediate updates.\n+ * overhead. Use the type {@link Updatable} to allow immediate updates.\n  *\n  * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement lower-case\n  * {@link #name()} comparison.\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex c665b39cc..0fde20a36 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -13,38 +13,135 @@\n  */\n package brave.propagation;\n \n+import brave.NoopSpanCustomizer;\n+import brave.ScopedSpan;\n+import brave.Span;\n+import brave.SpanCustomizer;\n+import brave.Tracing;\n+import brave.handler.MutableSpan;\n import brave.internal.Nullable;\n+import java.util.Locale;\n \n /**\n- * A field which are applied in a correlation context such as MDC via {@link\n- * CorrelationFieldScopeDecorator}.\n+ * A possibly remote field used for correlation such as MDC via {@link CorrelationScopeDecorator}.\n  *\n- * <p>Field updates only apply during {@linkplain CorrelationFieldScopeDecorator scope\n- * decoration}. This means values set do not flush immediately to the underlying correlation context\n- * by default. Rather, they are scheduled for the next scope operation. This is a way to control\n- * overhead. Use the type {@link Updatable} to allow immediate updates.\n+ * Here's an example of a constant field, which you want to add a span tag.\n+ * <pre>{@code\n+ * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n  *\n- * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement lower-case\n- * {@link #name()} comparison.\n+ * // Later, you can call below to add a tag with the field name to a span.\n+ * CLOUD_REGION.tag(span);\n+ * }</pre>\n  *\n- * @see CorrelationFieldScopeDecorator\n+ * <h3>Updatable fields</h3>\n+ * {@link Updatable} fields are mutable, typically in request scope. The most common mutable field\n+ * is {@linkplain BaggageField baggage}.\n+ *\n+ * <p>Ex. If you have access to an updatable field, you can reset its value at runtime.\n+ * <pre>{@code\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * COUNTRY_CODE.updateValue(\"FO\");\n+ * String countryCode = COUNTRY_CODE.getValue();\n+ * COUNTRY_CODE.tag(span);\n+ * }</pre>\n+ *\n+ * @see CorrelationFields\n+ * @see CorrelationScopeDecorator\n+ * @see BaggageField\n+ * @see BaggagePropagation\n  * @since 5.11\n  */\n-public interface CorrelationField {\n-  /** The name of this field in the correlation context. */\n-  String name();\n+public abstract class CorrelationField {\n+  /**\n+   * The non-empty name of the field. Ex \"userId\".\n+   *\n+   * <p>For example, if using log correlation and with field named \"userId\", the {@linkplain\n+   * #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next\n+   * made current.\n+   *\n+   * @see CorrelationScopeDecorator\n+   */\n+  public final String name() {\n+    return name;\n+  }\n \n   /**\n    * Returns the most recent value of the field named {@link #name()} in the context or null if\n    * unavailable.\n    */\n-  @Nullable String getValue(TraceContext context);\n+  @Nullable public abstract String getValue(TraceContext context);\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except against the current trace context.\n+   *\n+   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n+   */\n+  @Nullable public String getValue() {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context) : null;\n+  }\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) tags} the value if the input is not no-op and field\n+   * value is available.\n+   */\n+  public final void tag(ScopedSpan scopedSpan) {\n+    if (scopedSpan.isNoop()) return;\n+    String value = getValue(scopedSpan.context());\n+    if (value != null) scopedSpan.tag(name, value);\n+  }\n+\n+  /**\n+   * {@linkplain Span#tag(String, String) tags} the value if the input is not no-op and field value\n+   * is available.\n+   */\n+  public final void tag(Span span) {\n+    if (span.isNoop()) return;\n+    String value = getValue(span.context());\n+    if (value != null) span.tag(name, value);\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) tags} the value if the input is not no-op and\n+   * field value is available.\n+   */\n+  public final void tag(TraceContext context, SpanCustomizer customizer) {\n+    if (customizer instanceof Span) {\n+      tag((Span) customizer);\n+      return;\n+    }\n+    if (customizer == NoopSpanCustomizer.INSTANCE) return;\n+    String value = getValue(context);\n+    if (value != null) customizer.tag(name, value);\n+  }\n+\n+  /**\n+   * {@linkplain MutableSpan#tag(String, String) tags} the value if the input is not no-op and field\n+   * value is available.\n+   */\n+  public final void tag(TraceContext context, MutableSpan span) {\n+    String value = getValue(context);\n+    if (value != null) span.tag(name, value);\n+  }\n+\n+  public static abstract class Updatable extends CorrelationField {\n+    /** Updates the value of the this field, or ignores if not configured. */\n+    public abstract void updateValue(TraceContext context, @Nullable String value);\n+\n+    /**\n+     * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n+     *\n+     * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n+     * context.\n+     */\n+    public void updateValue(String value) {\n+      TraceContext context = currentTraceContext();\n+      if (context != null) updateValue(context, value);\n+    }\n \n-  interface Updatable extends CorrelationField {\n     /**\n-     * MCall this to immediately flush a value update to the correlation context as opposed waiting\n-     * for the next scope decoration. This has a significant performance impact as it requires even\n-     * {@link CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n+     * to the correlation context.\n      *\n      * <p>This is useful for callbacks that have a void return. Ex.\n      * <pre>{@code\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\ndeleted file mode 100644\nindex 0fde20a36..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ /dev/null\n", "chunk": "@@ -1,213 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.NoopSpanCustomizer;\n-import brave.ScopedSpan;\n-import brave.Span;\n-import brave.SpanCustomizer;\n-import brave.Tracing;\n-import brave.handler.MutableSpan;\n-import brave.internal.Nullable;\n-import java.util.Locale;\n-\n-/**\n- * A possibly remote field used for correlation such as MDC via {@link CorrelationScopeDecorator}.\n- *\n- * Here's an example of a constant field, which you want to add a span tag.\n- * <pre>{@code\n- * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- *\n- * // Later, you can call below to add a tag with the field name to a span.\n- * CLOUD_REGION.tag(span);\n- * }</pre>\n- *\n- * <h3>Updatable fields</h3>\n- * {@link Updatable} fields are mutable, typically in request scope. The most common mutable field\n- * is {@linkplain BaggageField baggage}.\n- *\n- * <p>Ex. If you have access to an updatable field, you can reset its value at runtime.\n- * <pre>{@code\n- * // Later, you can call below to affect the country code of the current trace context\n- * COUNTRY_CODE.updateValue(\"FO\");\n- * String countryCode = COUNTRY_CODE.getValue();\n- * COUNTRY_CODE.tag(span);\n- * }</pre>\n- *\n- * @see CorrelationFields\n- * @see CorrelationScopeDecorator\n- * @see BaggageField\n- * @see BaggagePropagation\n- * @since 5.11\n- */\n-public abstract class CorrelationField {\n-  /**\n-   * The non-empty name of the field. Ex \"userId\".\n-   *\n-   * <p>For example, if using log correlation and with field named \"userId\", the {@linkplain\n-   * #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next\n-   * made current.\n-   *\n-   * @see CorrelationScopeDecorator\n-   */\n-  public final String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * Returns the most recent value of the field named {@link #name()} in the context or null if\n-   * unavailable.\n-   */\n-  @Nullable public abstract String getValue(TraceContext context);\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * {@linkplain ScopedSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(ScopedSpan scopedSpan) {\n-    if (scopedSpan.isNoop()) return;\n-    String value = getValue(scopedSpan.context());\n-    if (value != null) scopedSpan.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain Span#tag(String, String) tags} the value if the input is not no-op and field value\n-   * is available.\n-   */\n-  public final void tag(Span span) {\n-    if (span.isNoop()) return;\n-    String value = getValue(span.context());\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain SpanCustomizer#tag(String, String) tags} the value if the input is not no-op and\n-   * field value is available.\n-   */\n-  public final void tag(TraceContext context, SpanCustomizer customizer) {\n-    if (customizer instanceof Span) {\n-      tag((Span) customizer);\n-      return;\n-    }\n-    if (customizer == NoopSpanCustomizer.INSTANCE) return;\n-    String value = getValue(context);\n-    if (value != null) customizer.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain MutableSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(TraceContext context, MutableSpan span) {\n-    String value = getValue(context);\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  public static abstract class Updatable extends CorrelationField {\n-    /** Updates the value of the this field, or ignores if not configured. */\n-    public abstract void updateValue(TraceContext context, @Nullable String value);\n-\n-    /**\n-     * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-     *\n-     * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-     * context.\n-     */\n-    public void updateValue(String value) {\n-      TraceContext context = currentTraceContext();\n-      if (context != null) updateValue(context, value);\n-    }\n-\n-    /**\n-     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n-     * to the correlation context.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   // Assume BUSINESS_PROCESS is an updatable field\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * <h3>Appropriate Usage</h3>\n-     * This has a significant performance impact as it requires even {@link\n-     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n-     *\n-     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-     * correlation context, as they will apply on the next scope operation.\n-     */\n-    public final boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    final boolean flushOnUpdate;\n-\n-    Updatable(String name, boolean flushOnUpdate) { // package sealed\n-      super(name);\n-      this.flushOnUpdate = flushOnUpdate;\n-    }\n-  }\n-\n-  final String name, lcName;\n-\n-  CorrelationField(String name) { // sealed to this package\n-    this.name = validateName(name);\n-    this.lcName = name.toLowerCase(Locale.ROOT);\n-  }\n-\n-  @Override public String toString() {\n-    return getClass().getSimpleName() + \"{\" + name + \"}\";\n-  }\n-\n-  /** Returns true for any correlation field with the same name (case insensitive). */\n-  @Override public final boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof CorrelationField)) return false;\n-    return lcName.equals(((CorrelationField) o).lcName);\n-  }\n-\n-  /** Returns the same value for any correlation field with the same name (case insensitive). */\n-  @Override public final int hashCode() {\n-    return lcName.hashCode();\n-  }\n-\n-  static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n-\n-  @Nullable static TraceContext currentTraceContext() {\n-    Tracing tracing = Tracing.current();\n-    return tracing != null ? tracing.currentTraceContext().get() : null;\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDE0MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764141", "body": "A bit uncertain what `value comparison` means here, I think it's more comparing a key?", "bodyText": "A bit uncertain what value comparison means here, I think it's more comparing a key?", "bodyHTML": "<p dir=\"auto\">A bit uncertain what <code>value comparison</code> means here, I think it's more comparing a key?</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:24:21Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDE3OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764179", "bodyText": "Though maybe at least for now just seal this so it's not subclassed by users?", "author": "anuraaga", "createdAt": "2020-03-29T08:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NjEwNw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399786107", "bodyText": "I reworded ptal. can't be sealed as we need it to be an interface for conditional use in ExtraField..", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex 24df9ba5d..e69cabe8b 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -16,10 +16,16 @@ package brave.propagation;\n import brave.internal.Nullable;\n \n /**\n- * Defines a field handling in a correlation context such as MDC.\n+ * A field which are applied in a correlation context such as MDC via {@link\n+ * CorrelationFieldScopeDecorator}.\n  *\n- * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value\n- * comparison.\n+ * <p>Field updates only apply during {@linkplain CorrelationFieldScopeDecorator scope\n+ * decoration}. This means values set do not flush immediately to the underlying correlation context\n+ * by default. Rather, they are scheduled for the next scope operation. This is a way to control\n+ * overhead. Use the type {@link Flushable} to allow immediate updates.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement lower-case\n+ * {@link #name()} comparison.\n  *\n  * @see CorrelationFieldScopeDecorator\n  * @since 5.11\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex e69cabe8b..c665b39cc 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -22,7 +22,7 @@ import brave.internal.Nullable;\n  * <p>Field updates only apply during {@linkplain CorrelationFieldScopeDecorator scope\n  * decoration}. This means values set do not flush immediately to the underlying correlation context\n  * by default. Rather, they are scheduled for the next scope operation. This is a way to control\n- * overhead. Use the type {@link Flushable} to allow immediate updates.\n+ * overhead. Use the type {@link Updatable} to allow immediate updates.\n  *\n  * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement lower-case\n  * {@link #name()} comparison.\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex c665b39cc..0fde20a36 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -13,38 +13,135 @@\n  */\n package brave.propagation;\n \n+import brave.NoopSpanCustomizer;\n+import brave.ScopedSpan;\n+import brave.Span;\n+import brave.SpanCustomizer;\n+import brave.Tracing;\n+import brave.handler.MutableSpan;\n import brave.internal.Nullable;\n+import java.util.Locale;\n \n /**\n- * A field which are applied in a correlation context such as MDC via {@link\n- * CorrelationFieldScopeDecorator}.\n+ * A possibly remote field used for correlation such as MDC via {@link CorrelationScopeDecorator}.\n  *\n- * <p>Field updates only apply during {@linkplain CorrelationFieldScopeDecorator scope\n- * decoration}. This means values set do not flush immediately to the underlying correlation context\n- * by default. Rather, they are scheduled for the next scope operation. This is a way to control\n- * overhead. Use the type {@link Updatable} to allow immediate updates.\n+ * Here's an example of a constant field, which you want to add a span tag.\n+ * <pre>{@code\n+ * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n  *\n- * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement lower-case\n- * {@link #name()} comparison.\n+ * // Later, you can call below to add a tag with the field name to a span.\n+ * CLOUD_REGION.tag(span);\n+ * }</pre>\n  *\n- * @see CorrelationFieldScopeDecorator\n+ * <h3>Updatable fields</h3>\n+ * {@link Updatable} fields are mutable, typically in request scope. The most common mutable field\n+ * is {@linkplain BaggageField baggage}.\n+ *\n+ * <p>Ex. If you have access to an updatable field, you can reset its value at runtime.\n+ * <pre>{@code\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * COUNTRY_CODE.updateValue(\"FO\");\n+ * String countryCode = COUNTRY_CODE.getValue();\n+ * COUNTRY_CODE.tag(span);\n+ * }</pre>\n+ *\n+ * @see CorrelationFields\n+ * @see CorrelationScopeDecorator\n+ * @see BaggageField\n+ * @see BaggagePropagation\n  * @since 5.11\n  */\n-public interface CorrelationField {\n-  /** The name of this field in the correlation context. */\n-  String name();\n+public abstract class CorrelationField {\n+  /**\n+   * The non-empty name of the field. Ex \"userId\".\n+   *\n+   * <p>For example, if using log correlation and with field named \"userId\", the {@linkplain\n+   * #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next\n+   * made current.\n+   *\n+   * @see CorrelationScopeDecorator\n+   */\n+  public final String name() {\n+    return name;\n+  }\n \n   /**\n    * Returns the most recent value of the field named {@link #name()} in the context or null if\n    * unavailable.\n    */\n-  @Nullable String getValue(TraceContext context);\n+  @Nullable public abstract String getValue(TraceContext context);\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except against the current trace context.\n+   *\n+   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n+   */\n+  @Nullable public String getValue() {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context) : null;\n+  }\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) tags} the value if the input is not no-op and field\n+   * value is available.\n+   */\n+  public final void tag(ScopedSpan scopedSpan) {\n+    if (scopedSpan.isNoop()) return;\n+    String value = getValue(scopedSpan.context());\n+    if (value != null) scopedSpan.tag(name, value);\n+  }\n+\n+  /**\n+   * {@linkplain Span#tag(String, String) tags} the value if the input is not no-op and field value\n+   * is available.\n+   */\n+  public final void tag(Span span) {\n+    if (span.isNoop()) return;\n+    String value = getValue(span.context());\n+    if (value != null) span.tag(name, value);\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) tags} the value if the input is not no-op and\n+   * field value is available.\n+   */\n+  public final void tag(TraceContext context, SpanCustomizer customizer) {\n+    if (customizer instanceof Span) {\n+      tag((Span) customizer);\n+      return;\n+    }\n+    if (customizer == NoopSpanCustomizer.INSTANCE) return;\n+    String value = getValue(context);\n+    if (value != null) customizer.tag(name, value);\n+  }\n+\n+  /**\n+   * {@linkplain MutableSpan#tag(String, String) tags} the value if the input is not no-op and field\n+   * value is available.\n+   */\n+  public final void tag(TraceContext context, MutableSpan span) {\n+    String value = getValue(context);\n+    if (value != null) span.tag(name, value);\n+  }\n+\n+  public static abstract class Updatable extends CorrelationField {\n+    /** Updates the value of the this field, or ignores if not configured. */\n+    public abstract void updateValue(TraceContext context, @Nullable String value);\n+\n+    /**\n+     * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n+     *\n+     * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n+     * context.\n+     */\n+    public void updateValue(String value) {\n+      TraceContext context = currentTraceContext();\n+      if (context != null) updateValue(context, value);\n+    }\n \n-  interface Updatable extends CorrelationField {\n     /**\n-     * MCall this to immediately flush a value update to the correlation context as opposed waiting\n-     * for the next scope decoration. This has a significant performance impact as it requires even\n-     * {@link CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n+     * to the correlation context.\n      *\n      * <p>This is useful for callbacks that have a void return. Ex.\n      * <pre>{@code\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\ndeleted file mode 100644\nindex 0fde20a36..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ /dev/null\n", "chunk": "@@ -1,213 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.NoopSpanCustomizer;\n-import brave.ScopedSpan;\n-import brave.Span;\n-import brave.SpanCustomizer;\n-import brave.Tracing;\n-import brave.handler.MutableSpan;\n-import brave.internal.Nullable;\n-import java.util.Locale;\n-\n-/**\n- * A possibly remote field used for correlation such as MDC via {@link CorrelationScopeDecorator}.\n- *\n- * Here's an example of a constant field, which you want to add a span tag.\n- * <pre>{@code\n- * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- *\n- * // Later, you can call below to add a tag with the field name to a span.\n- * CLOUD_REGION.tag(span);\n- * }</pre>\n- *\n- * <h3>Updatable fields</h3>\n- * {@link Updatable} fields are mutable, typically in request scope. The most common mutable field\n- * is {@linkplain BaggageField baggage}.\n- *\n- * <p>Ex. If you have access to an updatable field, you can reset its value at runtime.\n- * <pre>{@code\n- * // Later, you can call below to affect the country code of the current trace context\n- * COUNTRY_CODE.updateValue(\"FO\");\n- * String countryCode = COUNTRY_CODE.getValue();\n- * COUNTRY_CODE.tag(span);\n- * }</pre>\n- *\n- * @see CorrelationFields\n- * @see CorrelationScopeDecorator\n- * @see BaggageField\n- * @see BaggagePropagation\n- * @since 5.11\n- */\n-public abstract class CorrelationField {\n-  /**\n-   * The non-empty name of the field. Ex \"userId\".\n-   *\n-   * <p>For example, if using log correlation and with field named \"userId\", the {@linkplain\n-   * #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next\n-   * made current.\n-   *\n-   * @see CorrelationScopeDecorator\n-   */\n-  public final String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * Returns the most recent value of the field named {@link #name()} in the context or null if\n-   * unavailable.\n-   */\n-  @Nullable public abstract String getValue(TraceContext context);\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * {@linkplain ScopedSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(ScopedSpan scopedSpan) {\n-    if (scopedSpan.isNoop()) return;\n-    String value = getValue(scopedSpan.context());\n-    if (value != null) scopedSpan.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain Span#tag(String, String) tags} the value if the input is not no-op and field value\n-   * is available.\n-   */\n-  public final void tag(Span span) {\n-    if (span.isNoop()) return;\n-    String value = getValue(span.context());\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain SpanCustomizer#tag(String, String) tags} the value if the input is not no-op and\n-   * field value is available.\n-   */\n-  public final void tag(TraceContext context, SpanCustomizer customizer) {\n-    if (customizer instanceof Span) {\n-      tag((Span) customizer);\n-      return;\n-    }\n-    if (customizer == NoopSpanCustomizer.INSTANCE) return;\n-    String value = getValue(context);\n-    if (value != null) customizer.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain MutableSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(TraceContext context, MutableSpan span) {\n-    String value = getValue(context);\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  public static abstract class Updatable extends CorrelationField {\n-    /** Updates the value of the this field, or ignores if not configured. */\n-    public abstract void updateValue(TraceContext context, @Nullable String value);\n-\n-    /**\n-     * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-     *\n-     * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-     * context.\n-     */\n-    public void updateValue(String value) {\n-      TraceContext context = currentTraceContext();\n-      if (context != null) updateValue(context, value);\n-    }\n-\n-    /**\n-     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n-     * to the correlation context.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   // Assume BUSINESS_PROCESS is an updatable field\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * <h3>Appropriate Usage</h3>\n-     * This has a significant performance impact as it requires even {@link\n-     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n-     *\n-     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-     * correlation context, as they will apply on the next scope operation.\n-     */\n-    public final boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    final boolean flushOnUpdate;\n-\n-    Updatable(String name, boolean flushOnUpdate) { // package sealed\n-      super(name);\n-      this.flushOnUpdate = flushOnUpdate;\n-    }\n-  }\n-\n-  final String name, lcName;\n-\n-  CorrelationField(String name) { // sealed to this package\n-    this.name = validateName(name);\n-    this.lcName = name.toLowerCase(Locale.ROOT);\n-  }\n-\n-  @Override public String toString() {\n-    return getClass().getSimpleName() + \"{\" + name + \"}\";\n-  }\n-\n-  /** Returns true for any correlation field with the same name (case insensitive). */\n-  @Override public final boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof CorrelationField)) return false;\n-    return lcName.equals(((CorrelationField) o).lcName);\n-  }\n-\n-  /** Returns the same value for any correlation field with the same name (case insensitive). */\n-  @Override public final int hashCode() {\n-    return lcName.hashCode();\n-  }\n-\n-  static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n-\n-  @Nullable static TraceContext currentTraceContext() {\n-    Tracing tracing = Tracing.current();\n-    return tracing != null ? tracing.currentTraceContext().get() : null;\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDM0Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764343", "body": "```suggestion\r\n     * Returns the correlation property of the specified name if it is set, or null\r\n```\r\n\r\nI think", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns the correlation property of the specified name iff it is a string, or null\n          \n          \n            \n                 * Returns the correlation property of the specified name if it is set, or null\n          \n      \n    \n    \n  \n\nI think", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Returns</span> the correlation property of the specified name <span class=\"x x-first x-last\">iff</span> it is <span class=\"x x-first x-last\">a string</span>, or <span class=\"pl-c1\">null</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Returns</span> the correlation property of the specified name <span class=\"pl-k x x-first x-last\">if</span> it is <span class=\"x x-first x-last\">set</span>, or <span class=\"pl-c1\">null</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">I think</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:26:17Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value\n+ * comparison.\n+ *\n+ * @see CorrelationFieldScopeDecorator\n+ * @since 5.11\n+ */\n+public interface CorrelationField {\n+  /** The name of this field in the correlation context. */\n+  String name();\n+\n+  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  @Nullable String getValue(TraceContext context);\n+\n+  /** Dispatches methods to synchronize fields with a context such as SLF4J MDC */\n+  abstract class Context { // abstract to allow optimized methods to be added later\n+    /**\n+     * Returns the correlation property of the specified name iff it is a string, or null", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4MzQ4OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399783489", "bodyText": "some contexts allow object values, so the main intent here is that it is not null and a string..", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDM0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex 24df9ba5d..e69cabe8b 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -28,21 +34,28 @@ public interface CorrelationField {\n   /** The name of this field in the correlation context. */\n   String name();\n \n-  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  /**\n+   * Returns the most recent value of the field named {@link #name()} in the context or null if\n+   * unavailable.\n+   */\n   @Nullable String getValue(TraceContext context);\n \n-  /** Dispatches methods to synchronize fields with a context such as SLF4J MDC */\n-  abstract class Context { // abstract to allow optimized methods to be added later\n+  /**\n+   * Marks a field such that updates immediately flush to the correlation context, when configured\n+   * and their corresponding trace context is current. This has a significant performance impact as\n+   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.\n+   *\n+   * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n+   * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n+   * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n+   * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n+   * correlation context, as they will apply on the next scope operation.\n+   */\n+  interface Flushable extends CorrelationField {\n     /**\n-     * Returns the correlation property of the specified name iff it is a string, or null\n-     * otherwise.\n+     * Flushes the most recent value of the field named {@link #name()} into the correlation\n+     * context, or ignores if not configured.\n      */\n-    protected abstract @Nullable String get(String name);\n-\n-    /** Replaces the correlation property of the specified name with a non-null value. */\n-    protected abstract void put(String name, String value);\n-\n-    /** Removes the correlation property of the specified name. */\n-    protected abstract void remove(String name);\n+    void flushValue();\n   }\n }\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex e69cabe8b..c665b39cc 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -40,22 +40,32 @@ public interface CorrelationField {\n    */\n   @Nullable String getValue(TraceContext context);\n \n-  /**\n-   * Marks a field such that updates immediately flush to the correlation context, when configured\n-   * and their corresponding trace context is current. This has a significant performance impact as\n-   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.\n-   *\n-   * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-   * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-   * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-   * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-   * correlation context, as they will apply on the next scope operation.\n-   */\n-  interface Flushable extends CorrelationField {\n+  interface Updatable extends CorrelationField {\n     /**\n-     * Flushes the most recent value of the field named {@link #name()} into the correlation\n-     * context, or ignores if not configured.\n+     * MCall this to immediately flush a value update to the correlation context as opposed waiting\n+     * for the next scope decoration. This has a significant performance impact as it requires even\n+     * {@link CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   // Assume BUSINESS_PROCESS is an updatable field\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     *\n+     * <h3>Appropriate Usage</h3>\n+     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n+     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n+     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n+     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n+     * correlation context, as they will apply on the next scope operation.\n+     *\n+     * @see ExtraField.CorrelationBuilder#flushOnUpdate()\n      */\n-    void flushValue();\n+    boolean flushOnUpdate();\n   }\n }\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex c665b39cc..0fde20a36 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -58,14 +155,59 @@ public interface CorrelationField {\n      * }</pre>\n      *\n      * <h3>Appropriate Usage</h3>\n+     * This has a significant performance impact as it requires even {@link\n+     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n      * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n      * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n      * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n      * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n      * correlation context, as they will apply on the next scope operation.\n-     *\n-     * @see ExtraField.CorrelationBuilder#flushOnUpdate()\n      */\n-    boolean flushOnUpdate();\n+    public final boolean flushOnUpdate() {\n+      return flushOnUpdate;\n+    }\n+\n+    final boolean flushOnUpdate;\n+\n+    Updatable(String name, boolean flushOnUpdate) { // package sealed\n+      super(name);\n+      this.flushOnUpdate = flushOnUpdate;\n+    }\n+  }\n+\n+  final String name, lcName;\n+\n+  CorrelationField(String name) { // sealed to this package\n+    this.name = validateName(name);\n+    this.lcName = name.toLowerCase(Locale.ROOT);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + name + \"}\";\n+  }\n+\n+  /** Returns true for any correlation field with the same name (case insensitive). */\n+  @Override public final boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof CorrelationField)) return false;\n+    return lcName.equals(((CorrelationField) o).lcName);\n+  }\n+\n+  /** Returns the same value for any correlation field with the same name (case insensitive). */\n+  @Override public final int hashCode() {\n+    return lcName.hashCode();\n+  }\n+\n+  static String validateName(String name) {\n+    if (name == null) throw new NullPointerException(\"name == null\");\n+    name = name.trim();\n+    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n+    return name;\n+  }\n+\n+  @Nullable static TraceContext currentTraceContext() {\n+    Tracing tracing = Tracing.current();\n+    return tracing != null ? tracing.currentTraceContext().get() : null;\n   }\n }\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\ndeleted file mode 100644\nindex 0fde20a36..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ /dev/null\n", "chunk": "@@ -1,213 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.NoopSpanCustomizer;\n-import brave.ScopedSpan;\n-import brave.Span;\n-import brave.SpanCustomizer;\n-import brave.Tracing;\n-import brave.handler.MutableSpan;\n-import brave.internal.Nullable;\n-import java.util.Locale;\n-\n-/**\n- * A possibly remote field used for correlation such as MDC via {@link CorrelationScopeDecorator}.\n- *\n- * Here's an example of a constant field, which you want to add a span tag.\n- * <pre>{@code\n- * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- *\n- * // Later, you can call below to add a tag with the field name to a span.\n- * CLOUD_REGION.tag(span);\n- * }</pre>\n- *\n- * <h3>Updatable fields</h3>\n- * {@link Updatable} fields are mutable, typically in request scope. The most common mutable field\n- * is {@linkplain BaggageField baggage}.\n- *\n- * <p>Ex. If you have access to an updatable field, you can reset its value at runtime.\n- * <pre>{@code\n- * // Later, you can call below to affect the country code of the current trace context\n- * COUNTRY_CODE.updateValue(\"FO\");\n- * String countryCode = COUNTRY_CODE.getValue();\n- * COUNTRY_CODE.tag(span);\n- * }</pre>\n- *\n- * @see CorrelationFields\n- * @see CorrelationScopeDecorator\n- * @see BaggageField\n- * @see BaggagePropagation\n- * @since 5.11\n- */\n-public abstract class CorrelationField {\n-  /**\n-   * The non-empty name of the field. Ex \"userId\".\n-   *\n-   * <p>For example, if using log correlation and with field named \"userId\", the {@linkplain\n-   * #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next\n-   * made current.\n-   *\n-   * @see CorrelationScopeDecorator\n-   */\n-  public final String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * Returns the most recent value of the field named {@link #name()} in the context or null if\n-   * unavailable.\n-   */\n-  @Nullable public abstract String getValue(TraceContext context);\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * {@linkplain ScopedSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(ScopedSpan scopedSpan) {\n-    if (scopedSpan.isNoop()) return;\n-    String value = getValue(scopedSpan.context());\n-    if (value != null) scopedSpan.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain Span#tag(String, String) tags} the value if the input is not no-op and field value\n-   * is available.\n-   */\n-  public final void tag(Span span) {\n-    if (span.isNoop()) return;\n-    String value = getValue(span.context());\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain SpanCustomizer#tag(String, String) tags} the value if the input is not no-op and\n-   * field value is available.\n-   */\n-  public final void tag(TraceContext context, SpanCustomizer customizer) {\n-    if (customizer instanceof Span) {\n-      tag((Span) customizer);\n-      return;\n-    }\n-    if (customizer == NoopSpanCustomizer.INSTANCE) return;\n-    String value = getValue(context);\n-    if (value != null) customizer.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain MutableSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(TraceContext context, MutableSpan span) {\n-    String value = getValue(context);\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  public static abstract class Updatable extends CorrelationField {\n-    /** Updates the value of the this field, or ignores if not configured. */\n-    public abstract void updateValue(TraceContext context, @Nullable String value);\n-\n-    /**\n-     * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-     *\n-     * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-     * context.\n-     */\n-    public void updateValue(String value) {\n-      TraceContext context = currentTraceContext();\n-      if (context != null) updateValue(context, value);\n-    }\n-\n-    /**\n-     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n-     * to the correlation context.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   // Assume BUSINESS_PROCESS is an updatable field\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * <h3>Appropriate Usage</h3>\n-     * This has a significant performance impact as it requires even {@link\n-     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n-     *\n-     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-     * correlation context, as they will apply on the next scope operation.\n-     */\n-    public final boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    final boolean flushOnUpdate;\n-\n-    Updatable(String name, boolean flushOnUpdate) { // package sealed\n-      super(name);\n-      this.flushOnUpdate = flushOnUpdate;\n-    }\n-  }\n-\n-  final String name, lcName;\n-\n-  CorrelationField(String name) { // sealed to this package\n-    this.name = validateName(name);\n-    this.lcName = name.toLowerCase(Locale.ROOT);\n-  }\n-\n-  @Override public String toString() {\n-    return getClass().getSimpleName() + \"{\" + name + \"}\";\n-  }\n-\n-  /** Returns true for any correlation field with the same name (case insensitive). */\n-  @Override public final boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof CorrelationField)) return false;\n-    return lcName.equals(((CorrelationField) o).lcName);\n-  }\n-\n-  /** Returns the same value for any correlation field with the same name (case insensitive). */\n-  @Override public final int hashCode() {\n-    return lcName.hashCode();\n-  }\n-\n-  static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n-\n-  @Nullable static TraceContext currentTraceContext() {\n-    Tracing tracing = Tracing.current();\n-    return tracing != null ? tracing.currentTraceContext().get() : null;\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDYwNg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764606", "body": "Totally randomly, this looks a lot like a new class in Armeria for customizing Context storage, which is inspired by gRPC.\r\n\r\nhttps://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/RequestContextStorage.java#L77\r\n\r\nJust in case it's interesting. One feature that may be relevant is accepting a current value when doing `remove` - this can help catch instrumentation bugs if `remove` is being called from an unexpected place / thread.", "bodyText": "Totally randomly, this looks a lot like a new class in Armeria for customizing Context storage, which is inspired by gRPC.\nhttps://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/RequestContextStorage.java#L77\nJust in case it's interesting. One feature that may be relevant is accepting a current value when doing remove - this can help catch instrumentation bugs if remove is being called from an unexpected place / thread.", "bodyHTML": "<p dir=\"auto\">Totally randomly, this looks a lot like a new class in Armeria for customizing Context storage, which is inspired by gRPC.</p>\n<p dir=\"auto\"><a href=\"https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/RequestContextStorage.java#L77\">https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/RequestContextStorage.java#L77</a></p>\n<p dir=\"auto\">Just in case it's interesting. One feature that may be relevant is accepting a current value when doing <code>remove</code> - this can help catch instrumentation bugs if <code>remove</code> is being called from an unexpected place / thread.</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:28:36Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value\n+ * comparison.\n+ *\n+ * @see CorrelationFieldScopeDecorator\n+ * @since 5.11\n+ */\n+public interface CorrelationField {\n+  /** The name of this field in the correlation context. */\n+  String name();\n+\n+  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  @Nullable String getValue(TraceContext context);\n+\n+  /** Dispatches methods to synchronize fields with a context such as SLF4J MDC */\n+  abstract class Context { // abstract to allow optimized methods to be added later", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4MzY1MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399783650", "bodyText": "oh yeah I remember that. I didn't really want this to be a user type though. In fact, we can probably hide it again..", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4MzcwNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399783705", "bodyText": "reason is that the context is very expensive part of the code, and having to re-look up the old value will just make it worse.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex 24df9ba5d..e69cabe8b 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -28,21 +34,28 @@ public interface CorrelationField {\n   /** The name of this field in the correlation context. */\n   String name();\n \n-  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  /**\n+   * Returns the most recent value of the field named {@link #name()} in the context or null if\n+   * unavailable.\n+   */\n   @Nullable String getValue(TraceContext context);\n \n-  /** Dispatches methods to synchronize fields with a context such as SLF4J MDC */\n-  abstract class Context { // abstract to allow optimized methods to be added later\n+  /**\n+   * Marks a field such that updates immediately flush to the correlation context, when configured\n+   * and their corresponding trace context is current. This has a significant performance impact as\n+   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.\n+   *\n+   * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n+   * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n+   * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n+   * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n+   * correlation context, as they will apply on the next scope operation.\n+   */\n+  interface Flushable extends CorrelationField {\n     /**\n-     * Returns the correlation property of the specified name iff it is a string, or null\n-     * otherwise.\n+     * Flushes the most recent value of the field named {@link #name()} into the correlation\n+     * context, or ignores if not configured.\n      */\n-    protected abstract @Nullable String get(String name);\n-\n-    /** Replaces the correlation property of the specified name with a non-null value. */\n-    protected abstract void put(String name, String value);\n-\n-    /** Removes the correlation property of the specified name. */\n-    protected abstract void remove(String name);\n+    void flushValue();\n   }\n }\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex e69cabe8b..c665b39cc 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -40,22 +40,32 @@ public interface CorrelationField {\n    */\n   @Nullable String getValue(TraceContext context);\n \n-  /**\n-   * Marks a field such that updates immediately flush to the correlation context, when configured\n-   * and their corresponding trace context is current. This has a significant performance impact as\n-   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.\n-   *\n-   * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-   * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-   * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-   * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-   * correlation context, as they will apply on the next scope operation.\n-   */\n-  interface Flushable extends CorrelationField {\n+  interface Updatable extends CorrelationField {\n     /**\n-     * Flushes the most recent value of the field named {@link #name()} into the correlation\n-     * context, or ignores if not configured.\n+     * MCall this to immediately flush a value update to the correlation context as opposed waiting\n+     * for the next scope decoration. This has a significant performance impact as it requires even\n+     * {@link CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   // Assume BUSINESS_PROCESS is an updatable field\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     *\n+     * <h3>Appropriate Usage</h3>\n+     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n+     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n+     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n+     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n+     * correlation context, as they will apply on the next scope operation.\n+     *\n+     * @see ExtraField.CorrelationBuilder#flushOnUpdate()\n      */\n-    void flushValue();\n+    boolean flushOnUpdate();\n   }\n }\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex c665b39cc..0fde20a36 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -58,14 +155,59 @@ public interface CorrelationField {\n      * }</pre>\n      *\n      * <h3>Appropriate Usage</h3>\n+     * This has a significant performance impact as it requires even {@link\n+     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n      * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n      * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n      * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n      * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n      * correlation context, as they will apply on the next scope operation.\n-     *\n-     * @see ExtraField.CorrelationBuilder#flushOnUpdate()\n      */\n-    boolean flushOnUpdate();\n+    public final boolean flushOnUpdate() {\n+      return flushOnUpdate;\n+    }\n+\n+    final boolean flushOnUpdate;\n+\n+    Updatable(String name, boolean flushOnUpdate) { // package sealed\n+      super(name);\n+      this.flushOnUpdate = flushOnUpdate;\n+    }\n+  }\n+\n+  final String name, lcName;\n+\n+  CorrelationField(String name) { // sealed to this package\n+    this.name = validateName(name);\n+    this.lcName = name.toLowerCase(Locale.ROOT);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + name + \"}\";\n+  }\n+\n+  /** Returns true for any correlation field with the same name (case insensitive). */\n+  @Override public final boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof CorrelationField)) return false;\n+    return lcName.equals(((CorrelationField) o).lcName);\n+  }\n+\n+  /** Returns the same value for any correlation field with the same name (case insensitive). */\n+  @Override public final int hashCode() {\n+    return lcName.hashCode();\n+  }\n+\n+  static String validateName(String name) {\n+    if (name == null) throw new NullPointerException(\"name == null\");\n+    name = name.trim();\n+    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n+    return name;\n+  }\n+\n+  @Nullable static TraceContext currentTraceContext() {\n+    Tracing tracing = Tracing.current();\n+    return tracing != null ? tracing.currentTraceContext().get() : null;\n   }\n }\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\ndeleted file mode 100644\nindex 0fde20a36..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ /dev/null\n", "chunk": "@@ -1,213 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.NoopSpanCustomizer;\n-import brave.ScopedSpan;\n-import brave.Span;\n-import brave.SpanCustomizer;\n-import brave.Tracing;\n-import brave.handler.MutableSpan;\n-import brave.internal.Nullable;\n-import java.util.Locale;\n-\n-/**\n- * A possibly remote field used for correlation such as MDC via {@link CorrelationScopeDecorator}.\n- *\n- * Here's an example of a constant field, which you want to add a span tag.\n- * <pre>{@code\n- * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- *\n- * // Later, you can call below to add a tag with the field name to a span.\n- * CLOUD_REGION.tag(span);\n- * }</pre>\n- *\n- * <h3>Updatable fields</h3>\n- * {@link Updatable} fields are mutable, typically in request scope. The most common mutable field\n- * is {@linkplain BaggageField baggage}.\n- *\n- * <p>Ex. If you have access to an updatable field, you can reset its value at runtime.\n- * <pre>{@code\n- * // Later, you can call below to affect the country code of the current trace context\n- * COUNTRY_CODE.updateValue(\"FO\");\n- * String countryCode = COUNTRY_CODE.getValue();\n- * COUNTRY_CODE.tag(span);\n- * }</pre>\n- *\n- * @see CorrelationFields\n- * @see CorrelationScopeDecorator\n- * @see BaggageField\n- * @see BaggagePropagation\n- * @since 5.11\n- */\n-public abstract class CorrelationField {\n-  /**\n-   * The non-empty name of the field. Ex \"userId\".\n-   *\n-   * <p>For example, if using log correlation and with field named \"userId\", the {@linkplain\n-   * #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next\n-   * made current.\n-   *\n-   * @see CorrelationScopeDecorator\n-   */\n-  public final String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * Returns the most recent value of the field named {@link #name()} in the context or null if\n-   * unavailable.\n-   */\n-  @Nullable public abstract String getValue(TraceContext context);\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * {@linkplain ScopedSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(ScopedSpan scopedSpan) {\n-    if (scopedSpan.isNoop()) return;\n-    String value = getValue(scopedSpan.context());\n-    if (value != null) scopedSpan.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain Span#tag(String, String) tags} the value if the input is not no-op and field value\n-   * is available.\n-   */\n-  public final void tag(Span span) {\n-    if (span.isNoop()) return;\n-    String value = getValue(span.context());\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain SpanCustomizer#tag(String, String) tags} the value if the input is not no-op and\n-   * field value is available.\n-   */\n-  public final void tag(TraceContext context, SpanCustomizer customizer) {\n-    if (customizer instanceof Span) {\n-      tag((Span) customizer);\n-      return;\n-    }\n-    if (customizer == NoopSpanCustomizer.INSTANCE) return;\n-    String value = getValue(context);\n-    if (value != null) customizer.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain MutableSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(TraceContext context, MutableSpan span) {\n-    String value = getValue(context);\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  public static abstract class Updatable extends CorrelationField {\n-    /** Updates the value of the this field, or ignores if not configured. */\n-    public abstract void updateValue(TraceContext context, @Nullable String value);\n-\n-    /**\n-     * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-     *\n-     * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-     * context.\n-     */\n-    public void updateValue(String value) {\n-      TraceContext context = currentTraceContext();\n-      if (context != null) updateValue(context, value);\n-    }\n-\n-    /**\n-     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n-     * to the correlation context.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   // Assume BUSINESS_PROCESS is an updatable field\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * <h3>Appropriate Usage</h3>\n-     * This has a significant performance impact as it requires even {@link\n-     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n-     *\n-     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-     * correlation context, as they will apply on the next scope operation.\n-     */\n-    public final boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    final boolean flushOnUpdate;\n-\n-    Updatable(String name, boolean flushOnUpdate) { // package sealed\n-      super(name);\n-      this.flushOnUpdate = flushOnUpdate;\n-    }\n-  }\n-\n-  final String name, lcName;\n-\n-  CorrelationField(String name) { // sealed to this package\n-    this.name = validateName(name);\n-    this.lcName = name.toLowerCase(Locale.ROOT);\n-  }\n-\n-  @Override public String toString() {\n-    return getClass().getSimpleName() + \"{\" + name + \"}\";\n-  }\n-\n-  /** Returns true for any correlation field with the same name (case insensitive). */\n-  @Override public final boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof CorrelationField)) return false;\n-    return lcName.equals(((CorrelationField) o).lcName);\n-  }\n-\n-  /** Returns the same value for any correlation field with the same name (case insensitive). */\n-  @Override public final int hashCode() {\n-    return lcName.hashCode();\n-  }\n-\n-  static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n-\n-  @Nullable static TraceContext currentTraceContext() {\n-    Tracing tracing = Tracing.current();\n-    return tracing != null ? tracing.currentTraceContext().get() : null;\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NDk2NQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399764965", "body": "```suggestion\r\n * // Add the field \"region\", so it can be used as a log expression %X{region}\r\n```\r\n\r\nI think the example isn't our normal concept of \"extra fields\" ", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n          \n          \n            \n             * // Add the field \"region\", so it can be used as a log expression %X{region}\n          \n      \n    \n    \n  \n\nI think the example isn't our normal concept of \"extra fields\"", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> <span class=\"pl-c\"><span class=\"pl-c\">//</span> Add the <span class=\"x x-first x-last\">extra </span>field \"region\", so it can be used as a log expression %X{region}</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-c\"><span class=\"pl-c\">//</span> Add the field \"region\", so it can be used as a log expression %X{region}</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">I think the example isn't our normal concept of \"extra fields\"</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:32:32Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the extra field \"region\", so it can be used as a log expression %X{region}", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nindex d81dda6c5..38b100564 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n", "chunk": "@@ -23,37 +24,48 @@ import static java.util.Arrays.asList;\n \n /**\n  * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n- * as logging.\n+ * as logging through decoration of a scope.\n  *\n  * <p>Setup example:\n  * <pre>{@code\n  * // Allow logging patterns like %X{traceId}/%X{spanId}\n  * loggingContext = new Log4J2Context();\n  *\n- * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n- * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+ * // Add the field \"region\", so it can be used as a log expression %X{region}\n+ * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n  * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *   .addField(awsRegion)\n+ *   .addField(cloudRegion)\n  *   .build();\n  *\n  * // Integrate the decorator\n  * tracing = Tracing.newBuilder()\n  *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                    .addScopeDecorator(CorrelationFieldScopeDecorator.create(correlationContext))\n+ *                    .addScopeDecorator(decorator)\n  *                    .build()\n  *                  )\n  *                  ...\n  *                  .build();\n+ *\n+ * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n+ * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n+ * try {\n+ *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n+ *   return encoder.encode();\n+ * } catch (RuntimeException | Error e) {\n+ *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n+ *   throw e;\n+ * } finally {\n+ *   span.finish();\n+ * }\n  * }</pre>\n  *\n  * <h3>Extra Field integration</h3>\n  * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n  * builder here like any other correlation field. This will ensure that their values are applied and\n- * reverted upon scope decoration. You can also configure {@link ExtraFieldPropagation.FactoryBuilder#flushValuesToContext(CorrelationField.Context)}\n- * so that values updates reflect immediately in the {@link CorrelationField.Context}.\n+ * reverted upon scope decoration.\n  *\n  * @see CorrelationField\n- * @see CorrelationField.Context\n+ * @see CorrelationContext\n  * @see ExtraField.Builder#withCorrelation()\n  * @since 5.11\n  */\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nindex 38b100564..e9dd72c3a 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n", "chunk": "@@ -70,26 +72,8 @@ import static java.util.Arrays.asList;\n  * @since 5.11\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n-  /**\n-   * Initializes the builder with the standard fields: {@link CorrelationFields#TRACE_ID}, {@link\n-   * CorrelationFields#PARENT_ID}, {@link CorrelationFields#SPAN_ID} and {@link\n-   * CorrelationFields#SAMPLED}.\n-   *\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(CorrelationContext context) {\n-    return new Builder(context);\n-  }\n-\n-  /**\n-   * @see #newBuilder(CorrelationContext)\n-   * @since 5.11\n-   */\n-  public static ScopeDecorator create(CorrelationContext context) {\n-    return new Builder(context).build();\n-  }\n-\n-  public static final class Builder {\n+  // do not define newBuilder or create() here as it will mask subtypes\n+  public static abstract class Builder {\n     final CorrelationContext context;\n     final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n       CorrelationFields.TRACE_ID,\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\nsimilarity index 85%\nrename from brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nrename to brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\nindex e9dd72c3a..31b145671 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\n", "chunk": "@@ -61,31 +56,28 @@ import static java.util.Arrays.asList;\n  * }\n  * }</pre>\n  *\n- * <h3>Extra Field integration</h3>\n- * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n- * builder here like any other correlation field. This will ensure that their values are applied and\n- * reverted upon scope decoration.\n+ * <h3>Visibility</h3>\n+ * <p>By default, field updates only apply during {@linkplain CorrelationScopeDecorator scope\n+ * decoration}. This means values set do not flush immediately to the underlying correlation\n+ * context. Rather, they are scheduled for the next scope operation as a way to control overhead.\n+ * {@link Updatable#flushOnUpdate()} overrides this.\n  *\n  * @see CorrelationField\n- * @see CorrelationContext\n- * @see ExtraField.Builder#withCorrelation()\n  * @since 5.11\n  */\n-public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+public abstract class CorrelationScopeDecorator implements ScopeDecorator {\n+  /** Defaults to {@link CorrelationFields#TRACE_ID} and {@link CorrelationFields#SPAN_ID}. */\n   // do not define newBuilder or create() here as it will mask subtypes\n   public static abstract class Builder {\n     final CorrelationContext context;\n-    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n-      CorrelationFields.TRACE_ID,\n-      CorrelationFields.PARENT_ID,\n-      CorrelationFields.SPAN_ID,\n-      CorrelationFields.SAMPLED\n-    ));\n+    final Set<CorrelationField> fields = new LinkedHashSet<>();\n \n     /** Internal constructor used by subtypes. */\n     protected Builder(CorrelationContext context) {\n       if (context == null) throw new NullPointerException(\"context == null\");\n       this.context = context;\n+      fields.add(CorrelationFields.TRACE_ID);\n+      fields.add(CorrelationFields.SPAN_ID);\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NTE0MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399765141", "body": "```suggestion\r\n * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\r\n * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\r\n *   .addField(cloudRegion)\r\n *   .build();\r\n```\r\n\r\nProbably good to be more generic", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n          \n          \n            \n             * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n          \n          \n            \n             *   .addField(awsRegion)\n          \n          \n            \n             *   .build();\n          \n          \n            \n             * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n          \n          \n            \n             * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n          \n          \n            \n             *   .addField(cloudRegion)\n          \n          \n            \n             *   .build();\n          \n      \n    \n    \n  \n\nProbably good to be more generic", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> <span class=\"x x-first x-last\">awsRegion</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CorrelationFields</span><span class=\"pl-k\">.</span>constant(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>region<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>getEnv(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">AWS_REGION</span><span class=\"pl-pds\">\"</span></span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> decorator <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CorrelationFieldScopeDecorator</span><span class=\"pl-k\">.</span>newBuilder(loggingContext)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span>   .addField(<span class=\"x x-first x-last\">awsRegion</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span>   .build();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"x x-first x-last\">cloudRegion</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CorrelationFields</span><span class=\"pl-k\">.</span>constant(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>region<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>getEnv(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">CLOUD_REGION</span><span class=\"pl-pds\">\"</span></span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> decorator <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CorrelationFieldScopeDecorator</span><span class=\"pl-k\">.</span>newBuilder(loggingContext)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span>   .addField(<span class=\"x x-first x-last\">cloudRegion</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span>   .build();</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">Probably good to be more generic</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:34:01Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n+ * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(awsRegion)\n+ *   .build();", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nindex d81dda6c5..38b100564 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n", "chunk": "@@ -23,37 +24,48 @@ import static java.util.Arrays.asList;\n \n /**\n  * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n- * as logging.\n+ * as logging through decoration of a scope.\n  *\n  * <p>Setup example:\n  * <pre>{@code\n  * // Allow logging patterns like %X{traceId}/%X{spanId}\n  * loggingContext = new Log4J2Context();\n  *\n- * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n- * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+ * // Add the field \"region\", so it can be used as a log expression %X{region}\n+ * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n  * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *   .addField(awsRegion)\n+ *   .addField(cloudRegion)\n  *   .build();\n  *\n  * // Integrate the decorator\n  * tracing = Tracing.newBuilder()\n  *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                    .addScopeDecorator(CorrelationFieldScopeDecorator.create(correlationContext))\n+ *                    .addScopeDecorator(decorator)\n  *                    .build()\n  *                  )\n  *                  ...\n  *                  .build();\n+ *\n+ * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n+ * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n+ * try {\n+ *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n+ *   return encoder.encode();\n+ * } catch (RuntimeException | Error e) {\n+ *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n+ *   throw e;\n+ * } finally {\n+ *   span.finish();\n+ * }\n  * }</pre>\n  *\n  * <h3>Extra Field integration</h3>\n  * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n  * builder here like any other correlation field. This will ensure that their values are applied and\n- * reverted upon scope decoration. You can also configure {@link ExtraFieldPropagation.FactoryBuilder#flushValuesToContext(CorrelationField.Context)}\n- * so that values updates reflect immediately in the {@link CorrelationField.Context}.\n+ * reverted upon scope decoration.\n  *\n  * @see CorrelationField\n- * @see CorrelationField.Context\n+ * @see CorrelationContext\n  * @see ExtraField.Builder#withCorrelation()\n  * @since 5.11\n  */\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nindex 38b100564..e9dd72c3a 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n", "chunk": "@@ -70,26 +72,8 @@ import static java.util.Arrays.asList;\n  * @since 5.11\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n-  /**\n-   * Initializes the builder with the standard fields: {@link CorrelationFields#TRACE_ID}, {@link\n-   * CorrelationFields#PARENT_ID}, {@link CorrelationFields#SPAN_ID} and {@link\n-   * CorrelationFields#SAMPLED}.\n-   *\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(CorrelationContext context) {\n-    return new Builder(context);\n-  }\n-\n-  /**\n-   * @see #newBuilder(CorrelationContext)\n-   * @since 5.11\n-   */\n-  public static ScopeDecorator create(CorrelationContext context) {\n-    return new Builder(context).build();\n-  }\n-\n-  public static final class Builder {\n+  // do not define newBuilder or create() here as it will mask subtypes\n+  public static abstract class Builder {\n     final CorrelationContext context;\n     final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n       CorrelationFields.TRACE_ID,\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\nsimilarity index 85%\nrename from brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nrename to brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\nindex e9dd72c3a..31b145671 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\n", "chunk": "@@ -61,31 +56,28 @@ import static java.util.Arrays.asList;\n  * }\n  * }</pre>\n  *\n- * <h3>Extra Field integration</h3>\n- * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n- * builder here like any other correlation field. This will ensure that their values are applied and\n- * reverted upon scope decoration.\n+ * <h3>Visibility</h3>\n+ * <p>By default, field updates only apply during {@linkplain CorrelationScopeDecorator scope\n+ * decoration}. This means values set do not flush immediately to the underlying correlation\n+ * context. Rather, they are scheduled for the next scope operation as a way to control overhead.\n+ * {@link Updatable#flushOnUpdate()} overrides this.\n  *\n  * @see CorrelationField\n- * @see CorrelationContext\n- * @see ExtraField.Builder#withCorrelation()\n  * @since 5.11\n  */\n-public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+public abstract class CorrelationScopeDecorator implements ScopeDecorator {\n+  /** Defaults to {@link CorrelationFields#TRACE_ID} and {@link CorrelationFields#SPAN_ID}. */\n   // do not define newBuilder or create() here as it will mask subtypes\n   public static abstract class Builder {\n     final CorrelationContext context;\n-    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n-      CorrelationFields.TRACE_ID,\n-      CorrelationFields.PARENT_ID,\n-      CorrelationFields.SPAN_ID,\n-      CorrelationFields.SAMPLED\n-    ));\n+    final Set<CorrelationField> fields = new LinkedHashSet<>();\n \n     /** Internal constructor used by subtypes. */\n     protected Builder(CorrelationContext context) {\n       if (context == null) throw new NullPointerException(\"context == null\");\n       this.context = context;\n+      fields.add(CorrelationFields.TRACE_ID);\n+      fields.add(CorrelationFields.SPAN_ID);\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NTQ5MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399765491", "body": "```suggestion\r\n     * <p>Defaults may include a field you aren't using, such as \"parentId\". For best\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <p>Defaults may include a field you aren't using, such as \"parentId\". For better\n          \n          \n            \n                 * <p>Defaults may include a field you aren't using, such as \"parentId\". For best", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">&lt;</span>p<span class=\"pl-k\">&gt;</span><span class=\"pl-smi\">Defaults</span> may include a field you aren<span class=\"pl-s\"><span class=\"pl-pds\">'</span>t using, such as \"parentId\". For <span class=\"x x-first x-last\">better</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">&lt;</span>p<span class=\"pl-k\">&gt;</span><span class=\"pl-smi\">Defaults</span> may include a field you aren<span class=\"pl-s\"><span class=\"pl-pds\">'</span>t using, such as \"parentId\". For <span class=\"x x-first x-last\">best</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-29T08:38:06Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n+ * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(awsRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(CorrelationFieldScopeDecorator.create(correlationContext))\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ * }</pre>\n+ *\n+ * <h3>Extra Field integration</h3>\n+ * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n+ * builder here like any other correlation field. This will ensure that their values are applied and\n+ * reverted upon scope decoration. You can also configure {@link ExtraFieldPropagation.FactoryBuilder#flushValuesToContext(CorrelationField.Context)}\n+ * so that values updates reflect immediately in the {@link CorrelationField.Context}.\n+ *\n+ * @see CorrelationField\n+ * @see CorrelationField.Context\n+ * @see ExtraField.Builder#withCorrelation()\n+ * @since 5.11\n+ */\n+public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  /**\n+   * Initializes the builder with the standard fields: {@link CorrelationFields#TRACE_ID}, {@link\n+   * CorrelationFields#PARENT_ID}, {@link CorrelationFields#SPAN_ID} and {@link\n+   * CorrelationFields#SAMPLED}.\n+   *\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(CorrelationField.Context context) {\n+    return new Builder(context);\n+  }\n+\n+  /**\n+   * @see #newBuilder(CorrelationField.Context)\n+   * @since 5.11\n+   */\n+  public static ScopeDecorator create(CorrelationField.Context context) {\n+    return new Builder(context).build();\n+  }\n+\n+  public static final class Builder {\n+    final CorrelationField.Context context;\n+    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n+      CorrelationFields.TRACE_ID,\n+      CorrelationFields.PARENT_ID,\n+      CorrelationFields.SPAN_ID,\n+      CorrelationFields.SAMPLED\n+    ));\n+\n+    Builder(CorrelationField.Context context) {\n+      if (context == null) throw new NullPointerException(\"context == null\");\n+      this.context = context;\n+    }\n+\n+    /**\n+     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n+     * ones you need}.\n+     *\n+     * <p>Defaults may include a field you aren't using, such as \"parentId\". For better", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nindex d81dda6c5..38b100564 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n", "chunk": "@@ -95,7 +107,7 @@ public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n      * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n      * ones you need}.\n      *\n-     * <p>Defaults may include a field you aren't using, such as \"parentId\". For better\n+     * <p>Defaults may include a field you aren't using, such as \"parentId\". For best\n      * performance, only include the fields you use in your correlation expressions (such as log\n      * formats).\n      *\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\ndeleted file mode 100644\nindex 38b100564..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ /dev/null\n", "chunk": "@@ -1,260 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.CorrelationContext;\n-import brave.internal.Nullable;\n-import brave.propagation.CurrentTraceContext.Scope;\n-import brave.propagation.CurrentTraceContext.ScopeDecorator;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n- * as logging through decoration of a scope.\n- *\n- * <p>Setup example:\n- * <pre>{@code\n- * // Allow logging patterns like %X{traceId}/%X{spanId}\n- * loggingContext = new Log4J2Context();\n- *\n- * // Add the field \"region\", so it can be used as a log expression %X{region}\n- * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *   .addField(cloudRegion)\n- *   .build();\n- *\n- * // Integrate the decorator\n- * tracing = Tracing.newBuilder()\n- *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                    .addScopeDecorator(decorator)\n- *                    .build()\n- *                  )\n- *                  ...\n- *                  .build();\n- *\n- * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n- * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n- * try {\n- *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n- *   return encoder.encode();\n- * } catch (RuntimeException | Error e) {\n- *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n- *   throw e;\n- * } finally {\n- *   span.finish();\n- * }\n- * }</pre>\n- *\n- * <h3>Extra Field integration</h3>\n- * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n- * builder here like any other correlation field. This will ensure that their values are applied and\n- * reverted upon scope decoration.\n- *\n- * @see CorrelationField\n- * @see CorrelationContext\n- * @see ExtraField.Builder#withCorrelation()\n- * @since 5.11\n- */\n-public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n-  /**\n-   * Initializes the builder with the standard fields: {@link CorrelationFields#TRACE_ID}, {@link\n-   * CorrelationFields#PARENT_ID}, {@link CorrelationFields#SPAN_ID} and {@link\n-   * CorrelationFields#SAMPLED}.\n-   *\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(CorrelationContext context) {\n-    return new Builder(context);\n-  }\n-\n-  /**\n-   * @see #newBuilder(CorrelationContext)\n-   * @since 5.11\n-   */\n-  public static ScopeDecorator create(CorrelationContext context) {\n-    return new Builder(context).build();\n-  }\n-\n-  public static final class Builder {\n-    final CorrelationContext context;\n-    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n-      CorrelationFields.TRACE_ID,\n-      CorrelationFields.PARENT_ID,\n-      CorrelationFields.SPAN_ID,\n-      CorrelationFields.SAMPLED\n-    ));\n-\n-    Builder(CorrelationContext context) {\n-      if (context == null) throw new NullPointerException(\"context == null\");\n-      this.context = context;\n-    }\n-\n-    /**\n-     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n-     * ones you need}.\n-     *\n-     * <p>Defaults may include a field you aren't using, such as \"parentId\". For best\n-     * performance, only include the fields you use in your correlation expressions (such as log\n-     * formats).\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearFields() {\n-      this.fields.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addField(CorrelationField field) {\n-      if (field == null) throw new NullPointerException(\"field == null\");\n-      if (field.name() == null) throw new NullPointerException(\"field.name() == null\");\n-      if (field.name().isEmpty()) throw new NullPointerException(\"field.name() isEmpty\");\n-      fields.add(field);\n-      return this;\n-    }\n-\n-    /** @throws IllegalArgumentException if no correlation fields were added. */\n-    public final CorrelationFieldScopeDecorator build() {\n-      int fieldCount = fields.size();\n-      if (fieldCount == 0) throw new IllegalArgumentException(\"no correlation fields\");\n-      if (fieldCount == 1) {\n-        return new Single(context, fields.iterator().next());\n-      }\n-      return new Multiple(context, fields);\n-    }\n-  }\n-\n-  final CorrelationContext context;\n-\n-  CorrelationFieldScopeDecorator(CorrelationContext context) {\n-    this.context = context;\n-  }\n-\n-  // Users generally expect data to be \"cleaned up\" when a scope completes, even if it was written\n-  // mid-scope. Ex. https://github.com/spring-cloud/spring-cloud-sleuth/issues/1416\n-  //\n-  // This means we cannot return a no-op scope based on if we detect no change when comparing\n-  // values up front. Hence, we save off the first value and revert when a scope closes. If a late\n-  // update changed the value mid-scope, it will reverted.\n-  void updateUnconditionally(CorrelationField field, @Nullable String newValue) {\n-    if (newValue != null) {\n-      context.put(field.name(), newValue);\n-    } else {\n-      context.remove(field.name());\n-    }\n-  }\n-\n-  static final class Single extends CorrelationFieldScopeDecorator {\n-    final CorrelationField field;\n-\n-    Single(CorrelationContext context, CorrelationField field) {\n-      super(context);\n-      this.field = field;\n-    }\n-\n-    @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      String valueToRevert = context.get(field.name());\n-      String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n-\n-      if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n-\n-      // Only the value to revert is saved off in order to save overhead.\n-      return new SingleCorrelationFieldScope(scope, valueToRevert);\n-    }\n-\n-    final class SingleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n-      final Scope delegate;\n-      final @Nullable String valueToRevert;\n-\n-      SingleCorrelationFieldScope(Scope delegate, @Nullable String valueToRevert) {\n-        this.delegate = delegate;\n-        this.valueToRevert = valueToRevert;\n-      }\n-\n-      @Override public void close() {\n-        delegate.close();\n-        updateUnconditionally(field, valueToRevert);\n-      }\n-\n-      @Override public void update(CorrelationField field, String value) {\n-        if (!field.equals(Single.this.field)) return;\n-        updateUnconditionally(field, value);\n-      }\n-    }\n-  }\n-\n-  // TODO: put this in a thread local, and use in extra field propagation. Watch for overlaps\n-  // Ex look at how ThreadlocalSpan works.\n-  interface CorrelationFieldUpdater {\n-    void update(CorrelationField field, String value);\n-  }\n-\n-  static final class Multiple extends CorrelationFieldScopeDecorator {\n-    final CorrelationField[] fields;\n-\n-    Multiple(CorrelationContext context, Set<CorrelationField> correlationFields) {\n-      super(context);\n-      fields = correlationFields.toArray(new CorrelationField[0]);\n-    }\n-\n-    @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      // Only values to revert are saved off in order to save overhead.\n-      String[] valuesToRevert = new String[fields.length];\n-      for (int i = 0; i < fields.length; i++) {\n-        CorrelationField field = fields[i];\n-        String valueToRevert = context.get(field.name());\n-        String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n-\n-        if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n-\n-        valuesToRevert[i] = valueToRevert;\n-      }\n-\n-      return new MultipleCorrelationFieldScope(scope, valuesToRevert);\n-    }\n-\n-    final class MultipleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n-      final Scope delegate;\n-      final String[] valuesToRevert;\n-\n-      MultipleCorrelationFieldScope(Scope delegate, String[] valuesToRevert) {\n-        this.delegate = delegate;\n-        this.valuesToRevert = valuesToRevert;\n-      }\n-\n-      @Override public void close() {\n-        delegate.close();\n-        for (int i = 0; i < fields.length; i++) {\n-          updateUnconditionally(fields[i], valuesToRevert[i]);\n-        }\n-      }\n-\n-      @Override public void update(CorrelationField field, String value) {\n-        for (int i = 0; i < fields.length; i++) {\n-          if (field.equals(fields[i])) {\n-            updateUnconditionally(field, value);\n-            return;\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  static boolean equals(@Nullable String a, @Nullable String b) {\n-    return a == null ? b == null : a.equals(b); // Java 6 can't use Objects.equals()\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjI3MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399766270", "body": "```suggestion\r\n      String currentValue = update(traceContext, field, previousValue);\r\n      if (currentValue == null) {\r\n        return scope;\r\n      }\r\n\r\n      class SingleCorrelationFieldScope implements Scope {\r\n        @Override public void close() {\r\n          scope.close();\r\n          replace(field.name(), previousValue, currentValue);\r\n        }\r\n      }\r\n```\r\n\r\nJust an example of what it might look like to pass current value in when closing a scope if it seems useful. `replace` would check to make sure the current value is `currentValue` since if it isn't, the scope was closed in the wrong order - happens in reactive apps sometimes \ud83d\ude22 But admittedly having a check like this only for correlation scopes and not our more important ones is probably not so helpful either.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!update(traceContext, field, previousValue)) {\n          \n          \n            \n                    return scope;\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  class SingleCorrelationFieldScope implements Scope {\n          \n          \n            \n                    @Override public void close() {\n          \n          \n            \n                      scope.close();\n          \n          \n            \n                      replace(field.name(), previousValue);\n          \n          \n            \n                    }\n          \n          \n            \n                  }\n          \n          \n            \n                  String currentValue = update(traceContext, field, previousValue);\n          \n          \n            \n                  if (currentValue == null) {\n          \n          \n            \n                    return scope;\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  class SingleCorrelationFieldScope implements Scope {\n          \n          \n            \n                    @Override public void close() {\n          \n          \n            \n                      scope.close();\n          \n          \n            \n                      replace(field.name(), previousValue, currentValue);\n          \n          \n            \n                    }\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nJust an example of what it might look like to pass current value in when closing a scope if it seems useful. replace would check to make sure the current value is currentValue since if it isn't, the scope was closed in the wrong order - happens in reactive apps sometimes \ud83d\ude22 But admittedly having a check like this only for correlation scopes and not our more important ones is probably not so helpful either.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>update(traceContext, field, previousValue)) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> scope;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\">class</span> <span class=\"pl-en\">SingleCorrelationFieldScope</span> <span class=\"pl-k\">implements</span> <span class=\"pl-e\">Scope</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">@Override</span> <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> close() {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          scope<span class=\"pl-k\">.</span>close();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">          replace(field<span class=\"pl-k\">.</span>name(), previousValue);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-smi\">String</span> currentValue <span class=\"pl-k\">=</span> update(traceContext, field, previousValue);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">if</span> (currentValue <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> scope;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">class</span> <span class=\"pl-en\">SingleCorrelationFieldScope</span> <span class=\"pl-k\">implements</span> <span class=\"pl-e\">Scope</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">@Override</span> <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> close() {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          scope<span class=\"pl-k\">.</span>close();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">          replace(field<span class=\"pl-k\">.</span>name(), previousValue, currentValue);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">Just an example of what it might look like to pass current value in when closing a scope if it seems useful. <code>replace</code> would check to make sure the current value is <code>currentValue</code> since if it isn't, the scope was closed in the wrong order - happens in reactive apps sometimes <g-emoji class=\"g-emoji\" alias=\"cry\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f622.png\">\ud83d\ude22</g-emoji> But admittedly having a check like this only for correlation scopes and not our more important ones is probably not so helpful either.</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:45:54Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the extra field \"region\", so it can be used as a log expression %X{region}\n+ * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(awsRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(CorrelationFieldScopeDecorator.create(correlationContext))\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ * }</pre>\n+ *\n+ * <h3>Extra Field integration</h3>\n+ * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n+ * builder here like any other correlation field. This will ensure that their values are applied and\n+ * reverted upon scope decoration. You can also configure {@link ExtraFieldPropagation.FactoryBuilder#flushValuesToContext(CorrelationField.Context)}\n+ * so that values updates reflect immediately in the {@link CorrelationField.Context}.\n+ *\n+ * @see CorrelationField\n+ * @see CorrelationField.Context\n+ * @see ExtraField.Builder#withCorrelation()\n+ * @since 5.11\n+ */\n+public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  /**\n+   * Initializes the builder with the standard fields: {@link CorrelationFields#TRACE_ID}, {@link\n+   * CorrelationFields#PARENT_ID}, {@link CorrelationFields#SPAN_ID} and {@link\n+   * CorrelationFields#SAMPLED}.\n+   *\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(CorrelationField.Context context) {\n+    return new Builder(context);\n+  }\n+\n+  /**\n+   * @see #newBuilder(CorrelationField.Context)\n+   * @since 5.11\n+   */\n+  public static ScopeDecorator create(CorrelationField.Context context) {\n+    return new Builder(context).build();\n+  }\n+\n+  public static final class Builder {\n+    final CorrelationField.Context context;\n+    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n+      CorrelationFields.TRACE_ID,\n+      CorrelationFields.PARENT_ID,\n+      CorrelationFields.SPAN_ID,\n+      CorrelationFields.SAMPLED\n+    ));\n+\n+    Builder(CorrelationField.Context context) {\n+      if (context == null) throw new NullPointerException(\"context == null\");\n+      this.context = context;\n+    }\n+\n+    /**\n+     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n+     * ones you need}.\n+     *\n+     * <p>Defaults may include a field you aren't using, such as \"parentId\". For better\n+     * performance, only include the fields you use in your correlation expressions (such as log\n+     * formats).\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearFields() {\n+      this.fields.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addField(CorrelationField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      if (field.name() == null) throw new NullPointerException(\"field.name() == null\");\n+      if (field.name().isEmpty()) throw new NullPointerException(\"field.name() isEmpty\");\n+      fields.add(field);\n+      return this;\n+    }\n+\n+    /** @throws IllegalArgumentException if no correlation fields were added. */\n+    public final CorrelationFieldScopeDecorator build() {\n+      int fieldCount = fields.size();\n+      if (fieldCount == 0) throw new IllegalArgumentException(\"no correlation fields\");\n+      if (fieldCount == 1) {\n+        return new Single(context, fields.iterator().next());\n+      }\n+      return new Multiple(context, fields);\n+    }\n+  }\n+\n+  final CorrelationField.Context context;\n+\n+  CorrelationFieldScopeDecorator(CorrelationField.Context context) {\n+    this.context = context;\n+  }\n+\n+  boolean update(@Nullable TraceContext traceContext, CorrelationField field,\n+    String previousValue) {\n+    String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n+    if (currentValue != null) {\n+      if (!currentValue.equals(previousValue)) {\n+        context.put(field.name(), currentValue);\n+        return true;\n+      }\n+    } else if (previousValue != null) {\n+      context.remove(field.name());\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  void replace(String name, @Nullable String value) {\n+    if (value != null) {\n+      context.put(name, value);\n+    } else {\n+      context.remove(name);\n+    }\n+  }\n+\n+  static final class Single extends CorrelationFieldScopeDecorator {\n+    final CorrelationField field;\n+\n+    Single(CorrelationField.Context context, CorrelationField field) {\n+      super(context);\n+      this.field = field;\n+    }\n+\n+    @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n+      if (scope == Scope.NOOP) return scope;\n+\n+      String previousValue = context.get(field.name());\n+      if (!update(traceContext, field, previousValue)) {\n+        return scope;\n+      }\n+\n+      class SingleCorrelationFieldScope implements Scope {\n+        @Override public void close() {\n+          scope.close();\n+          replace(field.name(), previousValue);\n+        }\n+      }", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NjU5OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399786598", "bodyText": "made a comment elsewhere, but to read back the current value is expensive. also we allow late updates. finally we do want to clobber out of band updates because MDC can be used externally", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjI3MA=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nindex d81dda6c5..38b100564 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n", "chunk": "@@ -126,94 +138,123 @@ public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n     }\n   }\n \n-  final CorrelationField.Context context;\n+  final CorrelationContext context;\n \n-  CorrelationFieldScopeDecorator(CorrelationField.Context context) {\n+  CorrelationFieldScopeDecorator(CorrelationContext context) {\n     this.context = context;\n   }\n \n-  boolean update(@Nullable TraceContext traceContext, CorrelationField field,\n-    String previousValue) {\n-    String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n-    if (currentValue != null) {\n-      if (!currentValue.equals(previousValue)) {\n-        context.put(field.name(), currentValue);\n-        return true;\n-      }\n-    } else if (previousValue != null) {\n-      context.remove(field.name());\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  void replace(String name, @Nullable String value) {\n-    if (value != null) {\n-      context.put(name, value);\n+  // Users generally expect data to be \"cleaned up\" when a scope completes, even if it was written\n+  // mid-scope. Ex. https://github.com/spring-cloud/spring-cloud-sleuth/issues/1416\n+  //\n+  // This means we cannot return a no-op scope based on if we detect no change when comparing\n+  // values up front. Hence, we save off the first value and revert when a scope closes. If a late\n+  // update changed the value mid-scope, it will reverted.\n+  void updateUnconditionally(CorrelationField field, @Nullable String newValue) {\n+    if (newValue != null) {\n+      context.put(field.name(), newValue);\n     } else {\n-      context.remove(name);\n+      context.remove(field.name());\n     }\n   }\n \n   static final class Single extends CorrelationFieldScopeDecorator {\n     final CorrelationField field;\n \n-    Single(CorrelationField.Context context, CorrelationField field) {\n+    Single(CorrelationContext context, CorrelationField field) {\n       super(context);\n       this.field = field;\n     }\n \n     @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      if (scope == Scope.NOOP) return scope;\n+      String valueToRevert = context.get(field.name());\n+      String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n+\n+      if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n \n-      String previousValue = context.get(field.name());\n-      if (!update(traceContext, field, previousValue)) {\n-        return scope;\n+      // Only the value to revert is saved off in order to save overhead.\n+      return new SingleCorrelationFieldScope(scope, valueToRevert);\n+    }\n+\n+    final class SingleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n+      final Scope delegate;\n+      final @Nullable String valueToRevert;\n+\n+      SingleCorrelationFieldScope(Scope delegate, @Nullable String valueToRevert) {\n+        this.delegate = delegate;\n+        this.valueToRevert = valueToRevert;\n       }\n \n-      class SingleCorrelationFieldScope implements Scope {\n-        @Override public void close() {\n-          scope.close();\n-          replace(field.name(), previousValue);\n-        }\n+      @Override public void close() {\n+        delegate.close();\n+        updateUnconditionally(field, valueToRevert);\n+      }\n+\n+      @Override public void update(CorrelationField field, String value) {\n+        if (!field.equals(Single.this.field)) return;\n+        updateUnconditionally(field, value);\n       }\n-      return new SingleCorrelationFieldScope();\n     }\n   }\n \n+  // TODO: put this in a thread local, and use in extra field propagation. Watch for overlaps\n+  // Ex look at how ThreadlocalSpan works.\n+  interface CorrelationFieldUpdater {\n+    void update(CorrelationField field, String value);\n+  }\n+\n   static final class Multiple extends CorrelationFieldScopeDecorator {\n     final CorrelationField[] fields;\n \n-    Multiple(CorrelationField.Context context, Set<CorrelationField> correlationFields) {\n+    Multiple(CorrelationContext context, Set<CorrelationField> correlationFields) {\n       super(context);\n       fields = correlationFields.toArray(new CorrelationField[0]);\n     }\n \n     @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      if (scope == Scope.NOOP) return scope;\n-\n-      String[] previousValues = new String[fields.length];\n-      boolean changed = false;\n+      // Only values to revert are saved off in order to save overhead.\n+      String[] valuesToRevert = new String[fields.length];\n       for (int i = 0; i < fields.length; i++) {\n         CorrelationField field = fields[i];\n-        String previousValue = context.get(field.name());\n-        if (update(traceContext, field, previousValue)) {\n-          changed = true;\n-        }\n-        previousValues[i] = previousValue;\n+        String valueToRevert = context.get(field.name());\n+        String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n+\n+        if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n+\n+        valuesToRevert[i] = valueToRevert;\n+      }\n+\n+      return new MultipleCorrelationFieldScope(scope, valuesToRevert);\n+    }\n+\n+    final class MultipleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n+      final Scope delegate;\n+      final String[] valuesToRevert;\n+\n+      MultipleCorrelationFieldScope(Scope delegate, String[] valuesToRevert) {\n+        this.delegate = delegate;\n+        this.valuesToRevert = valuesToRevert;\n       }\n \n-      if (!changed) return scope;\n+      @Override public void close() {\n+        delegate.close();\n+        for (int i = 0; i < fields.length; i++) {\n+          updateUnconditionally(fields[i], valuesToRevert[i]);\n+        }\n+      }\n \n-      class MultipleCorrelationFieldScope implements Scope {\n-        @Override public void close() {\n-          scope.close();\n-          for (int i = 0; i < fields.length; i++) {\n-            replace(fields[i].name(), previousValues[i]);\n+      @Override public void update(CorrelationField field, String value) {\n+        for (int i = 0; i < fields.length; i++) {\n+          if (field.equals(fields[i])) {\n+            updateUnconditionally(field, value);\n+            return;\n           }\n         }\n       }\n-      return new MultipleCorrelationFieldScope();\n     }\n   }\n+\n+  static boolean equals(@Nullable String a, @Nullable String b) {\n+    return a == null ? b == null : a.equals(b); // Java 6 can't use Objects.equals()\n+  }\n }\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nindex 38b100564..e9dd72c3a 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n", "chunk": "@@ -212,49 +279,81 @@ public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n     }\n \n     @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      // Only values to revert are saved off in order to save overhead.\n+      int dirty = 0, flushOnUpdate = 0;\n       String[] valuesToRevert = new String[fields.length];\n       for (int i = 0; i < fields.length; i++) {\n         CorrelationField field = fields[i];\n+        boolean fieldUpdatable = field instanceof Updatable;\n         String valueToRevert = context.get(field.name());\n         String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n \n-        if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n+        if (scope != Scope.NOOP || fieldUpdatable) {\n+          if (!equal(valueToRevert, currentValue)) {\n+            update(context, field, currentValue);\n+            dirty = set(dirty, i);\n+          }\n+        }\n+\n+        if (fieldUpdatable && ((Updatable) field).flushOnUpdate()) {\n+          flushOnUpdate = set(flushOnUpdate, i);\n+        }\n \n         valuesToRevert[i] = valueToRevert;\n       }\n \n-      return new MultipleCorrelationFieldScope(scope, valuesToRevert);\n-    }\n+      // If there was or could be a value update, we need to track the value to revert.\n+      if (dirty != 0 || flushOnUpdate != 0) {\n+        return new MultipleCorrelationFieldScope(scope, context, fields, valuesToRevert, dirty);\n+      }\n \n-    final class MultipleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n-      final Scope delegate;\n-      final String[] valuesToRevert;\n+      return scope;\n+    }\n+  }\n \n-      MultipleCorrelationFieldScope(Scope delegate, String[] valuesToRevert) {\n-        this.delegate = delegate;\n-        this.valuesToRevert = valuesToRevert;\n-      }\n+  static final class MultipleCorrelationFieldScope extends CorrelationFieldScope {\n+    final CorrelationField[] fields;\n+    final String[] valuesToRevert;\n+    int dirty;\n+\n+    MultipleCorrelationFieldScope(\n+      Scope delegate,\n+      CorrelationContext context,\n+      CorrelationField[] fields,\n+      String[] valuesToRevert,\n+      int dirty\n+    ) {\n+      super(delegate, context);\n+      this.fields = fields;\n+      this.valuesToRevert = valuesToRevert;\n+      this.dirty = dirty;\n+    }\n \n-      @Override public void close() {\n-        delegate.close();\n-        for (int i = 0; i < fields.length; i++) {\n-          updateUnconditionally(fields[i], valuesToRevert[i]);\n-        }\n+    @Override public void close() {\n+      super.close();\n+      for (int i = 0; i < fields.length; i++) {\n+        if (isSet(dirty, i)) update(context, fields[i], valuesToRevert[i]);\n       }\n+    }\n \n-      @Override public void update(CorrelationField field, String value) {\n-        for (int i = 0; i < fields.length; i++) {\n-          if (field.equals(fields[i])) {\n-            updateUnconditionally(field, value);\n-            return;\n-          }\n+    @Override void handleUpdate(Updatable field, String value) {\n+      for (int i = 0; i < fields.length; i++) {\n+        if (fields[i].equals(field)) {\n+          if (!equal(value, valuesToRevert[i])) dirty = set(dirty, i);\n+          return;\n         }\n       }\n     }\n   }\n \n-  static boolean equals(@Nullable String a, @Nullable String b) {\n+  static int set(int bitset, int i) {\n+    return bitset | (1 << i);\n+  }\n+\n+  static boolean isSet(int bitset, int i) {\n+    return (bitset & (1 << i)) != 0;\n+  }\n+\n+  static boolean equal(@Nullable String a, @Nullable String b) {\n     return a == null ? b == null : a.equals(b); // Java 6 can't use Objects.equals()\n   }\n }\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\nsimilarity index 85%\nrename from brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nrename to brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\nindex e9dd72c3a..31b145671 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\n", "chunk": "@@ -353,7 +345,7 @@ public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n     return (bitset & (1 << i)) != 0;\n   }\n \n-  static boolean equal(@Nullable String a, @Nullable String b) {\n+  static boolean equal(@Nullable Object a, @Nullable Object b) {\n     return a == null ? b == null : a.equals(b); // Java 6 can't use Objects.equals()\n   }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjQ1Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399766457", "body": "How about naming `extract` similar to the javadoc? I find it a bit confusing with two types of contexts, the correlation context and the trace context, so using `get` with correlation context and `extract` with trace context might be a good way to define the boundaries better", "bodyText": "How about naming extract similar to the javadoc? I find it a bit confusing with two types of contexts, the correlation context and the trace context, so using get with correlation context and extract with trace context might be a good way to define the boundaries better", "bodyHTML": "<p dir=\"auto\">How about naming <code>extract</code> similar to the javadoc? I find it a bit confusing with two types of contexts, the correlation context and the trace context, so using <code>get</code> with correlation context and <code>extract</code> with trace context might be a good way to define the boundaries better</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:47:50Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Defines a field handling in a correlation context such as MDC.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement value\n+ * comparison.\n+ *\n+ * @see CorrelationFieldScopeDecorator\n+ * @since 5.11\n+ */\n+public interface CorrelationField {\n+  /** The name of this field in the correlation context. */\n+  String name();\n+\n+  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  @Nullable String getValue(TraceContext context);", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4Njc5OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399786798", "bodyText": "I'd rather use returns because it shouldn't be expensive like extract is. correlation field is in-process. updated.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NDg4NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399964884", "bodyText": "FWIW, I didn't find the confusing pattern of gets this time, so using the internal type probably resolved my original confusion.", "author": "anuraaga", "createdAt": "2020-03-30T06:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex 24df9ba5d..e69cabe8b 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -28,21 +34,28 @@ public interface CorrelationField {\n   /** The name of this field in the correlation context. */\n   String name();\n \n-  /** Extracts the value of the field named {@link #name()} in the context or null if unavailable. */\n+  /**\n+   * Returns the most recent value of the field named {@link #name()} in the context or null if\n+   * unavailable.\n+   */\n   @Nullable String getValue(TraceContext context);\n \n-  /** Dispatches methods to synchronize fields with a context such as SLF4J MDC */\n-  abstract class Context { // abstract to allow optimized methods to be added later\n+  /**\n+   * Marks a field such that updates immediately flush to the correlation context, when configured\n+   * and their corresponding trace context is current. This has a significant performance impact as\n+   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.\n+   *\n+   * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n+   * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n+   * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n+   * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n+   * correlation context, as they will apply on the next scope operation.\n+   */\n+  interface Flushable extends CorrelationField {\n     /**\n-     * Returns the correlation property of the specified name iff it is a string, or null\n-     * otherwise.\n+     * Flushes the most recent value of the field named {@link #name()} into the correlation\n+     * context, or ignores if not configured.\n      */\n-    protected abstract @Nullable String get(String name);\n-\n-    /** Replaces the correlation property of the specified name with a non-null value. */\n-    protected abstract void put(String name, String value);\n-\n-    /** Removes the correlation property of the specified name. */\n-    protected abstract void remove(String name);\n+    void flushValue();\n   }\n }\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex e69cabe8b..c665b39cc 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -40,22 +40,32 @@ public interface CorrelationField {\n    */\n   @Nullable String getValue(TraceContext context);\n \n-  /**\n-   * Marks a field such that updates immediately flush to the correlation context, when configured\n-   * and their corresponding trace context is current. This has a significant performance impact as\n-   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.\n-   *\n-   * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-   * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-   * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-   * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-   * correlation context, as they will apply on the next scope operation.\n-   */\n-  interface Flushable extends CorrelationField {\n+  interface Updatable extends CorrelationField {\n     /**\n-     * Flushes the most recent value of the field named {@link #name()} into the correlation\n-     * context, or ignores if not configured.\n+     * MCall this to immediately flush a value update to the correlation context as opposed waiting\n+     * for the next scope decoration. This has a significant performance impact as it requires even\n+     * {@link CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   // Assume BUSINESS_PROCESS is an updatable field\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     *\n+     * <h3>Appropriate Usage</h3>\n+     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n+     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n+     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n+     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n+     * correlation context, as they will apply on the next scope operation.\n+     *\n+     * @see ExtraField.CorrelationBuilder#flushOnUpdate()\n      */\n-    void flushValue();\n+    boolean flushOnUpdate();\n   }\n }\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex c665b39cc..0fde20a36 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -58,14 +155,59 @@ public interface CorrelationField {\n      * }</pre>\n      *\n      * <h3>Appropriate Usage</h3>\n+     * This has a significant performance impact as it requires even {@link\n+     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n      * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n      * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n      * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n      * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n      * correlation context, as they will apply on the next scope operation.\n-     *\n-     * @see ExtraField.CorrelationBuilder#flushOnUpdate()\n      */\n-    boolean flushOnUpdate();\n+    public final boolean flushOnUpdate() {\n+      return flushOnUpdate;\n+    }\n+\n+    final boolean flushOnUpdate;\n+\n+    Updatable(String name, boolean flushOnUpdate) { // package sealed\n+      super(name);\n+      this.flushOnUpdate = flushOnUpdate;\n+    }\n+  }\n+\n+  final String name, lcName;\n+\n+  CorrelationField(String name) { // sealed to this package\n+    this.name = validateName(name);\n+    this.lcName = name.toLowerCase(Locale.ROOT);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + name + \"}\";\n+  }\n+\n+  /** Returns true for any correlation field with the same name (case insensitive). */\n+  @Override public final boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof CorrelationField)) return false;\n+    return lcName.equals(((CorrelationField) o).lcName);\n+  }\n+\n+  /** Returns the same value for any correlation field with the same name (case insensitive). */\n+  @Override public final int hashCode() {\n+    return lcName.hashCode();\n+  }\n+\n+  static String validateName(String name) {\n+    if (name == null) throw new NullPointerException(\"name == null\");\n+    name = name.trim();\n+    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n+    return name;\n+  }\n+\n+  @Nullable static TraceContext currentTraceContext() {\n+    Tracing tracing = Tracing.current();\n+    return tracing != null ? tracing.currentTraceContext().get() : null;\n   }\n }\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\ndeleted file mode 100644\nindex 0fde20a36..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ /dev/null\n", "chunk": "@@ -1,213 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.NoopSpanCustomizer;\n-import brave.ScopedSpan;\n-import brave.Span;\n-import brave.SpanCustomizer;\n-import brave.Tracing;\n-import brave.handler.MutableSpan;\n-import brave.internal.Nullable;\n-import java.util.Locale;\n-\n-/**\n- * A possibly remote field used for correlation such as MDC via {@link CorrelationScopeDecorator}.\n- *\n- * Here's an example of a constant field, which you want to add a span tag.\n- * <pre>{@code\n- * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- *\n- * // Later, you can call below to add a tag with the field name to a span.\n- * CLOUD_REGION.tag(span);\n- * }</pre>\n- *\n- * <h3>Updatable fields</h3>\n- * {@link Updatable} fields are mutable, typically in request scope. The most common mutable field\n- * is {@linkplain BaggageField baggage}.\n- *\n- * <p>Ex. If you have access to an updatable field, you can reset its value at runtime.\n- * <pre>{@code\n- * // Later, you can call below to affect the country code of the current trace context\n- * COUNTRY_CODE.updateValue(\"FO\");\n- * String countryCode = COUNTRY_CODE.getValue();\n- * COUNTRY_CODE.tag(span);\n- * }</pre>\n- *\n- * @see CorrelationFields\n- * @see CorrelationScopeDecorator\n- * @see BaggageField\n- * @see BaggagePropagation\n- * @since 5.11\n- */\n-public abstract class CorrelationField {\n-  /**\n-   * The non-empty name of the field. Ex \"userId\".\n-   *\n-   * <p>For example, if using log correlation and with field named \"userId\", the {@linkplain\n-   * #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next\n-   * made current.\n-   *\n-   * @see CorrelationScopeDecorator\n-   */\n-  public final String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * Returns the most recent value of the field named {@link #name()} in the context or null if\n-   * unavailable.\n-   */\n-  @Nullable public abstract String getValue(TraceContext context);\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * {@linkplain ScopedSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(ScopedSpan scopedSpan) {\n-    if (scopedSpan.isNoop()) return;\n-    String value = getValue(scopedSpan.context());\n-    if (value != null) scopedSpan.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain Span#tag(String, String) tags} the value if the input is not no-op and field value\n-   * is available.\n-   */\n-  public final void tag(Span span) {\n-    if (span.isNoop()) return;\n-    String value = getValue(span.context());\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain SpanCustomizer#tag(String, String) tags} the value if the input is not no-op and\n-   * field value is available.\n-   */\n-  public final void tag(TraceContext context, SpanCustomizer customizer) {\n-    if (customizer instanceof Span) {\n-      tag((Span) customizer);\n-      return;\n-    }\n-    if (customizer == NoopSpanCustomizer.INSTANCE) return;\n-    String value = getValue(context);\n-    if (value != null) customizer.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain MutableSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(TraceContext context, MutableSpan span) {\n-    String value = getValue(context);\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  public static abstract class Updatable extends CorrelationField {\n-    /** Updates the value of the this field, or ignores if not configured. */\n-    public abstract void updateValue(TraceContext context, @Nullable String value);\n-\n-    /**\n-     * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-     *\n-     * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-     * context.\n-     */\n-    public void updateValue(String value) {\n-      TraceContext context = currentTraceContext();\n-      if (context != null) updateValue(context, value);\n-    }\n-\n-    /**\n-     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n-     * to the correlation context.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   // Assume BUSINESS_PROCESS is an updatable field\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * <h3>Appropriate Usage</h3>\n-     * This has a significant performance impact as it requires even {@link\n-     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n-     *\n-     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-     * correlation context, as they will apply on the next scope operation.\n-     */\n-    public final boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    final boolean flushOnUpdate;\n-\n-    Updatable(String name, boolean flushOnUpdate) { // package sealed\n-      super(name);\n-      this.flushOnUpdate = flushOnUpdate;\n-    }\n-  }\n-\n-  final String name, lcName;\n-\n-  CorrelationField(String name) { // sealed to this package\n-    this.name = validateName(name);\n-    this.lcName = name.toLowerCase(Locale.ROOT);\n-  }\n-\n-  @Override public String toString() {\n-    return getClass().getSimpleName() + \"{\" + name + \"}\";\n-  }\n-\n-  /** Returns true for any correlation field with the same name (case insensitive). */\n-  @Override public final boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof CorrelationField)) return false;\n-    return lcName.equals(((CorrelationField) o).lcName);\n-  }\n-\n-  /** Returns the same value for any correlation field with the same name (case insensitive). */\n-  @Override public final int hashCode() {\n-    return lcName.hashCode();\n-  }\n-\n-  static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n-\n-  @Nullable static TraceContext currentTraceContext() {\n-    Tracing tracing = Tracing.current();\n-    return tracing != null ? tracing.currentTraceContext().get() : null;\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2Njc5MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399766791", "body": "Is this supposed to say `#TRACE_ID`. Though not sure I agree - some might find it enough to use this as a request ID in their systems without actually tying into tracing.", "bodyText": "Is this supposed to say #TRACE_ID. Though not sure I agree - some might find it enough to use this as a request ID in their systems without actually tying into tracing.", "bodyHTML": "<p dir=\"auto\">Is this supposed to say <code>#TRACE_ID</code>. Though not sure I agree - some might find it enough to use this as a request ID in their systems without actually tying into tracing.</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:50:59Z", "path": "brave/src/main/java/brave/propagation/CorrelationFields.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Standard fields defined for a correlation context such as MDC.\n+ *\n+ * @since 5.11\n+ */\n+public final class CorrelationFields {\n+  /**\n+   * This is the most common log correlation field.\n+   *\n+   * @see TraceContext#traceIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField TRACE_ID = new BaseCorrelationField(\"traceId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.traceIdString();\n+    }\n+  };\n+  /**\n+   * Typically only useful when spans are parsed from log records.\n+   *\n+   * @see TraceContext#parentIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField PARENT_ID = new BaseCorrelationField(\"parentId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.parentIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #SPAN_ID} is also a correlation field.", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NzA0MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399787041", "bodyText": "span id isn't a request id, but anyway would like to dodge a discussion :)\ntrying \"Used with {@link #TRACE_ID} to correlate a log line with a span.\"", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:56:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2Njc5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\nindex caacd33eb..1162bce04 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFields.java\n", "chunk": "@@ -44,7 +45,7 @@ public final class CorrelationFields {\n     }\n   };\n   /**\n-   * This is only useful when {@link #SPAN_ID} is also a correlation field.\n+   * Used with {@link #TRACE_ID} to correlate a log line with a span.\n    *\n    * @see TraceContext#spanIdString()\n    * @since 5.11\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\nindex 1162bce04..752d907be 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFields.java\n", "chunk": "@@ -50,7 +49,7 @@ public final class CorrelationFields {\n    * @see TraceContext#spanIdString()\n    * @since 5.11\n    */\n-  public static final CorrelationField SPAN_ID = new BaseCorrelationField(\"spanId\") {\n+  public static final CorrelationField SPAN_ID = new CorrelationField(\"spanId\") {\n     @Override public String getValue(TraceContext context) {\n       return context.spanIdString();\n     }\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\ndeleted file mode 100644\nindex 752d907be..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-\n-/**\n- * Standard fields defined for a correlation context such as MDC.\n- *\n- * @since 5.11\n- */\n-public final class CorrelationFields {\n-  /**\n-   * This is the most common log correlation field.\n-   *\n-   * @see TraceContext#traceIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField TRACE_ID = new CorrelationField(\"traceId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.traceIdString();\n-    }\n-  };\n-  /**\n-   * Typically only useful when spans are parsed from log records.\n-   *\n-   * @see TraceContext#parentIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField PARENT_ID = new CorrelationField(\"parentId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.parentIdString();\n-    }\n-  };\n-  /**\n-   * Used with {@link #TRACE_ID} to correlate a log line with a span.\n-   *\n-   * @see TraceContext#spanIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SPAN_ID = new CorrelationField(\"spanId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.spanIdString();\n-    }\n-  };\n-  /**\n-   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n-   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n-   * typically reported to Zipkin.\n-   *\n-   * @see TraceContext#sampled()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SAMPLED = new CorrelationField(\"sampled\") {\n-    @Override public String getValue(TraceContext context) {\n-      Boolean sampled = context.sampled();\n-      return sampled != null ? sampled.toString() : null;\n-    }\n-  };\n-\n-  /**\n-   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n-   *\n-   * <p>Ex.\n-   * <pre>{@code\n-   * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n-   * }</pre>\n-   *\n-   * @since 5.11\n-   */\n-  public static CorrelationField constant(String name, @Nullable String value) {\n-    return new ConstantCorrelationField(name, value);\n-  }\n-\n-  static final class ConstantCorrelationField extends CorrelationField {\n-    final String value;\n-\n-    ConstantCorrelationField(String name, String value) {\n-      super(name);\n-      this.value = value;\n-    }\n-\n-    @Override public String getValue(TraceContext context) {\n-      return value;\n-    }\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjgzMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399766833", "body": "```suggestion\r\n   * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n          \n          \n            \n               * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"x x-first x-last\">awsRegion</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CorrelationFields</span><span class=\"pl-k\">.</span>constant(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>region<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>getEnv(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">AWS_REGION</span><span class=\"pl-pds\">\"</span></span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"x x-first x-last\">cloudRegion</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi\">CorrelationFields</span><span class=\"pl-k\">.</span>constant(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>region<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>getEnv(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">CLOUD_REGION</span><span class=\"pl-pds\">\"</span></span>));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-29T08:51:31Z", "path": "brave/src/main/java/brave/propagation/CorrelationFields.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Standard fields defined for a correlation context such as MDC.\n+ *\n+ * @since 5.11\n+ */\n+public final class CorrelationFields {\n+  /**\n+   * This is the most common log correlation field.\n+   *\n+   * @see TraceContext#traceIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField TRACE_ID = new BaseCorrelationField(\"traceId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.traceIdString();\n+    }\n+  };\n+  /**\n+   * Typically only useful when spans are parsed from log records.\n+   *\n+   * @see TraceContext#parentIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField PARENT_ID = new BaseCorrelationField(\"parentId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.parentIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #SPAN_ID} is also a correlation field.\n+   *\n+   * @see TraceContext#spanIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SPAN_ID = new BaseCorrelationField(\"spanId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.spanIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n+   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n+   * typically reported to Zipkin.\n+   *\n+   * @see TraceContext#sampled()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SAMPLED = new BaseCorrelationField(\"sampled\") {\n+    @Override public String getValue(TraceContext context) {\n+      Boolean sampled = context.sampled();\n+      return sampled != null ? sampled.toString() : null;\n+    }\n+  };\n+\n+  /**\n+   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n+   *\n+   * <p>Ex.\n+   * <pre>{@code\n+   * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDQ3NQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784475", "bodyText": "heh I actually looked up a real variable :D fair enough though.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NjgzMw=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\nindex caacd33eb..1162bce04 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFields.java\n", "chunk": "@@ -74,7 +75,7 @@ public final class CorrelationFields {\n    *\n    * <p>Ex.\n    * <pre>{@code\n-   * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+   * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n    * }</pre>\n    *\n    * @since 5.11\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\nindex 1162bce04..752d907be 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFields.java\n", "chunk": "@@ -75,7 +74,7 @@ public final class CorrelationFields {\n    *\n    * <p>Ex.\n    * <pre>{@code\n-   * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+   * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n    * }</pre>\n    *\n    * @since 5.11\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\ndeleted file mode 100644\nindex 752d907be..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-\n-/**\n- * Standard fields defined for a correlation context such as MDC.\n- *\n- * @since 5.11\n- */\n-public final class CorrelationFields {\n-  /**\n-   * This is the most common log correlation field.\n-   *\n-   * @see TraceContext#traceIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField TRACE_ID = new CorrelationField(\"traceId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.traceIdString();\n-    }\n-  };\n-  /**\n-   * Typically only useful when spans are parsed from log records.\n-   *\n-   * @see TraceContext#parentIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField PARENT_ID = new CorrelationField(\"parentId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.parentIdString();\n-    }\n-  };\n-  /**\n-   * Used with {@link #TRACE_ID} to correlate a log line with a span.\n-   *\n-   * @see TraceContext#spanIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SPAN_ID = new CorrelationField(\"spanId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.spanIdString();\n-    }\n-  };\n-  /**\n-   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n-   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n-   * typically reported to Zipkin.\n-   *\n-   * @see TraceContext#sampled()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SAMPLED = new CorrelationField(\"sampled\") {\n-    @Override public String getValue(TraceContext context) {\n-      Boolean sampled = context.sampled();\n-      return sampled != null ? sampled.toString() : null;\n-    }\n-  };\n-\n-  /**\n-   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n-   *\n-   * <p>Ex.\n-   * <pre>{@code\n-   * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n-   * }</pre>\n-   *\n-   * @since 5.11\n-   */\n-  public static CorrelationField constant(String name, @Nullable String value) {\n-    return new ConstantCorrelationField(name, value);\n-  }\n-\n-  static final class ConstantCorrelationField extends CorrelationField {\n-    final String value;\n-\n-    ConstantCorrelationField(String name, String value) {\n-      super(name);\n-      this.value = value;\n-    }\n-\n-    @Override public String getValue(TraceContext context) {\n-      return value;\n-    }\n-  }\n-}\n", "next_change": null}]}}, {"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\nindex 1162bce04..752d907be 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFields.java\n", "chunk": "@@ -84,7 +83,7 @@ public final class CorrelationFields {\n     return new ConstantCorrelationField(name, value);\n   }\n \n-  static final class ConstantCorrelationField extends BaseCorrelationField {\n+  static final class ConstantCorrelationField extends CorrelationField {\n     final String value;\n \n     ConstantCorrelationField(String name, String value) {\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\ndeleted file mode 100644\nindex 752d907be..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-\n-/**\n- * Standard fields defined for a correlation context such as MDC.\n- *\n- * @since 5.11\n- */\n-public final class CorrelationFields {\n-  /**\n-   * This is the most common log correlation field.\n-   *\n-   * @see TraceContext#traceIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField TRACE_ID = new CorrelationField(\"traceId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.traceIdString();\n-    }\n-  };\n-  /**\n-   * Typically only useful when spans are parsed from log records.\n-   *\n-   * @see TraceContext#parentIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField PARENT_ID = new CorrelationField(\"parentId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.parentIdString();\n-    }\n-  };\n-  /**\n-   * Used with {@link #TRACE_ID} to correlate a log line with a span.\n-   *\n-   * @see TraceContext#spanIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SPAN_ID = new CorrelationField(\"spanId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.spanIdString();\n-    }\n-  };\n-  /**\n-   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n-   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n-   * typically reported to Zipkin.\n-   *\n-   * @see TraceContext#sampled()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SAMPLED = new CorrelationField(\"sampled\") {\n-    @Override public String getValue(TraceContext context) {\n-      Boolean sampled = context.sampled();\n-      return sampled != null ? sampled.toString() : null;\n-    }\n-  };\n-\n-  /**\n-   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n-   *\n-   * <p>Ex.\n-   * <pre>{@code\n-   * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n-   * }</pre>\n-   *\n-   * @since 5.11\n-   */\n-  public static CorrelationField constant(String name, @Nullable String value) {\n-    return new ConstantCorrelationField(name, value);\n-  }\n-\n-  static final class ConstantCorrelationField extends CorrelationField {\n-    final String value;\n-\n-    ConstantCorrelationField(String name, String value) {\n-      super(name);\n-      this.value = value;\n-    }\n-\n-    @Override public String getValue(TraceContext context) {\n-      return value;\n-    }\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NzI4Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399767283", "body": "What about doing `instanceof CorrelationField`? Matters less if we seal the interface though", "bodyText": "What about doing instanceof CorrelationField? Matters less if we seal the interface though", "bodyHTML": "<p dir=\"auto\">What about doing <code>instanceof CorrelationField</code>? Matters less if we seal the interface though</p>", "author": "anuraaga", "createdAt": "2020-03-29T08:55:12Z", "path": "brave/src/main/java/brave/propagation/CorrelationFields.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * Standard fields defined for a correlation context such as MDC.\n+ *\n+ * @since 5.11\n+ */\n+public final class CorrelationFields {\n+  /**\n+   * This is the most common log correlation field.\n+   *\n+   * @see TraceContext#traceIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField TRACE_ID = new BaseCorrelationField(\"traceId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.traceIdString();\n+    }\n+  };\n+  /**\n+   * Typically only useful when spans are parsed from log records.\n+   *\n+   * @see TraceContext#parentIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField PARENT_ID = new BaseCorrelationField(\"parentId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.parentIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #SPAN_ID} is also a correlation field.\n+   *\n+   * @see TraceContext#spanIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SPAN_ID = new BaseCorrelationField(\"spanId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.spanIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n+   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n+   * typically reported to Zipkin.\n+   *\n+   * @see TraceContext#sampled()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SAMPLED = new BaseCorrelationField(\"sampled\") {\n+    @Override public String getValue(TraceContext context) {\n+      Boolean sampled = context.sampled();\n+      return sampled != null ? sampled.toString() : null;\n+    }\n+  };\n+\n+  /**\n+   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n+   *\n+   * <p>Ex.\n+   * <pre>{@code\n+   * awsRegion = CorrelationFields.constant(\"region\", System.getEnv(\"AWS_REGION\"));\n+   * }</pre>\n+   *\n+   * @since 5.11\n+   */\n+  public static CorrelationField constant(String name, @Nullable String value) {\n+    return new ConstantCorrelationField(name, value);\n+  }\n+\n+  static final class ConstantCorrelationField extends BaseCorrelationField {\n+    final String value;\n+\n+    ConstantCorrelationField(String name, String value) {\n+      super(name);\n+      this.value = value;\n+    }\n+\n+    @Override public String getValue(TraceContext context) {\n+      return value;\n+    }\n+  }\n+\n+  static abstract class BaseCorrelationField implements CorrelationField {\n+    final String name;\n+\n+    BaseCorrelationField(String name) {\n+      if (name == null) throw new NullPointerException(\"name == null\");\n+      name = name.trim();\n+      if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n+      this.name = name;\n+    }\n+\n+    @Override public String name() {\n+      return name;\n+    }\n+\n+    @Override public String toString() {\n+      return name;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      if (o == this) return true;\n+      if (!(o instanceof BaseCorrelationField)) return false;", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDM4MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784381", "bodyText": "sure.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NzI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg3MDY4Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399870682", "bodyText": "I will try to seal it, handling extra field differently..", "author": "codefromthecrypt", "createdAt": "2020-03-29T23:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2NzI4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\nindex caacd33eb..1162bce04 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFields.java\n", "chunk": "@@ -116,12 +115,19 @@ public final class CorrelationFields {\n \n     @Override public boolean equals(Object o) {\n       if (o == this) return true;\n-      if (!(o instanceof BaseCorrelationField)) return false;\n-      return name.equals(((BaseCorrelationField) o).name);\n+      if (!(o instanceof CorrelationField)) return false;\n+      return lcName.equals(((CorrelationField) o).name());\n     }\n \n     @Override public int hashCode() {\n-      return name.hashCode();\n+      return lcName.hashCode();\n     }\n   }\n+\n+  protected static String validateName(String name) {\n+    if (name == null) throw new NullPointerException(\"name == null\");\n+    name = name.trim();\n+    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n+    return name;\n+  }\n }\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\nindex 1162bce04..752d907be 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFields.java\n", "chunk": "@@ -96,38 +95,4 @@ public final class CorrelationFields {\n       return value;\n     }\n   }\n-\n-  static abstract class BaseCorrelationField implements CorrelationField {\n-    final String name, lcName;\n-\n-    BaseCorrelationField(String name) {\n-      this.name = validateName(name);\n-      this.lcName = name.toLowerCase(Locale.ROOT);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public String toString() {\n-      return name;\n-    }\n-\n-    @Override public boolean equals(Object o) {\n-      if (o == this) return true;\n-      if (!(o instanceof CorrelationField)) return false;\n-      return lcName.equals(((CorrelationField) o).name());\n-    }\n-\n-    @Override public int hashCode() {\n-      return lcName.hashCode();\n-    }\n-  }\n-\n-  protected static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n }\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\ndeleted file mode 100644\nindex 752d907be..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-\n-/**\n- * Standard fields defined for a correlation context such as MDC.\n- *\n- * @since 5.11\n- */\n-public final class CorrelationFields {\n-  /**\n-   * This is the most common log correlation field.\n-   *\n-   * @see TraceContext#traceIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField TRACE_ID = new CorrelationField(\"traceId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.traceIdString();\n-    }\n-  };\n-  /**\n-   * Typically only useful when spans are parsed from log records.\n-   *\n-   * @see TraceContext#parentIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField PARENT_ID = new CorrelationField(\"parentId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.parentIdString();\n-    }\n-  };\n-  /**\n-   * Used with {@link #TRACE_ID} to correlate a log line with a span.\n-   *\n-   * @see TraceContext#spanIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SPAN_ID = new CorrelationField(\"spanId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.spanIdString();\n-    }\n-  };\n-  /**\n-   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n-   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n-   * typically reported to Zipkin.\n-   *\n-   * @see TraceContext#sampled()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SAMPLED = new CorrelationField(\"sampled\") {\n-    @Override public String getValue(TraceContext context) {\n-      Boolean sampled = context.sampled();\n-      return sampled != null ? sampled.toString() : null;\n-    }\n-  };\n-\n-  /**\n-   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n-   *\n-   * <p>Ex.\n-   * <pre>{@code\n-   * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n-   * }</pre>\n-   *\n-   * @since 5.11\n-   */\n-  public static CorrelationField constant(String name, @Nullable String value) {\n-    return new ConstantCorrelationField(name, value);\n-  }\n-\n-  static final class ConstantCorrelationField extends CorrelationField {\n-    final String value;\n-\n-    ConstantCorrelationField(String name, String value) {\n-      super(name);\n-      this.value = value;\n-    }\n-\n-    @Override public String getValue(TraceContext context) {\n-      return value;\n-    }\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODA1MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399768050", "body": "I guess these can delegate to the static methods instead of copy-paste", "bodyText": "I guess these can delegate to the static methods instead of copy-paste", "bodyHTML": "<p dir=\"auto\">I guess these can delegate to the static methods instead of copy-paste</p>", "author": "anuraaga", "createdAt": "2020-03-29T09:02:28Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .flushValuesToContext(loggingContext)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   *\n+   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void setValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Sets the current value of the field with the specified key, or drops if not a configured\n+   * field.\n+   *\n+   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void setValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) setValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    String prefix;\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+    }\n+\n+    /**\n+     * @see #prefix()\n+     * @since 5.11\n+     */\n+    public Builder prefix(String prefix) {\n+      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n+      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      this.prefix = prefix;\n+      return this;\n+    }\n+\n+    /**\n+     * @see #redacted()\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Ensures this field can integrate with {@link CorrelationFieldScopeDecorator}.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder {\n+    final Builder delegate;\n+\n+    CorrelationBuilder(Builder delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    /** @see Builder#prefix(String) */\n+    public CorrelationBuilder prefix(String prefix) {\n+      delegate.prefix(prefix);\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder redacted() {\n+      delegate.redacted();\n+      return this;\n+    }\n+\n+    /** @see Builder#build() */\n+    public final WithCorrelation build() {\n+      return new WithCorrelation(delegate);\n+    }\n+  }\n+\n+  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n+    WithCorrelation(Builder builder) {\n+      super(builder);\n+    }\n+  }\n+\n+  final String prefix;\n+  final String name;\n+  final boolean redacted;\n+\n+  ExtraField(Builder builder) {\n+    prefix = builder.prefix;\n+    name = builder.name;\n+    redacted = builder.redacted;\n+  }\n+\n+  /** Extracts the value for this field in the context or null if unavailable. */\n+  @Nullable public String getValue(TraceContext context) {", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDA2OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784069", "bodyText": "this drifted after we now use the field type internally.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODA1MA=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex f34462de0..494f7442d 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -243,30 +301,42 @@ public class ExtraField {\n     WithCorrelation(Builder builder) {\n       super(builder);\n     }\n+\n+    @Override public String name() {\n+      return name;\n+    }\n+\n+    @Override public CorrelationBuilder toBuilder() {\n+      return new Builder(this).withCorrelation();\n+    }\n   }\n \n-  final String prefix;\n-  final String name;\n+  final String name, lcName;\n+  final String[] keys; // for faster iteration\n+  final List<String> keysList;\n   final boolean redacted;\n \n   ExtraField(Builder builder) {\n-    prefix = builder.prefix;\n     name = builder.name;\n+    lcName = name.toLowerCase(Locale.ROOT);\n+    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n+    keys = builder.keys.toArray(new String[0]);\n+    keysList = asList(keys);\n     redacted = builder.redacted;\n   }\n \n-  /** Extracts the value for this field in the context or null if unavailable. */\n+  /** Extracts the most recent value for this field in the context or null if unavailable. */\n   @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, name, ExtraFieldPropagation.Extra.class);\n+    return PropagationFields.get(context, this, ExtraFields.class);\n   }\n \n-  /** Sets the value of the this field, or drops if not configured. */\n+  /** Sets the value of the this field, or ignores if not configured. */\n   public void setValue(TraceContext context, String value) {\n-    PropagationFields.put(context, name, value, ExtraFieldPropagation.Extra.class);\n+    PropagationFields.put(context, this, value, ExtraFields.class);\n   }\n \n   /**\n-   * Returns the value of this field in the implicit trace context or null if not available.\n+   * Like {@link #getValue(TraceContext)} except against the current trace context.\n    *\n    * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n    */\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 494f7442d..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,385 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know the a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * countryCode.setValue(\"FO\");\n- * countryCode.setValue(context, \"FO\");\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * ExtraField.setValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #setValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void setValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #setValue(TraceContext, String, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void setValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * When set, the field will be added to the correlation context on {@link\n-     * CorrelationFieldScopeDecorator#decorateScope(TraceContext, CurrentTraceContext.Scope)}.\n-     *\n-     * <h3>Immediate flushing</h3>\n-     * <p>This will also immediately flush a value update to the correlation context on {@link\n-     * #setValue(String)} as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.setValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /** Extracts the most recent value for this field in the context or null if unavailable. */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Sets the value of the this field, or ignores if not configured. */\n-  public void setValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #setValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #setValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void setValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODQwNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399768405", "body": "Think you may have accidentally lost the strict checker", "bodyText": "Think you may have accidentally lost the strict checker", "bodyHTML": "<p dir=\"auto\">Think you may have accidentally lost the strict checker</p>", "author": "anuraaga", "createdAt": "2020-03-29T09:05:55Z", "path": "brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java", "diffHunk": "@@ -37,12 +36,12 @@\n  * the core concepts.\n  */\n public class OpenTracingAdapterTest {\n+  static final ExtraField EXTRA_FIELD = ExtraField.newBuilder(\"user-id\").build();\n+\n   List<zipkin2.Span> spans = new ArrayList<>();\n   Tracing brave = Tracing.newBuilder()\n-    .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n-      .addScopeDecorator(StrictScopeDecorator.create())", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDY0Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784643", "bodyText": "not needed as not multi-threaded.. sorry I was cleaning up.", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODQwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java b/brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java\nindex 92c7de7a6..2c8f51324 100644\n--- a/brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java\n+++ b/brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java\n", "chunk": "@@ -36,12 +36,12 @@ import static org.assertj.core.data.MapEntry.entry;\n  * the core concepts.\n  */\n public class OpenTracingAdapterTest {\n-  static final ExtraField EXTRA_FIELD = ExtraField.newBuilder(\"user-id\").build();\n+  static final BaggageField BAGGAGE_FIELD = BaggageField.newBuilder(\"user-id\").build();\n \n   List<zipkin2.Span> spans = new ArrayList<>();\n   Tracing brave = Tracing.newBuilder()\n-    .propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n-      .addField(EXTRA_FIELD).build())\n+    .propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+      .addField(BAGGAGE_FIELD).build())\n     .spanReporter(spans::add).build();\n \n   BraveTracer opentracing = BraveTracer.wrap(brave);\n", "next_change": {"commit": "016837e22164c69eb416b1c29fbd59e962634024", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java b/brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java\nindex 2c8f51324..42c63bae9 100644\n--- a/brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java\n+++ b/brave/src/test/java/brave/features/opentracing/OpenTracingAdapterTest.java\n", "chunk": "@@ -41,7 +41,7 @@ public class OpenTracingAdapterTest {\n   List<zipkin2.Span> spans = new ArrayList<>();\n   Tracing brave = Tracing.newBuilder()\n     .propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n-      .addField(BAGGAGE_FIELD).build())\n+      .addRemoteField(BAGGAGE_FIELD).build())\n     .spanReporter(spans::add).build();\n \n   BraveTracer opentracing = BraveTracer.wrap(brave);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODY1MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399768651", "body": "Since package name is `log4j2` think this can just be `Log4jContext`", "bodyText": "Since package name is log4j2 think this can just be Log4jContext", "bodyHTML": "<p dir=\"auto\">Since package name is <code>log4j2</code> think this can just be <code>Log4jContext</code></p>", "author": "anuraaga", "createdAt": "2020-03-29T09:08:27Z", "path": "context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.context.log4j2;\n+\n+import brave.propagation.CorrelationField;\n+import org.apache.logging.log4j.ThreadContext;\n+\n+/** Integrates Log4j 2's {@link org.apache.logging.log4j.ThreadContext} */\n+public final class Log4j2Context extends CorrelationField.Context {", "originalCommit": "1d06b5145bb86db30c83f1f9786a8ca20dbc7345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc4NDgyNw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399784827", "bodyText": "I was going by the marketing on their website and kinda prefer the match on package name..", "author": "codefromthecrypt", "createdAt": "2020-03-29T11:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3NTI4Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400075287", "bodyText": "obviated as the type is hidden", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTc2ODY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java b/context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java\nindex bfc6198bb..9eaaf0198 100644\n--- a/context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java\n+++ b/context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java\n", "chunk": "@@ -13,11 +13,13 @@\n  */\n package brave.context.log4j2;\n \n-import brave.propagation.CorrelationField;\n+import brave.internal.CorrelationContext;\n import org.apache.logging.log4j.ThreadContext;\n \n /** Integrates Log4j 2's {@link org.apache.logging.log4j.ThreadContext} */\n-public final class Log4j2Context extends CorrelationField.Context {\n+// TODO: see if we can read/write directly to skip some overhead similar to\n+// https://github.com/census-instrumentation/opencensus-java/blob/2903747aca08b1e2e29da35c5527ff046918e562/contrib/log_correlation/log4j2/src/main/java/io/opencensus/contrib/logcorrelation/log4j2/OpenCensusTraceContextDataInjector.java\n+public final class Log4j2Context extends CorrelationContext {\n   @Override public String get(String name) {\n     return ThreadContext.get(name);\n   }\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java b/context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java\ndeleted file mode 100644\nindex 9eaaf0198..000000000\n--- a/context/log4j2/src/main/java/brave/context/log4j2/Log4j2Context.java\n+++ /dev/null\n", "chunk": "@@ -1,34 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.context.log4j2;\n-\n-import brave.internal.CorrelationContext;\n-import org.apache.logging.log4j.ThreadContext;\n-\n-/** Integrates Log4j 2's {@link org.apache.logging.log4j.ThreadContext} */\n-// TODO: see if we can read/write directly to skip some overhead similar to\n-// https://github.com/census-instrumentation/opencensus-java/blob/2903747aca08b1e2e29da35c5527ff046918e562/contrib/log_correlation/log4j2/src/main/java/io/opencensus/contrib/logcorrelation/log4j2/OpenCensusTraceContextDataInjector.java\n-public final class Log4j2Context extends CorrelationContext {\n-  @Override public String get(String name) {\n-    return ThreadContext.get(name);\n-  }\n-\n-  @Override public void put(String name, String value) {\n-    ThreadContext.put(name, value);\n-  }\n-\n-  @Override public void remove(String name) {\n-    ThreadContext.remove(name);\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgzOTg2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399839862", "body": "remove 'the'", "bodyText": "remove 'the'", "bodyHTML": "<p dir=\"auto\">remove 'the'</p>", "author": "jorgheymans", "createdAt": "2020-03-29T19:10:30Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 1de5ecf94..494f7442d 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -15,9 +15,14 @@ package brave.propagation;\n \n import brave.internal.Nullable;\n import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.Set;\n \n+import static brave.propagation.CorrelationFields.validateName;\n import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n \n /**\n  * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 494f7442d..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -28,7 +28,7 @@ import static java.util.Arrays.asList;\n  * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n  * be no-op unless {@link ExtraFieldPropagation} is configured.\n  *\n- * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n  * propagate it through the trace:\n  * <pre>{@code\n  * // Configure your extra field\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MDIyMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399840223", "body": "'for a new request' rather ? otherwise the sentence looked incomplete at first sight - though grammatically correct ", "bodyText": "'for a new request' rather ? otherwise the sentence looked incomplete at first sight - though grammatically correct", "bodyHTML": "<p dir=\"auto\">'for a new request' rather ? otherwise the sentence looked incomplete at first sight - though grammatically correct</p>", "author": "jorgheymans", "createdAt": "2020-03-29T19:13:40Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkyMTYwMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399921602", "bodyText": "You can also update the value similarly, so that the new value will propagate downstream.\ncomment back if needed", "author": "codefromthecrypt", "createdAt": "2020-03-30T04:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MDIyMw=="}], "type": "inlineReview", "revised_code": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 1de5ecf94..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -34,11 +39,11 @@ import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n  * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n  * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n  *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * countryCode.setValue(\"FO\");\n- * countryCode.setValue(context, \"FO\");\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n  * }</pre>\n  *\n  * <h3>Correlation</h3>\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTI5Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399841296", "body": "this is already mentioned in brave's main README.md , any merit repeating the obvious here ? The security bits are very relevant but this applies to all public types in brave no ? ", "bodyText": "this is already mentioned in brave's main README.md , any merit repeating the obvious here ? The security bits are very relevant but this applies to all public types in brave no ?", "bodyHTML": "<p dir=\"auto\">this is already mentioned in brave's main README.md , any merit repeating the obvious here ? The security bits are very relevant but this applies to all public types in brave no ?</p>", "author": "jorgheymans", "createdAt": "2020-03-29T19:23:45Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg3MzkxNg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399873916", "bodyText": "The reason this is in the type doc is that this type specifically adds temptation to embed in your code, and readme doesn't inherit docs and visa versa (maybe asciidoc can help if someone can help with it)\nThat said, this doc was ignored on the type it was on last time, leading to this very change, heh!", "author": "codefromthecrypt", "createdAt": "2020-03-30T00:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTQyNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399951425", "bodyText": "gotcha.", "author": "jorgheymans", "createdAt": "2020-03-30T06:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTI5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 1de5ecf94..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,330 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.Locale;\n-\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know the a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * countryCode.setValue(\"FO\");\n- * countryCode.setValue(context, \"FO\");\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * ExtraField.setValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be implicitly lower-cased\n-   * @see #name()\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be implicitly lower-cased\n-   * @see #name()\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  /**\n-   * Returns the value of the field with the specified key or null if not available.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n-  }\n-\n-  /**\n-   * Returns the value of the field with the specified key or null if not available.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Sets the value of the field with the specified key, or drops if not a configured field.\n-   *\n-   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void setValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n-  }\n-\n-  /**\n-   * Sets the current value of the field with the specified key, or drops if not a configured\n-   * field.\n-   *\n-   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void setValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    String prefix;\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-    }\n-\n-    /**\n-     * @see #prefix()\n-     * @since 5.11\n-     */\n-    public Builder prefix(String prefix) {\n-      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n-      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n-      this.prefix = prefix;\n-      return this;\n-    }\n-\n-    /**\n-     * @see #redacted()\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Ensures this field can integrate with {@link CorrelationFieldScopeDecorator}.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder {\n-    final Builder delegate;\n-\n-    CorrelationBuilder(Builder delegate) {\n-      this.delegate = delegate;\n-    }\n-\n-    /** @see Builder#prefix(String) */\n-    public CorrelationBuilder prefix(String prefix) {\n-      delegate.prefix(prefix);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      delegate.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(delegate);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-  }\n-\n-  final String prefix;\n-  final String name;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    prefix = builder.prefix;\n-    name = builder.name;\n-    redacted = builder.redacted;\n-  }\n-\n-  /** Extracts the value for this field in the context or null if unavailable. */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, name, ExtraFieldPropagation.Extra.class);\n-  }\n-\n-  /** Sets the value of the this field, or drops if not configured. */\n-  public void setValue(TraceContext context, String value) {\n-    PropagationFields.put(context, name, value, ExtraFieldPropagation.Extra.class);\n-  }\n-\n-  /**\n-   * Returns the value of this field in the implicit trace context or null if not available.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Sets the value of this field in the implicit trace context or ignores when not available.\n-   *\n-   * <p>Prefer {@link #setValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void setValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, value);\n-  }\n-\n-  /** Optional non-empty, lower-case field prefix. Ex \"baggage-\" */\n-  @Nullable public String prefix() {\n-    return prefix;\n-  }\n-\n-  /** The non-empty, lower-case name of the field. Ex \"user-id\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /** When true, this field is only visible in process, redacted from remote propagation. */\n-  public boolean redacted() {\n-    return redacted;\n-  }\n-\n-  @Override public String toString() {\n-    return \"ExtraField(\" + name + \")\";\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    ExtraField that = (ExtraField) o;\n-    return name.equals(that.name) &&\n-      prefix == null ? that.prefix == null : prefix.equals(that.prefix);\n-  }\n-\n-  @Override public int hashCode() {\n-    int h = 1;\n-    h *= 1000003;\n-    h ^= (name == null) ? 0 : name.hashCode();\n-    h *= 1000003;\n-    h ^= (prefix == null) ? 0 : prefix.hashCode();\n-    return h;\n-  }\n-\n-  static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.toLowerCase(Locale.ROOT).trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTQ4OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399841489", "body": "if the paragraph about the infrastructure library gets removed consider merging this one and the `it is generally not a good idea ...` into one.", "bodyText": "if the paragraph about the infrastructure library gets removed consider merging this one and the it is generally not a good idea ... into one.", "bodyHTML": "<p dir=\"auto\">if the paragraph about the infrastructure library gets removed consider merging this one and the <code>it is generally not a good idea ...</code> into one.</p>", "author": "jorgheymans", "createdAt": "2020-03-29T19:25:19Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 1de5ecf94..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,330 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.Locale;\n-\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know the a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * countryCode.setValue(\"FO\");\n- * countryCode.setValue(context, \"FO\");\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * ExtraField.setValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be implicitly lower-cased\n-   * @see #name()\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be implicitly lower-cased\n-   * @see #name()\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  /**\n-   * Returns the value of the field with the specified key or null if not available.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n-  }\n-\n-  /**\n-   * Returns the value of the field with the specified key or null if not available.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Sets the value of the field with the specified key, or drops if not a configured field.\n-   *\n-   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void setValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n-  }\n-\n-  /**\n-   * Sets the current value of the field with the specified key, or drops if not a configured\n-   * field.\n-   *\n-   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void setValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    String prefix;\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-    }\n-\n-    /**\n-     * @see #prefix()\n-     * @since 5.11\n-     */\n-    public Builder prefix(String prefix) {\n-      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n-      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n-      this.prefix = prefix;\n-      return this;\n-    }\n-\n-    /**\n-     * @see #redacted()\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Ensures this field can integrate with {@link CorrelationFieldScopeDecorator}.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder {\n-    final Builder delegate;\n-\n-    CorrelationBuilder(Builder delegate) {\n-      this.delegate = delegate;\n-    }\n-\n-    /** @see Builder#prefix(String) */\n-    public CorrelationBuilder prefix(String prefix) {\n-      delegate.prefix(prefix);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      delegate.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(delegate);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-  }\n-\n-  final String prefix;\n-  final String name;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    prefix = builder.prefix;\n-    name = builder.name;\n-    redacted = builder.redacted;\n-  }\n-\n-  /** Extracts the value for this field in the context or null if unavailable. */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, name, ExtraFieldPropagation.Extra.class);\n-  }\n-\n-  /** Sets the value of the this field, or drops if not configured. */\n-  public void setValue(TraceContext context, String value) {\n-    PropagationFields.put(context, name, value, ExtraFieldPropagation.Extra.class);\n-  }\n-\n-  /**\n-   * Returns the value of this field in the implicit trace context or null if not available.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Sets the value of this field in the implicit trace context or ignores when not available.\n-   *\n-   * <p>Prefer {@link #setValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void setValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, value);\n-  }\n-\n-  /** Optional non-empty, lower-case field prefix. Ex \"baggage-\" */\n-  @Nullable public String prefix() {\n-    return prefix;\n-  }\n-\n-  /** The non-empty, lower-case name of the field. Ex \"user-id\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /** When true, this field is only visible in process, redacted from remote propagation. */\n-  public boolean redacted() {\n-    return redacted;\n-  }\n-\n-  @Override public String toString() {\n-    return \"ExtraField(\" + name + \")\";\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    ExtraField that = (ExtraField) o;\n-    return name.equals(that.name) &&\n-      prefix == null ? that.prefix == null : prefix.equals(that.prefix);\n-  }\n-\n-  @Override public int hashCode() {\n-    int h = 1;\n-    h *= 1000003;\n-    h ^= (name == null) ? 0 : name.hashCode();\n-    h *= 1000003;\n-    h ^= (prefix == null) ? 0 : prefix.hashCode();\n-    return h;\n-  }\n-\n-  static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.toLowerCase(Locale.ROOT).trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTk1OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399841959", "body": "`or drops if not a configured field` what do you mean it's just a no-op call like ignored ? `ignored if the key does not reference a configured field` perhaps", "bodyText": "or drops if not a configured field what do you mean it's just a no-op call like ignored ? ignored if the key does not reference a configured field perhaps", "bodyHTML": "<p dir=\"auto\"><code>or drops if not a configured field</code> what do you mean it's just a no-op call like ignored ? <code>ignored if the key does not reference a configured field</code> perhaps</p>", "author": "jorgheymans", "createdAt": "2020-03-29T19:29:20Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg3NDEwMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399874101", "bodyText": "thx", "author": "codefromthecrypt", "createdAt": "2020-03-30T00:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MTk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 1de5ecf94..494f7442d 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -142,18 +149,18 @@ public class ExtraField {\n   }\n \n   /**\n-   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   * Like {@link #setValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n    *\n    * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n    * underlying field.\n    */\n   public static void setValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n   }\n \n   /**\n-   * Sets the current value of the field with the specified key, or drops if not a configured\n-   * field.\n+   * Like {@link #setValue(TraceContext, String, String)} except against the current trace context.\n    *\n    * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n    * underlying field.\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 494f7442d..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -149,29 +149,30 @@ public class ExtraField {\n   }\n \n   /**\n-   * Like {@link #setValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n    * #name()}.\n    *\n-   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n    * underlying field.\n    */\n-  public static void setValue(TraceContext context, String name, String value) {\n+  public static void updateValue(TraceContext context, String name, String value) {\n     PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n   }\n \n   /**\n-   * Like {@link #setValue(TraceContext, String, String)} except against the current trace context.\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n    *\n-   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n    * underlying field.\n-   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n-   * context.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n    *\n    * @see ExtraField#name()\n    */\n-  public static void setValue(String name, String value) {\n+  public static void updateValue(String name, String value) {\n     TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, name, value);\n+    if (context != null) updateValue(context, name, value);\n   }\n \n   /** @since 5.11 */\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MjA0MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399842041", "body": "same comment as above", "bodyText": "same comment as above", "bodyHTML": "<p dir=\"auto\">same comment as above</p>", "author": "jorgheymans", "createdAt": "2020-03-29T19:29:54Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   *\n+   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void setValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Sets the current value of the field with the specified key, or drops if not a configured", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 1de5ecf94..494f7442d 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -142,18 +149,18 @@ public class ExtraField {\n   }\n \n   /**\n-   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   * Like {@link #setValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n    *\n    * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n    * underlying field.\n    */\n   public static void setValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n   }\n \n   /**\n-   * Sets the current value of the field with the specified key, or drops if not a configured\n-   * field.\n+   * Like {@link #setValue(TraceContext, String, String)} except against the current trace context.\n    *\n    * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n    * underlying field.\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 494f7442d..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -149,29 +149,30 @@ public class ExtraField {\n   }\n \n   /**\n-   * Like {@link #setValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n    * #name()}.\n    *\n-   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n    * underlying field.\n    */\n-  public static void setValue(TraceContext context, String name, String value) {\n+  public static void updateValue(TraceContext context, String name, String value) {\n     PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n   }\n \n   /**\n-   * Like {@link #setValue(TraceContext, String, String)} except against the current trace context.\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n    *\n-   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n    * underlying field.\n-   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n-   * context.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n    *\n    * @see ExtraField#name()\n    */\n-  public static void setValue(String name, String value) {\n+  public static void updateValue(String name, String value) {\n     TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, name, value);\n+    if (context != null) updateValue(context, name, value);\n   }\n \n   /** @since 5.11 */\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MjQ0NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399842444", "body": "same `drops` comment as above", "bodyText": "same drops comment as above", "bodyHTML": "<p dir=\"auto\">same <code>drops</code> comment as above</p>", "author": "jorgheymans", "createdAt": "2020-03-29T19:33:18Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   *\n+   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void setValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Sets the current value of the field with the specified key, or drops if not a configured\n+   * field.\n+   *\n+   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void setValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) setValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    String prefix;\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+    }\n+\n+    /**\n+     * @see #prefix()\n+     * @since 5.11\n+     */\n+    public Builder prefix(String prefix) {\n+      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n+      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      this.prefix = prefix;\n+      return this;\n+    }\n+\n+    /**\n+     * @see #redacted()\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Ensures this field can integrate with {@link CorrelationFieldScopeDecorator}.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder {\n+    final Builder delegate;\n+\n+    CorrelationBuilder(Builder delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    /** @see Builder#prefix(String) */\n+    public CorrelationBuilder prefix(String prefix) {\n+      delegate.prefix(prefix);\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder redacted() {\n+      delegate.redacted();\n+      return this;\n+    }\n+\n+    /** @see Builder#build() */\n+    public final WithCorrelation build() {\n+      return new WithCorrelation(delegate);\n+    }\n+  }\n+\n+  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n+    WithCorrelation(Builder builder) {\n+      super(builder);\n+    }\n+  }\n+\n+  final String prefix;\n+  final String name;\n+  final boolean redacted;\n+\n+  ExtraField(Builder builder) {\n+    prefix = builder.prefix;\n+    name = builder.name;\n+    redacted = builder.redacted;\n+  }\n+\n+  /** Extracts the value for this field in the context or null if unavailable. */\n+  @Nullable public String getValue(TraceContext context) {\n+    return PropagationFields.get(context, name, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /** Sets the value of the this field, or drops if not configured. */", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 1de5ecf94..494f7442d 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -242,30 +301,42 @@ public class ExtraField {\n     WithCorrelation(Builder builder) {\n       super(builder);\n     }\n+\n+    @Override public String name() {\n+      return name;\n+    }\n+\n+    @Override public CorrelationBuilder toBuilder() {\n+      return new Builder(this).withCorrelation();\n+    }\n   }\n \n-  final String prefix;\n-  final String name;\n+  final String name, lcName;\n+  final String[] keys; // for faster iteration\n+  final List<String> keysList;\n   final boolean redacted;\n \n   ExtraField(Builder builder) {\n-    prefix = builder.prefix;\n     name = builder.name;\n+    lcName = name.toLowerCase(Locale.ROOT);\n+    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n+    keys = builder.keys.toArray(new String[0]);\n+    keysList = asList(keys);\n     redacted = builder.redacted;\n   }\n \n-  /** Extracts the value for this field in the context or null if unavailable. */\n+  /** Extracts the most recent value for this field in the context or null if unavailable. */\n   @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, name, ExtraFieldPropagation.Extra.class);\n+    return PropagationFields.get(context, this, ExtraFields.class);\n   }\n \n-  /** Sets the value of the this field, or drops if not configured. */\n+  /** Sets the value of the this field, or ignores if not configured. */\n   public void setValue(TraceContext context, String value) {\n-    PropagationFields.put(context, name, value, ExtraFieldPropagation.Extra.class);\n+    PropagationFields.put(context, this, value, ExtraFields.class);\n   }\n \n   /**\n-   * Returns the value of this field in the implicit trace context or null if not available.\n+   * Like {@link #getValue(TraceContext)} except against the current trace context.\n    *\n    * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n    */\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 494f7442d..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,385 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know the a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * countryCode.setValue(\"FO\");\n- * countryCode.setValue(context, \"FO\");\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * ExtraField.setValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.setValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #setValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void setValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #setValue(TraceContext, String, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void setValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * When set, the field will be added to the correlation context on {@link\n-     * CorrelationFieldScopeDecorator#decorateScope(TraceContext, CurrentTraceContext.Scope)}.\n-     *\n-     * <h3>Immediate flushing</h3>\n-     * <p>This will also immediately flush a value update to the correlation context on {@link\n-     * #setValue(String)} as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.setValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /** Extracts the most recent value for this field in the context or null if unavailable. */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Sets the value of the this field, or ignores if not configured. */\n-  public void setValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #setValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #setValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void setValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0MjU4OQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399842589", "body": "here `ignores` is being used, wording is more clear to me ", "bodyText": "here ignores is being used, wording is more clear to me", "bodyHTML": "<p dir=\"auto\">here <code>ignores</code> is being used, wording is more clear to me</p>", "author": "jorgheymans", "createdAt": "2020-03-29T19:34:21Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Locale;\n+\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also set or override the value similarly, which might be needed if a new request\n+ * countryCode.setValue(\"FO\");\n+ * countryCode.setValue(context, \"FO\");\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * ExtraField.setValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.setValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be implicitly lower-cased\n+   * @see #name()\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, validateName(name), ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of the field with the specified key or null if not available.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Sets the value of the field with the specified key, or drops if not a configured field.\n+   *\n+   * <p>Prefer using {@link #setValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void setValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, validateName(name), value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Sets the current value of the field with the specified key, or drops if not a configured\n+   * field.\n+   *\n+   * <p>Prefer using {@link ExtraField#setValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #setValue(TraceContext, String, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void setValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) setValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    String prefix;\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+    }\n+\n+    /**\n+     * @see #prefix()\n+     * @since 5.11\n+     */\n+    public Builder prefix(String prefix) {\n+      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n+      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      this.prefix = prefix;\n+      return this;\n+    }\n+\n+    /**\n+     * @see #redacted()\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Ensures this field can integrate with {@link CorrelationFieldScopeDecorator}.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder {\n+    final Builder delegate;\n+\n+    CorrelationBuilder(Builder delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    /** @see Builder#prefix(String) */\n+    public CorrelationBuilder prefix(String prefix) {\n+      delegate.prefix(prefix);\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder redacted() {\n+      delegate.redacted();\n+      return this;\n+    }\n+\n+    /** @see Builder#build() */\n+    public final WithCorrelation build() {\n+      return new WithCorrelation(delegate);\n+    }\n+  }\n+\n+  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n+    WithCorrelation(Builder builder) {\n+      super(builder);\n+    }\n+  }\n+\n+  final String prefix;\n+  final String name;\n+  final boolean redacted;\n+\n+  ExtraField(Builder builder) {\n+    prefix = builder.prefix;\n+    name = builder.name;\n+    redacted = builder.redacted;\n+  }\n+\n+  /** Extracts the value for this field in the context or null if unavailable. */\n+  @Nullable public String getValue(TraceContext context) {\n+    return PropagationFields.get(context, name, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /** Sets the value of the this field, or drops if not configured. */\n+  public void setValue(TraceContext context, String value) {\n+    PropagationFields.put(context, name, value, ExtraFieldPropagation.Extra.class);\n+  }\n+\n+  /**\n+   * Returns the value of this field in the implicit trace context or null if not available.\n+   *\n+   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n+   */\n+  @Nullable public String getValue() {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context) : null;\n+  }\n+\n+  /**\n+   * Sets the value of this field in the implicit trace context or ignores when not available.", "originalCommit": "7bfa6a7341dfee7016cfc211f7b10c02f65f8676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bb169a201cfab20323b5b8b44db51ce00007e323", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 1de5ecf94..494f7442d 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -275,7 +346,7 @@ public class ExtraField {\n   }\n \n   /**\n-   * Sets the value of this field in the implicit trace context or ignores when not available.\n+   * Like {@link #setValue(TraceContext, String)} except against the current trace context.\n    *\n    * <p>Prefer {@link #setValue(TraceContext, String)} if you have a reference to the trace\n    * context.\n", "next_change": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 494f7442d..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -346,14 +386,14 @@ public class ExtraField {\n   }\n \n   /**\n-   * Like {@link #setValue(TraceContext, String)} except against the current trace context.\n+   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n    *\n-   * <p>Prefer {@link #setValue(TraceContext, String)} if you have a reference to the trace\n+   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n    * context.\n    */\n-  public void setValue(String value) {\n+  public void updateValue(String value) {\n     TraceContext context = currentTraceContext();\n-    if (context != null) setValue(context, value);\n+    if (context != null) updateValue(context, value);\n   }\n \n   /** The non-empty name of the field. Ex \"userId\" */\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"oid": "bb169a201cfab20323b5b8b44db51ce00007e323", "url": "https://github.com/openzipkin/brave/commit/bb169a201cfab20323b5b8b44db51ce00007e323", "message": "Exposes CorrelationField and ExtraField Apis\n\nThis completes the most common requests around correlation fields by\ngeneralizing code in support for correlation fields, both synchronizing\nto logging context and also propagation (extra fields).\n\nNotably, this allows you to not only define constants for the fields you\nwant, but also decide if they are permissible for correlation.\n\nEx.\n\n```java\n // configure the field, permitting it to be used in correlation contexts\n static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n\n // Allow logging patterns like %X{traceId} %X{bp}\n loggingContext = new Log4J2Context();\n\n decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n                                           .addField(BUSINESS_PROCESS).build();\n\n tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n                                                        .addField(BUSINESS_PROCESS)\n                                                        .build())\n               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n                                                                  .addScopeDecorator(decorator)\n                                                                  .build())\n\n // Assume runtime code looks like this\n @SendTo(SourceChannels.OUTPUT)\n public void timerMessageSource() {\n   BUSINESS_PROCESS.setValue(\"accounting\");\n   // The logging expression %{bp} will show \"accounting\" in businessCode()\n   businessCode();\n }\n```", "committedDate": "2020-03-30T04:26:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNTExNg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399935116", "body": "Makes sense", "bodyText": "Makes sense", "bodyHTML": "<p dir=\"auto\">Makes sense</p>", "author": "anuraaga", "createdAt": "2020-03-30T05:29:38Z", "path": "brave/src/main/java/brave/internal/CorrelationContext.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal;\n+\n+import brave.propagation.CorrelationFieldScopeDecorator;\n+\n+/**\n+ * Dispatches methods to synchronize fields with a context such as SLF4J MDC.\n+ *\n+ * <p><em>This is internal:</em> All subtypes of {@link CorrelationFieldScopeDecorator} are sealed\n+ * to this repository until we better understand implications of making this a public type.\n+ */\n+// NOTE: revert to abstract class with protected signatures if this is ever promoted to the\n+// brave.propagation package.\n+public interface CorrelationContext {\n+  /**\n+   * Returns the correlation property of the specified name iff it is a string, or null otherwise.\n+   */\n+  @Nullable String get(String name);\n+\n+  /** Replaces the correlation property of the specified name with a non-null value. */\n+  void put(String name, @Nullable String value);\n+\n+  /** Removes the correlation property of the specified name. */\n+  void remove(String name);\n+\n+  // The below will be sorted into RATIONALE.md once stable\n+  //\n+  // NOTES: This design is based on cherry-picking methods available in underlying log contexts, but\n+  // avoiding operations that accept Map as this implies overhead to construct and iterate over.\n+  //\n+  // Here is an example source from Log4J 2:\n+  //\n+  // public interface ThreadContextMap2 extends ThreadContextMap {\n+  //   void putAll(Map<String, String> var1);\n+  //\n+  //   StringMap getReadOnlyContextData();\n+  // }\n+  //\n+  // public interface ThreadContextMap {\n+  //   void clear();\n+  //\n+  //   boolean containsKey(String var1);\n+  //\n+  //   String get(String var1);\n+  //\n+  //   Map<String, String> getCopy();\n+  //\n+  //   Map<String, String> getImmutableMapOrNull();\n+  //\n+  //   boolean isEmpty();\n+  //\n+  //   void put(String var1, String var2);\n+  //\n+  //   void remove(String var1);\n+  // }\n+  //\n+  // ## On guarding with previous value\n+  //\n+  // While the current design is optimized for log contexts (or those similar such as JFR), you can\n+  // reasonably think of this like generic contexts such as gRPC and Armeria\n+  // https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/RequestContextStorage.java#L88\n+  // https://github.com/grpc/grpc-java/blob/master/context/src/main/java/io/grpc/ThreadLocalContextStorage.java\n+  //\n+  // They have some design facets to help with overlapping scopes, notably comparing the current\n+  // value vs the one written prior to reverting a value. Since this feature was designed for\n+  // contexts which don't have these operators, achieving this would require reading back from the\n+  // logging context manually. This has two problems, one is performance impact and the other is\n+  // that the value may have been updated out-of-band. Unlike gRPC context, logging contexts are\n+  // plain string keys, and are easy to clobber by users or other code. It is therefore hard to tell\n+  // if inconsistency is due to things under your control or not (ex bad instrumentation vs 3rd\n+  // party code).", "originalCommit": "aaee287518c76adf4db49c8879695c1754441b1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "da9738c589d721b4d8d0f21c1e49e1f9476fae69", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/CorrelationContext.java b/brave/src/main/java/brave/internal/CorrelationContext.java\nindex e8013c9f4..8c53012a8 100644\n--- a/brave/src/main/java/brave/internal/CorrelationContext.java\n+++ b/brave/src/main/java/brave/internal/CorrelationContext.java\n", "chunk": "@@ -29,56 +29,9 @@ public interface CorrelationContext {\n    */\n   @Nullable String get(String name);\n \n-  /** Replaces the correlation property of the specified name with a non-null value. */\n+  /** Replaces the correlation property of the specified name with the specified value. */\n   void put(String name, @Nullable String value);\n \n   /** Removes the correlation property of the specified name. */\n   void remove(String name);\n-\n-  // The below will be sorted into RATIONALE.md once stable\n-  //\n-  // NOTES: This design is based on cherry-picking methods available in underlying log contexts, but\n-  // avoiding operations that accept Map as this implies overhead to construct and iterate over.\n-  //\n-  // Here is an example source from Log4J 2:\n-  //\n-  // public interface ThreadContextMap2 extends ThreadContextMap {\n-  //   void putAll(Map<String, String> var1);\n-  //\n-  //   StringMap getReadOnlyContextData();\n-  // }\n-  //\n-  // public interface ThreadContextMap {\n-  //   void clear();\n-  //\n-  //   boolean containsKey(String var1);\n-  //\n-  //   String get(String var1);\n-  //\n-  //   Map<String, String> getCopy();\n-  //\n-  //   Map<String, String> getImmutableMapOrNull();\n-  //\n-  //   boolean isEmpty();\n-  //\n-  //   void put(String var1, String var2);\n-  //\n-  //   void remove(String var1);\n-  // }\n-  //\n-  // ## On guarding with previous value\n-  //\n-  // While the current design is optimized for log contexts (or those similar such as JFR), you can\n-  // reasonably think of this like generic contexts such as gRPC and Armeria\n-  // https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/common/RequestContextStorage.java#L88\n-  // https://github.com/grpc/grpc-java/blob/master/context/src/main/java/io/grpc/ThreadLocalContextStorage.java\n-  //\n-  // They have some design facets to help with overlapping scopes, notably comparing the current\n-  // value vs the one written prior to reverting a value. Since this feature was designed for\n-  // contexts which don't have these operators, achieving this would require reading back from the\n-  // logging context manually. This has two problems, one is performance impact and the other is\n-  // that the value may have been updated out-of-band. Unlike gRPC context, logging contexts are\n-  // plain string keys, and are easy to clobber by users or other code. It is therefore hard to tell\n-  // if inconsistency is due to things under your control or not (ex bad instrumentation vs 3rd\n-  // party code).\n }\n", "next_change": {"commit": "a042fe16ff30c94988396e85637471dfa9719845", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/CorrelationContext.java b/brave/src/main/java/brave/internal/CorrelationContext.java\nindex 8c53012a8..727e20cfe 100644\n--- a/brave/src/main/java/brave/internal/CorrelationContext.java\n+++ b/brave/src/main/java/brave/internal/CorrelationContext.java\n", "chunk": "@@ -24,14 +24,11 @@ import brave.propagation.CorrelationScopeDecorator;\n // NOTE: revert to abstract class with protected signatures if this is ever promoted to the\n // brave.propagation package.\n public interface CorrelationContext {\n-  /**\n-   * Returns the correlation property of the specified name iff it is a string, or null otherwise.\n-   */\n-  @Nullable String get(String name);\n+  /** Returns the string property of the specified name or {@code null}. */\n+  // same as BaggageContext#getValue(BaggageField, TraceContext)\n+  @Nullable String getValue(String name);\n \n-  /** Replaces the correlation property of the specified name with the specified value. */\n-  void put(String name, @Nullable String value);\n-\n-  /** Removes the correlation property of the specified name. */\n-  void remove(String name);\n+  /** Returns false if the update was ignored. */\n+  // same as BaggageContext#updateValue(BaggageField, TraceContext, String)\n+  boolean update(String name, @Nullable String value);\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNTk1Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399935957", "body": "Maybe could describe more what invalidation actually means - I guess it's losing any possible performance benefit.", "bodyText": "Maybe could describe more what invalidation actually means - I guess it's losing any possible performance benefit.", "bodyHTML": "<p dir=\"auto\">Maybe could describe more what invalidation actually means - I guess it's losing any possible performance benefit.</p>", "author": "anuraaga", "createdAt": "2020-03-30T05:32:55Z", "path": "brave/src/main/java/brave/propagation/CorrelationField.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+\n+/**\n+ * A field which are applied in a correlation context such as MDC via {@link\n+ * CorrelationFieldScopeDecorator}.\n+ *\n+ * <p>Field updates only apply during {@linkplain CorrelationFieldScopeDecorator scope\n+ * decoration}. This means values set do not flush immediately to the underlying correlation context\n+ * by default. Rather, they are scheduled for the next scope operation. This is a way to control\n+ * overhead. Use the type {@link Flushable} to allow immediate updates.\n+ *\n+ * <p>{@link #equals(Object)} and {@link #hashCode()} should be overridden to implement lower-case\n+ * {@link #name()} comparison.\n+ *\n+ * @see CorrelationFieldScopeDecorator\n+ * @since 5.11\n+ */\n+public interface CorrelationField {\n+  /** The name of this field in the correlation context. */\n+  String name();\n+\n+  /**\n+   * Returns the most recent value of the field named {@link #name()} in the context or null if\n+   * unavailable.\n+   */\n+  @Nullable String getValue(TraceContext context);\n+\n+  /**\n+   * Marks a field such that updates immediately flush to the correlation context, when configured\n+   * and their corresponding trace context is current. This has a significant performance impact as\n+   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.", "originalCommit": "aaee287518c76adf4db49c8879695c1754441b1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDE5NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400070194", "bodyText": "I rewrote as this:\n     * Call this to immediately flush a value update to the correlation context as opposed waiting\n     * for the next scope decoration. This has a significant performance impact as it requires even\n     * {@link CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n\nmaybeScope returns no-op when applying the context results in the same data. maybeScope when not interfered with prevents another layer (ex several arrays). If we don't know if a field will be flushed or not, we need to allocate all of that even if no change ever takes place. This could happen thousands of times.", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNTk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex e69cabe8b..c665b39cc 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -40,22 +40,32 @@ public interface CorrelationField {\n    */\n   @Nullable String getValue(TraceContext context);\n \n-  /**\n-   * Marks a field such that updates immediately flush to the correlation context, when configured\n-   * and their corresponding trace context is current. This has a significant performance impact as\n-   * it will invalidate the {@link CurrentTraceContext#maybeScope(TraceContext)} operator.\n-   *\n-   * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-   * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-   * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-   * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-   * correlation context, as they will apply on the next scope operation.\n-   */\n-  interface Flushable extends CorrelationField {\n+  interface Updatable extends CorrelationField {\n     /**\n-     * Flushes the most recent value of the field named {@link #name()} into the correlation\n-     * context, or ignores if not configured.\n+     * MCall this to immediately flush a value update to the correlation context as opposed waiting\n+     * for the next scope decoration. This has a significant performance impact as it requires even\n+     * {@link CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   // Assume BUSINESS_PROCESS is an updatable field\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     *\n+     * <h3>Appropriate Usage</h3>\n+     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n+     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n+     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n+     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n+     * correlation context, as they will apply on the next scope operation.\n+     *\n+     * @see ExtraField.CorrelationBuilder#flushOnUpdate()\n      */\n-    void flushValue();\n+    boolean flushOnUpdate();\n   }\n }\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\nindex c665b39cc..0fde20a36 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationField.java\n", "chunk": "@@ -58,14 +155,59 @@ public interface CorrelationField {\n      * }</pre>\n      *\n      * <h3>Appropriate Usage</h3>\n+     * This has a significant performance impact as it requires even {@link\n+     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n      * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n      * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n      * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n      * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n      * correlation context, as they will apply on the next scope operation.\n-     *\n-     * @see ExtraField.CorrelationBuilder#flushOnUpdate()\n      */\n-    boolean flushOnUpdate();\n+    public final boolean flushOnUpdate() {\n+      return flushOnUpdate;\n+    }\n+\n+    final boolean flushOnUpdate;\n+\n+    Updatable(String name, boolean flushOnUpdate) { // package sealed\n+      super(name);\n+      this.flushOnUpdate = flushOnUpdate;\n+    }\n+  }\n+\n+  final String name, lcName;\n+\n+  CorrelationField(String name) { // sealed to this package\n+    this.name = validateName(name);\n+    this.lcName = name.toLowerCase(Locale.ROOT);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + name + \"}\";\n+  }\n+\n+  /** Returns true for any correlation field with the same name (case insensitive). */\n+  @Override public final boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof CorrelationField)) return false;\n+    return lcName.equals(((CorrelationField) o).lcName);\n+  }\n+\n+  /** Returns the same value for any correlation field with the same name (case insensitive). */\n+  @Override public final int hashCode() {\n+    return lcName.hashCode();\n+  }\n+\n+  static String validateName(String name) {\n+    if (name == null) throw new NullPointerException(\"name == null\");\n+    name = name.trim();\n+    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n+    return name;\n+  }\n+\n+  @Nullable static TraceContext currentTraceContext() {\n+    Tracing tracing = Tracing.current();\n+    return tracing != null ? tracing.currentTraceContext().get() : null;\n   }\n }\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationField.java b/brave/src/main/java/brave/propagation/CorrelationField.java\ndeleted file mode 100644\nindex 0fde20a36..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationField.java\n+++ /dev/null\n", "chunk": "@@ -1,213 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.NoopSpanCustomizer;\n-import brave.ScopedSpan;\n-import brave.Span;\n-import brave.SpanCustomizer;\n-import brave.Tracing;\n-import brave.handler.MutableSpan;\n-import brave.internal.Nullable;\n-import java.util.Locale;\n-\n-/**\n- * A possibly remote field used for correlation such as MDC via {@link CorrelationScopeDecorator}.\n- *\n- * Here's an example of a constant field, which you want to add a span tag.\n- * <pre>{@code\n- * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- *\n- * // Later, you can call below to add a tag with the field name to a span.\n- * CLOUD_REGION.tag(span);\n- * }</pre>\n- *\n- * <h3>Updatable fields</h3>\n- * {@link Updatable} fields are mutable, typically in request scope. The most common mutable field\n- * is {@linkplain BaggageField baggage}.\n- *\n- * <p>Ex. If you have access to an updatable field, you can reset its value at runtime.\n- * <pre>{@code\n- * // Later, you can call below to affect the country code of the current trace context\n- * COUNTRY_CODE.updateValue(\"FO\");\n- * String countryCode = COUNTRY_CODE.getValue();\n- * COUNTRY_CODE.tag(span);\n- * }</pre>\n- *\n- * @see CorrelationFields\n- * @see CorrelationScopeDecorator\n- * @see BaggageField\n- * @see BaggagePropagation\n- * @since 5.11\n- */\n-public abstract class CorrelationField {\n-  /**\n-   * The non-empty name of the field. Ex \"userId\".\n-   *\n-   * <p>For example, if using log correlation and with field named \"userId\", the {@linkplain\n-   * #getValue(TraceContext) value} becomes the log variable {@code %{userId}} when the span is next\n-   * made current.\n-   *\n-   * @see CorrelationScopeDecorator\n-   */\n-  public final String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * Returns the most recent value of the field named {@link #name()} in the context or null if\n-   * unavailable.\n-   */\n-  @Nullable public abstract String getValue(TraceContext context);\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * {@linkplain ScopedSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(ScopedSpan scopedSpan) {\n-    if (scopedSpan.isNoop()) return;\n-    String value = getValue(scopedSpan.context());\n-    if (value != null) scopedSpan.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain Span#tag(String, String) tags} the value if the input is not no-op and field value\n-   * is available.\n-   */\n-  public final void tag(Span span) {\n-    if (span.isNoop()) return;\n-    String value = getValue(span.context());\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain SpanCustomizer#tag(String, String) tags} the value if the input is not no-op and\n-   * field value is available.\n-   */\n-  public final void tag(TraceContext context, SpanCustomizer customizer) {\n-    if (customizer instanceof Span) {\n-      tag((Span) customizer);\n-      return;\n-    }\n-    if (customizer == NoopSpanCustomizer.INSTANCE) return;\n-    String value = getValue(context);\n-    if (value != null) customizer.tag(name, value);\n-  }\n-\n-  /**\n-   * {@linkplain MutableSpan#tag(String, String) tags} the value if the input is not no-op and field\n-   * value is available.\n-   */\n-  public final void tag(TraceContext context, MutableSpan span) {\n-    String value = getValue(context);\n-    if (value != null) span.tag(name, value);\n-  }\n-\n-  public static abstract class Updatable extends CorrelationField {\n-    /** Updates the value of the this field, or ignores if not configured. */\n-    public abstract void updateValue(TraceContext context, @Nullable String value);\n-\n-    /**\n-     * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-     *\n-     * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-     * context.\n-     */\n-    public void updateValue(String value) {\n-      TraceContext context = currentTraceContext();\n-      if (context != null) updateValue(context, value);\n-    }\n-\n-    /**\n-     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n-     * to the correlation context.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   // Assume BUSINESS_PROCESS is an updatable field\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * <h3>Appropriate Usage</h3>\n-     * This has a significant performance impact as it requires even {@link\n-     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n-     *\n-     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n-     * fields such as {@link CorrelationFields#SPAN_ID the span ID} and {@linkplain\n-     * CorrelationFields#constant(String, String) constants} such as env variables do not need to be\n-     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n-     * correlation context, as they will apply on the next scope operation.\n-     */\n-    public final boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    final boolean flushOnUpdate;\n-\n-    Updatable(String name, boolean flushOnUpdate) { // package sealed\n-      super(name);\n-      this.flushOnUpdate = flushOnUpdate;\n-    }\n-  }\n-\n-  final String name, lcName;\n-\n-  CorrelationField(String name) { // sealed to this package\n-    this.name = validateName(name);\n-    this.lcName = name.toLowerCase(Locale.ROOT);\n-  }\n-\n-  @Override public String toString() {\n-    return getClass().getSimpleName() + \"{\" + name + \"}\";\n-  }\n-\n-  /** Returns true for any correlation field with the same name (case insensitive). */\n-  @Override public final boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof CorrelationField)) return false;\n-    return lcName.equals(((CorrelationField) o).lcName);\n-  }\n-\n-  /** Returns the same value for any correlation field with the same name (case insensitive). */\n-  @Override public final int hashCode() {\n-    return lcName.hashCode();\n-  }\n-\n-  static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n-\n-  @Nullable static TraceContext currentTraceContext() {\n-    Tracing tracing = Tracing.current();\n-    return tracing != null ? tracing.currentTraceContext().get() : null;\n-  }\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNzUzNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399937535", "body": "Maybe it's fun to put `logger.info('Encoding the span, hope it works') // Log message will have ... in the context!` ", "bodyText": "Maybe it's fun to put logger.info('Encoding the span, hope it works') // Log message will have ... in the context!", "bodyHTML": "<p dir=\"auto\">Maybe it's fun to put <code>logger.info('Encoding the span, hope it works') // Log message will have ... in the context!</code></p>", "author": "anuraaga", "createdAt": "2020-03-30T05:38:49Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.CorrelationContext;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging through decoration of a scope.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the field \"region\", so it can be used as a log expression %X{region}\n+ * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(cloudRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(decorator)\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ *\n+ * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n+ * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n+ * try {\n+ *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!", "originalCommit": "aaee287518c76adf4db49c8879695c1754441b1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MDM1NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400070354", "bodyText": "good idea", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzNzUzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\ndeleted file mode 100644\nindex 61fd08a92..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ /dev/null\n", "chunk": "@@ -1,243 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.CorrelationContext;\n-import brave.internal.Nullable;\n-import brave.propagation.CurrentTraceContext.Scope;\n-import brave.propagation.CurrentTraceContext.ScopeDecorator;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n- * as logging through decoration of a scope.\n- *\n- * <p>Setup example:\n- * <pre>{@code\n- * // Allow logging patterns like %X{traceId}/%X{spanId}\n- * loggingContext = new Log4J2Context();\n- *\n- * // Add the field \"region\", so it can be used as a log expression %X{region}\n- * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *   .addField(cloudRegion)\n- *   .build();\n- *\n- * // Integrate the decorator\n- * tracing = Tracing.newBuilder()\n- *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                    .addScopeDecorator(decorator)\n- *                    .build()\n- *                  )\n- *                  ...\n- *                  .build();\n- *\n- * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n- * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n- * try {\n- *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n- *   return encoder.encode();\n- * } catch (RuntimeException | Error e) {\n- *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n- *   throw e;\n- * } finally {\n- *   span.finish();\n- * }\n- * }</pre>\n- *\n- * <h3>Extra Field integration</h3>\n- * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n- * builder here like any other correlation field. This will ensure that their values are applied and\n- * reverted upon scope decoration.\n- *\n- * @see CorrelationField\n- * @see CorrelationContext\n- * @see ExtraField.Builder#withCorrelation()\n- * @since 5.11\n- */\n-public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n-  // do not define newBuilder or create() here as it will mask subtypes\n-  public static abstract class Builder {\n-    final CorrelationContext context;\n-    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n-      CorrelationFields.TRACE_ID,\n-      CorrelationFields.PARENT_ID,\n-      CorrelationFields.SPAN_ID,\n-      CorrelationFields.SAMPLED\n-    ));\n-\n-    /** Internal constructor used by subtypes. */\n-    protected Builder(CorrelationContext context) {\n-      if (context == null) throw new NullPointerException(\"context == null\");\n-      this.context = context;\n-    }\n-\n-    /**\n-     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n-     * ones you need}.\n-     *\n-     * <p>Defaults may include a field you aren't using, such as \"parentId\". For best\n-     * performance, only include the fields you use in your correlation expressions (such as log\n-     * formats).\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearFields() {\n-      this.fields.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addField(CorrelationField field) {\n-      if (field == null) throw new NullPointerException(\"field == null\");\n-      if (field.name() == null) throw new NullPointerException(\"field.name() == null\");\n-      if (field.name().isEmpty()) throw new NullPointerException(\"field.name() isEmpty\");\n-      fields.add(field);\n-      return this;\n-    }\n-\n-    /** @throws IllegalArgumentException if no correlation fields were added. */\n-    public final CorrelationFieldScopeDecorator build() {\n-      int fieldCount = fields.size();\n-      if (fieldCount == 0) throw new IllegalArgumentException(\"no correlation fields\");\n-      if (fieldCount == 1) {\n-        return new Single(context, fields.iterator().next());\n-      }\n-      return new Multiple(context, fields);\n-    }\n-  }\n-\n-  final CorrelationContext context;\n-\n-  CorrelationFieldScopeDecorator(CorrelationContext context) {\n-    this.context = context;\n-  }\n-\n-  // Users generally expect data to be \"cleaned up\" when a scope completes, even if it was written\n-  // mid-scope. Ex. https://github.com/spring-cloud/spring-cloud-sleuth/issues/1416\n-  //\n-  // This means we cannot return a no-op scope based on if we detect no change when comparing\n-  // values up front. Hence, we save off the first value and revert when a scope closes. If a late\n-  // update changed the value mid-scope, it will reverted.\n-  void updateUnconditionally(CorrelationField field, @Nullable String newValue) {\n-    if (newValue != null) {\n-      context.put(field.name(), newValue);\n-    } else {\n-      context.remove(field.name());\n-    }\n-  }\n-\n-  static final class Single extends CorrelationFieldScopeDecorator {\n-    final CorrelationField field;\n-\n-    Single(CorrelationContext context, CorrelationField field) {\n-      super(context);\n-      this.field = field;\n-    }\n-\n-    @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      String valueToRevert = context.get(field.name());\n-      String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n-\n-      if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n-\n-      // Only the value to revert is saved off in order to save overhead.\n-      return new SingleCorrelationFieldScope(scope, valueToRevert);\n-    }\n-\n-    final class SingleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n-      final Scope delegate;\n-      final @Nullable String valueToRevert;\n-\n-      SingleCorrelationFieldScope(Scope delegate, @Nullable String valueToRevert) {\n-        this.delegate = delegate;\n-        this.valueToRevert = valueToRevert;\n-      }\n-\n-      @Override public void close() {\n-        delegate.close();\n-        updateUnconditionally(field, valueToRevert);\n-      }\n-\n-      @Override public void update(CorrelationField field, String value) {\n-        if (!field.equals(Single.this.field)) return;\n-        updateUnconditionally(field, value);\n-      }\n-    }\n-  }\n-\n-  // TODO: put this in a thread local, and use in extra field propagation. Watch for overlaps\n-  // Ex look at how ThreadlocalSpan works.\n-  interface CorrelationFieldUpdater {\n-    void update(CorrelationField field, String value);\n-  }\n-\n-  static final class Multiple extends CorrelationFieldScopeDecorator {\n-    final CorrelationField[] fields;\n-\n-    Multiple(CorrelationContext context, Set<CorrelationField> correlationFields) {\n-      super(context);\n-      fields = correlationFields.toArray(new CorrelationField[0]);\n-    }\n-\n-    @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      // Only values to revert are saved off in order to save overhead.\n-      String[] valuesToRevert = new String[fields.length];\n-      for (int i = 0; i < fields.length; i++) {\n-        CorrelationField field = fields[i];\n-        String valueToRevert = context.get(field.name());\n-        String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n-\n-        if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n-\n-        valuesToRevert[i] = valueToRevert;\n-      }\n-\n-      return new MultipleCorrelationFieldScope(scope, valuesToRevert);\n-    }\n-\n-    final class MultipleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n-      final Scope delegate;\n-      final String[] valuesToRevert;\n-\n-      MultipleCorrelationFieldScope(Scope delegate, String[] valuesToRevert) {\n-        this.delegate = delegate;\n-        this.valuesToRevert = valuesToRevert;\n-      }\n-\n-      @Override public void close() {\n-        delegate.close();\n-        for (int i = 0; i < fields.length; i++) {\n-          updateUnconditionally(fields[i], valuesToRevert[i]);\n-        }\n-      }\n-\n-      @Override public void update(CorrelationField field, String value) {\n-        for (int i = 0; i < fields.length; i++) {\n-          if (field.equals(fields[i])) {\n-            updateUnconditionally(field, value);\n-            return;\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  static boolean equals(@Nullable String a, @Nullable String b) {\n-    return a == null ? b == null : a.equals(b); // Java 6 can't use Objects.equals()\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzOTY5MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399939691", "body": "Would it be more consistent for this to be `update` and others `maybeUpdate`?", "bodyText": "Would it be more consistent for this to be update and others maybeUpdate?", "bodyHTML": "<p dir=\"auto\">Would it be more consistent for this to be <code>update</code> and others <code>maybeUpdate</code>?</p>", "author": "anuraaga", "createdAt": "2020-03-30T05:46:28Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.CorrelationContext;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging through decoration of a scope.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the field \"region\", so it can be used as a log expression %X{region}\n+ * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(cloudRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(decorator)\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ *\n+ * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n+ * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n+ * try {\n+ *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n+ *   return encoder.encode();\n+ * } catch (RuntimeException | Error e) {\n+ *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n+ *   throw e;\n+ * } finally {\n+ *   span.finish();\n+ * }\n+ * }</pre>\n+ *\n+ * <h3>Extra Field integration</h3>\n+ * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n+ * builder here like any other correlation field. This will ensure that their values are applied and\n+ * reverted upon scope decoration.\n+ *\n+ * @see CorrelationField\n+ * @see CorrelationContext\n+ * @see ExtraField.Builder#withCorrelation()\n+ * @since 5.11\n+ */\n+public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  // do not define newBuilder or create() here as it will mask subtypes\n+  public static abstract class Builder {\n+    final CorrelationContext context;\n+    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n+      CorrelationFields.TRACE_ID,\n+      CorrelationFields.PARENT_ID,\n+      CorrelationFields.SPAN_ID,\n+      CorrelationFields.SAMPLED\n+    ));\n+\n+    /** Internal constructor used by subtypes. */\n+    protected Builder(CorrelationContext context) {\n+      if (context == null) throw new NullPointerException(\"context == null\");\n+      this.context = context;\n+    }\n+\n+    /**\n+     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n+     * ones you need}.\n+     *\n+     * <p>Defaults may include a field you aren't using, such as \"parentId\". For best\n+     * performance, only include the fields you use in your correlation expressions (such as log\n+     * formats).\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearFields() {\n+      this.fields.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addField(CorrelationField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      if (field.name() == null) throw new NullPointerException(\"field.name() == null\");\n+      if (field.name().isEmpty()) throw new NullPointerException(\"field.name() isEmpty\");\n+      fields.add(field);\n+      return this;\n+    }\n+\n+    /** @throws IllegalArgumentException if no correlation fields were added. */\n+    public final CorrelationFieldScopeDecorator build() {\n+      int fieldCount = fields.size();\n+      if (fieldCount == 0) throw new IllegalArgumentException(\"no correlation fields\");\n+      if (fieldCount == 1) {\n+        return new Single(context, fields.iterator().next());\n+      }\n+      return new Multiple(context, fields);\n+    }\n+  }\n+\n+  final CorrelationContext context;\n+\n+  CorrelationFieldScopeDecorator(CorrelationContext context) {\n+    this.context = context;\n+  }\n+\n+  // Users generally expect data to be \"cleaned up\" when a scope completes, even if it was written\n+  // mid-scope. Ex. https://github.com/spring-cloud/spring-cloud-sleuth/issues/1416\n+  //\n+  // This means we cannot return a no-op scope based on if we detect no change when comparing\n+  // values up front. Hence, we save off the first value and revert when a scope closes. If a late\n+  // update changed the value mid-scope, it will reverted.\n+  void updateUnconditionally(CorrelationField field, @Nullable String newValue) {", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MTgzMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400071832", "bodyText": "already changed to update :)", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkzOTY5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nindex 61fd08a92..e9dd72c3a 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n", "chunk": "@@ -133,7 +134,8 @@ public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n   // This means we cannot return a no-op scope based on if we detect no change when comparing\n   // values up front. Hence, we save off the first value and revert when a scope closes. If a late\n   // update changed the value mid-scope, it will reverted.\n-  void updateUnconditionally(CorrelationField field, @Nullable String newValue) {\n+  static void update(\n+    CorrelationContext context, CorrelationField field, @Nullable String newValue) {\n     if (newValue != null) {\n       context.put(field.name(), newValue);\n     } else {\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\nsimilarity index 85%\nrename from brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\nrename to brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\nindex e9dd72c3a..31b145671 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationScopeDecorator.java\n", "chunk": "@@ -143,7 +135,7 @@ public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n     }\n   }\n \n-  static final class Single extends CorrelationFieldScopeDecorator {\n+  static final class Single extends CorrelationScopeDecorator {\n     final CorrelationField field;\n     final boolean fieldUpdatable, flushOnUpdate;\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0Mzg4NA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399943884", "body": "Probably over optimization, but what do you think about defaulting to only trace ID + span ID (think the javadoc on the fields indicate those are the two common ones), and having a `Double` for premature optimization of this use case? :)", "bodyText": "Probably over optimization, but what do you think about defaulting to only trace ID + span ID (think the javadoc on the fields indicate those are the two common ones), and having a Double for premature optimization of this use case? :)", "bodyHTML": "<p dir=\"auto\">Probably over optimization, but what do you think about defaulting to only trace ID + span ID (think the javadoc on the fields indicate those are the two common ones), and having a <code>Double</code> for premature optimization of this use case? :)</p>", "author": "anuraaga", "createdAt": "2020-03-30T06:00:41Z", "path": "brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.CorrelationContext;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n+ * as logging through decoration of a scope.\n+ *\n+ * <p>Setup example:\n+ * <pre>{@code\n+ * // Allow logging patterns like %X{traceId}/%X{spanId}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * // Add the field \"region\", so it can be used as a log expression %X{region}\n+ * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *   .addField(cloudRegion)\n+ *   .build();\n+ *\n+ * // Integrate the decorator\n+ * tracing = Tracing.newBuilder()\n+ *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                    .addScopeDecorator(decorator)\n+ *                    .build()\n+ *                  )\n+ *                  ...\n+ *                  .build();\n+ *\n+ * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n+ * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n+ * try {\n+ *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n+ *   return encoder.encode();\n+ * } catch (RuntimeException | Error e) {\n+ *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n+ *   throw e;\n+ * } finally {\n+ *   span.finish();\n+ * }\n+ * }</pre>\n+ *\n+ * <h3>Extra Field integration</h3>\n+ * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n+ * builder here like any other correlation field. This will ensure that their values are applied and\n+ * reverted upon scope decoration.\n+ *\n+ * @see CorrelationField\n+ * @see CorrelationContext\n+ * @see ExtraField.Builder#withCorrelation()\n+ * @since 5.11\n+ */\n+public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  // do not define newBuilder or create() here as it will mask subtypes\n+  public static abstract class Builder {\n+    final CorrelationContext context;\n+    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n+      CorrelationFields.TRACE_ID,", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3MjQ0OA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400072448", "bodyText": "I suppose we can for the builder variant. we still need all fields for the backported factory method. Sounds good!", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0Mzg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java b/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\ndeleted file mode 100644\nindex 61fd08a92..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationFieldScopeDecorator.java\n+++ /dev/null\n", "chunk": "@@ -1,243 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.CorrelationContext;\n-import brave.internal.Nullable;\n-import brave.propagation.CurrentTraceContext.Scope;\n-import brave.propagation.CurrentTraceContext.ScopeDecorator;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Synchronizes fields such as {@link CorrelationFields#TRACE_ID} with a correlation context, such\n- * as logging through decoration of a scope.\n- *\n- * <p>Setup example:\n- * <pre>{@code\n- * // Allow logging patterns like %X{traceId}/%X{spanId}\n- * loggingContext = new Log4J2Context();\n- *\n- * // Add the field \"region\", so it can be used as a log expression %X{region}\n- * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *   .addField(cloudRegion)\n- *   .build();\n- *\n- * // Integrate the decorator\n- * tracing = Tracing.newBuilder()\n- *                  .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                    .addScopeDecorator(decorator)\n- *                    .build()\n- *                  )\n- *                  ...\n- *                  .build();\n- *\n- * // Any scope operations (updates to the current span) apply the fields defined by the decorator.\n- * ScopedSpan span = tracing.tracer().startScopedSpan(\"encode\");\n- * try {\n- *   // %X{traceId} %X{parentId} %X{spanId} %X{sampled} %X{region} are in the logging context!\n- *   return encoder.encode();\n- * } catch (RuntimeException | Error e) {\n- *   span.error(e); // Unless you handle exceptions, you might not know the operation failed!\n- *   throw e;\n- * } finally {\n- *   span.finish();\n- * }\n- * }</pre>\n- *\n- * <h3>Extra Field integration</h3>\n- * To configure extra fields marked {@link ExtraField.Builder#withCorrelation()}, add them to the\n- * builder here like any other correlation field. This will ensure that their values are applied and\n- * reverted upon scope decoration.\n- *\n- * @see CorrelationField\n- * @see CorrelationContext\n- * @see ExtraField.Builder#withCorrelation()\n- * @since 5.11\n- */\n-public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n-  // do not define newBuilder or create() here as it will mask subtypes\n-  public static abstract class Builder {\n-    final CorrelationContext context;\n-    final Set<CorrelationField> fields = new LinkedHashSet<>(asList(\n-      CorrelationFields.TRACE_ID,\n-      CorrelationFields.PARENT_ID,\n-      CorrelationFields.SPAN_ID,\n-      CorrelationFields.SAMPLED\n-    ));\n-\n-    /** Internal constructor used by subtypes. */\n-    protected Builder(CorrelationContext context) {\n-      if (context == null) throw new NullPointerException(\"context == null\");\n-      this.context = context;\n-    }\n-\n-    /**\n-     * Invoke this to clear fields so that you can {@linkplain #addField(CorrelationField) add the\n-     * ones you need}.\n-     *\n-     * <p>Defaults may include a field you aren't using, such as \"parentId\". For best\n-     * performance, only include the fields you use in your correlation expressions (such as log\n-     * formats).\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearFields() {\n-      this.fields.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addField(CorrelationField field) {\n-      if (field == null) throw new NullPointerException(\"field == null\");\n-      if (field.name() == null) throw new NullPointerException(\"field.name() == null\");\n-      if (field.name().isEmpty()) throw new NullPointerException(\"field.name() isEmpty\");\n-      fields.add(field);\n-      return this;\n-    }\n-\n-    /** @throws IllegalArgumentException if no correlation fields were added. */\n-    public final CorrelationFieldScopeDecorator build() {\n-      int fieldCount = fields.size();\n-      if (fieldCount == 0) throw new IllegalArgumentException(\"no correlation fields\");\n-      if (fieldCount == 1) {\n-        return new Single(context, fields.iterator().next());\n-      }\n-      return new Multiple(context, fields);\n-    }\n-  }\n-\n-  final CorrelationContext context;\n-\n-  CorrelationFieldScopeDecorator(CorrelationContext context) {\n-    this.context = context;\n-  }\n-\n-  // Users generally expect data to be \"cleaned up\" when a scope completes, even if it was written\n-  // mid-scope. Ex. https://github.com/spring-cloud/spring-cloud-sleuth/issues/1416\n-  //\n-  // This means we cannot return a no-op scope based on if we detect no change when comparing\n-  // values up front. Hence, we save off the first value and revert when a scope closes. If a late\n-  // update changed the value mid-scope, it will reverted.\n-  void updateUnconditionally(CorrelationField field, @Nullable String newValue) {\n-    if (newValue != null) {\n-      context.put(field.name(), newValue);\n-    } else {\n-      context.remove(field.name());\n-    }\n-  }\n-\n-  static final class Single extends CorrelationFieldScopeDecorator {\n-    final CorrelationField field;\n-\n-    Single(CorrelationContext context, CorrelationField field) {\n-      super(context);\n-      this.field = field;\n-    }\n-\n-    @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      String valueToRevert = context.get(field.name());\n-      String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n-\n-      if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n-\n-      // Only the value to revert is saved off in order to save overhead.\n-      return new SingleCorrelationFieldScope(scope, valueToRevert);\n-    }\n-\n-    final class SingleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n-      final Scope delegate;\n-      final @Nullable String valueToRevert;\n-\n-      SingleCorrelationFieldScope(Scope delegate, @Nullable String valueToRevert) {\n-        this.delegate = delegate;\n-        this.valueToRevert = valueToRevert;\n-      }\n-\n-      @Override public void close() {\n-        delegate.close();\n-        updateUnconditionally(field, valueToRevert);\n-      }\n-\n-      @Override public void update(CorrelationField field, String value) {\n-        if (!field.equals(Single.this.field)) return;\n-        updateUnconditionally(field, value);\n-      }\n-    }\n-  }\n-\n-  // TODO: put this in a thread local, and use in extra field propagation. Watch for overlaps\n-  // Ex look at how ThreadlocalSpan works.\n-  interface CorrelationFieldUpdater {\n-    void update(CorrelationField field, String value);\n-  }\n-\n-  static final class Multiple extends CorrelationFieldScopeDecorator {\n-    final CorrelationField[] fields;\n-\n-    Multiple(CorrelationContext context, Set<CorrelationField> correlationFields) {\n-      super(context);\n-      fields = correlationFields.toArray(new CorrelationField[0]);\n-    }\n-\n-    @Override public Scope decorateScope(TraceContext traceContext, Scope scope) {\n-      // Only values to revert are saved off in order to save overhead.\n-      String[] valuesToRevert = new String[fields.length];\n-      for (int i = 0; i < fields.length; i++) {\n-        CorrelationField field = fields[i];\n-        String valueToRevert = context.get(field.name());\n-        String currentValue = traceContext != null ? field.getValue(traceContext) : null;\n-\n-        if (!equals(valueToRevert, currentValue)) updateUnconditionally(field, currentValue);\n-\n-        valuesToRevert[i] = valueToRevert;\n-      }\n-\n-      return new MultipleCorrelationFieldScope(scope, valuesToRevert);\n-    }\n-\n-    final class MultipleCorrelationFieldScope implements CorrelationFieldUpdater, Scope {\n-      final Scope delegate;\n-      final String[] valuesToRevert;\n-\n-      MultipleCorrelationFieldScope(Scope delegate, String[] valuesToRevert) {\n-        this.delegate = delegate;\n-        this.valuesToRevert = valuesToRevert;\n-      }\n-\n-      @Override public void close() {\n-        delegate.close();\n-        for (int i = 0; i < fields.length; i++) {\n-          updateUnconditionally(fields[i], valuesToRevert[i]);\n-        }\n-      }\n-\n-      @Override public void update(CorrelationField field, String value) {\n-        for (int i = 0; i < fields.length; i++) {\n-          if (field.equals(fields[i])) {\n-            updateUnconditionally(field, value);\n-            return;\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  static boolean equals(@Nullable String a, @Nullable String b) {\n-    return a == null ? b == null : a.equals(b); // Java 6 can't use Objects.equals()\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NTk5MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399945990", "body": "`lcName`? Otherwise, I think `lcName.equals(o.name())` below doesn't work", "bodyText": "lcName? Otherwise, I think lcName.equals(o.name()) below doesn't work", "bodyHTML": "<p dir=\"auto\"><code>lcName</code>? Otherwise, I think <code>lcName.equals(o.name())</code> below doesn't work</p>", "author": "anuraaga", "createdAt": "2020-03-30T06:07:37Z", "path": "brave/src/main/java/brave/propagation/CorrelationFields.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import java.util.Locale;\n+\n+/**\n+ * Standard fields defined for a correlation context such as MDC.\n+ *\n+ * @since 5.11\n+ */\n+public final class CorrelationFields {\n+  /**\n+   * This is the most common log correlation field.\n+   *\n+   * @see TraceContext#traceIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField TRACE_ID = new BaseCorrelationField(\"traceId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.traceIdString();\n+    }\n+  };\n+  /**\n+   * Typically only useful when spans are parsed from log records.\n+   *\n+   * @see TraceContext#parentIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField PARENT_ID = new BaseCorrelationField(\"parentId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.parentIdString();\n+    }\n+  };\n+  /**\n+   * Used with {@link #TRACE_ID} to correlate a log line with a span.\n+   *\n+   * @see TraceContext#spanIdString()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SPAN_ID = new BaseCorrelationField(\"spanId\") {\n+    @Override public String getValue(TraceContext context) {\n+      return context.spanIdString();\n+    }\n+  };\n+  /**\n+   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n+   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n+   * typically reported to Zipkin.\n+   *\n+   * @see TraceContext#sampled()\n+   * @since 5.11\n+   */\n+  public static final CorrelationField SAMPLED = new BaseCorrelationField(\"sampled\") {\n+    @Override public String getValue(TraceContext context) {\n+      Boolean sampled = context.sampled();\n+      return sampled != null ? sampled.toString() : null;\n+    }\n+  };\n+\n+  /**\n+   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n+   *\n+   * <p>Ex.\n+   * <pre>{@code\n+   * cloudRegion = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n+   * }</pre>\n+   *\n+   * @since 5.11\n+   */\n+  public static CorrelationField constant(String name, @Nullable String value) {\n+    return new ConstantCorrelationField(name, value);\n+  }\n+\n+  static final class ConstantCorrelationField extends BaseCorrelationField {\n+    final String value;\n+\n+    ConstantCorrelationField(String name, String value) {\n+      super(name);\n+      this.value = value;\n+    }\n+\n+    @Override public String getValue(TraceContext context) {\n+      return value;\n+    }\n+  }\n+\n+  static abstract class BaseCorrelationField implements CorrelationField {\n+    final String name, lcName;\n+\n+    BaseCorrelationField(String name) {\n+      this.name = validateName(name);\n+      this.lcName = name.toLowerCase(Locale.ROOT);\n+    }\n+\n+    @Override public String name() {\n+      return name;", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3NDMzMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400074332", "bodyText": "no this is case sensitive.. it is only the extra keys (not name) that are downcase.\nexisting correlation patterns use 'traceId' not 'traceid' for example.\nI put a TODO to seal this type.", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NTk5MA=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\nindex 1162bce04..752d907be 100644\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ b/brave/src/main/java/brave/propagation/CorrelationFields.java\n", "chunk": "@@ -96,38 +95,4 @@ public final class CorrelationFields {\n       return value;\n     }\n   }\n-\n-  static abstract class BaseCorrelationField implements CorrelationField {\n-    final String name, lcName;\n-\n-    BaseCorrelationField(String name) {\n-      this.name = validateName(name);\n-      this.lcName = name.toLowerCase(Locale.ROOT);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public String toString() {\n-      return name;\n-    }\n-\n-    @Override public boolean equals(Object o) {\n-      if (o == this) return true;\n-      if (!(o instanceof CorrelationField)) return false;\n-      return lcName.equals(((CorrelationField) o).name());\n-    }\n-\n-    @Override public int hashCode() {\n-      return lcName.hashCode();\n-    }\n-  }\n-\n-  protected static String validateName(String name) {\n-    if (name == null) throw new NullPointerException(\"name == null\");\n-    name = name.trim();\n-    if (name.isEmpty()) throw new IllegalArgumentException(\"name is empty\");\n-    return name;\n-  }\n }\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/CorrelationFields.java b/brave/src/main/java/brave/propagation/CorrelationFields.java\ndeleted file mode 100644\nindex 752d907be..000000000\n--- a/brave/src/main/java/brave/propagation/CorrelationFields.java\n+++ /dev/null\n", "chunk": "@@ -1,98 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-\n-/**\n- * Standard fields defined for a correlation context such as MDC.\n- *\n- * @since 5.11\n- */\n-public final class CorrelationFields {\n-  /**\n-   * This is the most common log correlation field.\n-   *\n-   * @see TraceContext#traceIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField TRACE_ID = new CorrelationField(\"traceId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.traceIdString();\n-    }\n-  };\n-  /**\n-   * Typically only useful when spans are parsed from log records.\n-   *\n-   * @see TraceContext#parentIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField PARENT_ID = new CorrelationField(\"parentId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.parentIdString();\n-    }\n-  };\n-  /**\n-   * Used with {@link #TRACE_ID} to correlate a log line with a span.\n-   *\n-   * @see TraceContext#spanIdString()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SPAN_ID = new CorrelationField(\"spanId\") {\n-    @Override public String getValue(TraceContext context) {\n-      return context.spanIdString();\n-    }\n-  };\n-  /**\n-   * This is only useful when {@link #TRACE_ID} is also a correlation field. It is a hint that a\n-   * trace may exist in Zipkin, when a user is viewing logs. For example, unsampled traces are not\n-   * typically reported to Zipkin.\n-   *\n-   * @see TraceContext#sampled()\n-   * @since 5.11\n-   */\n-  public static final CorrelationField SAMPLED = new CorrelationField(\"sampled\") {\n-    @Override public String getValue(TraceContext context) {\n-      Boolean sampled = context.sampled();\n-      return sampled != null ? sampled.toString() : null;\n-    }\n-  };\n-\n-  /**\n-   * Creates a correlation field based on a possibly null value constant, such as an ENV variable.\n-   *\n-   * <p>Ex.\n-   * <pre>{@code\n-   * CLOUD_REGION = CorrelationFields.constant(\"region\", System.getEnv(\"CLOUD_REGION\"));\n-   * }</pre>\n-   *\n-   * @since 5.11\n-   */\n-  public static CorrelationField constant(String name, @Nullable String value) {\n-    return new ConstantCorrelationField(name, value);\n-  }\n-\n-  static final class ConstantCorrelationField extends CorrelationField {\n-    final String value;\n-\n-    ConstantCorrelationField(String name, String value) {\n-      super(name);\n-      this.value = value;\n-    }\n-\n-    @Override public String getValue(TraceContext context) {\n-      return value;\n-    }\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NjgyOQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399946829", "body": "```suggestion\r\n * <p>For example, if you have a need to know a specific request's country code in a downstream service, you can\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * <p>For example, if you have a need to know a specific request's country code, you can\n          \n          \n            \n             * <p>For example, if you have a need to know a specific request's country code in a downstream service, you can", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> <span class=\"pl-k\">&lt;</span>p<span class=\"pl-k\">&gt;</span><span class=\"pl-smi\">For</span> example, <span class=\"pl-k\">if</span> you have a need to know a specific request<span class=\"pl-s\"><span class=\"pl-pds\">'</span>s country code, you can</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-k\">&lt;</span>p<span class=\"pl-k\">&gt;</span><span class=\"pl-smi\">For</span> example, <span class=\"pl-k\">if</span> you have a need to know a specific request<span class=\"pl-s\"><span class=\"pl-pds\">'</span>s country code<span class=\"x x-first x-last\"> in a downstream service</span>, you can</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-30T06:10:09Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 56de8907b..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,409 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n-     * CorrelationBuilder#flushOnUpdate()} is invoked.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzA2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399947062", "body": "```suggestion\r\n * // If configured and set, you can retrieve it later. All of the below result in the same tag in any service handling the trace:\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n          \n          \n            \n             * // If configured and set, you can retrieve it later. All of the below result in the same tag in any service handling the trace:", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> <span class=\"pl-c\"><span class=\"pl-c\">//</span> If configured and set, you can retrieve it later. All of the below result in the same tag:</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-c\"><span class=\"pl-c\">//</span> If configured and set, you can retrieve it later. All of the below result in the same tag<span class=\"x x-first x-last\"> in any service handling the trace</span>:</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-30T06:10:51Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 56de8907b..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,409 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n-     * CorrelationBuilder#flushOnUpdate()} is invoked.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzM2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399947362", "body": "For this example, could consider `userinfo` instead of `baggage`", "bodyText": "For this example, could consider userinfo instead of baggage", "bodyHTML": "<p dir=\"auto\">For this example, could consider <code>userinfo</code> instead of <code>baggage</code></p>", "author": "anuraaga", "createdAt": "2020-03-30T06:11:45Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2OTI3Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399969273", "bodyText": "Realized that baggage + country code is fun too", "author": "anuraaga", "createdAt": "2020-03-30T07:08:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA3ODc2Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400078766", "bodyText": "these are actual header names prefixes. ex sleuth adds the baggage- prefix. you'll find a lot where we intentionally use real examples so that things aren't so abstract. This isn't just test json in zipkin, rather all the projects.\nIs there a prefix you've mapped that would be better I tried to find a header prefixed userinfo and couldn't..", "author": "codefromthecrypt", "createdAt": "2020-03-30T10:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NzM2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 56de8907b..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,409 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n-     * CorrelationBuilder#flushOnUpdate()} is invoked.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0OTE1Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399949152", "body": "```suggestion\r\n   * @param name will be lower-cased for remote propagation\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param name will be currently lower-cased for remote propagation\n          \n          \n            \n               * @param name will be lower-cased for remote propagation", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> name will be <span class=\"x x-first x-last\">currently </span>lower<span class=\"pl-k\">-</span>cased <span class=\"pl-k\">for</span> remote propagation</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> name will be lower<span class=\"pl-k\">-</span>cased <span class=\"pl-k\">for</span> remote propagation</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-30T06:16:59Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 56de8907b..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,409 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n-     * CorrelationBuilder#flushOnUpdate()} is invoked.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0OTIyMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399949222", "body": "```suggestion\r\n   * @param name will be lower-cased for remote propagation\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param name will be currently lower-cased for remote propagation\n          \n          \n            \n               * @param name will be lower-cased for remote propagation", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> name will be <span class=\"x x-first x-last\">currently </span>lower<span class=\"pl-k\">-</span>cased <span class=\"pl-k\">for</span> remote propagation</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">   <span class=\"pl-k\">*</span> <span class=\"pl-k\">@param</span> name will be lower<span class=\"pl-k\">-</span>cased <span class=\"pl-k\">for</span> remote propagation</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-30T06:17:12Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 56de8907b..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,409 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n-     * CorrelationBuilder#flushOnUpdate()} is invoked.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDYyNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399950625", "body": "Might be good to add a note that `redacted` fields will be correlated, so it's probably not desired to correlate a redacted field with a logging context.", "bodyText": "Might be good to add a note that redacted fields will be correlated, so it's probably not desired to correlate a redacted field with a logging context.", "bodyHTML": "<p dir=\"auto\">Might be good to add a note that <code>redacted</code> fields will be correlated, so it's probably not desired to correlate a redacted field with a logging context.</p>", "author": "anuraaga", "createdAt": "2020-03-30T06:21:08Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyOTM4MA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400129380", "bodyText": "actually redacted was made exactly for logging context (exists now and is in use in sleuth)\nthe docs say \"Sets this field to be only visible in process, redacted from remote propagation.\"", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDYyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 56de8907b..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -244,9 +244,6 @@ public class ExtraField {\n      * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n      * next made current.\n      *\n-     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n-     * CorrelationBuilder#flushOnUpdate()} is invoked.\n-     *\n      * @since 5.11\n      */\n     public CorrelationBuilder withCorrelation() {\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDgyOQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399950829", "body": "```suggestion\r\n     * the correlation context as opposed to waiting for the next scope decoration.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * the correlation context as opposed waiting for the next scope decoration.\n          \n          \n            \n                 * the correlation context as opposed to waiting for the next scope decoration.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> the correlation context as opposed waiting <span class=\"pl-k\">for</span> the next scope decoration.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> the correlation context as opposed <span class=\"x x-first x-last\">to </span>waiting <span class=\"pl-k\">for</span> the next scope decoration.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-30T06:21:38Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder extends Builder {\n+    boolean flushOnUpdate = false;\n+\n+    CorrelationBuilder(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public CorrelationBuilder withCorrelation() {\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n+     * the correlation context as opposed waiting for the next scope decoration.", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 56de8907b..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -272,20 +269,25 @@ public class ExtraField {\n     }\n \n     /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n+     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n+     * String)} is invoked.\n      *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <p>Ex.\n      * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n+     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n+     *                                                      .withCorrelation()\n+     *                                                      .flushOnUpdate()\n+     *                                                      .build();\n      *\n      * @SendTo(SourceChannels.OUTPUT)\n      * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n      *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n      *   businessCode();\n      * }\n      * }</pre>\n+     *\n+     * @see CorrelationField.Updatable#flushOnUpdate()\n      */\n     public CorrelationBuilder flushOnUpdate() {\n       this.flushOnUpdate = true;\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTAwOQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399951009", "body": "```suggestion\r\n    /** @see Builder#clearKeys() */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** @see Builder#redacted() */\n          \n          \n            \n                /** @see Builder#clearKeys() */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* @see Builder#<span class=\"x x-first x-last\">redacted</span>() <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* @see Builder#<span class=\"x x-first x-last\">clearKeys</span>() <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-30T06:22:14Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder extends Builder {\n+    boolean flushOnUpdate = false;\n+\n+    CorrelationBuilder(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public CorrelationBuilder withCorrelation() {\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n+     * the correlation context as opposed waiting for the next scope decoration.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n+     *\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     */\n+    public CorrelationBuilder flushOnUpdate() {\n+      this.flushOnUpdate = true;\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 56de8907b..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -272,20 +269,25 @@ public class ExtraField {\n     }\n \n     /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n+     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n+     * String)} is invoked.\n      *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <p>Ex.\n      * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n+     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n+     *                                                      .withCorrelation()\n+     *                                                      .flushOnUpdate()\n+     *                                                      .build();\n      *\n      * @SendTo(SourceChannels.OUTPUT)\n      * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n      *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n      *   businessCode();\n      * }\n      * }</pre>\n+     *\n+     * @see CorrelationField.Updatable#flushOnUpdate()\n      */\n     public CorrelationBuilder flushOnUpdate() {\n       this.flushOnUpdate = true;\n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTA0NQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399951045", "body": "```suggestion\r\n    /** @see Builder#addKey() */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** @see Builder#redacted() */\n          \n          \n            \n                /** @see Builder#addKey() */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* @see Builder#<span class=\"x x-first x-last\">redacted</span>() <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* @see Builder#<span class=\"x x-first x-last\">addKey</span>() <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "anuraaga", "createdAt": "2020-03-30T06:22:21Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder extends Builder {\n+    boolean flushOnUpdate = false;\n+\n+    CorrelationBuilder(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public CorrelationBuilder withCorrelation() {\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n+     * the correlation context as opposed waiting for the next scope decoration.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n+     *\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     */\n+    public CorrelationBuilder flushOnUpdate() {\n+      this.flushOnUpdate = true;\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder clearKeys() {\n+      super.clearKeys();\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 56de8907b..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,409 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n-     * CorrelationBuilder#flushOnUpdate()} is invoked.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTgwMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399951803", "body": "Not sure what `ignores if not configured.` is referring to", "bodyText": "Not sure what ignores if not configured. is referring to", "bodyHTML": "<p dir=\"auto\">Not sure what <code>ignores if not configured.</code> is referring to</p>", "author": "anuraaga", "createdAt": "2020-03-30T06:24:41Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();\n+    boolean redacted;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      keys.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.keys.addAll(builder.keys);\n+      this.redacted = builder.redacted;\n+    }\n+\n+    Builder(ExtraField extraField) {\n+      this.name = extraField.name;\n+      this.keys.addAll(asList(extraField.keys));\n+      this.redacted = extraField.redacted;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n+     * name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * userId = ExtraField.newBuilder(\"userId\")\n+     *                    .clearKeys()\n+     *                    .addKey(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearKeys() {\n+      keys.clear();\n+      return this;\n+    }\n+\n+    /** @since 5.11 */\n+    public Builder addKey(String key) {\n+      keys.add(validateName(key));\n+      return this;\n+    }\n+\n+    /**\n+     * Sets this field to be only visible in process, redacted from remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder redacted() {\n+      this.redacted = true;\n+      return this;\n+    }\n+\n+    /**\n+     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n+     * CurrentTraceContext.Scope)}.\n+     *\n+     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n+     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n+     * next made current.\n+     *\n+     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n+     * CorrelationBuilder#flushOnUpdate()} is invoked.\n+     *\n+     * @since 5.11\n+     */\n+    public CorrelationBuilder withCorrelation() {\n+      return new CorrelationBuilder(this);\n+    }\n+\n+    /** @since 5.11 */\n+    public ExtraField build() {\n+      return new ExtraField(this);\n+    }\n+  }\n+\n+  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n+  public static class CorrelationBuilder extends Builder {\n+    boolean flushOnUpdate = false;\n+\n+    CorrelationBuilder(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public CorrelationBuilder withCorrelation() {\n+      return this;\n+    }\n+\n+    /**\n+     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n+     * the correlation context as opposed waiting for the next scope decoration.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n+     *\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     */\n+    public CorrelationBuilder flushOnUpdate() {\n+      this.flushOnUpdate = true;\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder clearKeys() {\n+      super.clearKeys();\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder addKey(String key) {\n+      super.addKey(key);\n+      return this;\n+    }\n+\n+    /** @see Builder#redacted() */\n+    public CorrelationBuilder redacted() {\n+      super.redacted();\n+      return this;\n+    }\n+\n+    /** @see Builder#build() */\n+    public final WithCorrelation build() {\n+      return new WithCorrelation(this);\n+    }\n+  }\n+\n+  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n+    WithCorrelation(Builder builder) {\n+      super(builder);\n+    }\n+\n+    @Override public String name() {\n+      return name;\n+    }\n+\n+    @Override public CorrelationBuilder toBuilder() {\n+      return new Builder(this).withCorrelation();\n+    }\n+  }\n+\n+  final String name, lcName;\n+  final String[] keys; // for faster iteration\n+  final List<String> keysList;\n+  final boolean redacted;\n+\n+  ExtraField(Builder builder) {\n+    name = builder.name;\n+    lcName = name.toLowerCase(Locale.ROOT);\n+    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n+    keys = builder.keys.toArray(new String[0]);\n+    keysList = asList(keys);\n+    redacted = builder.redacted;\n+  }\n+\n+  /**\n+   * Returns the most recent value for this field in the context or null if unavailable.\n+   *\n+   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n+   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n+   */\n+  @Nullable public String getValue(TraceContext context) {\n+    return PropagationFields.get(context, this, ExtraFields.class);\n+  }\n+\n+  /** Updates the value of the this field, or ignores if not configured. */", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEzMDYxOA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400130618", "bodyText": "ExtraFieldPropagation is the component that configures extra fields and that's the first line of the type. comment later if you have another thing we have to do on this.", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MTgwMw=="}], "type": "inlineReview", "revised_code": {"commit": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\nindex 56de8907b..43a765657 100644\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ b/brave/src/main/java/brave/propagation/ExtraField.java\n", "chunk": "@@ -355,7 +371,7 @@ public class ExtraField {\n   }\n \n   /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, String value) {\n+  public void updateValue(TraceContext context, @Nullable String value) {\n     PropagationFields.put(context, this, value, ExtraFields.class);\n   }\n \n", "next_change": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 43a765657..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,425 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field integrated with {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Flushes an updated value to the correlation context when {@linkplain #updateValue(String,\n-     * String)} is invoked.\n-     *\n-     * <p>Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\")\n-     *                                                      .withCorrelation()\n-     *                                                      .flushOnUpdate()\n-     *                                                      .build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\"); // implicitly flushes\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     *\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static class WithCorrelation extends ExtraField implements CorrelationField.Updatable {\n-    final boolean flushOnUpdate;\n-\n-    @Override public void updateValue(TraceContext context, String value) {\n-      super.updateValue(context, value);\n-      if (flushOnUpdate) CorrelationFieldScopeDecorator.flush(this, value);\n-    }\n-\n-    WithCorrelation(CorrelationBuilder builder) {\n-      super(builder);\n-      this.flushOnUpdate = builder.flushOnUpdate;\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public boolean flushOnUpdate() {\n-      return flushOnUpdate;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      CorrelationBuilder result = new Builder(this).withCorrelation();\n-      if (flushOnUpdate) result.flushOnUpdate();\n-      return result;\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, @Nullable String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTE0Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399955147", "body": "```suggestion\r\n        // remainingNames contains the names that need be propagated as is, so only remove\r\n        // the default propagated keys if this name is not one of those.\r\n        if (!remainingNames.remove(name)) builder.clearKeys();\r\n```\r\n\r\nTried to see if a variable name change could clear that up but think this comment is better. It took me many rereads to finally understand it", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!remainingNames.remove(name)) builder.clearKeys();\n          \n          \n            \n                    // remainingNames contains the names that need be propagated as is, so only remove\n          \n          \n            \n                    // the default propagated keys if this name is not one of those.\n          \n          \n            \n                    if (!remainingNames.remove(name)) builder.clearKeys();\n          \n      \n    \n    \n  \n\nTried to see if a variable name change could clear that up but think this comment is better. It took me many rereads to finally understand it", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k x x-first\">if</span><span class=\"x\"> (</span><span class=\"pl-k x x-last\">!</span>remainingNames<span class=\"pl-k x x-first\">.</span><span class=\"x\">remove(name)) builder</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">clearKeys();</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c x x-first\">//</span><span class=\"x x-last\"> </span>remainingNames<span class=\"x x-first x-last\"> contains the names that need be propagated as is, so only remove</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c\">//</span> the default propagated keys if this name is not one of those.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>remainingNames<span class=\"pl-k\">.</span>remove(name)) builder<span class=\"pl-k\">.</span>clearKeys();</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">Tried to see if a variable name change could clear that up but think this comment is better. It took me many rereads to finally understand it</p>", "author": "anuraaga", "createdAt": "2020-03-30T06:34:00Z", "path": "brave/src/main/java/brave/propagation/ExtraFieldPropagation.java", "diffHunk": "@@ -15,246 +15,197 @@\n \n import brave.Tracing;\n import brave.internal.Nullable;\n-import brave.internal.PredefinedPropagationFields;\n-import brave.internal.PropagationFields;\n-import brave.internal.PropagationFieldsFactory;\n import brave.propagation.TraceContext.Extractor;\n import brave.propagation.TraceContext.Injector;\n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.BitSet;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n \n+import static brave.propagation.CorrelationFields.validateName;\n+\n /**\n- * Allows you to propagate predefined request-scoped fields, usually but not always HTTP headers.\n+ * This implements {@linkplain ExtraField extra field} in-process and remote propagation.\n  *\n- * <p>For example, if you are in a Cloud Foundry environment, you might want to pass the request\n- * ID:\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace as HTTP headers.\n  * <pre>{@code\n- * // when you initialize the builder, define the extra field you want to propagate\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, \"x-vcap-request-id\")\n- * );\n- *\n- * // later, you can tag that request ID or use it in log correlation\n- * requestId = ExtraFieldPropagation.get(\"x-vcap-request-id\");\n- *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * ExtraFieldPropagation.get(\"x-country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n  *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * <h3>Passing through alternate trace contexts</h3>\n- * <p>You may also need to propagate an second trace context transparently. For example, when in\n- * an Amazon Web Services environment, but not reporting data to X-Ray. To ensure X-Ray can co-exist\n- * correctly, pass-through its tracing header like so.\n- *\n- * <pre>{@code\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, \"x-amzn-trace-id\")\n- * );\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * // Setup your tracing instance with allowed fields\n+ * // When you initialize the builder, add the extra field you want to propagate\n  * tracingBuilder.propagationFactory(\n  *   ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                        .addField(\"x-vcap-request-id\")\n- *                        .addPrefixedFields(\"baggage-\", Arrays.asList(\"country-code\", \"user-id\"))\n+ *                        .addField(countryCode)\n  *                        .build()\n  * );\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraFieldPropagation.set(\"country-code\", \"FO\");\n- * String countryCode = ExtraFieldPropagation.get(\"country-code\");\n- *\n- * // Or, if you have a reference to a trace context, use it explicitly\n- * ExtraFieldPropagation.set(span.context(), \"country-code\", \"FO\");\n- * String countryCode = ExtraFieldPropagation.get(span.context(), \"country-code\");\n- * }</pre>\n  */\n public class ExtraFieldPropagation<K> implements Propagation<K> {\n-  /** Wraps an underlying propagation implementation, pushing one or more fields */\n-  public static Factory newFactory(Propagation.Factory delegate, String... fieldNames) {\n+  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+  @Deprecated public static Factory newFactory(Propagation.Factory delegate, String... names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-    return newFactory(delegate, Arrays.asList(fieldNames));\n+    if (names == null) throw new NullPointerException(\"field names == null\");\n+    return newFactory(delegate, Arrays.asList(names));\n   }\n \n-  /** Wraps an underlying propagation implementation, pushing one or more fields */\n-  public static Factory newFactory(Propagation.Factory delegate, Collection<String> fieldNames) {\n+  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+  @Deprecated\n+  public static Factory newFactory(Propagation.Factory delegate, Collection<String> names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-    String[] validated = ensureLowerCaseFieldNames(new LinkedHashSet<>(fieldNames));\n-    return new RealFactory(delegate, validated, validated, new BitSet());\n+    if (names == null) throw new NullPointerException(\"field names == null\");\n+    if (names.isEmpty()) throw new IllegalArgumentException(\"no field names\");\n+    FactoryBuilder builder = new FactoryBuilder(delegate);\n+    for (String name : names) builder.addField(ExtraField.create(name));\n+    return builder.build();\n   }\n \n+  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n   public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n     return new FactoryBuilder(delegate);\n   }\n \n   public static final class FactoryBuilder {\n     final Propagation.Factory delegate;\n-    final Set<String> fieldNames = new LinkedHashSet<>();\n-    final Set<String> redactedFieldNames = new LinkedHashSet<>();\n-    final Map<String, String[]> prefixedNames = new LinkedHashMap<>();\n+    final Set<String> names = new LinkedHashSet<>();\n+    final Set<String> redactedNames = new LinkedHashSet<>();\n+    final Map<String, Set<String>> nameToPrefixes = new LinkedHashMap<>();\n+\n+    final Set<ExtraField> fields = new LinkedHashSet<>();\n \n     FactoryBuilder(Propagation.Factory delegate) {\n       if (delegate == null) throw new NullPointerException(\"delegate == null\");\n       this.delegate = delegate;\n     }\n \n-    /** Same as {@link #addField} except that this field is redacted from downstream propagation. */\n-    public FactoryBuilder addRedactedField(String fieldName) {\n-      fieldName = validateFieldName(fieldName);\n-      fieldNames.add(fieldName);\n-      redactedFieldNames.add(fieldName);\n-      return this;\n-    }\n-\n     /**\n-     * Adds a field that is referenced the same in-process as it is on the wire. For example, the\n-     * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+     * Adds an {@linkplain ExtraField extra field} for remote propagation.\n      *\n-     * <p>Note: {@code fieldName} will be implicitly lower-cased.\n+     * @since 5.11\n      */\n-    public FactoryBuilder addField(String fieldName) {\n-      fieldNames.add(validateFieldName(fieldName));\n+    public FactoryBuilder addField(ExtraField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      fields.add(field);\n       return this;\n     }\n \n-    /**\n-     * Adds a prefix when fields are extracted or injected from headers. For example, if the prefix\n-     * is \"baggage-\", the field \"country-code\" would end up as \"baggage-country-code\" on the wire.\n-     *\n-     * <p>Note: any {@code fieldNames} will be implicitly lower-cased.\n-     */\n-    public FactoryBuilder addPrefixedFields(String prefix, Collection<String> fieldNames) {\n-      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n-      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n-      if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-      prefixedNames.put(prefix, ensureLowerCaseFieldNames(new LinkedHashSet<>(fieldNames)));\n+    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n+    public FactoryBuilder addRedactedField(String name) {\n+      name = validateName(name).toLowerCase(Locale.ROOT);\n+      names.add(name);\n+      redactedNames.add(name);\n       return this;\n     }\n \n-    /** Returns a wrapper of the delegate if there are no fields to propagate. */\n-    public Factory build() {\n-      BitSet redacted = new BitSet();\n-      List<String> fields = new ArrayList<>(), keys = new ArrayList<>();\n-      List<Integer> keyToFieldList = new ArrayList<>();\n+    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n+    public FactoryBuilder addField(String name) {\n+      names.add(validateName(name).toLowerCase(Locale.ROOT));\n+      return this;\n+    }\n \n-      // First pass: add any field names that are used as propagation keys directly\n-      int i = 0;\n-      for (String fieldName : fieldNames) {\n-        if (redactedFieldNames.contains(fieldName)) redacted.set(i); // flag to redact on inject\n-        fields.add(fieldName);\n-        keys.add(fieldName);\n-        keyToFieldList.add(i++);\n+    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n+    public FactoryBuilder addPrefixedFields(String prefix, Collection<String> names) {\n+      if (prefix == null) throw new NullPointerException(\"prefix == null\");\n+      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      if (names == null) throw new NullPointerException(\"names == null\");\n+      for (String name : names) {\n+        name = validateName(name).toLowerCase(Locale.ROOT);\n+        Set<String> prefixes = nameToPrefixes.get(name);\n+        if (prefixes == null) nameToPrefixes.put(name, prefixes = new LinkedHashSet<>());\n+        prefixes.add(prefix);\n       }\n+      return this;\n+    }\n \n-      // Second pass: add prefixed fields, noting a prefixed field could be a dupe of a non-prefixed\n-      for (Map.Entry<String, String[]> entry : prefixedNames.entrySet()) {\n-        String nextPrefix = entry.getKey();\n-        String[] nextFieldNames = entry.getValue();\n-        for (i = 0; i < nextFieldNames.length; i++) {\n-          String nextFieldName = nextFieldNames[i];\n-          int index = fields.indexOf(nextFieldName);\n-          if (index == -1) {\n-            index = fields.size();\n-            fields.add(nextFieldName);\n-          }\n-          keys.add(nextPrefix + nextFieldName);\n-          keyToFieldList.add(index);\n+    Set<ExtraField> convertDeprecated() {\n+      Set<String> remainingNames = new LinkedHashSet<>(names);\n+      Set<ExtraField> result = new LinkedHashSet<>();\n+      for (Map.Entry<String, Set<String>> entry : nameToPrefixes.entrySet()) {\n+        String name = entry.getKey();\n+        ExtraField.Builder builder = ExtraField.newBuilder(name);\n+        if (redactedNames.contains(name)) builder.redacted();\n+        if (!remainingNames.remove(name)) builder.clearKeys();", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NzM1MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399957351", "bodyText": "Alternatively, this pattern might be clearer\nMap<String, ExtraField.Builder> converted = new LinkedHashMap<>();\nfor (String name : names) {\n  ExtraField.Builder builder = ExtraField.newBuilder(name);\n  if (redactedNames.contains(name)) builder.redacted();\n  converted.add(builder);\n}\n\nfor (Map.Entry<String, Set<String>> entry : nameToPrefixes.entrySet()) {\n  ExtraField.Builder builder = conveted.get(entry.key());\n  if (builder == null) {\n    // Only propagated with prefixes, not original name.\n    builder = ExtraField.newBuilder(name).clearKeys();\n    converted.put(name, builder);\n  }\n  for (String prefix : entry.getValue()) {\n    builder.addKey(prefix + name);\n  }\n}\n\nSet<ExtraField> result = new LinkedHashSet<>();\nfor (ExtraField.Builder builder : converted.valueSet()) {\n  result.add(builder.build());\n}\nreturn result;", "author": "anuraaga", "createdAt": "2020-03-30T06:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEzMjI5Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400132292", "bodyText": "I'm overloaded so I'll get back to this..", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTE0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\nindex 56b1d9a76..af3bdc207 100644\n--- a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n+++ b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n", "chunk": "@@ -122,23 +101,25 @@ public class ExtraFieldPropagation<K> implements Propagation<K> {\n       return this;\n     }\n \n-    Set<ExtraField> convertDeprecated() {\n+    Set<BaggageField> convertDeprecated() {\n       Set<String> remainingNames = new LinkedHashSet<>(names);\n-      Set<ExtraField> result = new LinkedHashSet<>();\n+      Set<BaggageField> result = new LinkedHashSet<>();\n       for (Map.Entry<String, Set<String>> entry : nameToPrefixes.entrySet()) {\n         String name = entry.getKey();\n-        ExtraField.Builder builder = ExtraField.newBuilder(name);\n-        if (redactedNames.contains(name)) builder.redacted();\n-        if (!remainingNames.remove(name)) builder.clearKeys();\n+        if (redactedNames.contains(name)) continue;\n+\n+        BaggageField.Builder builder = BaggageField.newBuilder(name);\n+        // If we didn't add the name directly, we should only add prefixed names.\n+        if (!remainingNames.remove(name)) builder.clearRemoteNames();\n         for (String prefix : entry.getValue()) {\n-          builder.addKey(prefix + name);\n+          builder.addRemoteName(prefix + name);\n         }\n         result.add(builder.build());\n       }\n \n       for (String name : remainingNames) {\n-        ExtraField.Builder builder = ExtraField.newBuilder(name);\n-        if (redactedNames.contains(name)) builder.redacted();\n+        BaggageField.Builder builder = BaggageField.newBuilder(name);\n+        if (redactedNames.contains(name)) builder.clearRemoteNames();\n         result.add(builder.build());\n       }\n       return result;\n", "next_change": {"commit": "a042fe16ff30c94988396e85637471dfa9719845", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\nindex af3bdc207..758247e31 100644\n--- a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n+++ b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n", "chunk": "@@ -128,12 +131,16 @@ import java.util.Set;\n     /** Returns a wrapper of the delegate if there are no fields to propagate. */\n     public Factory build() {\n       Set<BaggageField> fields = convertDeprecated();\n-      fields.addAll(this.fields); // clobbering deprecated config is ok\n+      fields.addAll(baggageFactory.fields()); // clobbering deprecated config is ok\n       BaggageField[] fieldsArray = fields.toArray(new BaggageField[0]);\n       if (fieldsArray.length == 0) {\n         return new Factory(delegate, fieldsArray);\n       }\n-      return new Factory(new BaggagePropagation.Factory(delegate, fieldsArray), fieldsArray);\n+      baggageFactory.clear();\n+      for (BaggageField field : fields) {\n+        baggageFactory.addField(field);\n+      }\n+      return new Factory(baggageFactory.build(), fieldsArray);\n     }\n   }\n \n", "next_change": {"commit": "016837e22164c69eb416b1c29fbd59e962634024", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\nindex 758247e31..5297156f5 100644\n--- a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n+++ b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n", "chunk": "@@ -97,50 +99,30 @@ import java.util.Set;\n       if (names == null) throw new NullPointerException(\"names == null\");\n       for (String name : names) {\n         name = validateFieldName(name);\n-        Set<String> prefixes = nameToPrefixes.get(name);\n-        if (prefixes == null) nameToPrefixes.put(name, prefixes = new LinkedHashSet<>());\n-        prefixes.add(prefix);\n+        addKeyName(name, prefix + name);\n       }\n       return this;\n     }\n \n-    Set<BaggageField> convertDeprecated() {\n-      Set<String> remainingNames = new LinkedHashSet<>(names);\n-      Set<BaggageField> result = new LinkedHashSet<>();\n-      for (Map.Entry<String, Set<String>> entry : nameToPrefixes.entrySet()) {\n-        String name = entry.getKey();\n-        if (redactedNames.contains(name)) continue;\n-\n-        BaggageField.Builder builder = BaggageField.newBuilder(name);\n-        // If we didn't add the name directly, we should only add prefixed names.\n-        if (!remainingNames.remove(name)) builder.clearRemoteNames();\n-        for (String prefix : entry.getValue()) {\n-          builder.addRemoteName(prefix + name);\n-        }\n-        result.add(builder.build());\n-      }\n-\n-      for (String name : remainingNames) {\n-        BaggageField.Builder builder = BaggageField.newBuilder(name);\n-        if (redactedNames.contains(name)) builder.clearRemoteNames();\n-        result.add(builder.build());\n-      }\n-      return result;\n+    void addKeyName(String name, String keyName) {\n+      Set<String> keyNames = nameToKeyNames.get(name);\n+      if (keyNames == null) nameToKeyNames.put(name, keyNames = new LinkedHashSet<>());\n+      keyNames.add(keyName);\n     }\n \n     /** Returns a wrapper of the delegate if there are no fields to propagate. */\n     public Factory build() {\n-      Set<BaggageField> fields = convertDeprecated();\n-      fields.addAll(baggageFactory.fields()); // clobbering deprecated config is ok\n-      BaggageField[] fieldsArray = fields.toArray(new BaggageField[0]);\n-      if (fieldsArray.length == 0) {\n-        return new Factory(delegate, fieldsArray);\n-      }\n-      baggageFactory.clear();\n-      for (BaggageField field : fields) {\n-        baggageFactory.addField(field);\n+      Set<String> extraKeyNames = new LinkedHashSet<>();\n+      for (Map.Entry<String, Set<String>> entry : nameToKeyNames.entrySet()) {\n+        BaggageField field = BaggageField.create(entry.getKey());\n+        if (redactedNames.contains(field.name())) {\n+          baggageFactory.addField(field);\n+        } else {\n+          extraKeyNames.addAll(entry.getValue());\n+          baggageFactory.addRemoteField(field, entry.getValue());\n+        }\n       }\n-      return new Factory(baggageFactory.build(), fieldsArray);\n+      return new Factory(baggageFactory.build(), extraKeyNames.toArray(new String[0]));\n     }\n   }\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTUwNw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399955507", "body": "Wonder tradeoff of `propagatedName` vs `key` in clarity / verbosity", "bodyText": "Wonder tradeoff of propagatedName vs key in clarity / verbosity", "bodyHTML": "<p dir=\"auto\">Wonder tradeoff of <code>propagatedName</code> vs <code>key</code> in clarity / verbosity</p>", "author": "anuraaga", "createdAt": "2020-03-30T06:34:59Z", "path": "brave/src/main/java/brave/propagation/ExtraField.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static brave.propagation.CorrelationFields.validateName;\n+import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link ExtraFieldPropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code, you can\n+ * propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n+ *\n+ * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n+ * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n+ * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n+ *\n+ * // You can also update the value similarly, so that the new value will propagate downstream.\n+ * countryCode.updateValue(\"FO\");\n+ * countryCode.updateValue(context, \"FO\");\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * ExtraField.updateValue(context, \"country-code\", \"FO\");\n+ * }</pre>\n+ *\n+ * <h3>Correlation</h3>\n+ * If you want an extra field to also be available in correlation such as logging contexts, use\n+ * {@link Builder#withCorrelation()}.\n+ *\n+ * <pre>{@code\n+ * // configure the field, permitting it to be used in correlation contexts\n+ * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * loggingContext = new Log4J2Context();\n+ *\n+ * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n+ *                                           .addField(amznTraceId).build();\n+ *\n+ * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                        .addField(amznTraceId)\n+ *                                                        .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Prefixed fields</h3>\n+ * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n+ * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n+ * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n+ *\n+ * <pre>{@code\n+ * requestId = ExtraField.create(\"x-vcap-request-id\");\n+ * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n+ * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n+ *\n+ * // Later, you can call below to affect the country code of the current trace context\n+ * ExtraField.updateValue(\"country-code\", \"FO\");\n+ * String countryCode = ExtraField.getValue(\"country-code\");\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see ExtraFieldPropagation\n+ * @see CorrelationFieldScopeDecorator\n+ */\n+public class ExtraField {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static ExtraField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be currently lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n+   *\n+   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n+   * underlying field.\n+   */\n+  @Nullable public static String getValue(TraceContext context, String name) {\n+    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n+   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  @Nullable public static String getValue(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getValue(context, name) : null;\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n+   * #name()}.\n+   *\n+   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n+   * underlying field.\n+   */\n+  public static void updateValue(TraceContext context, String name, String value) {\n+    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n+  }\n+\n+  /**\n+   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n+   * context.\n+   *\n+   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n+   * underlying field.\n+   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n+   * trace context.\n+   *\n+   * @see ExtraField#name()\n+   */\n+  public static void updateValue(String name, String value) {\n+    TraceContext context = currentTraceContext();\n+    if (context != null) updateValue(context, name, value);\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> keys = new LinkedHashSet<>();", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEzMjA2Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400132067", "bodyText": "key is already used in Propagation component, that's what these names are literally for. I added @see ExtraFieldPropagation#keys() to the thing.", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NTUwNw=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraField.java b/brave/src/main/java/brave/propagation/ExtraField.java\ndeleted file mode 100644\nindex 56de8907b..000000000\n--- a/brave/src/main/java/brave/propagation/ExtraField.java\n+++ /dev/null\n", "chunk": "@@ -1,409 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.propagation;\n-\n-import brave.internal.Nullable;\n-import brave.internal.PropagationFields;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-\n-import static brave.propagation.CorrelationFields.validateName;\n-import static brave.propagation.ExtraFieldPropagation.currentTraceContext;\n-import static java.util.Arrays.asList;\n-\n-/**\n- * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n- * be no-op unless {@link ExtraFieldPropagation} is configured.\n- *\n- * <p>For example, if you have a need to know a specific request's country code, you can\n- * propagate it through the trace:\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // If configured and set, you can retrieve it later. All of the below result in the same tag:\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue());\n- * spanCustomizer.tag(countryCode.name(), countryCode.getValue(context));\n- * spanCustomizer.tag(\"country-code\", ExtraField.getValue(\"country-code\"));\n- *\n- * // You can also update the value similarly, so that the new value will propagate downstream.\n- * countryCode.updateValue(\"FO\");\n- * countryCode.updateValue(context, \"FO\");\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * ExtraField.updateValue(context, \"country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Correlation</h3>\n- * If you want an extra field to also be available in correlation such as logging contexts, use\n- * {@link Builder#withCorrelation()}.\n- *\n- * <pre>{@code\n- * // configure the field, permitting it to be used in correlation contexts\n- * amznTraceId = ExtraField.newBuilder(\"x-amzn-trace-id\").withCorrelation().build();\n- *\n- * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n- * loggingContext = new Log4J2Context();\n- *\n- * decorator = CorrelationFieldScopeDecorator.newBuilder(loggingContext)\n- *                                           .addField(amznTraceId).build();\n- *\n- * tracingBuilder.propagationFactory(ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                                                        .addField(amznTraceId)\n- *                                                        .build())\n- *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n- *                                                                  .addScopeDecorator(decorator)\n- *                                                                  .build())\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * requestId = ExtraField.create(\"x-vcap-request-id\");\n- * userId = ExtraField.newBuilder(\"user-id\").prefix(\"baggage-\").build();\n- * countryCode = ExtraField.newBuilder(\"country-code\").prefix(\"baggage-\").build();\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraField.updateValue(\"country-code\", \"FO\");\n- * String countryCode = ExtraField.getValue(\"country-code\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n- *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * @see ExtraFieldPropagation\n- * @see CorrelationFieldScopeDecorator\n- */\n-public class ExtraField {\n-  /**\n-   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n-   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static ExtraField create(String name) {\n-    return new Builder(name).build();\n-  }\n-\n-  /**\n-   * Creates a builder for the specified {@linkplain #name()}.\n-   *\n-   * @param name will be currently lower-cased for remote propagation\n-   * @since 5.11\n-   */\n-  public static Builder newBuilder(String name) {\n-    return new Builder(name);\n-  }\n-\n-  public Builder toBuilder() {\n-    return new Builder(this);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except looks up the field by {@linkplain #name()}.\n-   *\n-   * <p>Prefer using {@link ExtraField#getValue(TraceContext)} when you have a reference to the\n-   * underlying field.\n-   */\n-  @Nullable public static String getValue(TraceContext context, String name) {\n-    return PropagationFields.get(context, ExtraField.create(name), ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer using {@link #getValue()} when you have a reference to the underlying field.\n-   * <p>Prefer {@link #getValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  @Nullable public static String getValue(String name) {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context, name) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except looks up the field by {@linkplain\n-   * #name()}.\n-   *\n-   * <p>Prefer using {@link #updateValue(TraceContext, String)} when you have a reference to the\n-   * underlying field.\n-   */\n-  public static void updateValue(TraceContext context, String name, String value) {\n-    PropagationFields.put(context, ExtraField.create(name), value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String, String)} except against the current trace\n-   * context.\n-   *\n-   * <p>Prefer using {@link ExtraField#updateValue(String)} when you have a reference to the\n-   * underlying field.\n-   * <p>Prefer {@link #updateValue(TraceContext, String, String)} if you have a reference to the\n-   * trace context.\n-   *\n-   * @see ExtraField#name()\n-   */\n-  public static void updateValue(String name, String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, name, value);\n-  }\n-\n-  /** @since 5.11 */\n-  public static class Builder {\n-    final String name;\n-    final Set<String> keys = new LinkedHashSet<>();\n-    boolean redacted;\n-\n-    Builder(String name) {\n-      this.name = validateName(name);\n-      keys.add(this.name.toLowerCase(Locale.ROOT));\n-    }\n-\n-    Builder(Builder builder) {\n-      this.name = builder.name;\n-      this.keys.addAll(builder.keys);\n-      this.redacted = builder.redacted;\n-    }\n-\n-    Builder(ExtraField extraField) {\n-      this.name = extraField.name;\n-      this.keys.addAll(asList(extraField.keys));\n-      this.redacted = extraField.redacted;\n-    }\n-\n-    /**\n-     * Invoke this to clear propagated names of this field. You can add alternatives later with\n-     * {@link #addKey(String)}. <p>The default propagated name is the lowercase variant of the field\n-     * name.\n-     *\n-     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n-     * rather only a prefixed name in hyphen case. For example, the following would make the field\n-     * named \"userId\" propagated only as \"baggage-user-id\".\n-     *\n-     * <pre>{@code\n-     * userId = ExtraField.newBuilder(\"userId\")\n-     *                    .clearKeys()\n-     *                    .addKey(\"baggage-user-id\").build();\n-     * }</pre>\n-     *\n-     * @since 5.11\n-     */\n-    public Builder clearKeys() {\n-      keys.clear();\n-      return this;\n-    }\n-\n-    /** @since 5.11 */\n-    public Builder addKey(String key) {\n-      keys.add(validateName(key));\n-      return this;\n-    }\n-\n-    /**\n-     * Sets this field to be only visible in process, redacted from remote propagation.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder redacted() {\n-      this.redacted = true;\n-      return this;\n-    }\n-\n-    /**\n-     * Adds this field to the correlation context on {@link CorrelationFieldScopeDecorator#decorateScope(TraceContext,\n-     * CurrentTraceContext.Scope)}.\n-     *\n-     * <p>For example, if using log correlation and an extra field named {@link #name() named}\n-     * \"userId\", the extracted value becomes the log variable {@code %{userId}} when the span is\n-     * next made current.\n-     *\n-     * <p><em>Note:</em>Updates after extraction are not synchronized unless {@link\n-     * CorrelationBuilder#flushOnUpdate()} is invoked.\n-     *\n-     * @since 5.11\n-     */\n-    public CorrelationBuilder withCorrelation() {\n-      return new CorrelationBuilder(this);\n-    }\n-\n-    /** @since 5.11 */\n-    public ExtraField build() {\n-      return new ExtraField(this);\n-    }\n-  }\n-\n-  /** Used to make an extra field for {@link CorrelationFieldScopeDecorator} */\n-  public static class CorrelationBuilder extends Builder {\n-    boolean flushOnUpdate = false;\n-\n-    CorrelationBuilder(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public CorrelationBuilder withCorrelation() {\n-      return this;\n-    }\n-\n-    /**\n-     * Call this to immediately flush a {@linkplain #updateValue(String, String) value update} to\n-     * the correlation context as opposed waiting for the next scope decoration.\n-     *\n-     * <p>This is useful for callbacks that have a void return. Ex.\n-     * <pre>{@code\n-     * static final ExtraField BUSINESS_PROCESS = ExtraField.newBuilder(\"bp\").withCorrelation().build();\n-     *\n-     * @SendTo(SourceChannels.OUTPUT)\n-     * public void timerMessageSource() {\n-     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n-     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n-     *   businessCode();\n-     * }\n-     * }</pre>\n-     */\n-    public CorrelationBuilder flushOnUpdate() {\n-      this.flushOnUpdate = true;\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder clearKeys() {\n-      super.clearKeys();\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder addKey(String key) {\n-      super.addKey(key);\n-      return this;\n-    }\n-\n-    /** @see Builder#redacted() */\n-    public CorrelationBuilder redacted() {\n-      super.redacted();\n-      return this;\n-    }\n-\n-    /** @see Builder#build() */\n-    public final WithCorrelation build() {\n-      return new WithCorrelation(this);\n-    }\n-  }\n-\n-  public static final class WithCorrelation extends ExtraField implements CorrelationField {\n-    WithCorrelation(Builder builder) {\n-      super(builder);\n-    }\n-\n-    @Override public String name() {\n-      return name;\n-    }\n-\n-    @Override public CorrelationBuilder toBuilder() {\n-      return new Builder(this).withCorrelation();\n-    }\n-  }\n-\n-  final String name, lcName;\n-  final String[] keys; // for faster iteration\n-  final List<String> keysList;\n-  final boolean redacted;\n-\n-  ExtraField(Builder builder) {\n-    name = builder.name;\n-    lcName = name.toLowerCase(Locale.ROOT);\n-    if (builder.keys.isEmpty()) throw new IllegalArgumentException(\"keys are empty\");\n-    keys = builder.keys.toArray(new String[0]);\n-    keysList = asList(keys);\n-    redacted = builder.redacted;\n-  }\n-\n-  /**\n-   * Returns the most recent value for this field in the context or null if unavailable.\n-   *\n-   * <p>The result may not be the same as the one {@link TraceContext.Extractor#extract(Object)\n-   * extracted} from the incoming context because {@link #updateValue(String)} can override it.\n-   */\n-  @Nullable public String getValue(TraceContext context) {\n-    return PropagationFields.get(context, this, ExtraFields.class);\n-  }\n-\n-  /** Updates the value of the this field, or ignores if not configured. */\n-  public void updateValue(TraceContext context, String value) {\n-    PropagationFields.put(context, this, value, ExtraFields.class);\n-  }\n-\n-  /**\n-   * Like {@link #getValue(TraceContext)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #getValue(TraceContext)} if you have a reference to the trace context.\n-   */\n-  @Nullable public String getValue() {\n-    TraceContext context = currentTraceContext();\n-    return context != null ? getValue(context) : null;\n-  }\n-\n-  /**\n-   * Like {@link #updateValue(TraceContext, String)} except against the current trace context.\n-   *\n-   * <p>Prefer {@link #updateValue(TraceContext, String)} if you have a reference to the trace\n-   * context.\n-   */\n-  public void updateValue(String value) {\n-    TraceContext context = currentTraceContext();\n-    if (context != null) updateValue(context, value);\n-  }\n-\n-  /** The non-empty name of the field. Ex \"userId\" */\n-  public String name() {\n-    return name;\n-  }\n-\n-  /**\n-   * The non-empty list of names for use in remote propagation. By default it includes only the\n-   * lowercase variant of the {@link #name()}.\n-   */\n-  public List<String> keys() {\n-    return keysList;\n-  }\n-\n-  @Override public String toString() {\n-    return name;\n-  }\n-\n-  @Override public boolean equals(Object o) {\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraField)) return false;\n-    return lcName.equals(((ExtraField) o).lcName);\n-  }\n-\n-  @Override public int hashCode() {\n-    return lcName.hashCode();\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1NzU2Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399957566", "body": "This new API is so much nicer!", "bodyText": "This new API is so much nicer!", "bodyHTML": "<p dir=\"auto\">This new API is so much nicer!</p>", "author": "anuraaga", "createdAt": "2020-03-30T06:40:29Z", "path": "brave/src/main/java/brave/propagation/ExtraFieldPropagation.java", "diffHunk": "@@ -15,246 +15,197 @@\n \n import brave.Tracing;\n import brave.internal.Nullable;\n-import brave.internal.PredefinedPropagationFields;\n-import brave.internal.PropagationFields;\n-import brave.internal.PropagationFieldsFactory;\n import brave.propagation.TraceContext.Extractor;\n import brave.propagation.TraceContext.Injector;\n import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.BitSet;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n \n+import static brave.propagation.CorrelationFields.validateName;\n+\n /**\n- * Allows you to propagate predefined request-scoped fields, usually but not always HTTP headers.\n+ * This implements {@linkplain ExtraField extra field} in-process and remote propagation.\n  *\n- * <p>For example, if you are in a Cloud Foundry environment, you might want to pass the request\n- * ID:\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace as HTTP headers.\n  * <pre>{@code\n- * // when you initialize the builder, define the extra field you want to propagate\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, \"x-vcap-request-id\")\n- * );\n- *\n- * // later, you can tag that request ID or use it in log correlation\n- * requestId = ExtraFieldPropagation.get(\"x-vcap-request-id\");\n- *\n- * // You can also set or override the value similarly, which might be needed if a new request\n- * ExtraFieldPropagation.get(\"x-country-code\", \"FO\");\n- * }</pre>\n- *\n- * <h3>Appropriate usage</h3>\n- * It is generally not a good idea to use the tracing system for application logic or critical code\n- * such as security context propagation.\n- *\n- * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n- * business code. Prefer exposing your own types for utility functions that use this class as this\n- * will insulate you from lock-in.\n+ * // Configure your extra field\n+ * countryCode = ExtraField.create(\"country-code\");\n  *\n- * <p>While it may seem convenient, do not use this for security context propagation as it was not\n- * designed for this use case. For example, anything placed in here can be accessed by any code in\n- * the same classloader!\n- *\n- * <h3>Passing through alternate trace contexts</h3>\n- * <p>You may also need to propagate an second trace context transparently. For example, when in\n- * an Amazon Web Services environment, but not reporting data to X-Ray. To ensure X-Ray can co-exist\n- * correctly, pass-through its tracing header like so.\n- *\n- * <pre>{@code\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactory(B3Propagation.FACTORY, \"x-amzn-trace-id\")\n- * );\n- * }</pre>\n- *\n- * <h3>Prefixed fields</h3>\n- * <p>You can also prefix fields, if they follow a common pattern. For example, the following will\n- * propagate the field \"x-vcap-request-id\" as-is, but send the fields \"country-code\" and \"user-id\"\n- * on the wire as \"baggage-country-code\" and \"baggage-user-id\" respectively.\n- *\n- * <pre>{@code\n- * // Setup your tracing instance with allowed fields\n+ * // When you initialize the builder, add the extra field you want to propagate\n  * tracingBuilder.propagationFactory(\n  *   ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                        .addField(\"x-vcap-request-id\")\n- *                        .addPrefixedFields(\"baggage-\", Arrays.asList(\"country-code\", \"user-id\"))\n+ *                        .addField(countryCode)\n  *                        .build()\n  * );\n- *\n- * // Later, you can call below to affect the country code of the current trace context\n- * ExtraFieldPropagation.set(\"country-code\", \"FO\");\n- * String countryCode = ExtraFieldPropagation.get(\"country-code\");\n- *\n- * // Or, if you have a reference to a trace context, use it explicitly\n- * ExtraFieldPropagation.set(span.context(), \"country-code\", \"FO\");\n- * String countryCode = ExtraFieldPropagation.get(span.context(), \"country-code\");\n- * }</pre>\n  */\n public class ExtraFieldPropagation<K> implements Propagation<K> {\n-  /** Wraps an underlying propagation implementation, pushing one or more fields */\n-  public static Factory newFactory(Propagation.Factory delegate, String... fieldNames) {\n+  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+  @Deprecated public static Factory newFactory(Propagation.Factory delegate, String... names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-    return newFactory(delegate, Arrays.asList(fieldNames));\n+    if (names == null) throw new NullPointerException(\"field names == null\");\n+    return newFactory(delegate, Arrays.asList(names));\n   }\n \n-  /** Wraps an underlying propagation implementation, pushing one or more fields */\n-  public static Factory newFactory(Propagation.Factory delegate, Collection<String> fieldNames) {\n+  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+  @Deprecated\n+  public static Factory newFactory(Propagation.Factory delegate, Collection<String> names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (fieldNames == null) throw new NullPointerException(\"fieldNames == null\");\n-    String[] validated = ensureLowerCaseFieldNames(new LinkedHashSet<>(fieldNames));\n-    return new RealFactory(delegate, validated, validated, new BitSet());\n+    if (names == null) throw new NullPointerException(\"field names == null\");\n+    if (names.isEmpty()) throw new IllegalArgumentException(\"no field names\");\n+    FactoryBuilder builder = new FactoryBuilder(delegate);\n+    for (String name : names) builder.addField(ExtraField.create(name));\n+    return builder.build();\n   }\n \n+  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n   public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n     return new FactoryBuilder(delegate);\n   }\n \n   public static final class FactoryBuilder {\n     final Propagation.Factory delegate;\n-    final Set<String> fieldNames = new LinkedHashSet<>();\n-    final Set<String> redactedFieldNames = new LinkedHashSet<>();\n-    final Map<String, String[]> prefixedNames = new LinkedHashMap<>();\n+    final Set<String> names = new LinkedHashSet<>();\n+    final Set<String> redactedNames = new LinkedHashSet<>();\n+    final Map<String, Set<String>> nameToPrefixes = new LinkedHashMap<>();\n+\n+    final Set<ExtraField> fields = new LinkedHashSet<>();\n \n     FactoryBuilder(Propagation.Factory delegate) {\n       if (delegate == null) throw new NullPointerException(\"delegate == null\");\n       this.delegate = delegate;\n     }\n \n-    /** Same as {@link #addField} except that this field is redacted from downstream propagation. */\n-    public FactoryBuilder addRedactedField(String fieldName) {\n-      fieldName = validateFieldName(fieldName);\n-      fieldNames.add(fieldName);\n-      redactedFieldNames.add(fieldName);\n-      return this;\n-    }\n-\n     /**\n-     * Adds a field that is referenced the same in-process as it is on the wire. For example, the\n-     * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+     * Adds an {@linkplain ExtraField extra field} for remote propagation.\n      *\n-     * <p>Note: {@code fieldName} will be implicitly lower-cased.\n+     * @since 5.11\n      */\n-    public FactoryBuilder addField(String fieldName) {\n-      fieldNames.add(validateFieldName(fieldName));\n+    public FactoryBuilder addField(ExtraField field) {", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\nindex 56b1d9a76..af3bdc207 100644\n--- a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n+++ b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n", "chunk": "@@ -28,93 +26,74 @@ import java.util.Locale;\n import java.util.Map;\n import java.util.Set;\n \n-import static brave.propagation.CorrelationFields.validateName;\n-\n-/**\n- * This implements {@linkplain ExtraField extra field} in-process and remote propagation.\n- *\n- * <p>For example, if you have a need to know the a specific request's country code, you can\n- * propagate it through the trace as HTTP headers.\n- * <pre>{@code\n- * // Configure your extra field\n- * countryCode = ExtraField.create(\"country-code\");\n- *\n- * // When you initialize the builder, add the extra field you want to propagate\n- * tracingBuilder.propagationFactory(\n- *   ExtraFieldPropagation.newFactoryBuilder(B3Propagation.FACTORY)\n- *                        .addField(countryCode)\n- *                        .build()\n- * );\n- */\n-public class ExtraFieldPropagation<K> implements Propagation<K> {\n-  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n+/** @deprecated Since 5.11 use {@link BaggagePropagation} */\n+@Deprecated public class ExtraFieldPropagation<K> implements Propagation<K> {\n+  /** @deprecated Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)} */\n   @Deprecated public static Factory newFactory(Propagation.Factory delegate, String... names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-    if (names == null) throw new NullPointerException(\"field names == null\");\n+    if (names == null) throw new NullPointerException(\"names == null\");\n     return newFactory(delegate, Arrays.asList(names));\n   }\n \n-  /** @deprecated Since 5.11 please always use {@link #newFactoryBuilder(Propagation.Factory)) */\n-  @Deprecated\n-  public static Factory newFactory(Propagation.Factory delegate, Collection<String> names) {\n+  /** @deprecated Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)} */\n+  @Deprecated public static Factory newFactory(Propagation.Factory delegate,\n+    Collection<String> names) {\n     if (delegate == null) throw new NullPointerException(\"delegate == null\");\n     if (names == null) throw new NullPointerException(\"field names == null\");\n     if (names.isEmpty()) throw new IllegalArgumentException(\"no field names\");\n     FactoryBuilder builder = new FactoryBuilder(delegate);\n-    for (String name : names) builder.addField(ExtraField.create(name));\n+    for (String name : names) {\n+      builder.addField(BaggageField.create(validateFieldName(name)));\n+    }\n     return builder.build();\n   }\n \n-  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n-  public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n+  /** @deprecated Since 5.11 use {@link BaggagePropagation#newFactoryBuilder(Propagation.Factory)} */\n+  @Deprecated public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n     return new FactoryBuilder(delegate);\n   }\n \n-  public static final class FactoryBuilder {\n-    final Propagation.Factory delegate;\n+  /** @deprecated Since 5.11 use {@link BaggagePropagation.FactoryBuilder} */\n+  @Deprecated public static final class FactoryBuilder extends BaggagePropagation.FactoryBuilder {\n     final Set<String> names = new LinkedHashSet<>();\n     final Set<String> redactedNames = new LinkedHashSet<>();\n     final Map<String, Set<String>> nameToPrefixes = new LinkedHashMap<>();\n \n-    final Set<ExtraField> fields = new LinkedHashSet<>();\n-\n     FactoryBuilder(Propagation.Factory delegate) {\n-      if (delegate == null) throw new NullPointerException(\"delegate == null\");\n-      this.delegate = delegate;\n+      super(delegate);\n     }\n \n     /**\n-     * Adds an {@linkplain ExtraField extra field} for remote propagation.\n-     *\n-     * @since 5.11\n+     * @deprecated Since 5.11,  use {@link #addField(BaggageField)} with a baggage field built with\n+     * {@link BaggageField.Builder#clearRemoteNames()}.\n      */\n-    public FactoryBuilder addField(ExtraField field) {\n-      if (field == null) throw new NullPointerException(\"field == null\");\n-      fields.add(field);\n+    @Deprecated public FactoryBuilder addRedactedField(String fieldName) {\n+      fieldName = validateFieldName(fieldName);\n+      names.add(fieldName);\n+      redactedNames.add(fieldName);\n       return this;\n     }\n \n-    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n-    public FactoryBuilder addRedactedField(String name) {\n-      name = validateName(name).toLowerCase(Locale.ROOT);\n-      names.add(name);\n-      redactedNames.add(name);\n-      return this;\n-    }\n-\n-    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n-    public FactoryBuilder addField(String name) {\n-      names.add(validateName(name).toLowerCase(Locale.ROOT));\n+    /**\n+     * @deprecated Since 5.11, use {@link #addField(BaggageField)} with {@link\n+     * BaggageField.Builder#create(String)}.\n+     */\n+    @Deprecated public FactoryBuilder addField(String fieldName) {\n+      names.add(validateFieldName(fieldName));\n       return this;\n     }\n \n-    /** @deprecated Since 5.11 please always use {@link #addField(ExtraField)) */\n-    public FactoryBuilder addPrefixedFields(String prefix, Collection<String> names) {\n+    /**\n+     * @deprecated Since 5.11, use {@link #addField(BaggageField)} with a baggage field built with\n+     * {@link BaggageField.Builder#clearRemoteNames()} and {@linkplain\n+     * BaggageField.Builder#addRemoteName(String) add the prefixed name explicitly}.\n+     */\n+    @Deprecated public FactoryBuilder addPrefixedFields(String prefix, Collection<String> names) {\n       if (prefix == null) throw new NullPointerException(\"prefix == null\");\n-      if (prefix.isEmpty()) throw new IllegalArgumentException(\"prefix is empty\");\n+      prefix = validateFieldName(prefix);\n       if (names == null) throw new NullPointerException(\"names == null\");\n       for (String name : names) {\n-        name = validateName(name).toLowerCase(Locale.ROOT);\n+        name = validateFieldName(name);\n         Set<String> prefixes = nameToPrefixes.get(name);\n         if (prefixes == null) nameToPrefixes.put(name, prefixes = new LinkedHashSet<>());\n         prefixes.add(prefix);\n", "next_change": {"commit": "016837e22164c69eb416b1c29fbd59e962634024", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\nindex af3bdc207..5297156f5 100644\n--- a/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n+++ b/brave/src/main/java/brave/propagation/ExtraFieldPropagation.java\n", "chunk": "@@ -94,46 +99,30 @@ import java.util.Set;\n       if (names == null) throw new NullPointerException(\"names == null\");\n       for (String name : names) {\n         name = validateFieldName(name);\n-        Set<String> prefixes = nameToPrefixes.get(name);\n-        if (prefixes == null) nameToPrefixes.put(name, prefixes = new LinkedHashSet<>());\n-        prefixes.add(prefix);\n+        addKeyName(name, prefix + name);\n       }\n       return this;\n     }\n \n-    Set<BaggageField> convertDeprecated() {\n-      Set<String> remainingNames = new LinkedHashSet<>(names);\n-      Set<BaggageField> result = new LinkedHashSet<>();\n-      for (Map.Entry<String, Set<String>> entry : nameToPrefixes.entrySet()) {\n-        String name = entry.getKey();\n-        if (redactedNames.contains(name)) continue;\n-\n-        BaggageField.Builder builder = BaggageField.newBuilder(name);\n-        // If we didn't add the name directly, we should only add prefixed names.\n-        if (!remainingNames.remove(name)) builder.clearRemoteNames();\n-        for (String prefix : entry.getValue()) {\n-          builder.addRemoteName(prefix + name);\n-        }\n-        result.add(builder.build());\n-      }\n-\n-      for (String name : remainingNames) {\n-        BaggageField.Builder builder = BaggageField.newBuilder(name);\n-        if (redactedNames.contains(name)) builder.clearRemoteNames();\n-        result.add(builder.build());\n-      }\n-      return result;\n+    void addKeyName(String name, String keyName) {\n+      Set<String> keyNames = nameToKeyNames.get(name);\n+      if (keyNames == null) nameToKeyNames.put(name, keyNames = new LinkedHashSet<>());\n+      keyNames.add(keyName);\n     }\n \n     /** Returns a wrapper of the delegate if there are no fields to propagate. */\n     public Factory build() {\n-      Set<BaggageField> fields = convertDeprecated();\n-      fields.addAll(this.fields); // clobbering deprecated config is ok\n-      BaggageField[] fieldsArray = fields.toArray(new BaggageField[0]);\n-      if (fieldsArray.length == 0) {\n-        return new Factory(delegate, fieldsArray);\n+      Set<String> extraKeyNames = new LinkedHashSet<>();\n+      for (Map.Entry<String, Set<String>> entry : nameToKeyNames.entrySet()) {\n+        BaggageField field = BaggageField.create(entry.getKey());\n+        if (redactedNames.contains(field.name())) {\n+          baggageFactory.addField(field);\n+        } else {\n+          extraKeyNames.addAll(entry.getValue());\n+          baggageFactory.addRemoteField(field, entry.getValue());\n+        }\n       }\n-      return new Factory(new BaggagePropagation.Factory(delegate, fieldsArray), fieldsArray);\n+      return new Factory(baggageFactory.build(), extraKeyNames.toArray(new String[0]));\n     }\n   }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzEwMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399963101", "body": "```suggestion\r\n    LinkedHashMap<String, String> result = new LinkedHashMap<>();\r\n    for (int i = 0, length = elements.length; i < length; i++) {\r\n      result.put(fields[i].name, elements[i]);\r\n    }\r\n    return Collections.unmodifiableMap(result);\r\n```\r\n\r\nLooks like same amount of code as the mapfield consumer, but avoids introducing a custom type into user stacktraces. `unmodifiableMap` is optional but I guess it's good for both return branches to return immutable instead of just one.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                MapFieldConsumer result = new MapFieldConsumer();\n          \n          \n            \n                forEach(result);\n          \n          \n            \n                return result;\n          \n          \n            \n                LinkedHashMap<String, String> result = new LinkedHashMap<>();\n          \n          \n            \n                for (int i = 0, length = elements.length; i < length; i++) {\n          \n          \n            \n                  result.put(fields[i].name, elements[i]);\n          \n          \n            \n                }\n          \n          \n            \n                return Collections.unmodifiableMap(result);\n          \n      \n    \n    \n  \n\nLooks like same amount of code as the mapfield consumer, but avoids introducing a custom type into user stacktraces. unmodifiableMap is optional but I guess it's good for both return branches to return immutable instead of just one.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-smi\">MapFieldConsumer</span> result <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">MapFieldConsumer</span>();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    forEach(result);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">return</span> result;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">LinkedHashMap&lt;<span class=\"pl-smi\">String</span>, <span class=\"pl-smi\">String</span>&gt;</span> result <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-k\">LinkedHashMap&lt;&gt;</span>();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">for</span> (<span class=\"pl-k\">int</span> i <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>, length <span class=\"pl-k\">=</span> elements<span class=\"pl-k\">.</span>length; i <span class=\"pl-k\">&lt;</span> length; i<span class=\"pl-k\">++</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      result<span class=\"pl-k\">.</span>put(fields[i]<span class=\"pl-k\">.</span>name, elements[i]);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">Collections</span><span class=\"pl-k\">.</span>unmodifiableMap(result);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">Looks like same amount of code as the mapfield consumer, but avoids introducing a custom type into user stacktraces. <code>unmodifiableMap</code> is optional but I guess it's good for both return branches to return immutable instead of just one.</p>", "author": "anuraaga", "createdAt": "2020-03-30T06:54:38Z", "path": "brave/src/main/java/brave/propagation/ExtraFields.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.PropagationFields;\n+import brave.internal.PropagationFieldsFactory;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Copy-on-write keeps propagation changes in a child context from affecting its parent */\n+final class ExtraFields extends PropagationFields<ExtraField, String> {\n+  static final class Factory extends PropagationFieldsFactory<ExtraField, String, ExtraFields> {\n+    final ExtraField[] fields;\n+\n+    Factory(ExtraField... fields) {\n+      this.fields = fields;\n+    }\n+\n+    @Override public Class<ExtraFields> type() {\n+      return ExtraFields.class;\n+    }\n+\n+    @Override public ExtraFields create() {\n+      return new ExtraFields(fields);\n+    }\n+\n+    @Override public ExtraFields create(ExtraFields parent) {\n+      return new ExtraFields(parent, fields);\n+    }\n+\n+    @Override protected TraceContext contextWithExtra(TraceContext context, List<Object> extra) {\n+      return context.withExtra(extra); // more efficient\n+    }\n+  }\n+\n+  final ExtraField[] fields;\n+  volatile String[] values; // guarded by this, copy on write\n+\n+  ExtraFields(ExtraField... fields) {\n+    this.fields = fields;\n+  }\n+\n+  ExtraFields(ExtraFields parent, ExtraField... fields) {\n+    this(fields);\n+    checkSameFields(parent);\n+    this.values = parent.values;\n+  }\n+\n+  @Override protected String get(ExtraField field) {\n+    int index = indexOf(field);\n+    return index != -1 ? get(index) : null;\n+  }\n+\n+  String get(int index) {\n+    if (index >= fields.length) return null;\n+\n+    String[] elements = values;\n+    return elements != null ? elements[index] : null;\n+  }\n+\n+  @Override protected void forEach(FieldConsumer<ExtraField, String> fieldConsumer) {\n+    String[] elements = values;\n+    if (elements == null) return;\n+\n+    for (int i = 0, length = fields.length; i < length; i++) {\n+      String value = elements[i];\n+      if (value == null) continue;\n+      fieldConsumer.accept(fields[i], value);\n+    }\n+  }\n+\n+  @Override protected final void put(ExtraField field, String value) {\n+    int index = indexOf(field);\n+    if (index == -1) return;\n+    put(index, value);\n+  }\n+\n+  @Override protected boolean isEmpty() {\n+    String[] elements = values;\n+    if (elements == null) return true;\n+    for (String value : elements) {\n+      if (value != null) return false;\n+    }\n+    return true;\n+  }\n+\n+  protected final void put(int index, String value) {\n+    if (index >= fields.length) return;\n+\n+    synchronized (this) {\n+      doPut(index, value);\n+    }\n+  }\n+\n+  void doPut(int index, String value) {\n+    String[] elements = values;\n+    if (elements == null) {\n+      elements = new String[fields.length];\n+      elements[index] = value;\n+    } else if (value.equals(elements[index])) {\n+      return;\n+    } else { // this is the copy-on-write part\n+      elements = Arrays.copyOf(elements, elements.length);\n+      elements[index] = value;\n+    }\n+    values = elements;\n+  }\n+\n+  @Override protected final void putAllIfAbsent(PropagationFields parent) {\n+    if (!(parent instanceof ExtraFields)) return;\n+    ExtraFields predefinedParent = (ExtraFields) parent;\n+    checkSameFields(predefinedParent);\n+    String[] parentValues = predefinedParent.values;\n+    if (parentValues == null) return;\n+    for (int i = 0; i < parentValues.length; i++) {\n+      if (parentValues[i] != null && get(i) == null) { // extracted wins vs parent\n+        doPut(i, parentValues[i]);\n+      }\n+    }\n+  }\n+\n+  void checkSameFields(ExtraFields predefinedParent) {\n+    if (!Arrays.equals(fields, predefinedParent.fields)) {\n+      throw new IllegalStateException(\n+        String.format(\"Mixed name configuration unsupported: found %s, expected %s\",\n+          Arrays.toString(fields), Arrays.toString(predefinedParent.fields))\n+      );\n+    }\n+  }\n+\n+  @Override public final Map<String, String> toMap() {\n+    String[] elements = values;\n+    if (elements == null) return Collections.emptyMap();\n+\n+    MapFieldConsumer result = new MapFieldConsumer();\n+    forEach(result);\n+    return result;", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEzMjYxMg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400132612", "bodyText": "saved also for tomorrow.", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2MzEwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraFields.java b/brave/src/main/java/brave/propagation/PredefinedBaggageFields.java\nsimilarity index 61%\nrename from brave/src/main/java/brave/propagation/ExtraFields.java\nrename to brave/src/main/java/brave/propagation/PredefinedBaggageFields.java\nindex d7782ca8a..ac4569838 100644\n--- a/brave/src/main/java/brave/propagation/ExtraFields.java\n+++ b/brave/src/main/java/brave/propagation/PredefinedBaggageFields.java\n", "chunk": "@@ -146,35 +148,34 @@ final class ExtraFields extends PropagationFields<ExtraField, String> {\n     String[] elements = values;\n     if (elements == null) return Collections.emptyMap();\n \n-    MapFieldConsumer result = new MapFieldConsumer();\n-    forEach(result);\n-    return result;\n-  }\n-\n-  static final class MapFieldConsumer extends LinkedHashMap<String, String>\n-    implements FieldConsumer<ExtraField, String> {\n-    @Override public void accept(ExtraField field, String value) {\n-      put(field.name, value);\n+    LinkedHashMap<String, String> result = new LinkedHashMap<>();\n+    for (int i = 0, length = fields.length; i < length; i++) {\n+      String value = elements[i];\n+      if (value != null) result.put(fields[i].name, value);\n     }\n+    return Collections.unmodifiableMap(result);\n   }\n \n-  int indexOf(ExtraField name) {\n+  int indexOf(BaggageField field) {\n     for (int i = 0, length = fields.length; i < length; i++) {\n-      if (fields[i].equals(name)) return i;\n+      if (fields[i].equals(field)) return i;\n     }\n     return -1;\n   }\n \n-  @Override public int hashCode() { // for unit tests\n-    String[] values = this.values;\n-    return values == null ? 0 : Arrays.hashCode(values);\n+  // Implemented for equals when no baggage was extracted\n+  @Override public boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof PredefinedBaggageFields)) return false;\n+    PredefinedBaggageFields that = (PredefinedBaggageFields) o;\n+    return Arrays.equals(fields, that.fields) && Arrays.equals(values, that.values);\n   }\n \n-  @Override public boolean equals(Object o) { // for unit tests\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraFields)) return false;\n-    ExtraFields that = (ExtraFields) o;\n-    String[] values = this.values, thatValues = that.values;\n-    return values == null ? thatValues == null : Arrays.equals(values, thatValues);\n+  @Override public int hashCode() {\n+    int h = 1000003;\n+    h ^= Arrays.hashCode(fields);\n+    h *= 1000003;\n+    h ^= Arrays.hashCode(values);\n+    return h;\n   }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjA2Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r399966062", "body": "Even only for unit tests, probably good to compare `fields` too or if a newly added test doesn't work because of that in the future it will be quite mysterious", "bodyText": "Even only for unit tests, probably good to compare fields too or if a newly added test doesn't work because of that in the future it will be quite mysterious", "bodyHTML": "<p dir=\"auto\">Even only for unit tests, probably good to compare <code>fields</code> too or if a newly added test doesn't work because of that in the future it will be quite mysterious</p>", "author": "anuraaga", "createdAt": "2020-03-30T07:01:31Z", "path": "brave/src/main/java/brave/propagation/ExtraFields.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.PropagationFields;\n+import brave.internal.PropagationFieldsFactory;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Copy-on-write keeps propagation changes in a child context from affecting its parent */\n+final class ExtraFields extends PropagationFields<ExtraField, String> {\n+  static final class Factory extends PropagationFieldsFactory<ExtraField, String, ExtraFields> {\n+    final ExtraField[] fields;\n+\n+    Factory(ExtraField... fields) {\n+      this.fields = fields;\n+    }\n+\n+    @Override public Class<ExtraFields> type() {\n+      return ExtraFields.class;\n+    }\n+\n+    @Override public ExtraFields create() {\n+      return new ExtraFields(fields);\n+    }\n+\n+    @Override public ExtraFields create(ExtraFields parent) {\n+      return new ExtraFields(parent, fields);\n+    }\n+\n+    @Override protected TraceContext contextWithExtra(TraceContext context, List<Object> extra) {\n+      return context.withExtra(extra); // more efficient\n+    }\n+  }\n+\n+  final ExtraField[] fields;\n+  volatile String[] values; // guarded by this, copy on write\n+\n+  ExtraFields(ExtraField... fields) {\n+    this.fields = fields;\n+  }\n+\n+  ExtraFields(ExtraFields parent, ExtraField... fields) {\n+    this(fields);\n+    checkSameFields(parent);\n+    this.values = parent.values;\n+  }\n+\n+  @Override protected String get(ExtraField field) {\n+    int index = indexOf(field);\n+    return index != -1 ? get(index) : null;\n+  }\n+\n+  String get(int index) {\n+    if (index >= fields.length) return null;\n+\n+    String[] elements = values;\n+    return elements != null ? elements[index] : null;\n+  }\n+\n+  @Override protected void forEach(FieldConsumer<ExtraField, String> fieldConsumer) {\n+    String[] elements = values;\n+    if (elements == null) return;\n+\n+    for (int i = 0, length = fields.length; i < length; i++) {\n+      String value = elements[i];\n+      if (value == null) continue;\n+      fieldConsumer.accept(fields[i], value);\n+    }\n+  }\n+\n+  @Override protected final void put(ExtraField field, String value) {\n+    int index = indexOf(field);\n+    if (index == -1) return;\n+    put(index, value);\n+  }\n+\n+  @Override protected boolean isEmpty() {\n+    String[] elements = values;\n+    if (elements == null) return true;\n+    for (String value : elements) {\n+      if (value != null) return false;\n+    }\n+    return true;\n+  }\n+\n+  protected final void put(int index, String value) {\n+    if (index >= fields.length) return;\n+\n+    synchronized (this) {\n+      doPut(index, value);\n+    }\n+  }\n+\n+  void doPut(int index, String value) {\n+    String[] elements = values;\n+    if (elements == null) {\n+      elements = new String[fields.length];\n+      elements[index] = value;\n+    } else if (value.equals(elements[index])) {\n+      return;\n+    } else { // this is the copy-on-write part\n+      elements = Arrays.copyOf(elements, elements.length);\n+      elements[index] = value;\n+    }\n+    values = elements;\n+  }\n+\n+  @Override protected final void putAllIfAbsent(PropagationFields parent) {\n+    if (!(parent instanceof ExtraFields)) return;\n+    ExtraFields predefinedParent = (ExtraFields) parent;\n+    checkSameFields(predefinedParent);\n+    String[] parentValues = predefinedParent.values;\n+    if (parentValues == null) return;\n+    for (int i = 0; i < parentValues.length; i++) {\n+      if (parentValues[i] != null && get(i) == null) { // extracted wins vs parent\n+        doPut(i, parentValues[i]);\n+      }\n+    }\n+  }\n+\n+  void checkSameFields(ExtraFields predefinedParent) {\n+    if (!Arrays.equals(fields, predefinedParent.fields)) {\n+      throw new IllegalStateException(\n+        String.format(\"Mixed name configuration unsupported: found %s, expected %s\",\n+          Arrays.toString(fields), Arrays.toString(predefinedParent.fields))\n+      );\n+    }\n+  }\n+\n+  @Override public final Map<String, String> toMap() {\n+    String[] elements = values;\n+    if (elements == null) return Collections.emptyMap();\n+\n+    MapFieldConsumer result = new MapFieldConsumer();\n+    forEach(result);\n+    return result;\n+  }\n+\n+  static final class MapFieldConsumer extends LinkedHashMap<String, String>\n+    implements FieldConsumer<ExtraField, String> {\n+    @Override public void accept(ExtraField field, String value) {\n+      put(field.name, value);\n+    }\n+  }\n+\n+  int indexOf(ExtraField name) {\n+    for (int i = 0, length = fields.length; i < length; i++) {\n+      if (fields[i].equals(name)) return i;\n+    }\n+    return -1;\n+  }\n+\n+  @Override public int hashCode() { // for unit tests", "originalCommit": "468f78c0ef806286a0fd17344a214b2449373f83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEwOTE4Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400109186", "bodyText": "went offline for a while as I really don't want to do this.. I'm rejigging the tests instead.", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNzQzOQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400117439", "bodyText": "glad I didn't want to change the hashCode/equals.. there's a bug in the impl :)", "author": "codefromthecrypt", "createdAt": "2020-03-30T11:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk2NjA2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/ExtraFields.java b/brave/src/main/java/brave/propagation/PredefinedBaggageFields.java\nsimilarity index 61%\nrename from brave/src/main/java/brave/propagation/ExtraFields.java\nrename to brave/src/main/java/brave/propagation/PredefinedBaggageFields.java\nindex d7782ca8a..ac4569838 100644\n--- a/brave/src/main/java/brave/propagation/ExtraFields.java\n+++ b/brave/src/main/java/brave/propagation/PredefinedBaggageFields.java\n", "chunk": "@@ -146,35 +148,34 @@ final class ExtraFields extends PropagationFields<ExtraField, String> {\n     String[] elements = values;\n     if (elements == null) return Collections.emptyMap();\n \n-    MapFieldConsumer result = new MapFieldConsumer();\n-    forEach(result);\n-    return result;\n-  }\n-\n-  static final class MapFieldConsumer extends LinkedHashMap<String, String>\n-    implements FieldConsumer<ExtraField, String> {\n-    @Override public void accept(ExtraField field, String value) {\n-      put(field.name, value);\n+    LinkedHashMap<String, String> result = new LinkedHashMap<>();\n+    for (int i = 0, length = fields.length; i < length; i++) {\n+      String value = elements[i];\n+      if (value != null) result.put(fields[i].name, value);\n     }\n+    return Collections.unmodifiableMap(result);\n   }\n \n-  int indexOf(ExtraField name) {\n+  int indexOf(BaggageField field) {\n     for (int i = 0, length = fields.length; i < length; i++) {\n-      if (fields[i].equals(name)) return i;\n+      if (fields[i].equals(field)) return i;\n     }\n     return -1;\n   }\n \n-  @Override public int hashCode() { // for unit tests\n-    String[] values = this.values;\n-    return values == null ? 0 : Arrays.hashCode(values);\n+  // Implemented for equals when no baggage was extracted\n+  @Override public boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof PredefinedBaggageFields)) return false;\n+    PredefinedBaggageFields that = (PredefinedBaggageFields) o;\n+    return Arrays.equals(fields, that.fields) && Arrays.equals(values, that.values);\n   }\n \n-  @Override public boolean equals(Object o) { // for unit tests\n-    if (o == this) return true;\n-    if (!(o instanceof ExtraFields)) return false;\n-    ExtraFields that = (ExtraFields) o;\n-    String[] values = this.values, thatValues = that.values;\n-    return values == null ? thatValues == null : Arrays.equals(values, thatValues);\n+  @Override public int hashCode() {\n+    int h = 1000003;\n+    h ^= Arrays.hashCode(fields);\n+    h *= 1000003;\n+    h ^= Arrays.hashCode(values);\n+    return h;\n   }\n }\n", "next_change": null}]}}, {"oid": "1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "url": "https://github.com/openzipkin/brave/commit/1533b803a705c7cebe8eb1edf233c10c20b5fbf0", "message": "First pass of lazy scope", "committedDate": "2020-03-30T08:44:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczMjkxMw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400732913", "body": "I think this is missing `else values.remove(key)`. But maybe simpler to just remove both `!= null` checks", "bodyText": "I think this is missing else values.remove(key). But maybe simpler to just remove both != null checks", "bodyHTML": "<p dir=\"auto\">I think this is missing <code>else values.remove(key)</code>. But maybe simpler to just remove both <code>!= null</code> checks</p>", "author": "anuraaga", "createdAt": "2020-03-31T08:29:23Z", "path": "brave/src/main/java/brave/internal/MapPropagationFields.java", "diffHunk": "@@ -59,18 +59,18 @@ protected MapPropagationFields(MapPropagationFields<K, V> parent) {\n     }\n   }\n \n-  @Override public final void put(K key, V value) {\n+  @Override public final void put(K key, @Nullable V value) {\n     synchronized (this) {\n       Map<K, V> values = this.values;\n       if (values == null) {\n         values = new LinkedHashMap<>();\n-        values.put(key, value);\n-      } else if (value.equals(values.get(key))) {\n+        if (value != null) values.put(key, value);\n+      } else if (equal(value, values.get(key))) {\n         return;\n       } else {\n         // this is the copy-on-write part\n         values = new LinkedHashMap<>(values);\n-        values.put(key, value);\n+        if (value != null) values.put(key, value);", "originalCommit": "f26b1f2e804249834f89c00df9d209fba806d290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2Nzk4MQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400767981", "bodyText": "we just newed up values so we don't need an else right?", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczMjkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3MTgwMA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400771800", "bodyText": "We newed by copying values. If value is null, don't we need to remove it from the copy?", "author": "anuraaga", "createdAt": "2020-03-31T09:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczMjkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5NjM4Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400796387", "bodyText": "you were right! we were missing a test", "author": "codefromthecrypt", "createdAt": "2020-03-31T10:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczMjkxMw=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/MapPropagationFields.java b/brave/src/main/java/brave/internal/MapPropagationFields.java\nindex 084d9c58b..1bd4c6cee 100644\n--- a/brave/src/main/java/brave/internal/MapPropagationFields.java\n+++ b/brave/src/main/java/brave/internal/MapPropagationFields.java\n", "chunk": "@@ -70,7 +70,11 @@ public class MapPropagationFields<K, V> extends PropagationFields<K, V> {\n       } else {\n         // this is the copy-on-write part\n         values = new LinkedHashMap<>(values);\n-        if (value != null) values.put(key, value);\n+        if (value != null) {\n+          values.put(key, value);\n+        } else {\n+          values.remove(key);\n+        }\n       }\n       this.values = Collections.unmodifiableMap(values);\n     }\n", "next_change": {"commit": "a042fe16ff30c94988396e85637471dfa9719845", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/MapPropagationFields.java b/brave/src/main/java/brave/internal/MapPropagationFields.java\nindex 1bd4c6cee..a72ec0c97 100644\n--- a/brave/src/main/java/brave/internal/MapPropagationFields.java\n+++ b/brave/src/main/java/brave/internal/MapPropagationFields.java\n", "chunk": "@@ -78,6 +78,7 @@ public class MapPropagationFields<K, V> extends PropagationFields<K, V> {\n       }\n       this.values = Collections.unmodifiableMap(values);\n     }\n+    return false;\n   }\n \n   @Override public boolean isEmpty() {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400744228", "body": "For this new class is it possible to return `Propagation.Factory` and make the implementation package private?", "bodyText": "For this new class is it possible to return Propagation.Factory and make the implementation package private?", "bodyHTML": "<p dir=\"auto\">For this new class is it possible to return <code>Propagation.Factory</code> and make the implementation package private?</p>", "author": "anuraaga", "createdAt": "2020-03-31T08:48:02Z", "path": "brave/src/main/java/brave/propagation/BaggagePropagation.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This implements in-process and remote {@linkplain BaggageField baggage} propagation.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace as HTTP headers.\n+ * <pre>{@code\n+ * // Configure your baggage field\n+ * COUNTRY_CODE = BaggageField.create(\"country-code\");\n+ *\n+ * // When you initialize the builder, add the baggage you want to propagate\n+ * tracingBuilder.propagationFactory(\n+ *   BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                     .addField(COUNTRY_CODE)\n+ *                     .build()\n+ * );\n+ *\n+ * // later, you can tag that country code\n+ * COUNTRY_CODE.tag(span);\n+ * }</pre>\n+ *\n+ * @since 5.11\n+ */\n+public class BaggagePropagation<K> implements Propagation<K> {\n+  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n+  public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n+    return new FactoryBuilder(delegate);\n+  }\n+\n+  public static final class FactoryBuilder {\n+    final Propagation.Factory delegate;\n+    final Set<BaggageField> fields = new LinkedHashSet<>();\n+\n+    FactoryBuilder(Propagation.Factory delegate) {\n+      if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+      this.delegate = delegate;\n+    }\n+\n+    /**\n+     * Adds a {@linkplain BaggageField baggage field} for remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public FactoryBuilder addField(BaggageField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      fields.add(field);\n+      return this;\n+    }\n+\n+    /** Returns a wrapper of the delegate if there are no fields to propagate. */\n+    public Factory build() {", "originalCommit": "f26b1f2e804249834f89c00df9d209fba806d290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2ODI0Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400768242", "bodyText": "we need to expose baggageKeys() for opentracing..", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3MDk3Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400770976", "bodyText": "Ah got it", "author": "anuraaga", "createdAt": "2020-03-31T09:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3NTAxNQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400775015", "bodyText": "wait maybe we don't anymore .. lemme check!", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3NTQ0Mg==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400775442", "bodyText": "yeah we do.. I'll make a note", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc3NjYxMQ==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400776611", "bodyText": "actually I think we can maybe cheat. lemme try..", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5MjY0Mw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400792643", "bodyText": "wow that was nice! cheating works fine", "author": "codefromthecrypt", "createdAt": "2020-03-31T10:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0NDIyOA=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/BaggagePropagation.java b/brave/src/main/java/brave/propagation/BaggagePropagation.java\nindex a6de5f198..066581fc6 100644\n--- a/brave/src/main/java/brave/propagation/BaggagePropagation.java\n+++ b/brave/src/main/java/brave/propagation/BaggagePropagation.java\n", "chunk": "@@ -69,34 +67,10 @@ public class BaggagePropagation<K> implements Propagation<K> {\n       return this;\n     }\n \n-    /** Returns a wrapper of the delegate if there are no fields to propagate. */\n-    public Factory build() {\n-      if (fields.isEmpty()) return new Factory(delegate);\n-      return new RealFactory(delegate, fields.toArray(new BaggageField[0]));\n-    }\n-  }\n-\n-  public static class Factory extends Propagation.Factory {\n-    final Propagation.Factory delegate;\n-\n-    Factory(Propagation.Factory delegate) {\n-      this.delegate = delegate;\n-    }\n-\n-    @Override public <K> BaggagePropagation<K> create(Propagation.KeyFactory<K> keyFactory) {\n-      return new BaggagePropagation<>(delegate, keyFactory);\n-    }\n-\n-    @Override public boolean supportsJoin() {\n-      return delegate.supportsJoin();\n-    }\n-\n-    @Override public boolean requires128BitTraceId() {\n-      return delegate.requires128BitTraceId();\n-    }\n-\n-    @Override public TraceContext decorate(TraceContext context) {\n-      return delegate.decorate(context);\n+    /** Returns the delegate if there are no fields to propagate. */\n+    public Propagation.Factory build() {\n+      if (fields.isEmpty()) return delegate;\n+      return new Factory(delegate, fields.toArray(new BaggageField[0]));\n     }\n   }\n \n", "next_change": {"commit": "587b2a9179e0edb6c48d97c761ff2c288da0f4d0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/BaggagePropagation.java b/brave/src/main/java/brave/propagation/BaggagePropagation.java\nindex 066581fc6..49dc362af 100644\n--- a/brave/src/main/java/brave/propagation/BaggagePropagation.java\n+++ b/brave/src/main/java/brave/propagation/BaggagePropagation.java\n", "chunk": "@@ -70,6 +73,24 @@ public class BaggagePropagation<K> implements Propagation<K> {\n     /** Returns the delegate if there are no fields to propagate. */\n     public Propagation.Factory build() {\n       if (fields.isEmpty()) return delegate;\n+\n+      // check for duplicate remote names\n+      Map<String, Set<String>> remoteNameToFields = new LinkedHashMap<>();\n+      for (BaggageField field : fields) {\n+        for (String remoteName : field.remoteNames()) {\n+          Set<String> fields = remoteNameToFields.get(remoteName);\n+          if (fields == null) remoteNameToFields.put(remoteName, fields = new LinkedHashSet<>());\n+          fields.add(field.name());\n+        }\n+      }\n+\n+      for (Entry<String, Set<String>> entry : remoteNameToFields.entrySet()) {\n+        if (entry.getValue().size() > 1) {\n+          throw new UnsupportedOperationException( // Later, we will support this!\n+            entry.getValue() + \" have the same remote name: \" + entry.getKey());\n+        }\n+      }\n+\n       return new Factory(delegate, fields.toArray(new BaggageField[0]));\n     }\n   }\n", "next_change": {"commit": "016837e22164c69eb416b1c29fbd59e962634024", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/BaggagePropagation.java b/brave/src/main/java/brave/baggage/BaggagePropagation.java\nsimilarity index 51%\nrename from brave/src/main/java/brave/propagation/BaggagePropagation.java\nrename to brave/src/main/java/brave/baggage/BaggagePropagation.java\nindex 49dc362af..74b5f6754 100644\n--- a/brave/src/main/java/brave/propagation/BaggagePropagation.java\n+++ b/brave/src/main/java/brave/baggage/BaggagePropagation.java\n", "chunk": "@@ -60,44 +95,116 @@ public class BaggagePropagation<K> implements Propagation<K> {\n     }\n \n     /**\n-     * Adds a {@linkplain BaggageField baggage field} for remote propagation.\n+     * Returns an immutable copy of the currently configured fields mapped to names for use in\n+     * remote propagation. This allows those who can't create the builder to reconfigure this\n+     * builder.\n+     *\n+     * @since 5.11\n+     */\n+    public Map<BaggageField, Set<String>> fieldToKeyNames() {\n+      return Collections.unmodifiableMap(fieldToKeyNames);\n+    }\n+\n+    /**\n+     * Clears all state. This allows those who can't create the builder to reconfigure fields.\n+     *\n+     * @see #fieldToKeyNames()\n+     * @see BaggagePropagationCustomizer\n+     * @since 5.11\n+     */\n+    public FactoryBuilder clear() {\n+      allKeyNames.clear();\n+      fieldToKeyNames.clear();\n+      return this;\n+    }\n+\n+    /**\n+     * Adds a {@linkplain BaggageField baggage field}, but does not configure remote propagation.\n      *\n+     * @throws IllegalArgumentException if the field was already added\n      * @since 5.11\n      */\n     public FactoryBuilder addField(BaggageField field) {\n       if (field == null) throw new NullPointerException(\"field == null\");\n-      fields.add(field);\n+      if (fieldToKeyNames.containsKey(field)) {\n+        throw new IllegalArgumentException(field.name + \" already added\");\n+      }\n+      fieldToKeyNames.put(field, Collections.emptySet());\n       return this;\n     }\n \n-    /** Returns the delegate if there are no fields to propagate. */\n-    public Propagation.Factory build() {\n-      if (fields.isEmpty()) return delegate;\n-\n-      // check for duplicate remote names\n-      Map<String, Set<String>> remoteNameToFields = new LinkedHashMap<>();\n-      for (BaggageField field : fields) {\n-        for (String remoteName : field.remoteNames()) {\n-          Set<String> fields = remoteNameToFields.get(remoteName);\n-          if (fields == null) remoteNameToFields.put(remoteName, fields = new LinkedHashSet<>());\n-          fields.add(field.name());\n+    /**\n+     * Adds a {@linkplain BaggageField baggage field} for remote propagation.\n+     *\n+     * <p>When {@code keyNames} are not supplied the field is referenced the same in-process as it\n+     * is on the wire. For example, the {@linkplain BaggageField#name() name} \"x-vcap-request-id\"\n+     * would be set as-is including the prefix.\n+     *\n+     * @param keyNames possibly empty lower-case {@link Propagation#keys() propagation key names}.\n+     * @throws IllegalArgumentException if the field was already added or a key name is already in\n+     * use.\n+     * @since 5.11\n+     */\n+    public FactoryBuilder addRemoteField(BaggageField field, String... keyNames) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      if (keyNames == null) throw new NullPointerException(\"keyNames == null\");\n+      return addRemoteField(field, Arrays.asList(keyNames));\n+    }\n+\n+    /**\n+     * Same as {@link #addRemoteField(BaggageField, String...)}.\n+     *\n+     * @since 5.11\n+     */\n+    public FactoryBuilder addRemoteField(BaggageField field, Iterable<String> keyNames) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      if (keyNames == null) throw new NullPointerException(\"keyNames == null\");\n+      if (fieldToKeyNames.containsKey(field)) {\n+        throw new IllegalArgumentException(field.name + \" already added\");\n+      }\n+      Set<String> lcKeyNames = new LinkedHashSet<>();\n+      for (String keyName : keyNames) {\n+        String lcName = validateName(keyName).toLowerCase(Locale.ROOT);\n+        if (allKeyNames.contains(lcName)) {\n+          throw new IllegalArgumentException(\"Propagation key already in use: \" + lcName);\n         }\n+        allKeyNames.add(lcName);\n+        lcKeyNames.add(lcName);\n       }\n+      if (lcKeyNames.isEmpty()) lcKeyNames.add(field.lcName);\n+      fieldToKeyNames.put(field, Collections.unmodifiableSet(lcKeyNames));\n+      return this;\n+    }\n \n-      for (Entry<String, Set<String>> entry : remoteNameToFields.entrySet()) {\n-        if (entry.getValue().size() > 1) {\n-          throw new UnsupportedOperationException( // Later, we will support this!\n-            entry.getValue() + \" have the same remote name: \" + entry.getKey());\n-        }\n+    /** Returns the delegate if there are no fields to propagate. */\n+    public Propagation.Factory build() {\n+      if (fieldToKeyNames.isEmpty()) return delegate;\n+\n+      BaggageFieldWithKeyNames[] fieldWithKeyNames =\n+        new BaggageFieldWithKeyNames[fieldToKeyNames.size()];\n+      int i = 0;\n+      for (Map.Entry<BaggageField, Set<String>> entry : fieldToKeyNames.entrySet()) {\n+        fieldWithKeyNames[i++] =\n+          new BaggageFieldWithKeyNames(entry.getKey(), entry.getValue().toArray(new String[0]));\n       }\n+      return new Factory(delegate, fieldWithKeyNames);\n+    }\n+  }\n+\n+  /** For {@link Propagation.Factory} */\n+  static final class BaggageFieldWithKeyNames {\n+    final BaggageField field;\n+    final String[] keyNames;\n \n-      return new Factory(delegate, fields.toArray(new BaggageField[0]));\n+    BaggageFieldWithKeyNames(BaggageField field, String[] keyNames) {\n+      this.field = field;\n+      this.keyNames = keyNames;\n     }\n   }\n \n-  static class BaggageFieldWithKeys<K> {\n+  /** For {@link Propagation.Factory#create(KeyFactory)} */\n+  static final class BaggageFieldWithKeys<K> {\n     final BaggageField field;\n-    /** Corresponds to {@link BaggageField#remoteNames()} */\n     final K[] keys;\n \n     BaggageFieldWithKeys(BaggageField field, K[] keys) {\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0ODQzNA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400748434", "body": "Since a local field never has keys (`BaggateField.remoteNames = new String[0]`) we could possibly reduce the checks in this class by not checking `local`.", "bodyText": "Since a local field never has keys (BaggateField.remoteNames = new String[0]) we could possibly reduce the checks in this class by not checking local.", "bodyHTML": "<p dir=\"auto\">Since a local field never has keys (<code>BaggateField.remoteNames = new String[0]</code>) we could possibly reduce the checks in this class by not checking <code>local</code>.</p>", "author": "anuraaga", "createdAt": "2020-03-31T08:54:41Z", "path": "brave/src/main/java/brave/propagation/BaggagePropagation.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This implements in-process and remote {@linkplain BaggageField baggage} propagation.\n+ *\n+ * <p>For example, if you have a need to know the a specific request's country code, you can\n+ * propagate it through the trace as HTTP headers.\n+ * <pre>{@code\n+ * // Configure your baggage field\n+ * COUNTRY_CODE = BaggageField.create(\"country-code\");\n+ *\n+ * // When you initialize the builder, add the baggage you want to propagate\n+ * tracingBuilder.propagationFactory(\n+ *   BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                     .addField(COUNTRY_CODE)\n+ *                     .build()\n+ * );\n+ *\n+ * // later, you can tag that country code\n+ * COUNTRY_CODE.tag(span);\n+ * }</pre>\n+ *\n+ * @since 5.11\n+ */\n+public class BaggagePropagation<K> implements Propagation<K> {\n+  /** Wraps an underlying propagation implementation, pushing one or more fields. */\n+  public static FactoryBuilder newFactoryBuilder(Propagation.Factory delegate) {\n+    return new FactoryBuilder(delegate);\n+  }\n+\n+  public static final class FactoryBuilder {\n+    final Propagation.Factory delegate;\n+    final Set<BaggageField> fields = new LinkedHashSet<>();\n+\n+    FactoryBuilder(Propagation.Factory delegate) {\n+      if (delegate == null) throw new NullPointerException(\"delegate == null\");\n+      this.delegate = delegate;\n+    }\n+\n+    /**\n+     * Adds a {@linkplain BaggageField baggage field} for remote propagation.\n+     *\n+     * @since 5.11\n+     */\n+    public FactoryBuilder addField(BaggageField field) {\n+      if (field == null) throw new NullPointerException(\"field == null\");\n+      fields.add(field);\n+      return this;\n+    }\n+\n+    /** Returns a wrapper of the delegate if there are no fields to propagate. */\n+    public Factory build() {\n+      if (fields.isEmpty()) return new Factory(delegate);\n+      return new RealFactory(delegate, fields.toArray(new BaggageField[0]));\n+    }\n+  }\n+\n+  public static class Factory extends Propagation.Factory {\n+    final Propagation.Factory delegate;\n+\n+    Factory(Propagation.Factory delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override public <K> BaggagePropagation<K> create(Propagation.KeyFactory<K> keyFactory) {\n+      return new BaggagePropagation<>(delegate, keyFactory);\n+    }\n+\n+    @Override public boolean supportsJoin() {\n+      return delegate.supportsJoin();\n+    }\n+\n+    @Override public boolean requires128BitTraceId() {\n+      return delegate.requires128BitTraceId();\n+    }\n+\n+    @Override public TraceContext decorate(TraceContext context) {\n+      return delegate.decorate(context);\n+    }\n+  }\n+\n+  static class BaggageFieldWithKeys<K> {\n+    final BaggageField field;\n+    /** Corresponds to {@link BaggageField#remoteNames()} */\n+    final K[] keys;\n+\n+    BaggageFieldWithKeys(BaggageField field, K[] keys) {\n+      this.field = field;\n+      this.keys = keys;\n+    }\n+  }\n+\n+  static final class RealFactory extends Factory {\n+    final PredefinedBaggageFields.Factory extraFactory;\n+\n+    RealFactory(Propagation.Factory delegate, BaggageField[] fields) {\n+      super(delegate);\n+      this.extraFactory = new PredefinedBaggageFields.Factory(fields);\n+    }\n+\n+    @Override\n+    public final <K> BaggagePropagation<K> create(Propagation.KeyFactory<K> keyFactory) {\n+      int i = 0;\n+      List<K> allKeys = new ArrayList<>();\n+      BaggageFieldWithKeys<K>[] fieldsWithKeys =\n+        new BaggageFieldWithKeys[extraFactory.fields.length];\n+      for (BaggageField field : extraFactory.fields) {\n+        K[] keysForField = (K[]) new Object[field.remoteNames.length];\n+        for (int j = 0, length = field.remoteNames.length; j < length; j++) {\n+          keysForField[j] = keyFactory.create(field.remoteNames[j]);\n+          allKeys.add(keysForField[j]);\n+        }\n+        fieldsWithKeys[i++] = new BaggageFieldWithKeys<>(field, keysForField);\n+      }\n+      return new RealBaggagePropagation<>(this, keyFactory, fieldsWithKeys, allKeys);\n+    }\n+\n+    @Override public TraceContext decorate(TraceContext context) {\n+      TraceContext result = delegate.decorate(context);\n+      return extraFactory.decorate(result);\n+    }\n+  }\n+\n+  final Propagation<K> delegate;\n+\n+  BaggagePropagation(Propagation.Factory factory, Propagation.KeyFactory<K> keyFactory) {\n+    this.delegate = factory.create(keyFactory);\n+  }\n+\n+  /**\n+   * Returns all propagation keys derived from {@linkplain BaggageField#remoteNames()}. This result\n+   * does not include any {@link #keys() trace context keys}.\n+   */\n+  // This is here to support extraction from carriers missing a get field by name function. The only\n+  // known example is OpenTracing TextMap https://github.com/opentracing/opentracing-java/issues/305\n+  public List<K> baggageKeys() {\n+    return Collections.emptyList();\n+  }\n+\n+  /**\n+   * Only returns trace context keys. Baggage field names are not returned to ensure tools don't\n+   * delete them. This is to support users accessing baggage without Brave apis (ex via headers).\n+   */\n+  @Override public List<K> keys() {\n+    return delegate.keys();\n+  }\n+\n+  @Override public <C> Injector<C> injector(Setter<C, K> setter) {\n+    return delegate.injector(setter);\n+  }\n+\n+  @Override public <C> Extractor<C> extractor(Getter<C, K> getter) {\n+    return delegate.extractor(getter);\n+  }\n+\n+  static final class RealBaggagePropagation<K> extends BaggagePropagation<K> {\n+    final RealFactory factory;\n+    final BaggageFieldWithKeys<K>[] fieldsWithKeys;\n+    final List<K> allKeys;\n+\n+    RealBaggagePropagation(\n+      RealFactory factory, Propagation.KeyFactory<K> keyFactory,\n+      BaggageFieldWithKeys<K>[] fieldsWithKeys, List<K> allKeys) {\n+      super(factory.delegate, keyFactory);\n+      this.factory = factory;\n+      this.fieldsWithKeys = fieldsWithKeys;\n+      this.allKeys = Collections.unmodifiableList(allKeys);\n+    }\n+\n+    @Override public List<K> baggageKeys() {\n+      return allKeys;\n+    }\n+\n+    @Override public <C> Injector<C> injector(Setter<C, K> setter) {\n+      return new BaggageFieldInjector<>(this, setter);\n+    }\n+\n+    @Override public <C> Extractor<C> extractor(Getter<C, K> getter) {\n+      return new BaggageFieldExtractor<>(this, getter);\n+    }\n+  }\n+\n+  static final class BaggageFieldInjector<C, K> implements Injector<C> {\n+    final RealBaggagePropagation<K> propagation;\n+    final Injector<C> delegate;\n+    final Propagation.Setter<C, K> setter;\n+\n+    BaggageFieldInjector(RealBaggagePropagation<K> propagation, Setter<C, K> setter) {\n+      this.propagation = propagation;\n+      this.delegate = propagation.delegate.injector(setter);\n+      this.setter = setter;\n+    }\n+\n+    @Override public void inject(TraceContext traceContext, C carrier) {\n+      delegate.inject(traceContext, carrier);\n+      PredefinedBaggageFields extra = traceContext.findExtra(PredefinedBaggageFields.class);\n+      if (extra == null) return;\n+      inject(extra, carrier);\n+    }\n+\n+    void inject(PredefinedBaggageFields fields, C carrier) {\n+      for (BaggageFieldWithKeys<K> fieldWithKeys : propagation.fieldsWithKeys) {\n+        if (fieldWithKeys.field.local) continue; // don't propagate downstream", "originalCommit": "f26b1f2e804249834f89c00df9d209fba806d290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2ODc2Nw==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400768767", "bodyText": "yep good idea!", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0ODQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/BaggagePropagation.java b/brave/src/main/java/brave/propagation/BaggagePropagation.java\nindex a6de5f198..066581fc6 100644\n--- a/brave/src/main/java/brave/propagation/BaggagePropagation.java\n+++ b/brave/src/main/java/brave/propagation/BaggagePropagation.java\n", "chunk": "@@ -221,7 +170,6 @@ public class BaggagePropagation<K> implements Propagation<K> {\n \n     void inject(PredefinedBaggageFields fields, C carrier) {\n       for (BaggageFieldWithKeys<K> fieldWithKeys : propagation.fieldsWithKeys) {\n-        if (fieldWithKeys.field.local) continue; // don't propagate downstream\n         String maybeValue = fields.get(fieldWithKeys.field);\n         if (maybeValue == null) continue;\n         for (K key : fieldWithKeys.keys) setter.put(carrier, key, maybeValue);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0OTM1Ng==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400749356", "body": "Any thoughts on removing `local` in favor of calling `clearRemoteNames` without `addRemoteName` and removing our validation on remote names length? If it quacks it's a duck.", "bodyText": "Any thoughts on removing local in favor of calling clearRemoteNames without addRemoteName and removing our validation on remote names length? If it quacks it's a duck.", "bodyHTML": "<p dir=\"auto\">Any thoughts on removing <code>local</code> in favor of calling <code>clearRemoteNames</code> without <code>addRemoteName</code> and removing our validation on remote names length? If it quacks it's a duck.</p>", "author": "anuraaga", "createdAt": "2020-03-31T08:56:06Z", "path": "brave/src/main/java/brave/propagation/BaggageField.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.propagation;\n+\n+import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+/**\n+ * Defines a request-scoped field, usually but not always analogous to an HTTP header. Fields will\n+ * be no-op unless {@link BaggagePropagation} is configured.\n+ *\n+ * <p>For example, if you have a need to know a specific request's country code in a downstream\n+ * service, you can propagate it through the trace:\n+ * <pre>{@code\n+ * // Configure your baggage field\n+ * COUNTRY_CODE = BaggageField.create(\"country-code\");\n+ * }</pre>\n+ *\n+ * <p>If you don't have a reference to a baggage field, you can use {@linkplain\n+ * #getByName(TraceContext, String)}.\n+ *\n+ * <h3>Local Usage</h3>\n+ * Baggage fields are also {@linkplain CorrelationField correlation fields}. As long as a field is\n+ * configured with {@link BaggagePropagation}, local reads and updates are possible in-process.\n+ *\n+ * <p>You can also integrate baggage with other correlated contexts such as logging:\n+ * <pre>{@code\n+ * AMZN_TRACE_ID = BaggageField.newBuilder(\"x-amzn-trace-id\").build();\n+ *\n+ * // Allow logging patterns like %X{traceId} %X{x-amzn-trace-id}\n+ * decorator = MDCScopeDecorator.newBuilder()\n+ *                              .addField(AMZN_TRACE_ID).build();\n+ *\n+ * tracingBuilder.propagationFactory(BaggagePropagation.newFactoryBuilder(B3Propagation.FACTORY)\n+ *                                                     .addField(AMZN_TRACE_ID)\n+ *                                                     .build())\n+ *               .currentTraceContext(ThreadLocalCurrentTraceContext.newBuilder()\n+ *                                                                  .addScopeDecorator(decorator)\n+ *                                                                  .build())\n+ * }</pre>\n+ *\n+ * <h3>Local-only Baggage</h3>\n+ * You may have some fields that you would like to propagate in-process, but not downstream to other\n+ * hosts. Use {@link Builder#local()} to indicate a field should not be injected into headers.\n+ *\n+ * <h3>Different naming conventions</h3>\n+ * By default the name used for remote propagation (header) is the same as the lowercase variant of\n+ * the field name. You can override this using the builder.\n+ *\n+ * For example, the following will propagate the field \"x-vcap-request-id\" as-is, but send the\n+ * fields \"countryCode\" and \"userId\" on the wire as \"baggage-country-code\" and \"baggage-user-id\"\n+ * respectively.\n+ * <pre>{@code\n+ * REQUEST_ID = BaggageField.create(\"x-vcap-request-id\");\n+ * COUNTRY_CODE = BaggageField.newBuilder(\"countryCode\").clearKeys()\n+ *                            .addKey(\"baggage-country-code\").build();\n+ * USER_ID = BaggageField.newBuilder(\"userId\").clearKeys()\n+ *                       .addKey(\"baggage-user-id\").build();\n+ * }</pre>\n+ *\n+ * <h3>Appropriate usage</h3>\n+ * It is generally not a good idea to use the tracing system for application logic or critical code\n+ * such as security context propagation.\n+ *\n+ * <p>Brave is an infrastructure library: you will create lock-in if you expose its apis into\n+ * business code. Prefer exposing your own types for utility functions that use this class as this\n+ * will insulate you from lock-in.\n+ *\n+ * <p>While it may seem convenient, do not use this for security context propagation as it was not\n+ * designed for this use case. For example, anything placed in here can be accessed by any code in\n+ * the same classloader!\n+ *\n+ * @see BaggagePropagation\n+ * @see CorrelationScopeDecorator\n+ */\n+public final class BaggageField extends CorrelationField.Updatable {\n+  /**\n+   * Creates a field that is referenced the same in-process as it is on the wire. For example, the\n+   * name \"x-vcap-request-id\" would be set as-is including the prefix.\n+   *\n+   * @param name will be lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static BaggageField create(String name) {\n+    return new Builder(name).build();\n+  }\n+\n+  /**\n+   * Creates a builder for the specified {@linkplain #name()}.\n+   *\n+   * @param name will be lower-cased for remote propagation\n+   * @since 5.11\n+   */\n+  public static Builder newBuilder(String name) {\n+    return new Builder(name);\n+  }\n+\n+  public Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /** Gets any fields in the in given trace context. */\n+  public static List<BaggageField> getAll(TraceContext context) {\n+    PredefinedBaggageFields fields = context.findExtra(PredefinedBaggageFields.class);\n+    if (fields == null) return Collections.emptyList();\n+    return Collections.unmodifiableList(asList(fields.fields));\n+  }\n+\n+  /**\n+   * Like {@link #getAll()} except against the current trace context.\n+   *\n+   * <p>Prefer {@link #getAll()} if you have a reference to the trace context.\n+   */\n+  @Nullable public static List<BaggageField> getAll() {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getAll(context) : Collections.emptyList();\n+  }\n+\n+  /** Looks up the field by {@linkplain #name()} when you do not have a reference to it. */\n+  @Nullable public static BaggageField getByName(TraceContext context, String name) {\n+    if (name == null) throw new NullPointerException(\"name == null\");\n+    PredefinedBaggageFields fields = context.findExtra(PredefinedBaggageFields.class);\n+    if (fields == null) return null;\n+    for (BaggageField field : fields.fields) {\n+      if (name.equals(field.name())) {\n+        return field;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Like {@link #getByName(TraceContext, String)} except against the current trace context.\n+   *\n+   * <p>Prefer {@link #getByName(TraceContext, String)} if you have a reference to the trace\n+   * context.\n+   */\n+  @Nullable public static BaggageField getByName(String name) {\n+    TraceContext context = currentTraceContext();\n+    return context != null ? getByName(context, name) : null;\n+  }\n+\n+  /** @since 5.11 */\n+  public static class Builder {\n+    final String name;\n+    final Set<String> remoteNames = new LinkedHashSet<>();\n+    boolean local = false, flushOnUpdate = false;\n+\n+    Builder(String name) {\n+      this.name = validateName(name);\n+      remoteNames.add(this.name.toLowerCase(Locale.ROOT));\n+    }\n+\n+    Builder(Builder builder) {\n+      this.name = builder.name;\n+      this.remoteNames.addAll(builder.remoteNames);\n+      this.local = builder.local;\n+      this.flushOnUpdate = builder.flushOnUpdate;\n+    }\n+\n+    Builder(BaggageField baggageField) {\n+      this.name = baggageField.name;\n+      this.remoteNames.addAll(asList(baggageField.remoteNames));\n+      this.local = baggageField.local;\n+    }\n+\n+    /**\n+     * Invoke this to clear propagated names of this field. You can add alternatives later with\n+     * {@link #addRemoteName(String)}. <p>The default propagated name is the lowercase variant of\n+     * the field name.\n+     *\n+     * <p>One use case is prefixing. You may wish to not propagate the plain name of this field,\n+     * rather only a prefixed name in hyphen case. For example, the following would make the field\n+     * named \"userId\" propagated only as \"baggage-user-id\".\n+     *\n+     * <pre>{@code\n+     * USER_ID = BaggageField.newBuilder(\"userId\")\n+     *                       .clearRemoteNames()\n+     *                       .addRemoteName(\"baggage-user-id\").build();\n+     * }</pre>\n+     *\n+     * @since 5.11\n+     */\n+    public Builder clearRemoteNames() {\n+      remoteNames.clear();\n+      return this;\n+    }\n+\n+    /**\n+     * Adds a {@linkplain #remoteNames() remote name} (header).\n+     *\n+     * <p>Note: remote names are implicitly lower-cased.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder addRemoteName(String remoteName) {\n+      remoteNames.add(validateName(remoteName).toLowerCase(Locale.ROOT));\n+      return this;\n+    }\n+\n+    /**\n+     * Restricts to local (in-process) propagation only. This is mostly useful when also configuring\n+     * {@link CorrelationScopeDecorator}.\n+     *\n+     * @since 5.11\n+     */\n+    public Builder local() {", "originalCommit": "f26b1f2e804249834f89c00df9d209fba806d290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc2OTQyOA==", "url": "https://github.com/openzipkin/brave/pull/1130#discussion_r400769428", "bodyText": "yep sounds good!", "author": "codefromthecrypt", "createdAt": "2020-03-31T09:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0OTM1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/BaggageField.java b/brave/src/main/java/brave/propagation/BaggageField.java\nindex 1b8ec4d22..9eb35ae85 100644\n--- a/brave/src/main/java/brave/propagation/BaggageField.java\n+++ b/brave/src/main/java/brave/propagation/BaggageField.java\n", "chunk": "@@ -216,17 +233,6 @@ public final class BaggageField extends CorrelationField.Updatable {\n       return this;\n     }\n \n-    /**\n-     * Restricts to local (in-process) propagation only. This is mostly useful when also configuring\n-     * {@link CorrelationScopeDecorator}.\n-     *\n-     * @since 5.11\n-     */\n-    public Builder local() {\n-      this.local = true;\n-      return this;\n-    }\n-\n     /**\n      * @see CorrelationField.Updatable#flushOnUpdate()\n      * @since 5.11\n", "next_change": {"commit": "2079169132145921644ad7d5c7a95682c5d514a0", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/BaggageField.java b/brave/src/main/java/brave/propagation/BaggageField.java\nindex 9eb35ae85..32784519b 100644\n--- a/brave/src/main/java/brave/propagation/BaggageField.java\n+++ b/brave/src/main/java/brave/propagation/BaggageField.java\n", "chunk": "@@ -234,7 +253,16 @@ public final class BaggageField extends CorrelationField.Updatable {\n     }\n \n     /**\n-     * @see CorrelationField.Updatable#flushOnUpdate()\n+     * @see BaggageField#readOnly()\n+     * @since 5.11\n+     */\n+    public Builder readOnly() {\n+      this.readOnly = true;\n+      return this;\n+    }\n+\n+    /**\n+     * @see BaggageField#flushOnUpdate()\n      * @since 5.11\n      */\n     public Builder flushOnUpdate() {\n", "next_change": {"commit": "a042fe16ff30c94988396e85637471dfa9719845", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/propagation/BaggageField.java b/brave/src/main/java/brave/baggage/BaggageField.java\nsimilarity index 69%\nrename from brave/src/main/java/brave/propagation/BaggageField.java\nrename to brave/src/main/java/brave/baggage/BaggageField.java\nindex 32784519b..8932f6698 100644\n--- a/brave/src/main/java/brave/propagation/BaggageField.java\n+++ b/brave/src/main/java/brave/baggage/BaggageField.java\n", "chunk": "@@ -253,16 +244,30 @@ public final class BaggageField {\n     }\n \n     /**\n-     * @see BaggageField#readOnly()\n-     * @since 5.11\n-     */\n-    public Builder readOnly() {\n-      this.readOnly = true;\n-      return this;\n-    }\n-\n-    /**\n-     * @see BaggageField#flushOnUpdate()\n+     * When true, updates made via {@linkplain #updateValue(TraceContext, String)} flush immediately\n+     * to the correlation context.\n+     *\n+     * <p>This is useful for callbacks that have a void return. Ex.\n+     * <pre>{@code\n+     * @SendTo(SourceChannels.OUTPUT)\n+     * public void timerMessageSource() {\n+     *   // Assume BUSINESS_PROCESS is an updatable field\n+     *   BUSINESS_PROCESS.updateValue(\"accounting\");\n+     *   // Assuming a Log4j context, the expression %{bp} will show \"accounting\" in businessCode()\n+     *   businessCode();\n+     * }\n+     * }</pre>\n+     *\n+     * <h3>Appropriate Usage</h3>\n+     * This has a significant performance impact as it requires even {@link\n+     * CurrentTraceContext#maybeScope(TraceContext)} to always track values.\n+     *\n+     * <p>Most fields do not change in the scope of a {@link TraceContext}. For example, standard\n+     * fields such as {@link BaggageFields#SPAN_ID the span ID} and {@linkplain\n+     * BaggageFields#constant(String, String) constants} such as env variables do not need to be\n+     * tracked. Even field value updates do not necessarily need to be flushed to the underlying\n+     * correlation context, as they will apply on the next scope operation.\n+     *\n      * @since 5.11\n      */\n     public Builder flushOnUpdate() {\n", "next_change": null}]}}]}}]}}, {"oid": "261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "url": "https://github.com/openzipkin/brave/commit/261c8bb7413b7ccbe689f46d5d75e6598e7d5827", "message": "Exposes CorrelationField and Baggage Apis", "committedDate": "2020-04-01T05:42:13Z", "type": "forcePushed"}, {"oid": "b70fe2ba9a617214b6431b49cc0d546c3fcf7a51", "url": "https://github.com/openzipkin/brave/commit/b70fe2ba9a617214b6431b49cc0d546c3fcf7a51", "message": "Exposes CorrelationField and Baggage Apis", "committedDate": "2020-04-01T05:45:04Z", "type": "forcePushed"}, {"oid": "f9410a443424c9a12db7b02196c2119ff6a05ee1", "url": "https://github.com/openzipkin/brave/commit/f9410a443424c9a12db7b02196c2119ff6a05ee1", "message": "addRemoteName", "committedDate": "2020-04-01T07:26:56Z", "type": "forcePushed"}, {"oid": "902eea9fe62f2a20be6a73ba005991ef400bf872", "url": "https://github.com/openzipkin/brave/commit/902eea9fe62f2a20be6a73ba005991ef400bf872", "message": "Exposes CorrelationField and Baggage Apis", "committedDate": "2020-04-02T02:56:25Z", "type": "commit"}, {"oid": "b36285a0a04b41e7876040e048a53c975a8f5a1d", "url": "https://github.com/openzipkin/brave/commit/b36285a0a04b41e7876040e048a53c975a8f5a1d", "message": "addRemoteName", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "50595d41ad5c5f2c458b179cac173a811a6e983c", "url": "https://github.com/openzipkin/brave/commit/50595d41ad5c5f2c458b179cac173a811a6e983c", "message": "fix spring tests", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "587b2a9179e0edb6c48d97c761ff2c288da0f4d0", "url": "https://github.com/openzipkin/brave/commit/587b2a9179e0edb6c48d97c761ff2c288da0f4d0", "message": "Don't yet support folding fields", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "4938e53719af19498e9e254d797f131c3db43a60", "url": "https://github.com/openzipkin/brave/commit/4938e53719af19498e9e254d797f131c3db43a60", "message": "organization", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "5191a21b466e9503b9f79b924fe2ecdbddeac918", "url": "https://github.com/openzipkin/brave/commit/5191a21b466e9503b9f79b924fe2ecdbddeac918", "message": "removes misalignment possibility", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "da9738c589d721b4d8d0f21c1e49e1f9476fae69", "url": "https://github.com/openzipkin/brave/commit/da9738c589d721b4d8d0f21c1e49e1f9476fae69", "message": "moves rationale", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "2079169132145921644ad7d5c7a95682c5d514a0", "url": "https://github.com/openzipkin/brave/commit/2079169132145921644ad7d5c7a95682c5d514a0", "message": "Collapsed to BaggageField", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "55dc29a3e85a3c9849341133dbf3026a8dab8aa3", "url": "https://github.com/openzipkin/brave/commit/55dc29a3e85a3c9849341133dbf3026a8dab8aa3", "message": "100% coverage on BaggageField", "committedDate": "2020-04-02T02:56:26Z", "type": "commit"}, {"oid": "a042fe16ff30c94988396e85637471dfa9719845", "url": "https://github.com/openzipkin/brave/commit/a042fe16ff30c94988396e85637471dfa9719845", "message": "Moves to baggage package and refactors out read-only flag", "committedDate": "2020-04-02T02:56:56Z", "type": "forcePushed"}, {"oid": "a042fe16ff30c94988396e85637471dfa9719845", "url": "https://github.com/openzipkin/brave/commit/a042fe16ff30c94988396e85637471dfa9719845", "message": "Moves to baggage package and refactors out read-only flag", "committedDate": "2020-04-02T02:56:56Z", "type": "commit"}, {"oid": "016837e22164c69eb416b1c29fbd59e962634024", "url": "https://github.com/openzipkin/brave/commit/016837e22164c69eb416b1c29fbd59e962634024", "message": "Moves remote propagation concerns to BaggagePropagation", "committedDate": "2020-04-02T05:37:52Z", "type": "commit"}, {"oid": "59558faa081f4d5494509a814b81965444341825", "url": "https://github.com/openzipkin/brave/commit/59558faa081f4d5494509a814b81965444341825", "message": "drift", "committedDate": "2020-04-02T05:59:50Z", "type": "commit"}, {"oid": "bfc66a890876d4f4856e50d1e26482b50a3ee467", "url": "https://github.com/openzipkin/brave/commit/bfc66a890876d4f4856e50d1e26482b50a3ee467", "message": "opentracing and deprecated factory", "committedDate": "2020-04-02T06:37:20Z", "type": "commit"}, {"oid": "d077d1d08c2ca766bcc6252c208a329fabd94cb5", "url": "https://github.com/openzipkin/brave/commit/d077d1d08c2ca766bcc6252c208a329fabd94cb5", "message": "lenient on null tracecontext and backfill tests", "committedDate": "2020-04-02T08:38:35Z", "type": "commit"}, {"oid": "628f0a95015688e92b359773c7988b6ed6a615ba", "url": "https://github.com/openzipkin/brave/commit/628f0a95015688e92b359773c7988b6ed6a615ba", "message": "missing file", "committedDate": "2020-04-02T08:38:53Z", "type": "commit"}]}