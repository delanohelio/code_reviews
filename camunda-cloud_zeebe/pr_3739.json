{"pr_number": 3739, "pr_title": "chore(broker): distribute broker version in topology", "pr_author": "MiguelPires", "pr_createdAt": "2020-01-27T13:58:18Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/3739", "timeline": [{"oid": "14388190ad289364d9cc48b879ef43772617ed28", "url": "https://github.com/camunda-cloud/zeebe/commit/14388190ad289364d9cc48b879ef43772617ed28", "message": "chore(broker): distribute broker version in topology", "committedDate": "2020-01-27T14:26:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc1NTA0MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371755040", "body": "Hm, feels strange to have side effects of putting things in other objects as part of the compute if absent, no? Seems a little unexpected.", "bodyText": "Hm, feels strange to have side effects of putting things in other objects as part of the compute if absent, no? Seems a little unexpected.", "bodyHTML": "<p dir=\"auto\">Hm, feels strange to have side effects of putting things in other objects as part of the compute if absent, no? Seems a little unexpected.</p>", "author": "npepinpe", "createdAt": "2020-01-28T11:46:30Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/cluster/BrokerClusterStateImpl.java", "diffHunk": "@@ -76,20 +79,26 @@ public void addPartitionIfAbsent(final int partitionId) {\n   }\n \n   public void addBrokerIfAbsent(final int nodeId) {\n-    if (brokerAddresses.get(nodeId) == null) {\n-      brokerAddresses.put(nodeId, \"\");\n-      brokers.addInt(nodeId);\n-    }\n+    brokerAddresses.computeIfAbsent(", "originalCommit": "14388190ad289364d9cc48b879ef43772617ed28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwMjcyNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371802727", "bodyText": "I get what you mean. It doesn't bother me too much, but maybe it's because I'm the one who did it. I'll revert it", "author": "MiguelPires", "createdAt": "2020-01-28T13:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc1NTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc5MDg2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371790868", "body": "I think with `bodyDecoder.wrapVersion()` we don't need to keep track of the offset. The whole method can be replaced by:\r\n\r\n```java\r\n@Override\r\n  public void wrap(final DirectBuffer buffer, int offset, final int length) {\r\n    reset();\r\n\r\n    final int frameEnd = offset + length;\r\n\r\n    headerDecoder.wrap(buffer, offset);\r\n    bodyDecoder.wrap(\r\n        buffer,\r\n        offset + headerDecoder.encodedLength(),\r\n        headerDecoder.blockLength(),\r\n        headerDecoder.version());\r\n\r\n    nodeId = bodyDecoder.nodeId();\r\n    partitionsCount = bodyDecoder.partitionsCount();\r\n    clusterSize = bodyDecoder.clusterSize();\r\n    replicationFactor = bodyDecoder.replicationFactor();\r\n\r\n    final AddressesDecoder addressesDecoder = bodyDecoder.addresses();\r\n    while (addressesDecoder.hasNext()) {\r\n      addressesDecoder.next();\r\n      final int apiNameLength = addressesDecoder.apiNameLength();\r\n      final byte[] apiNameBytes = new byte[apiNameLength];\r\n      addressesDecoder.getApiName(apiNameBytes, 0, apiNameLength);\r\n\r\n      final int addressLength = addressesDecoder.addressLength();\r\n      final byte[] addressBytes = new byte[addressLength];\r\n      addressesDecoder.getAddress(addressBytes, 0, addressLength);\r\n\r\n      this.addAddress(new UnsafeBuffer(apiNameBytes), new UnsafeBuffer(addressBytes));\r\n    }\r\n\r\n    final PartitionRolesDecoder partitionRolesDecoder = bodyDecoder.partitionRoles();\r\n    while (partitionRolesDecoder.hasNext()) {\r\n      partitionRolesDecoder.next();\r\n      this.addPartitionRole(partitionRolesDecoder.partitionId(), partitionRolesDecoder.role());\r\n    }\r\n\r\n    final PartitionLeaderTermsDecoder partitionLeaderTermsDecoder =\r\n        bodyDecoder.partitionLeaderTerms();\r\n    while (partitionLeaderTermsDecoder.hasNext()) {\r\n      partitionLeaderTermsDecoder.next();\r\n      this.partitionLeaderTerms.put(\r\n          partitionLeaderTermsDecoder.partitionId(), partitionLeaderTermsDecoder.term());\r\n    }\r\n\r\n    if (bodyDecoder.versionLength() > 0) {\r\n      bodyDecoder.wrapVersion(version);\r\n    } else {\r\n      bodyDecoder.skipVersion();\r\n    }\r\n\r\n    assert bodyDecoder.limit() == frameEnd\r\n        : \"Decoder read only to position \"\r\n            + bodyDecoder.limit()\r\n            + \" but expected \"\r\n            + frameEnd\r\n            + \" as final position\";\r\n  }\r\n```", "bodyText": "I think with bodyDecoder.wrapVersion() we don't need to keep track of the offset. The whole method can be replaced by:\n@Override\n  public void wrap(final DirectBuffer buffer, int offset, final int length) {\n    reset();\n\n    final int frameEnd = offset + length;\n\n    headerDecoder.wrap(buffer, offset);\n    bodyDecoder.wrap(\n        buffer,\n        offset + headerDecoder.encodedLength(),\n        headerDecoder.blockLength(),\n        headerDecoder.version());\n\n    nodeId = bodyDecoder.nodeId();\n    partitionsCount = bodyDecoder.partitionsCount();\n    clusterSize = bodyDecoder.clusterSize();\n    replicationFactor = bodyDecoder.replicationFactor();\n\n    final AddressesDecoder addressesDecoder = bodyDecoder.addresses();\n    while (addressesDecoder.hasNext()) {\n      addressesDecoder.next();\n      final int apiNameLength = addressesDecoder.apiNameLength();\n      final byte[] apiNameBytes = new byte[apiNameLength];\n      addressesDecoder.getApiName(apiNameBytes, 0, apiNameLength);\n\n      final int addressLength = addressesDecoder.addressLength();\n      final byte[] addressBytes = new byte[addressLength];\n      addressesDecoder.getAddress(addressBytes, 0, addressLength);\n\n      this.addAddress(new UnsafeBuffer(apiNameBytes), new UnsafeBuffer(addressBytes));\n    }\n\n    final PartitionRolesDecoder partitionRolesDecoder = bodyDecoder.partitionRoles();\n    while (partitionRolesDecoder.hasNext()) {\n      partitionRolesDecoder.next();\n      this.addPartitionRole(partitionRolesDecoder.partitionId(), partitionRolesDecoder.role());\n    }\n\n    final PartitionLeaderTermsDecoder partitionLeaderTermsDecoder =\n        bodyDecoder.partitionLeaderTerms();\n    while (partitionLeaderTermsDecoder.hasNext()) {\n      partitionLeaderTermsDecoder.next();\n      this.partitionLeaderTerms.put(\n          partitionLeaderTermsDecoder.partitionId(), partitionLeaderTermsDecoder.term());\n    }\n\n    if (bodyDecoder.versionLength() > 0) {\n      bodyDecoder.wrapVersion(version);\n    } else {\n      bodyDecoder.skipVersion();\n    }\n\n    assert bodyDecoder.limit() == frameEnd\n        : \"Decoder read only to position \"\n            + bodyDecoder.limit()\n            + \" but expected \"\n            + frameEnd\n            + \" as final position\";\n  }", "bodyHTML": "<p dir=\"auto\">I think with <code>bodyDecoder.wrapVersion()</code> we don't need to keep track of the offset. The whole method can be replaced by:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"@Override\n  public void wrap(final DirectBuffer buffer, int offset, final int length) {\n    reset();\n\n    final int frameEnd = offset + length;\n\n    headerDecoder.wrap(buffer, offset);\n    bodyDecoder.wrap(\n        buffer,\n        offset + headerDecoder.encodedLength(),\n        headerDecoder.blockLength(),\n        headerDecoder.version());\n\n    nodeId = bodyDecoder.nodeId();\n    partitionsCount = bodyDecoder.partitionsCount();\n    clusterSize = bodyDecoder.clusterSize();\n    replicationFactor = bodyDecoder.replicationFactor();\n\n    final AddressesDecoder addressesDecoder = bodyDecoder.addresses();\n    while (addressesDecoder.hasNext()) {\n      addressesDecoder.next();\n      final int apiNameLength = addressesDecoder.apiNameLength();\n      final byte[] apiNameBytes = new byte[apiNameLength];\n      addressesDecoder.getApiName(apiNameBytes, 0, apiNameLength);\n\n      final int addressLength = addressesDecoder.addressLength();\n      final byte[] addressBytes = new byte[addressLength];\n      addressesDecoder.getAddress(addressBytes, 0, addressLength);\n\n      this.addAddress(new UnsafeBuffer(apiNameBytes), new UnsafeBuffer(addressBytes));\n    }\n\n    final PartitionRolesDecoder partitionRolesDecoder = bodyDecoder.partitionRoles();\n    while (partitionRolesDecoder.hasNext()) {\n      partitionRolesDecoder.next();\n      this.addPartitionRole(partitionRolesDecoder.partitionId(), partitionRolesDecoder.role());\n    }\n\n    final PartitionLeaderTermsDecoder partitionLeaderTermsDecoder =\n        bodyDecoder.partitionLeaderTerms();\n    while (partitionLeaderTermsDecoder.hasNext()) {\n      partitionLeaderTermsDecoder.next();\n      this.partitionLeaderTerms.put(\n          partitionLeaderTermsDecoder.partitionId(), partitionLeaderTermsDecoder.term());\n    }\n\n    if (bodyDecoder.versionLength() &gt; 0) {\n      bodyDecoder.wrapVersion(version);\n    } else {\n      bodyDecoder.skipVersion();\n    }\n\n    assert bodyDecoder.limit() == frameEnd\n        : &quot;Decoder read only to position &quot;\n            + bodyDecoder.limit()\n            + &quot; but expected &quot;\n            + frameEnd\n            + &quot; as final position&quot;;\n  }\"><pre><span class=\"pl-k\">@Override</span>\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> wrap(<span class=\"pl-k\">final</span> <span class=\"pl-smi\">DirectBuffer</span> buffer, <span class=\"pl-k\">int</span> offset, <span class=\"pl-k\">final</span> <span class=\"pl-k\">int</span> length) {\n    reset();\n\n    <span class=\"pl-k\">final</span> <span class=\"pl-k\">int</span> frameEnd <span class=\"pl-k\">=</span> offset <span class=\"pl-k\">+</span> length;\n\n    headerDecoder<span class=\"pl-k\">.</span>wrap(buffer, offset);\n    bodyDecoder<span class=\"pl-k\">.</span>wrap(\n        buffer,\n        offset <span class=\"pl-k\">+</span> headerDecoder<span class=\"pl-k\">.</span>encodedLength(),\n        headerDecoder<span class=\"pl-k\">.</span>blockLength(),\n        headerDecoder<span class=\"pl-k\">.</span>version());\n\n    nodeId <span class=\"pl-k\">=</span> bodyDecoder<span class=\"pl-k\">.</span>nodeId();\n    partitionsCount <span class=\"pl-k\">=</span> bodyDecoder<span class=\"pl-k\">.</span>partitionsCount();\n    clusterSize <span class=\"pl-k\">=</span> bodyDecoder<span class=\"pl-k\">.</span>clusterSize();\n    replicationFactor <span class=\"pl-k\">=</span> bodyDecoder<span class=\"pl-k\">.</span>replicationFactor();\n\n    <span class=\"pl-k\">final</span> <span class=\"pl-smi\">AddressesDecoder</span> addressesDecoder <span class=\"pl-k\">=</span> bodyDecoder<span class=\"pl-k\">.</span>addresses();\n    <span class=\"pl-k\">while</span> (addressesDecoder<span class=\"pl-k\">.</span>hasNext()) {\n      addressesDecoder<span class=\"pl-k\">.</span>next();\n      <span class=\"pl-k\">final</span> <span class=\"pl-k\">int</span> apiNameLength <span class=\"pl-k\">=</span> addressesDecoder<span class=\"pl-k\">.</span>apiNameLength();\n      <span class=\"pl-k\">final</span> <span class=\"pl-k\">byte</span>[] apiNameBytes <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">byte</span>[apiNameLength];\n      addressesDecoder<span class=\"pl-k\">.</span>getApiName(apiNameBytes, <span class=\"pl-c1\">0</span>, apiNameLength);\n\n      <span class=\"pl-k\">final</span> <span class=\"pl-k\">int</span> addressLength <span class=\"pl-k\">=</span> addressesDecoder<span class=\"pl-k\">.</span>addressLength();\n      <span class=\"pl-k\">final</span> <span class=\"pl-k\">byte</span>[] addressBytes <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">byte</span>[addressLength];\n      addressesDecoder<span class=\"pl-k\">.</span>getAddress(addressBytes, <span class=\"pl-c1\">0</span>, addressLength);\n\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>addAddress(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">UnsafeBuffer</span>(apiNameBytes), <span class=\"pl-k\">new</span> <span class=\"pl-smi\">UnsafeBuffer</span>(addressBytes));\n    }\n\n    <span class=\"pl-k\">final</span> <span class=\"pl-smi\">PartitionRolesDecoder</span> partitionRolesDecoder <span class=\"pl-k\">=</span> bodyDecoder<span class=\"pl-k\">.</span>partitionRoles();\n    <span class=\"pl-k\">while</span> (partitionRolesDecoder<span class=\"pl-k\">.</span>hasNext()) {\n      partitionRolesDecoder<span class=\"pl-k\">.</span>next();\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>addPartitionRole(partitionRolesDecoder<span class=\"pl-k\">.</span>partitionId(), partitionRolesDecoder<span class=\"pl-k\">.</span>role());\n    }\n\n    <span class=\"pl-k\">final</span> <span class=\"pl-smi\">PartitionLeaderTermsDecoder</span> partitionLeaderTermsDecoder <span class=\"pl-k\">=</span>\n        bodyDecoder<span class=\"pl-k\">.</span>partitionLeaderTerms();\n    <span class=\"pl-k\">while</span> (partitionLeaderTermsDecoder<span class=\"pl-k\">.</span>hasNext()) {\n      partitionLeaderTermsDecoder<span class=\"pl-k\">.</span>next();\n      <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>partitionLeaderTerms<span class=\"pl-k\">.</span>put(\n          partitionLeaderTermsDecoder<span class=\"pl-k\">.</span>partitionId(), partitionLeaderTermsDecoder<span class=\"pl-k\">.</span>term());\n    }\n\n    <span class=\"pl-k\">if</span> (bodyDecoder<span class=\"pl-k\">.</span>versionLength() <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>) {\n      bodyDecoder<span class=\"pl-k\">.</span>wrapVersion(version);\n    } <span class=\"pl-k\">else</span> {\n      bodyDecoder<span class=\"pl-k\">.</span>skipVersion();\n    }\n\n    <span class=\"pl-k\">assert</span> bodyDecoder<span class=\"pl-k\">.</span>limit() <span class=\"pl-k\">==</span> frameEnd\n        <span class=\"pl-k\">:</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Decoder read only to position <span class=\"pl-pds\">\"</span></span>\n            <span class=\"pl-k\">+</span> bodyDecoder<span class=\"pl-k\">.</span>limit()\n            <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> but expected <span class=\"pl-pds\">\"</span></span>\n            <span class=\"pl-k\">+</span> frameEnd\n            <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> as final position<span class=\"pl-pds\">\"</span></span>;\n  }</pre></div>", "author": "npepinpe", "createdAt": "2020-01-28T13:08:50Z", "path": "protocol-impl/src/main/java/io/zeebe/protocol/impl/encoding/BrokerInfo.java", "diffHunk": "@@ -209,22 +227,40 @@ public void wrap(final DirectBuffer buffer, int offset, final int length) {\n       addressesDecoder.getAddress(addressBytes, 0, addressLength);\n \n       this.addAddress(new UnsafeBuffer(apiNameBytes), new UnsafeBuffer(addressBytes));\n+      offset +=\n+          AddressesDecoder.apiNameHeaderLength()\n+              + apiNameLength\n+              + AddressesDecoder.addressHeaderLength()\n+              + addressLength;\n     }\n \n+    offset += PartitionRolesDecoder.sbeHeaderSize();\n     final PartitionRolesDecoder partitionRolesDecoder = bodyDecoder.partitionRoles();\n     while (partitionRolesDecoder.hasNext()) {\n       partitionRolesDecoder.next();\n       this.addPartitionRole(partitionRolesDecoder.partitionId(), partitionRolesDecoder.role());\n+      offset += 4 + 1;\n     }\n \n+    offset += PartitionLeaderTermsDecoder.sbeHeaderSize();\n     final PartitionLeaderTermsDecoder partitionLeaderTermsDecoder =\n         bodyDecoder.partitionLeaderTerms();\n     while (partitionLeaderTermsDecoder.hasNext()) {\n       partitionLeaderTermsDecoder.next();\n       this.partitionLeaderTerms.put(\n           partitionLeaderTermsDecoder.partitionId(), partitionLeaderTermsDecoder.term());\n+      offset += 4 + 8;\n     }\n \n+    final int versionLength = bodyDecoder.versionLength();", "originalCommit": "14388190ad289364d9cc48b879ef43772617ed28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwNjE2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371806165", "body": "Missing `brokerVersions.put(nodeId, \"\")`?", "bodyText": "Missing brokerVersions.put(nodeId, \"\")?", "bodyHTML": "<p dir=\"auto\">Missing <code>brokerVersions.put(nodeId, \"\")</code>?</p>", "author": "npepinpe", "createdAt": "2020-01-28T13:39:10Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/cluster/BrokerClusterStateImpl.java", "diffHunk": "@@ -79,13 +79,10 @@ public void addPartitionIfAbsent(final int partitionId) {\n   }\n \n   public void addBrokerIfAbsent(final int nodeId) {\n-    brokerAddresses.computeIfAbsent(\n-        nodeId,\n-        k -> {\n-          brokerVersions.put(nodeId, \"\");\n-          brokers.addInt(nodeId);\n-          return \"\";\n-        });\n+    if (brokerAddresses.get(nodeId) == null) {\n+      brokerAddresses.put(nodeId, \"\");\n+      brokers.addInt(nodeId);", "originalCommit": "4f20325d48eddce5493013b861d281059bfe8d7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwODc5OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371808798", "bodyText": "Yup, missed it when rolling back. Thanks", "author": "MiguelPires", "createdAt": "2020-01-28T13:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwNjE2NQ=="}], "type": "inlineReview"}, {"oid": "ceeea9bdadff934000365d539e8350147f8dd453", "url": "https://github.com/camunda-cloud/zeebe/commit/ceeea9bdadff934000365d539e8350147f8dd453", "message": "chore(broker): distribute broker version in topology", "committedDate": "2020-01-28T13:44:28Z", "type": "commit"}, {"oid": "ceeea9bdadff934000365d539e8350147f8dd453", "url": "https://github.com/camunda-cloud/zeebe/commit/ceeea9bdadff934000365d539e8350147f8dd453", "message": "chore(broker): distribute broker version in topology", "committedDate": "2020-01-28T13:44:28Z", "type": "forcePushed"}]}