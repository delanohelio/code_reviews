{"pr_number": 6233, "pr_title": "clean code of the undo button", "pr_author": "Arthur-Milchior", "pr_createdAt": "2020-05-20T20:26:15Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6233", "merge_commit": "052b1c1a12e688f336d73647b68e27194ef049d3", "timeline": [{"oid": "79b76ab0457d27a62a9354216c2656f23152b751", "url": "https://github.com/ankidroid/Anki-Android/commit/79b76ab0457d27a62a9354216c2656f23152b751", "message": "NF: comments undo button", "committedDate": "2020-05-20T22:18:43Z", "type": "commit"}, {"oid": "14c9f6af08f3c6fc9b814c5be8636613b5a21496", "url": "https://github.com/ankidroid/Anki-Android/commit/14c9f6af08f3c6fc9b814c5be8636613b5a21496", "message": "Disable undo if slow block", "committedDate": "2020-05-20T22:22:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTM1NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429151354", "body": "Nit: could we use AOSP naming (`m` Prefix), and move these variables to the top of the class?\r\n\r\nAside: I don't like Hungarian Notation, but it's best to be consistent.", "bodyText": "Nit: could we use AOSP naming (m Prefix), and move these variables to the top of the class?\nAside: I don't like Hungarian Notation, but it's best to be consistent.", "bodyHTML": "<p dir=\"auto\">Nit: could we use AOSP naming (<code>m</code> Prefix), and move these variables to the top of the class?</p>\n<p dir=\"auto\">Aside: I don't like Hungarian Notation, but it's best to be consistent.</p>", "author": "david-allison-1", "createdAt": "2020-05-22T09:48:53Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java", "diffHunk": "@@ -431,21 +431,29 @@ public boolean onCreateOptionsMenu(Menu menu) {\n             }\n         }\n \n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n-            // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_eraser_variant_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-        } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_eraser_variant_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-        } else if (colIsOpen() && getCol().undoAvailable()) {\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_undo_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+        // Undo button\n+        int undoIcon;\n+        boolean undoEnabled;", "originalCommit": "14c9f6af08f3c6fc9b814c5be8636613b5a21496", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1NjQ2Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429156463", "bodyText": "Nit: Do these need to be members, or can these be function scoped?", "author": "david-allison-1", "createdAt": "2020-05-22T09:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwMTUwOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429401508", "bodyText": "\"these\" ? I don't know what you are referring to.\nI don't believe that there is any interest in having undoEnabled as a member of the class. It's quite easy right now to get this information from the undoEmpty and undoAvailable function. If we wanted to keep this information as a method, the code change would get bigger as it means we would need to ensure that this variable is changed each time the collection/whiteboard undo list is changed", "author": "Arthur-Milchior", "createdAt": "2020-05-22T18:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwMzA5Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429403092", "bodyText": "Are there other variables you want to move to the class level ?", "author": "Arthur-Milchior", "createdAt": "2020-05-22T18:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxMDY2Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429410662", "bodyText": "Disregard this, the spacing inside GitHub implied that these were member variables.", "author": "david-allison-1", "createdAt": "2020-05-22T19:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "500a421fd53021424407cb6fc519b47d2792521a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex dd3f78516..73df40156 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -432,7 +432,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         }\n \n         // Undo button\n-        int undoIcon;\n+        @DrawableRes int undoIcon;\n         boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard is here and strokes have been added at some point\n", "next_change": {"commit": "c432c854a77f728bdec36e23c06f69fc02cc276a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 73df40156..7ecfe317f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -433,20 +435,22 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n         // Undo button\n         @DrawableRes int undoIcon;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n+        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n+            // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n+            undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n+            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+        } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n+            // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n+            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+        } else if (colIsOpen() && getCol().undoAvailable()) {\n+            undoIcon = R.drawable.ic_undo_white_24dp;\n+            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n         } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n+            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n         }\n-        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n-        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n         // White board button\n         if (mPrefWhiteboard) {\n", "next_change": {"commit": "4df47eb1e552de1918c80651163b11efe103c10f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 7ecfe317f..403c14f13 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -435,22 +435,25 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n         // Undo button\n         @DrawableRes int undoIcon;\n+        boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n             // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+            undoEnabled = true;\n         } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+            undoEnabled = false;\n         } else if (colIsOpen() && getCol().undoAvailable()) {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+            undoEnabled = true;\n         } else {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+            undoEnabled = false;\n         }\n+        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n+        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n         // White board button\n         if (mPrefWhiteboard) {\n", "next_change": {"commit": "2ce9d1bd6d39e24167496c73981e94b9fa614699", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 403c14f13..74e6de472 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -444,12 +444,15 @@ public class Reviewer extends AbstractFlashcardViewer {\n             // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n             undoEnabled = false;\n-        } else if (colIsOpen() && getCol().undoAvailable()) {\n-            undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = true;\n         } else {\n+            // We can arrive here even if `mShowWhiteboard &&\n+            // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = false;\n+            if (colIsOpen() && getCol().undoAvailable()) {\n+                undoEnabled = true;\n+            } else {\n+                undoEnabled = false;\n+            }\n         }\n         int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n", "next_change": {"commit": "f741531f20a1adc0989ebc078c502802e18b10df", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 74e6de472..beaf2a147 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -448,11 +448,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n             // We can arrive here even if `mShowWhiteboard &&\n             // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            if (colIsOpen() && getCol().undoAvailable()) {\n-                undoEnabled = true;\n-            } else {\n-                undoEnabled = false;\n-            }\n+            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n         }\n         int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "052b1c1a12e688f336d73647b68e27194ef049d3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex dd3f78516..c0932f0db 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -432,7 +434,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         }\n \n         // Undo button\n-        int undoIcon;\n+        @DrawableRes int undoIcon;\n         boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard is here and strokes have been added at some point\n", "next_change": {"commit": "09931324c60760a157fc450e210981f664abb809", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex c0932f0db..e758da514 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -432,6 +532,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 break;\n             }\n         }\n+        menu.findItem(R.id.action_flag).getIcon().mutate().setAlpha(alpha);\n \n         // Undo button\n         @DrawableRes int undoIcon;\n", "next_change": {"commit": "5408ceaef7eef4db61b4064e5997099700913ed8", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex e758da514..ceddfae16 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -505,61 +505,67 @@ public class Reviewer extends AbstractFlashcardViewer {\n         // NOTE: This is called every time a new question is shown via invalidate options menu\n         getMenuInflater().inflate(R.menu.reviewer, menu);\n         mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n+        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n+        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n         if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            menu.findItem(R.id.action_mark_card).setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white_24dp);\n+            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white_24dp);\n         } else {\n-            menu.findItem(R.id.action_mark_card).setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_outline_white_24dp);\n+            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_outline_white_24dp);\n         }\n-        menu.findItem(R.id.action_mark_card).getIcon().mutate().setAlpha(alpha);\n+        markCardIcon.getIcon().mutate().setAlpha(alpha);\n \n+        MenuItem flag_icon = menu.findItem(R.id.action_flag);\n         if (mCurrentCard != null) {\n             switch (mCurrentCard.userFlag()) {\n             case 1:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_red);\n+                flag_icon.setIcon(R.drawable.ic_flag_red);\n                 break;\n             case 2:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_orange);\n+                flag_icon.setIcon(R.drawable.ic_flag_orange);\n                 break;\n             case 3:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_green);\n+                flag_icon.setIcon(R.drawable.ic_flag_green);\n                 break;\n             case 4:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_blue);\n+                flag_icon.setIcon(R.drawable.ic_flag_blue);\n                 break;\n             default:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_transparent);\n+                flag_icon.setIcon(R.drawable.ic_flag_transparent);\n                 break;\n             }\n         }\n-        menu.findItem(R.id.action_flag).getIcon().mutate().setAlpha(alpha);\n+        flag_icon.getIcon().mutate().setAlpha(alpha);\n \n         // Undo button\n-        @DrawableRes int undoIcon;\n+        @DrawableRes int undoIconId;\n         boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard is here and strokes have been added at some point\n-            undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n+            undoIconId = R.drawable.ic_eraser_variant_white_24dp;\n             undoEnabled = !mWhiteboard.undoEmpty();\n         } else {\n             // We can arrive here even if `mShowWhiteboard &&\n             // mWhiteboard != null` if no stroke had ever been made\n-            undoIcon = R.drawable.ic_undo_white_24dp;\n+            undoIconId = R.drawable.ic_undo_white_24dp;\n             undoEnabled = (colIsOpen() && getCol().undoAvailable());\n         }\n         int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        menu.findItem(R.id.action_undo).setIcon(undoIcon);\n-        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n+        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n+        undoIcon.setIcon(undoIconId);\n+        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n \n+        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n+        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n+        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n         // White board button\n         if (mPrefWhiteboard) {\n             // Configure the whiteboard related items in the action bar\n-            menu.findItem(R.id.action_toggle_whiteboard).setTitle(R.string.disable_whiteboard);\n+            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n             // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            menu.findItem(R.id.action_toggle_whiteboard).setVisible(true);\n+            toggle_whiteboard_icon.setVisible(true);\n \n             if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_hide_whiteboard).setVisible(true);\n+                hide_whiteboard_icon.setVisible(true);\n             }\n             if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex ceddfae16..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1017 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.app.Activity;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anim.ActivityTransitionAnimation;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.async.TaskListener;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Collection.DismissType;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anki.reviewer.CardMarker.FLAG_NONE;\n-import static com.ichi2.anki.cardviewer.ViewerCommand.COMMAND_NOTHING;\n-import static com.ichi2.async.CollectionTask.TASK_TYPE.*;\n-import com.ichi2.async.TaskData;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mBlackWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout colorPalette;\n-\n-    private ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    private TaskListener mRescheduleCardHandler = new ScheduleCollectionTaskListener() {\n-        protected int getToastResourceId() {\n-            return R.plurals.reschedule_cards_dialog_acknowledge;\n-        }\n-    };\n-\n-    private TaskListener mResetProgressCardHandler = new ScheduleCollectionTaskListener() {\n-        protected int getToastResourceId() {\n-            return R.plurals.reset_cards_dialog_acknowledge;\n-        }\n-    };\n-\n-    @VisibleForTesting\n-    protected PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-\n-    /** We need to listen for and handle reschedules / resets very similarly */\n-    abstract class ScheduleCollectionTaskListener extends NextCardHandler {\n-\n-        abstract protected int getToastResourceId();\n-\n-\n-        @Override\n-        public void onPostExecute(TaskData result) {\n-            super.onPostExecute(result);\n-            invalidateOptionsMenu();\n-            int cardCount = result.getObjArray().length;\n-            UIUtils.showThemedToast(Reviewer.this,\n-                    getResources().getQuantityString(getToastResourceId(), cardCount, cardCount), true);\n-        }\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(ActivityTransitionAnimation.RIGHT);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        colorPalette = (LinearLayout) findViewById(R.id.whiteboard_pen_color);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        long did = Long.MIN_VALUE;\n-        if (extras != null) {\n-            did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-        }\n-\n-        if(did == Long.MIN_VALUE) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(int fullscreenMode) {\n-        if (CompatHelper.getSdkVersion() < Build.VERSION_CODES.KITKAT) {\n-            fullscreenMode = 0;     // The specific fullscreen layouts are only applicable for immersive mode\n-        }\n-        switch (fullscreenMode) {\n-            case 1:\n-                return R.layout.reviewer_fullscreen;\n-            case 2:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        CollectionTask.launchCollectionTask(ANSWER_CARD, mAnswerCardHandler(false),\n-                new TaskData(null, 0));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<Activity>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            CompatHelper.getCompat().setFullScreen(this);\n-        }\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        switch (item.getItemId()) {\n-\n-            case android.R.id.home:\n-                Timber.i(\"Reviewer:: Home button pressed\");\n-                closeReviewer(RESULT_OK, true);\n-                break;\n-\n-            case R.id.action_undo:\n-                Timber.i(\"Reviewer:: Undo button pressed\");\n-                if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                    mWhiteboard.undo();\n-                } else {\n-                    undo();\n-                }\n-                break;\n-\n-            case R.id.action_reset_card_progress:\n-                Timber.i(\"Reviewer:: Reset progress button pressed\");\n-                showResetCardDialog();\n-                break;\n-\n-            case R.id.action_mark_card:\n-                Timber.i(\"Reviewer:: Mark button pressed\");\n-                onMark(mCurrentCard);\n-                break;\n-\n-            case R.id.action_replay:\n-                Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-                playSounds(true);\n-                break;\n-\n-            case R.id.action_toggle_mic_tool_bar:\n-                Timber.i(\"Reviewer:: Record mic\");\n-                // Check permission to record and request if not granted\n-                if (!Permissions.canRecordAudio(this)) {\n-                    ActivityCompat.requestPermissions(this, new String[]{android.Manifest.permission.RECORD_AUDIO},\n-                            REQUEST_AUDIO_PERMISSION);\n-                } else {\n-                    toggleMicToolBar();\n-                }\n-                break;\n-\n-            case R.id.action_tag:\n-                Timber.i(\"Reviewer:: Tag button pressed\");\n-                showTagsDialog();\n-                break;\n-\n-            case R.id.action_edit:\n-                Timber.i(\"Reviewer:: Edit note button pressed\");\n-                return editCard();\n-\n-            case R.id.action_bury:\n-                Timber.i(\"Reviewer:: Bury button pressed\");\n-                if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                    Timber.d(\"Bury card due to no submenu\");\n-                    dismiss(DismissType.BURY_CARD);\n-                }\n-                break;\n-\n-            case R.id.action_suspend:\n-                Timber.i(\"Reviewer:: Suspend button pressed\");\n-                if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                    Timber.d(\"Suspend card due to no submenu\");\n-                    dismiss(DismissType.SUSPEND_CARD);\n-                }\n-                break;\n-\n-            case R.id.action_delete:\n-                Timber.i(\"Reviewer:: Delete note button pressed\");\n-                showDeleteNoteDialog();\n-                break;\n-\n-            case R.id.action_change_whiteboard_pen_color:\n-                Timber.i(\"Reviewer:: Pen Color button pressed\");\n-                if (colorPalette.getVisibility() == View.GONE) {\n-                    colorPalette.setVisibility(View.VISIBLE);\n-                } else {\n-                    colorPalette.setVisibility(View.GONE);\n-                }\n-                break;\n-\n-            case R.id.action_save_whiteboard:\n-                Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-                if (mWhiteboard != null) {\n-                    try {\n-                        String savedWhiteboardFileName = mWhiteboard.saveWhiteboard();\n-                        UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                    } catch (Exception e) {\n-                        UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                    }\n-                }\n-                break;\n-\n-            case R.id.action_clear_whiteboard:\n-                Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-                if (mWhiteboard != null) {\n-                    mWhiteboard.clear();\n-                }\n-                break;\n-\n-            case R.id.action_hide_whiteboard:\n-                // toggle whiteboard visibility\n-                Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-                setWhiteboardVisibility(!mShowWhiteboard);\n-                refreshActionBar();\n-                break;\n-\n-            case R.id.action_toggle_whiteboard:\n-                toggleWhiteboard();\n-                break;\n-\n-            case R.id.action_search_dictionary:\n-                Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-                lookUpOrSelectText();\n-                break;\n-\n-            case R.id.action_open_deck_options:\n-                Intent i = new Intent(this, DeckOptions.class);\n-                startActivityForResultWithAnimation(i, DECK_OPTIONS, ActivityTransitionAnimation.FADE);\n-                break;\n-\n-            case R.id.action_select_tts:\n-                Timber.i(\"Reviewer:: Select TTS button pressed\");\n-                showSelectTtsDialogue();\n-                break;\n-\n-            case R.id.action_add_note_reviewer:\n-                Timber.i(\"Reviewer:: Add note button pressed\");\n-                addNote();\n-                break;\n-\n-            case R.id.action_flag_zero:\n-                Timber.i(\"Reviewer:: No flag\");\n-                onFlag(mCurrentCard, FLAG_NONE);\n-                break;\n-            case R.id.action_flag_one:\n-                Timber.i(\"Reviewer:: Flag one\");\n-                onFlag(mCurrentCard, FLAG_RED);\n-                break;\n-            case R.id.action_flag_two:\n-                Timber.i(\"Reviewer:: Flag two\");\n-                onFlag(mCurrentCard, FLAG_ORANGE);\n-                break;\n-            case R.id.action_flag_three:\n-                Timber.i(\"Reviewer:: Flag three\");\n-                onFlag(mCurrentCard, FLAG_GREEN);\n-                break;\n-            case R.id.action_flag_four:\n-                Timber.i(\"Reviewer:: Flag four\");\n-                onFlag(mCurrentCard, FLAG_BLUE);\n-                break;\n-            default:\n-                return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    protected void toggleWhiteboard() {\n-        // toggle whiteboard enabled state (and show/hide whiteboard item in action bar)\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            colorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.av_play, R.drawable.av_pause,\n-                        R.drawable.av_stop, R.drawable.av_rec, R.drawable.av_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult (int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        if ( (requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days ->\n-            CollectionTask.launchCollectionTask(DISMISS_MULTI, mRescheduleCardHandler,\n-                    new TaskData(new Object[]{new long[]{mCurrentCard.getId()},\n-                    Collection.DismissType.RESCHEDULE_CARDS, days})\n-            );\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            CollectionTask.launchCollectionTask(DISMISS_MULTI, mResetProgressCardHandler,\n-                    new TaskData(new Object[]{new long[]{mCurrentCard.getId()}, Collection.DismissType.RESET_CARDS}));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, ActivityTransitionAnimation.LEFT);\n-    }\n-\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white_24dp);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_outline_white_24dp);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (mCurrentCard != null) {\n-            switch (mCurrentCard.userFlag()) {\n-            case 1:\n-                flag_icon.setIcon(R.drawable.ic_flag_red);\n-                break;\n-            case 2:\n-                flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                break;\n-            case 3:\n-                flag_icon.setIcon(R.drawable.ic_flag_green);\n-                break;\n-            case 4:\n-                flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                break;\n-            default:\n-                flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                break;\n-            }\n-        }\n-        flag_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.ic_eraser_variant_white_24dp;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                colorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-        MenuItemCompat.setActionProvider(suspend_icon, new SuspendProvider(this));\n-        MenuItemCompat.setActionProvider(bury_icon, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24dp);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_schedule), new ScheduleProvider(this));\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        return mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event);\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyUp(keyCode, event);\n-        }\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        int buttonCount;\n-        try {\n-            buttonCount = mSched.answerButtons(mCurrentCard);\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        final int[] background = Themes.getResFromAttr(this, new int [] {\n-                R.attr.againButtonRef,\n-                R.attr.hardButtonRef,\n-                R.attr.goodButtonRef,\n-                R.attr.easyButtonRef});\n-        final int[] textColor = Themes.getColorFromAttr(this, new int [] {\n-                R.attr.againButtonTextColor,\n-                R.attr.hardButtonTextColor,\n-                R.attr.goodButtonTextColor,\n-                R.attr.easyButtonTextColor});\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        super.restorePreferences();\n-        this.mProcessor.setup();\n-        //Is this line necessary? Can we not use the return value from the call to super?\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-        mBlackWhiteboard = preferences.getBoolean(\"blackWhiteboard\", true);\n-        mPrefFullscreenReview = Integer.parseInt(preferences.getString(\"fullscreenMode\", \"0\")) > 0;\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    // Create the whiteboard\n-    private void createWhiteboard() {\n-        mWhiteboard = new Whiteboard(this, isInNightMode(), mBlackWhiteboard);\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-        mWhiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = findViewById(R.id.whiteboard);\n-        fl.addView(mWhiteboard);\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && CompatHelper.getCompat().isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-        mWhiteboard.setEnabled(true);\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-        boolean gesturesEnabled = AnkiDroidApp.initiateGestures(preferences);\n-        if (gesturesEnabled) {\n-            int gestureSwipeUp = Integer.parseInt(preferences.getString(\"gestureSwipeUp\", \"9\"));\n-            int gestureSwipeDown = Integer.parseInt(preferences.getString(\"gestureSwipeDown\", \"0\"));\n-            int gestureSwipeRight = Integer.parseInt(preferences.getString(\"gestureSwipeRight\", \"17\"));\n-            if (gestureSwipeUp != COMMAND_NOTHING ||\n-                    gestureSwipeDown != COMMAND_NOTHING ||\n-                    gestureSwipeRight != COMMAND_NOTHING) {\n-                mHasDrawerSwipeConflicts = true;\n-                super.disableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        boolean bury = getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-        return bury;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements MenuItem.OnMenuItemClickListener {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(R.menu.reviewer_suspend, subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            switch (item.getItemId()) {\n-                case R.id.action_suspend_card:\n-                    dismiss(DismissType.SUSPEND_CARD);\n-                    return true;\n-                case R.id.action_suspend_note:\n-                    dismiss(DismissType.SUSPEND_NOTE);\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements MenuItem.OnMenuItemClickListener {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(R.menu.reviewer_bury, subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            switch (item.getItemId()) {\n-                case R.id.action_bury_card:\n-                    dismiss(DismissType.BURY_CARD);\n-                    return true;\n-                case R.id.action_bury_note:\n-                    dismiss(DismissType.BURY_NOTE);\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements MenuItem.OnMenuItemClickListener {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(R.menu.reviewer_schedule, subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            switch (item.getItemId()) {\n-                case R.id.action_reschedule_card:\n-                    showRescheduleCardDialog();\n-                    return true;\n-                case R.id.action_reset_card_progress:\n-                    showResetCardDialog();\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "052b1c1a12e688f336d73647b68e27194ef049d3", "message": "Merge commit", "committedDate": null}, {"oid": "806410f0e13d01d55bac641c9bd606833f9ab067", "committedDate": "2020-05-24 17:51:17 -0500", "message": "Extract Peripheral Keymap"}, {"oid": "c529371b2b9431018f168536c054d67aaaceb60b", "committedDate": "2020-05-24 17:51:17 -0500", "message": "Peripheral Input Mappings: convert code to config"}, {"oid": "5aca79273b4df934e30cd59ae1a6418d0de13ac9", "committedDate": "2020-06-01 17:28:09 -0500", "message": "Whiteboard: Continue Drawing if UI is shown"}, {"oid": "8fa42c4683f6b01ac1f3805e014e324b0d06a5dc", "committedDate": "2020-06-03 10:52:56 -0500", "message": "Improve opening deck package from Firefox"}, {"oid": "44ea5d66c7ac3dcec765d7ca645a98e03bb2eee4", "committedDate": "2020-06-09 13:52:14 -0500", "message": "Add mic tool bar to reviewer"}, {"oid": "bd641a86a179f4a4f2431e110f2f74d732b2002d", "committedDate": "2020-06-11 11:30:22 -0500", "message": "Turn off undo during slow control block"}, {"oid": "b1135ff3cbd8d536a0175e7b9b156fdb88585e1b", "committedDate": "2020-06-12 23:28:18 -0500", "message": "Remove unused parameter in saveCollectionInBackground"}, {"oid": "ced164afe1e5e4cf758c2295fda18e4395527047", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Add \"Edit tags\" to review menu"}, {"oid": "41167c4b53cb9648bbd78a2dcb0ed32b3458ef73", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Refresh card in Reviewer after tags are changed"}, {"oid": "034d7f28ff2b44deeacb089b96ca29e96520bf88", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Add gesture support for Reviewer's tag feature"}, {"oid": "e541b3ede91ca0bf8b1995deb32bd1a8f28ac1fb", "committedDate": "2020-06-23 11:38:19 -0500", "message": "Remove mSchedResetDone"}, {"oid": "f27b0ba079258f4d15ec8701f5f1e91563234b50", "committedDate": "2020-06-23 11:38:19 -0500", "message": "reset -> planifyReset"}, {"oid": "6d413c3d24c40f1e267229a474759548dfdaf7c3", "committedDate": "2020-06-25 15:51:20 -0500", "message": "Mutate Drawables before mutating alpha"}, {"oid": "7574ad576813e609baf204561d5495bf5b30e2f8", "committedDate": "2020-06-25 15:51:20 -0500", "message": "NF: Use theme constants for alpha values"}, {"oid": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "committedDate": "2020-06-25 20:31:38 -0500", "message": "Save whiteboard while reviewing"}, {"oid": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "committedDate": "2020-06-28 11:48:26 -0500", "message": "Change whiteboard pen color while reviewing"}, {"oid": "b91a511d46b57a88b2a000ca2f6a2375dfbe3bdd", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Task type becomes an enum"}, {"oid": "017cb41d04e55b284f5e11410c50f63d2b368d38", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Remove TASK_TYPE from enum name"}, {"oid": "38b28aa472ccc706c5e80ae260d70e070ec87705", "committedDate": "2020-07-14 16:06:17 -0500", "message": "Load SVG in compat mode for lower APIs"}, {"oid": "0dba81bdef77c234dd4d9a90e1ee89e6c0dc827f", "committedDate": "2020-07-20 19:51:47 -0500", "message": "getUserFlag->userFlag"}, {"oid": "03aa2f4cd0aea7032cc93d27d8676be51154db3c", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: import static com.ichi2.async.CollectionTask.TaskData;"}, {"oid": "1df6f2510ed5c6d410b98c8955a0c230e1ffb309", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: TaskData in a separate file"}, {"oid": "fdadd0f6ef21863c7d8318e089b3d92320cc84d6", "committedDate": "2020-07-23 11:26:40 -0500", "message": "NF: avoid new Object[] in queries"}, {"oid": "1593af8a2f950ca61676f91e2e9a36004d55ff10", "committedDate": "2020-07-25 12:27:22 -0500", "message": "Whiteboard: Add Toggle for Pen Color"}, {"oid": "1990ab81616a4f7efaa260b24f18833863631fc3", "committedDate": "2020-07-29 10:49:24 -0500", "message": "Pen color & save whiteboard - hide if disabled"}, {"oid": "5dfaf9012e6c38f4c601ccfc61131176a1fe11ee", "committedDate": "2020-07-29 10:49:24 -0500", "message": "\"Enable Whiteboard\" - hide if disabled"}, {"oid": "937d3027a35f3af8c478b2066c8f35d1627710ee", "committedDate": "2020-07-29 10:49:24 -0500", "message": "Reviewer: Add tests to ensure app bar consistency"}, {"oid": "2f0af8ff7c5cc18d850aa1fc8c1bdd2c39a6bb1c", "committedDate": "2020-08-08 09:05:50 -0500", "message": "NF: Listener as separate file"}, {"oid": "09931324c60760a157fc450e210981f664abb809", "committedDate": "2020-08-17 10:56:47 -0500", "message": "During slow operation, bury/suspend get correct alpha"}, {"oid": "5408ceaef7eef4db61b4064e5997099700913ed8", "committedDate": "2020-08-17 10:56:47 -0500", "message": "NF: factorize findItem"}, {"oid": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "committedDate": "2020-08-23 16:11:57 -0500", "message": "NF: Use col's time instead of `new SystemTime`"}, {"oid": "34e64b767c2d9348d083a8835d02eb9b74d23580", "committedDate": "2020-08-24 11:18:36 -0500", "message": "Time box opened at correct time"}, {"oid": "e6e3ca34ff92a55fd39d4523dc86a09afa21b865", "committedDate": "2020-09-06 17:08:04 -0500", "message": "Disable fullscreen in Previewer"}, {"oid": "4915505729adfd441b43c529684b2b9e1843644b", "committedDate": "2020-09-06 18:36:55 -0500", "message": "Extract performReload to Reviewer"}, {"oid": "bea7c15e3e2830897b8617471ddd257f1fea9bd4", "committedDate": "2020-09-07 11:23:23 -0500", "message": "NF: restorePreferences: get preferences from super"}, {"oid": "08bb0597601de2995c81e16ee6b187b68a60a49a", "committedDate": "2020-09-07 11:23:23 -0500", "message": "Counts moved from AbstractFlashcardViewer to Reviewer"}, {"oid": "3666002970af46cb6a17d106b9911f980dc77044", "committedDate": "2020-09-13 19:16:40 -0500", "message": "Correct #7076"}, {"oid": "6fe67dfce162038b912f35011c8354dc72ba5339", "committedDate": "2020-09-13 19:16:40 -0500", "message": "NF: updateScreenCounts -> updateActionBar"}, {"oid": "721edd9f369640334bbf5cbb8047537a70d696d9", "committedDate": "2020-09-13 19:16:40 -0500", "message": "Previewer show deck name"}, {"oid": "8039a189ac17813fb0903a3318e2f52487ab683b", "committedDate": "2020-09-17 14:17:15 -0500", "message": "Reviewer buttons now respect safe display setting"}, {"oid": "5850b7e0240ccdf52e8f6f334eafc57463851998", "committedDate": "2020-09-21 10:24:18 -0500", "message": "NF: remove warning UnnecessaryLocalVariable"}, {"oid": "b6ab21bf0086676013450fb09eb786944aac4a4a", "committedDate": "2020-09-22 09:13:07 -0500", "message": "NF: represents counts as a class"}, {"oid": "1b167377ea83a0b25c42fb5f423977948861539c", "committedDate": "2020-09-22 09:13:07 -0500", "message": "NF: represent counts's index as enum"}, {"oid": "3763d6d0bc27900a9aa808f4b7fc3b3e68053d74", "committedDate": "2020-09-22 09:17:52 -0500", "message": "Enable TV Support for Reviewer"}, {"oid": "c55947a68e37e88503151a7121e68c4246ee281f", "committedDate": "2020-09-22 09:17:52 -0500", "message": "TV: Add Icons to Menu"}, {"oid": "c99c91041d851085d037fb39424c5f8545eb721d", "committedDate": "2020-09-22 09:17:52 -0500", "message": "Android TV: Work around AOSP Menu Bug"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "4935ac517deb2d784bba0a9f7793fd2e65f99712", "committedDate": "2020-09-23 11:19:42 -0500", "message": "NF: Sort imports"}, {"oid": "ae684d50cf1e4b84423f087dc1180c4dc1df90ed", "committedDate": "2020-09-24 00:20:35 -0500", "message": "Fix Dark Icons in Light Mode"}, {"oid": "9e4efa56d39ca2fdb5b0afac0747f807b91cba36", "committedDate": "2020-09-24 00:20:35 -0500", "message": "LINT: Improve compat - setIconTintList"}, {"oid": "975a902915821a23623b20e8daeff9fc681b92cd", "committedDate": "2020-09-24 09:30:56 -0500", "message": "NF: Remove warning about useless type in generic class constructors"}, {"oid": "42b92180120040299e590634f5b03d6f352c0a4f", "committedDate": "2020-09-24 11:41:08 -0500", "message": "NF: remove useless casts"}, {"oid": "0b23ca26293d5834775f39ede7dbd55c627fc3f6", "committedDate": "2020-09-30 10:51:24 -0500", "message": "NF: use enum for direction"}, {"oid": "ada67bc3d304193eab15d42badaafe9863d340cf", "committedDate": "2020-10-14 06:06:10 -0500", "message": "Adjust resoure reference usage to handle future non-final state"}, {"oid": "46075e2ccc93a40e3b64c39333263184f43fbe07", "committedDate": "2020-10-28 11:56:29 -0500", "message": "Add Card Info to Reviewer"}, {"oid": "9c8182dde2ed45a0c0de69214097ac10c85bd14a", "committedDate": "2020-11-09 13:08:37 -0500", "message": "Handle App.onCreate not executing after restore"}, {"oid": "d52c31b31ffa1d86ac35e18e0a1da13e225880c3", "committedDate": "2020-11-10 06:36:07 -0500", "message": "Undo in reviewer state what will be undone"}, {"oid": "f016ec5eff15092cddf94231d9028cb040128027", "committedDate": "2020-11-19 02:22:25 +0000", "message": "NF: editCard always return true"}, {"oid": "50ff61b7737d2b265e41d24d3a67f511957d6f56", "committedDate": "2020-11-20 07:28:46 -0500", "message": "Add Keyboard shortcut: Check Pronunciation"}, {"oid": "cce056d89cb1cc4176faf3a4b4be5f9bd8c31283", "committedDate": "2020-12-08 09:27:51 -0500", "message": "BugFix - Previewer: Display same card after edit"}, {"oid": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "committedDate": "2020-12-08 09:34:56 -0500", "message": "Persist Whiteboard Pen Color"}, {"oid": "7b607d2ee38fad34102f3dbc033e2b4d225e7943", "committedDate": "2020-12-08 13:07:30 -0500", "message": "NF: split AnswerCard in GetCard and GetAndAnswerCard"}, {"oid": "23158d37a7743112e6122fb67e0bfa8c618c1eb9", "committedDate": "2020-12-09 11:44:05 -0500", "message": "NF: avoid useless type conversion list to array"}, {"oid": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "committedDate": "2020-12-09 12:17:48 -0500", "message": "NF: Move static part of CollectionTask to other class"}, {"oid": "24443a327ed060dc31f4c16c88a3553d50d7ad05", "committedDate": "2020-12-09 13:40:58 -0500", "message": "Bump minSdkVersion to 21, purge related lower-API workarounds"}, {"oid": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: Add Type Task, type CollectionTask and TaskListener"}, {"oid": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "committedDate": "2020-12-12 17:14:13 -0500", "message": "Remove legacy Whiteboard settings (#7858)"}, {"oid": "34c87ba75f980d82cb215aa33293209f72ee8eed", "committedDate": "2020-12-13 08:30:34 -0500", "message": "NF: remove useless casts, and related warning"}, {"oid": "d3e0dcfd9db849d2093ce5ef0bc513ec11995f48", "committedDate": "2020-12-20 13:21:31 -0500", "message": "removed useless comments"}, {"oid": "be70f9ae13bac500a7454842faf27df9c7bd34bf", "committedDate": "2020-12-20 13:21:31 -0500", "message": "Togglewhiteboard: basic functionality seems to work"}, {"oid": "e034b3851f1b7de0f5864d3c7f830e19de4e5d87", "committedDate": "2021-01-23 14:59:29 -0500", "message": "A bit of misc cleanup"}, {"oid": "7459828a32d0713bea0fd427b78856ba701bf9db", "committedDate": "2021-01-28 09:17:50 -0500", "message": "Reviewer: Resume fullscreen after interaction"}, {"oid": "0b869c7bcd3aacfce7587704ba03f52b993979a7", "committedDate": "2021-03-24 14:32:35 -0500", "message": "Timber all exceptions catched not re-thrown"}, {"oid": "7351e8481615bb2edd181153a6d9db8c429cf776", "committedDate": "2021-03-28 20:38:59 +0200", "message": "fix: make undo icon in menus to be RTL compliant."}, {"oid": "a18fc25f8babb93ba73abcd9f30c6ab172793026", "committedDate": "2021-04-02 13:59:50 -0500", "message": "NF: Split Dismiss task"}, {"oid": "48eaec826892b940182fb6bdee7a53c2d44ea53e", "committedDate": "2021-04-02 13:59:50 -0500", "message": "NF: remove the enum DismissType"}, {"oid": "eb665dea6aebc138ab7dc773181c39e828efa90a", "committedDate": "2021-04-03 13:41:02 -0500", "message": "Call super method in DeckPicker.onRequestPermissionResult"}, {"oid": "2d344bfb26b7a97e3173c8db4461a0def36e496f", "committedDate": "2021-04-03 19:44:26 -0500", "message": "dynamically enable software render on all Reviewer and Info views"}, {"oid": "5fa8827e0503f775d81704868cbd20d64fe554b0", "committedDate": "2021-04-07 22:39:02 -0500", "message": "Reverse Activity transition for RTL language (#8470)"}, {"oid": "81aee9505593db591235e8744a3967c90cf89f98", "committedDate": "2021-04-07 23:29:23 -0500", "message": "infra: ignored tests: Audio Recording Shortcuts"}, {"oid": "164200255997ac4750493118c24cec649191b630", "committedDate": "2021-04-10 07:53:08 -0500", "message": "m prefix non-public, non-static fields #8387 (#8532)"}, {"oid": "a5a68b0fbecc837980174ca35f9ebf364ecc54b8", "committedDate": "2021-04-10 17:00:02 +0100", "message": "NF: @PluralRes on getToastResourceId"}, {"oid": "d8c66722e7c9fdabf35cfa795cdfc6a59ef66f88", "committedDate": "2021-04-23 22:59:42 -0500", "message": "NF: simplify ScheduleCollectionTaskListener"}, {"oid": "85c332ee3237b7aed14e006ef9609d708b96a514", "committedDate": "2021-04-23 22:59:42 -0500", "message": "NF: Remove a variable used a single time"}, {"oid": "0c544371db268cb520e1f89dbc7aa2f499153452", "committedDate": "2021-04-25 12:25:39 -0500", "message": "Convert google material design icons"}, {"oid": "a04e79f50575f3e05da488f7223b2f804508c325", "committedDate": "2021-04-29 18:02:58 -0500", "message": "NF: AnswerCardHandler is child"}, {"oid": "9ade194166473303cf9a42c89e05725fdcb792d1", "committedDate": "2021-04-29 18:05:29 -0500", "message": "NF: dismiss return whether the task succeeded"}, {"oid": "4fd0a2b6253f1650032d951b76d3591edbb13dd4", "committedDate": "2021-04-29 18:14:02 -0500", "message": "NF: simplify selectDeckFromExtra code"}, {"oid": "9b502cbacb9214632493abd30e118fb51080dc31", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize buryCard"}, {"oid": "6bf673072d8590c820098e2c61406db22697dc0d", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize suspendCard"}, {"oid": "1d13f5ab2491c1800eb91d27b31a9cd769e54bbf", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize suspendNote"}, {"oid": "eaf51cd53a6dc565b90352060116b87b84ff96fa", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize buryNote"}, {"oid": "910ed30408fcfd28b38e7ef5b9bd826db58b263a", "committedDate": "2021-05-01 09:14:17 -0500", "message": "Convert remaining PNG files to SVG where possible  (#8707)"}, {"oid": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "committedDate": "2021-05-01 16:33:55 -0500", "message": "WhiteBoard : Improve UX - color, width, (#8715)"}, {"oid": "42ab45ce31c43f8b9d05129303d42c1fb506b488", "committedDate": "2021-06-19 22:48:41 -0500", "message": "nf[Gestures]: extract fling gestures"}, {"oid": "eea1e3227805017d850cae48e16b636838666a4e", "committedDate": "2021-06-24 22:58:48 -0500", "message": "nf: refactor disableDrawerSwipeOnConflicts"}, {"oid": "0b1b8073eedff37982b2467a3575f4993138a27a", "committedDate": "2021-06-24 23:17:29 -0500", "message": "Added incon in action_bar overflow menu"}, {"oid": "f692b10de3bbc75e37075b4cc42b04cbada3bef6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename `other` to `value`"}, {"oid": "22e0854ccc348a1ac395e1b9a73245a34621545f", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename PairWithBoolean to Computation"}, {"oid": "8f423418a4b5aa3c754d94fdcf04017ea602894c", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: use getVlaue instead of mValue"}, {"oid": "259bc73dc31f3527d35c133dbc247b3c98517b7d", "committedDate": "2021-07-03 11:47:27 -0500", "message": "NF: SCREEN_MODE use constants"}, {"oid": "17fb1032c3fc622630c81405369093c8f5e8d841", "committedDate": "2021-07-16 12:24:15 -0500", "message": "nf: Add enum: FullScreenMode"}, {"oid": "94ae96cee6b95ac00282e1bfd885c387f1c3631a", "committedDate": "2021-07-16 12:24:15 -0500", "message": "fix: borders on fullscreen Reviewer"}, {"oid": "36f19cb5017f1707a1b8dafe5da300155dffbcdb", "committedDate": "2021-07-16 13:48:10 -0500", "message": "fix: reviewer fullscreen ui"}, {"oid": "341e453ae469ca14405ba54fdd79fc77b1eeef76", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on handlers"}, {"oid": "5dd818a24706a4d48efb901c525063be85a5de56", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on UI Visibility"}, {"oid": "37b924539e93597a65e7750bc260428b4837dced", "committedDate": "2021-08-04 20:45:34 -0500", "message": "feat: pink, turquoise & purple flags"}, {"oid": "7cb435f0c64462a623a603ff89ae275962952cb1", "committedDate": "2021-08-11 23:06:21 +0200", "message": "Implement onboarding for Reviewer"}, {"oid": "a607e46055ad967d587fb26b0c9a824759dfe3c4", "committedDate": "2021-08-18 16:12:27 -0500", "message": "Compat saveImage: return Uri instead path"}, {"oid": "060357b99f0cc510f319d3aa6f242c9783e3bffa", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf using strongly typed get_config"}, {"oid": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Extracted createInstance in a method of whiteboard"}, {"oid": "840dbe4dca484b8ef7baa5d5d4800f519f2c07f9", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Changed WeakReference to AnkiActivity in whiteboard to let other activities use whiteboard view"}, {"oid": "c965c7daafd716ee73dd8cd32c8152a48ebc1d5a", "committedDate": "2021-08-31 13:00:50 -0500", "message": "fix: Ignore key presses if answer field focused"}, {"oid": "65ce8b1286f936f3d1d106b68463dfa384918a3e", "committedDate": "2021-08-31 13:00:50 -0500", "message": "Remove duplicate preferences"}, {"oid": "8d4d9016057ed58e7d5b014b1b75734b467743fd", "committedDate": "2021-10-13 11:31:32 -0500", "message": "refactor: extract `Collection` to parameter"}, {"oid": "9b33f44fc864f1e61ac8e793d9ddc8f10f33ee7f", "committedDate": "2021-10-13 11:31:32 -0500", "message": "refactor: AnswerButtons"}, {"oid": "cf5458895631166c601720132a2caf533b31756e", "committedDate": "2021-10-14 09:13:56 -0500", "message": "feat(Auto-answer): allow user selection of action"}, {"oid": "562cfac72209132f9f22ff707276d0a46c3ecfbc", "committedDate": "2021-10-18 12:10:56 -0500", "message": "Computation: add \"out\" constraint"}, {"oid": "88740fa355e20096cdb620f5cf0f2f8caf5daec1", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert AnswerCardHandler async style"}, {"oid": "c88bc2e14bf2691c597b8702f701801c99632e2a", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert ScheduleCollectionTask async style"}, {"oid": "cb57ff16f3d8131cfd797b2e2f4a2771419adb9b", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert RescheduleRepositionReset async style"}, {"oid": "6aacb38fc115bfdf7c038f74aa0c9757ebf446a0", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert GetCard async style"}, {"oid": "a316393d837034884fd4ceacef44572111f93ea5", "committedDate": "2021-10-18 12:10:56 -0500", "message": "sched: Extract Next Card functionality to pair"}, {"oid": "a8f17f64771b79e8b83c8b1630f689594150d3e0", "committedDate": "2021-10-21 08:32:26 -0500", "message": "refactor: extract mSpeakText to mTTs.isEnabled"}, {"oid": "81d1d134863b8ab2c0560f9f11148b6a91996c0d", "committedDate": "2021-10-22 08:59:35 -0500", "message": "fix(handler): deprecation"}, {"oid": "7646ad4a7569b2c26a7f65ee3b6b3189ba99a035", "committedDate": "2021-10-23 07:55:39 -0500", "message": "refactor: extract AnswerTimer from CardViewer"}, {"oid": "d2d37ae3ae272200f73a75cb9b4966d423386c44", "committedDate": "2021-10-23 07:55:39 -0500", "message": "refactor: extract mAnswerTimer to Reviewer"}, {"oid": "e53370e6ea4a4fbf124e9e4056754791d6235589", "committedDate": "2021-10-24 09:29:13 -0500", "message": "refactor: extract EaseButton from CardViewer"}, {"oid": "8ffd19d6cac86d79d20c95a09c0dda83d121e1ee", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Whiteboard from CardViewer"}, {"oid": "f04ffba5fd4be1ad442bd4a1b012b99e13b3a0e5", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Audio Recorder from CardViewer"}, {"oid": "66300a61a4c91227423308b6492964a7403dd7eb", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Flag/Mark from CardViewer"}, {"oid": "a56bd548e6d37bf1d9b746559b43b54198d1b9ca", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract toggleMark from CardViewer"}, {"oid": "1c0fa70b13d270cd2f230c0fb87d9e9347e75320", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract NoteService.isMarked"}, {"oid": "80b74bbed2198030c7823dcb4af2d1e83259ef1d", "committedDate": "2021-10-26 10:04:26 -0500", "message": "JS API to Kotlin"}, {"oid": "ae2b26febb9abb25861425e53f29854b24bef7e3", "committedDate": "2021-10-31 13:31:08 -0500", "message": "removed current card from constructor and access directly from activity"}, {"oid": "e599145b41d85b148286e920edd7a77cfd5c64f0", "committedDate": "2021-11-10 07:29:11 -0500", "message": "refactor: remove FunctionalInterfaces.Consumer"}, {"oid": "cffaf251d40be3c2e1babb28e06f37c5fde206e2", "committedDate": "2022-02-20 18:05:09 -0500", "message": "Remove lookup dictionary (#10341)"}, {"oid": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "committedDate": "2022-03-24 08:21:29 -0500", "message": "Rename Reviewer.java to .kt"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTY4NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429151684", "body": "nit/personal preference: `isEmpty()`", "bodyText": "nit/personal preference: isEmpty()", "bodyHTML": "<p dir=\"auto\">nit/personal preference: <code>isEmpty()</code></p>", "author": "david-allison-1", "createdAt": "2020-05-22T09:49:36Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -402,5 +407,9 @@ public void apply() {\n             }\n             invalidate();\n         }\n+\n+        public boolean empty() {", "originalCommit": "14c9f6af08f3c6fc9b814c5be8636613b5a21496", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwMjMyNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429402324", "bodyText": "I wanted to stay consistent with the method name of Stack. After all, UndoStack is essentially a Stack, so keeping name as consistent as possible with the Stack class seems better. After all, that is already what occurs with add, clear, size and pop.", "author": "Arthur-Milchior", "createdAt": "2020-05-22T18:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwMjg3OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429402878", "bodyText": "So I currently stick with my choice here, unless a second person share your preference", "author": "Arthur-Milchior", "createdAt": "2020-05-22T18:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTY4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c432c854a77f728bdec36e23c06f69fc02cc276a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6ac1a424c..75e6d92ee 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -407,9 +402,5 @@ public class Whiteboard extends View {\n             }\n             invalidate();\n         }\n-\n-        public boolean empty() {\n-            return mWhichStack.empty();\n-        }\n     }\n }\n", "next_change": {"commit": "961752b37709879baf096e59839cc809791e80a6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 75e6d92ee..11dbd07a1 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -402,5 +402,9 @@ public class Whiteboard extends View {\n             }\n             invalidate();\n         }\n+\n+        public boolean empty() {\n+            return mWhichStack.empty();\n+        }\n     }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "5aca79273b4df934e30cd59ae1a6418d0de13ac9", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6ac1a424c..31b8ecc90 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -412,4 +412,8 @@ public class Whiteboard extends View {\n             return mWhichStack.empty();\n         }\n     }\n+\n+    public boolean isCurrentlyDrawing() {\n+        return mCurrentlyDrawing;\n+    }\n }\n", "next_change": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 31b8ecc90..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -416,4 +425,33 @@ public class Whiteboard extends View {\n     public boolean isCurrentlyDrawing() {\n         return mCurrentlyDrawing;\n     }\n+\n+    protected String saveWhiteboard() throws FileNotFoundException {\n+\n+        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n+        Canvas canvas = new Canvas(bitmap);\n+\n+        File pictures = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n+        File ankiDroidFolder = new File(pictures, \"AnkiDroid\");\n+\n+        if (!ankiDroidFolder.exists()) {\n+            ankiDroidFolder.mkdirs();\n+        }\n+\n+        String baseFileName = \"Whiteboard\";\n+        String timeStamp = TimeUtils.getTimestamp(mTime);\n+        String finalFileName = baseFileName + timeStamp + \".png\";\n+\n+        File saveWhiteboardImagFile = new File(ankiDroidFolder, finalFileName);\n+\n+        if (foregroundColor != Color.BLACK) {\n+            canvas.drawColor(Color.BLACK);\n+        } else {\n+            canvas.drawColor(Color.WHITE);\n+        }\n+\n+        this.draw(canvas);\n+        bitmap.compress(Bitmap.CompressFormat.JPEG, 95, new FileOutputStream(saveWhiteboardImagFile));\n+        return saveWhiteboardImagFile.getAbsolutePath();\n+    }\n }\n", "next_change": {"commit": "2ca67492ab0086e02e9fecc9085102399e6cfdec", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..3acf23728 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -454,4 +510,10 @@ public class Whiteboard extends View {\n         bitmap.compress(Bitmap.CompressFormat.JPEG, 95, new FileOutputStream(saveWhiteboardImagFile));\n         return saveWhiteboardImagFile.getAbsolutePath();\n     }\n+\n+    @VisibleForTesting\n+    @CheckResult\n+    protected int getForegroundColor() {\n+        return foregroundColor;\n+    }\n }\n", "next_change": {"commit": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 3acf23728..09c5cb62e 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -516,4 +530,8 @@ public class Whiteboard extends View {\n     protected int getForegroundColor() {\n         return foregroundColor;\n     }\n+\n+    public interface OnPaintColorChangeListener {\n+        void onPaintColorChange(@Nullable Integer color);\n+    }\n }\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 09c5cb62e..9839e2295 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -528,7 +606,7 @@ public class Whiteboard extends View {\n     @VisibleForTesting\n     @CheckResult\n     protected int getForegroundColor() {\n-        return foregroundColor;\n+        return mForegroundColor;\n     }\n \n     public interface OnPaintColorChangeListener {\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9839e2295..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,615 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.os.Environment;\n-import android.view.Display;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.WindowManager;\n-import android.widget.Button;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-    }\n-\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        Display display = ((WindowManager) AnkiDroidApp.getInstance().getApplicationContext().\n-                getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\n-        Point point = new Point();\n-        display.getSize(point);\n-        return point;\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        }\n-    }\n-\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"}) // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n-    protected String saveWhiteboard(Time time) throws FileNotFoundException {\n-\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-\n-        File pictures = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n-        File ankiDroidFolder = new File(pictures, \"AnkiDroid\");\n-\n-        if (!ankiDroidFolder.exists()) {\n-            //noinspection ResultOfMethodCallIgnored\n-            ankiDroidFolder.mkdirs();\n-        }\n-\n-        String baseFileName = \"Whiteboard\";\n-        String timeStamp = TimeUtils.getTimestamp(time);\n-        String finalFileName = baseFileName + timeStamp + \".png\";\n-\n-        File saveWhiteboardImageFile = new File(ankiDroidFolder, finalFileName);\n-\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-\n-        this.draw(canvas);\n-        bitmap.compress(Bitmap.CompressFormat.JPEG, 95, new FileOutputStream(saveWhiteboardImageFile));\n-        return saveWhiteboardImageFile.getAbsolutePath();\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "052b1c1a12e688f336d73647b68e27194ef049d3", "message": "Merge commit", "committedDate": null}, {"oid": "5aca79273b4df934e30cd59ae1a6418d0de13ac9", "committedDate": "2020-06-01 17:28:09 -0500", "message": "Whiteboard: Continue Drawing if UI is shown"}, {"oid": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "committedDate": "2020-06-25 20:31:38 -0500", "message": "Save whiteboard while reviewing"}, {"oid": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "committedDate": "2020-06-28 11:48:26 -0500", "message": "Change whiteboard pen color while reviewing"}, {"oid": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "committedDate": "2020-08-23 16:11:57 -0500", "message": "NF: Use col's time instead of `new SystemTime`"}, {"oid": "3e8148c2deb5cea4afb1e7de2b7523d8f6244a91", "committedDate": "2020-08-30 18:24:56 -0500", "message": "Supress lint for Whiteboard View"}, {"oid": "bd2fb549a2e827068ae3d3bd03623d4a549fe16d", "committedDate": "2020-09-21 09:32:28 -0500", "message": "NF: remove useless mInvertedColors"}, {"oid": "bf209dc67aa56c94d84a173d10aa415fb4470aaf", "committedDate": "2020-09-21 09:32:28 -0500", "message": "NF: remove useless member mMonochrome"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "4935ac517deb2d784bba0a9f7793fd2e65f99712", "committedDate": "2020-09-23 11:19:42 -0500", "message": "NF: Sort imports"}, {"oid": "42b92180120040299e590634f5b03d6f352c0a4f", "committedDate": "2020-09-24 11:41:08 -0500", "message": "NF: remove useless casts"}, {"oid": "69dba64459dc466daad2d81012c55b9d66b721bb", "committedDate": "2020-10-02 11:17:10 -0500", "message": "API 29 Dependency Updates (#7332)"}, {"oid": "ada67bc3d304193eab15d42badaafe9863d340cf", "committedDate": "2020-10-14 06:06:10 -0500", "message": "Adjust resoure reference usage to handle future non-final state"}, {"oid": "2ca67492ab0086e02e9fecc9085102399e6cfdec", "committedDate": "2020-12-08 09:34:56 -0500", "message": "TEST: Add tests for getForegroundColor"}, {"oid": "24a01ecfe55797fdb2011f49fb2c903b1528f075", "committedDate": "2020-12-08 09:34:56 -0500", "message": "LINT: Fix Whiteboard Lint Errors"}, {"oid": "9597e35418e8923a12cfe5915dad2f71fa4d5aa5", "committedDate": "2020-12-08 09:34:56 -0500", "message": "NF: Extract setPenColor"}, {"oid": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "committedDate": "2020-12-08 09:34:56 -0500", "message": "Persist Whiteboard Pen Color"}, {"oid": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "committedDate": "2020-12-12 17:14:13 -0500", "message": "Remove legacy Whiteboard settings (#7858)"}, {"oid": "591407338b226ecadd93f33446a807514d228d0f", "committedDate": "2021-03-03 15:52:33 -0500", "message": "Add support for S Pen erase to whiteboard (#8138)"}, {"oid": "164200255997ac4750493118c24cec649191b630", "committedDate": "2021-04-10 07:53:08 -0500", "message": "m prefix non-public, non-static fields #8387 (#8532)"}, {"oid": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "committedDate": "2021-05-01 16:33:55 -0500", "message": "WhiteBoard : Improve UX - color, width, (#8715)"}, {"oid": "b6ccfd9aae9721a40f121a06979bfc80ec1c49cc", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: extract DisplayUtils.getDisplayDimensions"}, {"oid": "9bdf38906bd7954fd443bf92de4199f42a00c1d6", "committedDate": "2021-08-08 13:20:25 -0500", "message": "Use MediaStore to save whiteboard for API > 28"}, {"oid": "a607e46055ad967d587fb26b0c9a824759dfe3c4", "committedDate": "2021-08-18 16:12:27 -0500", "message": "Compat saveImage: return Uri instead path"}, {"oid": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Extracted createInstance in a method of whiteboard"}, {"oid": "840dbe4dca484b8ef7baa5d5d4800f519f2c07f9", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Changed WeakReference to AnkiActivity in whiteboard to let other activities use whiteboard view"}, {"oid": "250097f54e0bf28371770275b613bc0e5e5b3248", "committedDate": "2021-08-27 08:15:20 -0500", "message": "nf: Avoid use of field prefixes for variable names"}, {"oid": "e546c9ac7bfc2d33afee48da4e3e77666a438149", "committedDate": "2021-08-27 08:19:38 -0500", "message": "nf: Use isEmpty in place of checking size to be zero when possible"}, {"oid": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "committedDate": "2021-10-09 16:59:56 -0500", "message": "Rename Whiteboard.java to .kt"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1ODAwOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429158009", "body": "Could you change the title of the PR if there's a functional change mixed in", "bodyText": "Could you change the title of the PR if there's a functional change mixed in", "bodyHTML": "<p dir=\"auto\">Could you change the title of the PR if there's a functional change mixed in</p>", "author": "david-allison-1", "createdAt": "2020-05-22T10:03:27Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java", "diffHunk": "@@ -431,21 +431,29 @@ public boolean onCreateOptionsMenu(Menu menu) {\n             }\n         }\n \n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n-            // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_eraser_variant_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-        } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_eraser_variant_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-        } else if (colIsOpen() && getCol().undoAvailable()) {\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_undo_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+        // Undo button\n+        int undoIcon;\n+        boolean undoEnabled;\n+        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n+            // Whiteboard is here and strokes have been added at some point\n+            undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n+            undoEnabled = !mWhiteboard.undoEmpty();\n         } else {\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_undo_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+            // We can arrive here even if `mShowWhiteboard &&\n+            // mWhiteboard != null` if no stroke had ever been made\n+            undoIcon = R.drawable.ic_undo_white_24dp;\n+            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n+        }\n+        int alpha;\n+        if (getControlBlocked() == ControlBlock.SLOW || !undoEnabled) {", "originalCommit": "14c9f6af08f3c6fc9b814c5be8636613b5a21496", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwMjQwNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429402405", "bodyText": "Sorry, I thought I already did it. My bad", "author": "Arthur-Milchior", "createdAt": "2020-05-22T18:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1ODAwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "500a421fd53021424407cb6fc519b47d2792521a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex dd3f78516..73df40156 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -444,12 +444,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n             undoEnabled = (colIsOpen() && getCol().undoAvailable());\n         }\n-        int alpha;\n-        if (getControlBlocked() == ControlBlock.SLOW || !undoEnabled) {\n-            alpha = Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        } else {\n-            alpha = Themes.ALPHA_ICON_ENABLED_LIGHT ;\n-        }\n+        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n         menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n", "next_change": {"commit": "c432c854a77f728bdec36e23c06f69fc02cc276a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 73df40156..7ecfe317f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -433,20 +435,22 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n         // Undo button\n         @DrawableRes int undoIcon;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n+        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n+            // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n+            undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n+            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+        } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n+            // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n+            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+        } else if (colIsOpen() && getCol().undoAvailable()) {\n+            undoIcon = R.drawable.ic_undo_white_24dp;\n+            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n         } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n+            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n         }\n-        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n-        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n         // White board button\n         if (mPrefWhiteboard) {\n", "next_change": {"commit": "4df47eb1e552de1918c80651163b11efe103c10f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 7ecfe317f..403c14f13 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -435,22 +435,25 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n         // Undo button\n         @DrawableRes int undoIcon;\n+        boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n             // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+            undoEnabled = true;\n         } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+            undoEnabled = false;\n         } else if (colIsOpen() && getCol().undoAvailable()) {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+            undoEnabled = true;\n         } else {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+            undoEnabled = false;\n         }\n+        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n+        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n         // White board button\n         if (mPrefWhiteboard) {\n", "next_change": {"commit": "2ce9d1bd6d39e24167496c73981e94b9fa614699", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 403c14f13..74e6de472 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -444,12 +444,15 @@ public class Reviewer extends AbstractFlashcardViewer {\n             // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n             undoEnabled = false;\n-        } else if (colIsOpen() && getCol().undoAvailable()) {\n-            undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = true;\n         } else {\n+            // We can arrive here even if `mShowWhiteboard &&\n+            // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = false;\n+            if (colIsOpen() && getCol().undoAvailable()) {\n+                undoEnabled = true;\n+            } else {\n+                undoEnabled = false;\n+            }\n         }\n         int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n", "next_change": {"commit": "f741531f20a1adc0989ebc078c502802e18b10df", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 74e6de472..beaf2a147 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -448,11 +448,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n             // We can arrive here even if `mShowWhiteboard &&\n             // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            if (colIsOpen() && getCol().undoAvailable()) {\n-                undoEnabled = true;\n-            } else {\n-                undoEnabled = false;\n-            }\n+            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n         }\n         int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "052b1c1a12e688f336d73647b68e27194ef049d3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex dd3f78516..c0932f0db 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -444,12 +446,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n             undoEnabled = (colIsOpen() && getCol().undoAvailable());\n         }\n-        int alpha;\n-        if (getControlBlocked() == ControlBlock.SLOW || !undoEnabled) {\n-            alpha = Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        } else {\n-            alpha = Themes.ALPHA_ICON_ENABLED_LIGHT ;\n-        }\n+        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n         menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n", "next_change": {"commit": "bd641a86a179f4a4f2431e110f2f74d732b2002d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex c0932f0db..0e9876da1 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -446,7 +513,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n             undoEnabled = (colIsOpen() && getCol().undoAvailable());\n         }\n-        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n+        int alpha = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n         menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n", "next_change": {"commit": "6d413c3d24c40f1e267229a474759548dfdaf7c3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 0e9876da1..a91e7e413 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -515,7 +512,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         }\n         int alpha = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n-        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n+        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha);\n \n         // White board button\n         if (mPrefWhiteboard) {\n", "next_change": {"commit": "5dfaf9012e6c38f4c601ccfc61131176a1fe11ee", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex a91e7e413..9cb039b83 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -518,22 +546,41 @@ public class Reviewer extends AbstractFlashcardViewer {\n         if (mPrefWhiteboard) {\n             // Configure the whiteboard related items in the action bar\n             menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.disable_whiteboard);\n+            // Always allow \"Disable Whiteboard\", even if the preference\n+            menu.findItem(R.id.action_enable_whiteboard).setVisible(true);\n+\n             if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n                 menu.findItem(R.id.action_hide_whiteboard).setVisible(true);\n             }\n             if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n             }\n+            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n+                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n+            }\n+            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setVisible(true);\n+            }\n \n             Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp).mutate();\n+            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n+\n             if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(255);\n+                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n+\n+                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n             } else {\n-                whiteboardIcon.setAlpha(77);\n+                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n+\n+                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setEnabled(false);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n             menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);\n", "next_change": {"commit": "937d3027a35f3af8c478b2066c8f35d1627710ee", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 9cb039b83..bb9623c9f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -583,7 +588,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n-            menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);\n+            menu.findItem(R.id.action_toggle_whiteboard).setTitle(R.string.enable_whiteboard);\n         }\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n", "next_change": {"commit": "5408ceaef7eef4db61b4064e5997099700913ed8", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex bb9623c9f..ceddfae16 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -572,23 +582,23 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n             if (mShowWhiteboard) {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n-                menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n+                hide_whiteboard_icon.setIcon(whiteboardIcon);\n+                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n \n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n             } else {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n-                menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n+                hide_whiteboard_icon.setIcon(whiteboardIcon);\n+                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n \n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setEnabled(false);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                change_pen_color_icon.setEnabled(false);\n+                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n                 colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n-            menu.findItem(R.id.action_toggle_whiteboard).setTitle(R.string.enable_whiteboard);\n+            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n         }\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex ceddfae16..4e4d9ed2d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -595,7 +661,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n                 change_pen_color_icon.setEnabled(false);\n                 change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                colorPalette.setVisibility(View.GONE);\n+                mColorPalette.setVisibility(View.GONE);\n             }\n         } else {\n             toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n", "next_change": {"commit": "a8f17f64771b79e8b83c8b1630f689594150d3e0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 4e4d9ed2d..26b70bfec 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -669,7 +718,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n         }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n+        if (mTTS.isEnabled() && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n             menu.findItem(R.id.action_select_tts).setVisible(true);\n         }\n         // Setup bury / suspend providers\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex 26b70bfec..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1510 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.Manifest;\n-import android.animation.Animator;\n-import android.animation.AnimatorListenerAdapter;\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.content.res.ColorStateList;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.text.SpannableString;\n-import android.text.style.UnderlineSpan;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.webkit.WebView;\n-import android.webkit.JavascriptInterface;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-import android.widget.TextView;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.MenuRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.PluralsRes;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.view.menu.MenuBuilder;\n-import androidx.appcompat.app.ActionBar;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.content.res.ResourcesCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.cardviewer.Gesture;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.AnswerButtons;\n-import com.ichi2.anki.reviewer.AutomaticAnswerAction;\n-import com.ichi2.anki.reviewer.FullScreenMode;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.servicelayer.SchedulerService;\n-import com.ichi2.anki.servicelayer.SchedulerService.NextCard;\n-import com.ichi2.anki.servicelayer.TaskListenerBuilder;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AndroidUiUtils;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.utils.ViewGroupUtils;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import kotlin.Unit;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout mColorPalette;\n-\n-    // TODO: Consider extracting to ViewModel\n-    // Card counts\n-    private SpannableString mNewCount;\n-    private SpannableString mLrnCount;\n-    private SpannableString mRevCount;\n-\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-\n-    private boolean mPrefHideDueCount;\n-\n-    // ETA\n-    private int mEta;\n-    private boolean mPrefShowETA;\n-\n-\n-    // Preferences from the collection\n-    private boolean mShowRemainingCardCount;\n-\n-    private final ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    @VisibleForTesting\n-    protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-    \n-    private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n-\n-    protected <T extends Computation<? extends NextCard<? extends Card[]>>> TaskListenerBuilder<Unit, T>\n-    scheduleCollectionTaskHandler(@PluralsRes int toastResourceId) {\n-        return nextCardHandler().alsoExecuteAfter(result -> {\n-            // BUG: If the method crashes, this will crash\n-            invalidateOptionsMenu();\n-            int cardCount = result.getValue().getResult().length;\n-            UIUtils.showThemedToast(this,\n-                    getResources().getQuantityString(toastResourceId, cardCount, cardCount), true);\n-        });\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(END);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        mColorPalette = findViewById(R.id.whiteboard_editor);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected WebView createWebView() {\n-        WebView ret = super.createWebView();\n-        if (AndroidUiUtils.isRunningOnTv(this)) {\n-            ret.setFocusable(false);\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    protected void recreateWebView() {\n-        super.recreateWebView();\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        if (extras == null || !extras.containsKey(\"deckId\")) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-        long did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(FullScreenMode fullscreenMode) {\n-        switch (fullscreenMode) {\n-            case BUTTONS_ONLY:\n-                return R.layout.reviewer_fullscreen;\n-            case FULLSCREEN_ALL_GONE:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected boolean fitsSystemWindows() {\n-        return !getFullscreenMode().isFullScreenReview();\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        getCol().startTimebox();\n-        new SchedulerService.GetCard().runWithHandler(answerCardHandler(false));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            setFullScreen(this);\n-        }\n-\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        // 100ms was not enough on my device (Honor 9 Lite -  Android Pie)\n-        delayedHide(1000);\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            Timber.i(\"Reviewer:: Home button pressed\");\n-            closeReviewer(RESULT_OK, true);\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.i(\"Reviewer:: Undo button pressed\");\n-            if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                mWhiteboard.undo();\n-            } else {\n-                undo();\n-            }\n-        } else if (itemId == R.id.action_reset_card_progress) {\n-            Timber.i(\"Reviewer:: Reset progress button pressed\");\n-            showResetCardDialog();\n-        } else if (itemId == R.id.action_mark_card) {\n-            Timber.i(\"Reviewer:: Mark button pressed\");\n-            onMark(mCurrentCard);\n-        } else if (itemId == R.id.action_replay) {\n-            Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-            playSounds(true);\n-        } else if (itemId == R.id.action_toggle_mic_tool_bar) {\n-            Timber.i(\"Reviewer:: Record mic\");\n-            // Check permission to record and request if not granted\n-            openOrToggleMicToolbar();\n-        } else if (itemId == R.id.action_tag) {\n-            Timber.i(\"Reviewer:: Tag button pressed\");\n-            showTagsDialog();\n-        } else if (itemId == R.id.action_edit) {\n-            Timber.i(\"Reviewer:: Edit note button pressed\");\n-            editCard();\n-            return true;\n-        } else if (itemId == R.id.action_bury) {\n-            Timber.i(\"Reviewer:: Bury button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Bury card due to no submenu\");\n-                buryCard();\n-            }\n-        } else if (itemId == R.id.action_suspend) {\n-            Timber.i(\"Reviewer:: Suspend button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Suspend card due to no submenu\");\n-                suspendCard();\n-            }\n-        } else if (itemId == R.id.action_delete) {\n-            Timber.i(\"Reviewer:: Delete note button pressed\");\n-            showDeleteNoteDialog();\n-        } else if (itemId == R.id.action_change_whiteboard_pen_color) {\n-            Timber.i(\"Reviewer:: Pen Color button pressed\");\n-            if (mColorPalette.getVisibility() == View.GONE) {\n-                mColorPalette.setVisibility(View.VISIBLE);\n-            } else {\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else if (itemId == R.id.action_save_whiteboard) {\n-            Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                try {\n-                    String savedWhiteboardFileName = mWhiteboard.saveWhiteboard(getCol().getTime()).getPath();\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                } catch (Exception e) {\n-                    Timber.w(e);\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                }\n-            }\n-        } else if (itemId == R.id.action_clear_whiteboard) {\n-            Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-        } else if (itemId == R.id.action_hide_whiteboard) {// toggle whiteboard visibility\n-            Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-            setWhiteboardVisibility(!mShowWhiteboard);\n-            refreshActionBar();\n-        } else if (itemId == R.id.action_toggle_whiteboard) {\n-            toggleWhiteboard();\n-        } else if (itemId == R.id.action_search_dictionary) {\n-            Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-            lookUpOrSelectText();\n-        } else if (itemId == R.id.action_open_deck_options) {\n-            Intent i = new Intent(this, DeckOptions.class);\n-            startActivityForResultWithAnimation(i, DECK_OPTIONS, FADE);\n-        } else if (itemId == R.id.action_select_tts) {\n-            Timber.i(\"Reviewer:: Select TTS button pressed\");\n-            showSelectTtsDialogue();\n-        } else if (itemId == R.id.action_add_note_reviewer) {\n-            Timber.i(\"Reviewer:: Add note button pressed\");\n-            addNote();\n-        } else if (itemId == R.id.action_flag_zero) {\n-            Timber.i(\"Reviewer:: No flag\");\n-            onFlag(mCurrentCard, FLAG_NONE);\n-        } else if (itemId == R.id.action_flag_one) {\n-            Timber.i(\"Reviewer:: Flag one\");\n-            onFlag(mCurrentCard, FLAG_RED);\n-        } else if (itemId == R.id.action_flag_two) {\n-            Timber.i(\"Reviewer:: Flag two\");\n-            onFlag(mCurrentCard, FLAG_ORANGE);\n-        } else if (itemId == R.id.action_flag_three) {\n-            Timber.i(\"Reviewer:: Flag three\");\n-            onFlag(mCurrentCard, FLAG_GREEN);\n-        } else if (itemId == R.id.action_flag_four) {\n-            Timber.i(\"Reviewer:: Flag four\");\n-            onFlag(mCurrentCard, FLAG_BLUE);\n-        } else if (itemId == R.id.action_flag_five) {\n-            Timber.i(\"Reviewer:: Flag five\");\n-            onFlag(mCurrentCard, FLAG_PINK);\n-        } else if (itemId == R.id.action_flag_six) {\n-            Timber.i(\"Reviewer:: Flag six\");\n-            onFlag(mCurrentCard, FLAG_TURQUOISE);\n-        } else if (itemId == R.id.action_flag_seven) {\n-            Timber.i(\"Reviewer:: Flag seven\");\n-            onFlag(mCurrentCard, FLAG_PURPLE);\n-        } else if (itemId == R.id.action_card_info) {\n-            Timber.i(\"Card Viewer:: Card Info\");\n-            openCardInfo();\n-        } else {\n-            return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void toggleWhiteboard() {\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            mColorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    @Override\n-    protected void replayVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        // COULD_BE_BETTER: this shows \"Failed\" if nothing was recorded\n-\n-        mMicToolBar.togglePlay();\n-    }\n-\n-\n-    @Override\n-    protected void recordVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        mMicToolBar.toggleRecord();\n-    }\n-\n-\n-    /**\n-     *\n-     * @return Whether the mic toolbar is usable\n-     */\n-    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-    @VisibleForTesting\n-    public boolean openMicToolbar() {\n-        if (mMicToolBar == null || mMicToolBar.getVisibility() != View.VISIBLE) {\n-            openOrToggleMicToolbar();\n-        }\n-        return mMicToolBar != null;\n-    }\n-\n-\n-    protected void openOrToggleMicToolbar() {\n-        if (!Permissions.canRecordAudio(this)) {\n-            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.RECORD_AUDIO},\n-                    REQUEST_AUDIO_PERMISSION);\n-        } else {\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.ic_play_arrow_white_24dp, R.drawable.ic_pause_white_24dp,\n-                        R.drawable.ic_stop_white_24dp, R.drawable.ic_rec, R.drawable.ic_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n-        if ((requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days -> {\n-            List<Long> cardIds = Collections.singletonList(mCurrentCard.getId());\n-            new SchedulerService.RescheduleCards(cardIds, days).runWithHandler(scheduleCollectionTaskHandler(R.plurals.reschedule_cards_dialog_acknowledge));\n-        };\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            List<Long> cardIds = Collections.singletonList(mCurrentCard.getId());\n-            new SchedulerService.ResetCards(cardIds).runWithHandler(scheduleCollectionTaskHandler(R.plurals.reset_cards_dialog_acknowledge));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, START);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public boolean onMenuOpened(int featureId, Menu menu) {\n-        new Handler().post(() -> {\n-            for (int i = 0; i < menu.size(); i++) {\n-                MenuItem menuItem = menu.getItem(i);\n-                shouldUseDefaultColor(menuItem);\n-            }\n-        });\n-        return super.onMenuOpened(featureId, menu);\n-    }\n-\n-    /**\n-     * This Method changes the color of icon if user taps in overflow button.\n-     */\n-    private void shouldUseDefaultColor(MenuItem menuItem) {\n-        Drawable drawable = menuItem.getIcon();\n-\n-        if (drawable != null && !menuItem.hasSubMenu() && !isFlagResource(menuItem.getItemId())) {\n-            drawable.mutate();\n-            drawable.setTint(ResourcesCompat.getColor(getResources(), R.color.material_blue_600, null));\n-        }\n-    }\n-\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public void onPanelClosed(int featureId, @NonNull Menu menu) {\n-        new Handler().postDelayed(this::refreshActionBar, 100);\n-    }\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-\n-        displayIconsOnTv(menu);\n-        displayIcons(menu);\n-\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_border_white);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        // 1643 - currently null on a TV\n-        @Nullable MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (flag_icon != null) {\n-            if (mCurrentCard != null) {\n-                switch (mCurrentCard.userFlag()) {\n-                    case 1:\n-                        flag_icon.setIcon(R.drawable.ic_flag_red);\n-                        break;\n-                    case 2:\n-                        flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                        break;\n-                    case 3:\n-                        flag_icon.setIcon(R.drawable.ic_flag_green);\n-                        break;\n-                    case 4:\n-                        flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                        break;\n-                    case 5:\n-                        flag_icon.setIcon(R.drawable.ic_flag_pink);\n-                        break;\n-                    case 6:\n-                        flag_icon.setIcon(R.drawable.ic_flag_turquoise);\n-                        break;\n-                    case 7:\n-                        flag_icon.setIcon(R.drawable.ic_flag_purple);\n-                        break;\n-                    default:\n-                        flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                        break;\n-                }\n-            }\n-            flag_icon.getIcon().mutate().setAlpha(alpha);\n-        }\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.eraser;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-        undoIcon.getActionView().setEnabled(undoEnabled);\n-        if (colIsOpen()) { // Required mostly because there are tests where `col` is null\n-            undoIcon.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        if (undoEnabled) {\n-            mOnboarding.onUndoButtonEnabled();\n-        }\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mTTS.isEnabled() && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-\n-        setupSubMenu(menu, R.id.action_suspend, new SuspendProvider(this));\n-        setupSubMenu(menu, R.id.action_bury, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_pause_circle_outline);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        setupSubMenu(menu, R.id.action_schedule, new ScheduleProvider(this));\n-        mOnboarding.onCreate();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\")\n-    private void displayIcons(Menu menu) {\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-        }catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons in Over flow menu\");\n-        }\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\") // setOptionalIconsVisible\n-    private void displayIconsOnTv(Menu menu) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return;\n-        }\n-\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-\n-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-                for (int i = 0; i < menu.size(); i++) {\n-                    MenuItem m = menu.getItem(i);\n-\n-                    if (m == null || isFlagResource(m.getItemId())) {\n-                        continue;\n-                    }\n-\n-                    int color = Themes.getColorFromAttr(this, R.attr.navDrawerItemColor);\n-                    MenuItemCompat.setIconTintList(m, ColorStateList.valueOf(color));\n-                }\n-            }\n-\n-        } catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons\");\n-        }\n-    }\n-\n-\n-    private boolean isFlagResource(int itemId) {\n-        return itemId == R.id.action_flag_seven\n-                || itemId == R.id.action_flag_six\n-                || itemId == R.id.action_flag_five\n-                || itemId == R.id.action_flag_four\n-                || itemId == R.id.action_flag_three\n-                || itemId == R.id.action_flag_two\n-                || itemId == R.id.action_flag_one;\n-    }\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyDown(keyCode, event);\n-        }\n-\n-        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n-            return true;\n-        }\n-\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return false;\n-        }\n-\n-        // Process DPAD Up/Down to focus the TV Controls\n-        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n-            return false;\n-        }\n-\n-        // HACK: This shouldn't be required, as the navigation should handle this.\n-        if (isDrawerOpen()) {\n-            return false;\n-        }\n-\n-\n-        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n-        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n-        // I couldn't get either to work\n-        if (view == null) {\n-            return false;\n-        }\n-\n-        view.requestFocus();\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    private <T extends ActionProvider & SubMenuProvider> void setupSubMenu(Menu menu, @IdRes int parentMenu, T subMenuProvider) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            MenuItemCompat.setActionProvider(menu.findItem(parentMenu), subMenuProvider);\n-            return;\n-        }\n-\n-        // Don't do anything if the menu is hidden (bury for example)\n-        if (!subMenuProvider.hasSubMenu()) {\n-            return;\n-        }\n-\n-        // 7227 - If we're running on a TV, then we can't show submenus until AOSP is fixed\n-        menu.removeItem(parentMenu);\n-        int count = menu.size();\n-        // move the menu to the bottom of the page\n-        getMenuInflater().inflate(subMenuProvider.getSubMenu(), menu);\n-        for (int i = 0; i < menu.size() - count; i++) {\n-            MenuItem item = menu.getItem(count + i);\n-            item.setOnMenuItemClickListener(subMenuProvider);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected boolean canAccessScheduler() {\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void performReload() {\n-        getCol().getSched().deferReset();\n-        new SchedulerService.GetCard().runWithHandler(answerCardHandler(false));\n-    }\n-\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        mOnboarding.onAnswerShown();\n-        int buttonCount;\n-        try {\n-            buttonCount = getButtonCount();\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        final int[] background = AnswerButtons.getBackgroundColors(this);\n-        final int[] textColor = AnswerButtons.getTextColors(this);\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    public int getButtonCount() {\n-        return mSched.answerButtons(mCurrentCard);\n-    }\n-\n-\n-    @Override\n-    public void automaticShowQuestion(@NonNull AutomaticAnswerAction action) {\n-        // explicitly do not call super\n-        if (mEase1Layout.isEnabled() && mEase1Layout.getVisibility() == View.VISIBLE) {\n-            action.execute(this);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = super.restorePreferences();\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        this.mProcessor.setup();\n-        mPrefFullscreenReview = FullScreenMode.isFullScreenReview(preferences);\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    protected void updateActionBar() {\n-        super.updateActionBar();\n-        updateScreenCounts();\n-    }\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        super.updateActionBar();\n-        ActionBar actionBar = getSupportActionBar();\n-        Counts counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            if (mPrefShowETA) {\n-                mEta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), mEta * 60));\n-            }\n-        }\n-\n-\n-        mNewCount = new SpannableString(String.valueOf(counts.getNew()));\n-        mLrnCount = new SpannableString(String.valueOf(counts.getLrn()));\n-        mRevCount = new SpannableString(String.valueOf(counts.getRev()));\n-        if (mPrefHideDueCount) {\n-            mRevCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case NEW:\n-                mNewCount.setSpan(new UnderlineSpan(), 0, mNewCount.length(), 0);\n-                break;\n-            case LRN:\n-                mLrnCount.setSpan(new UnderlineSpan(), 0, mLrnCount.length(), 0);\n-                break;\n-            case REV:\n-                mRevCount.setSpan(new UnderlineSpan(), 0, mRevCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(mNewCount);\n-        mTextBarLearn.setText(mLrnCount);\n-        mTextBarReview.setText(mRevCount);\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        delayedHide(100);\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void displayCardAnswer() {\n-        delayedHide(100);\n-        super.displayCardAnswer();\n-    }\n-\n-    @Override\n-    protected void initLayout() {\n-        mTextBarNew = findViewById(R.id.new_number);\n-        mTextBarLearn = findViewById(R.id.learn_number);\n-        mTextBarReview = findViewById(R.id.review_number);\n-\n-        super.initLayout();\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-    }\n-\n-    @Override\n-    protected void switchTopBarVisibility(int visible) {\n-        super.switchTopBarVisibility(visible);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-    protected void restoreCollectionPreferences(Collection col) {\n-        super.restoreCollectionPreferences(col);\n-        mShowRemainingCardCount = col.get_config_boolean(\"dueCounts\");\n-    }\n-\n-    @Override\n-    protected boolean onSingleTap() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected void onFling() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    protected final Handler mFullScreenHandler = new Handler() {\n-        @Override\n-        public void handleMessage(Message msg) {\n-            if (mPrefFullscreenReview) {\n-                setFullScreen(Reviewer.this);\n-            }\n-        }\n-    };\n-\n-    /** Hide the navigation if in full-screen mode after a given period of time */\n-    protected void delayedHide(int delayMillis) {\n-        Timber.d(\"Fullscreen delayed hide in %dms\", delayMillis);\n-        mFullScreenHandler.removeMessages(0);\n-        mFullScreenHandler.sendEmptyMessageDelayed(0, delayMillis);\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private void setFullScreen(final AbstractFlashcardViewer a) {\n-        // Set appropriate flags to enable Sticky Immersive mode.\n-        a.getWindow().getDecorView().setSystemUiVisibility(\n-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE\n-                        //| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // temporarily disabled due to #5245\n-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\n-                        | View.SYSTEM_UI_FLAG_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_LOW_PROFILE\n-                        | View.SYSTEM_UI_FLAG_IMMERSIVE\n-        );\n-        // Show / hide the Action bar together with the status bar\n-        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(a);\n-        FullScreenMode fullscreenMode = FullScreenMode.fromPreference(prefs);\n-        a.getWindow().setStatusBarColor(Themes.getColorFromAttr(a, R.attr.colorPrimaryDark));\n-        View decorView = a.getWindow().getDecorView();\n-        decorView.setOnSystemUiVisibilityChangeListener\n-                (flags -> {\n-                    final View toolbar = a.findViewById(R.id.toolbar);\n-                    final View answerButtons = a.findViewById(R.id.answer_options_layout);\n-                    final View topbar = a.findViewById(R.id.top_bar);\n-                    if (toolbar == null || topbar == null || answerButtons == null) {\n-                        return;\n-                    }\n-                    // Note that system bars will only be \"visible\" if none of the\n-                    // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.\n-                    boolean visible = (flags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-                    Timber.d(\"System UI visibility change. Visible: %b\", visible);\n-                    if (visible) {\n-                        showViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            showViewWithAnimation(topbar);\n-                            showViewWithAnimation(answerButtons);\n-                        }\n-                    } else {\n-                        hideViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            hideViewWithAnimation(topbar);\n-                            hideViewWithAnimation(answerButtons);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    private static final int ANIMATION_DURATION = 200;\n-    private static final float TRANSPARENCY = 0.90f;\n-\n-\n-    private void showViewWithAnimation(final View view) {\n-        view.setAlpha(0.0f);\n-        view.setVisibility(View.VISIBLE);\n-        view.animate().alpha(TRANSPARENCY).setDuration(ANIMATION_DURATION).setListener(null);\n-    }\n-\n-    private void hideViewWithAnimation(final View view) {\n-        view.animate()\n-                .alpha(0f)\n-                .setDuration(ANIMATION_DURATION)\n-                .setListener(new AnimatorListenerAdapter() {\n-                    @Override\n-                    public void onAnimationEnd(Animator animation) {\n-                        view.setVisibility(View.GONE);\n-                    }\n-                });\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private boolean isImmersiveSystemUiVisible(AnkiActivity activity) {\n-        return (activity.getWindow().getDecorView().getSystemUiVisibility() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-    }\n-\n-    private void createWhiteboard() {\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(this);\n-        mWhiteboard = Whiteboard.createInstance(this, true, this);\n-\n-        // We use the pen color of the selected deck at the time the whiteboard is enabled.\n-        // This is how all other whiteboard settings are\n-        Integer whiteboardPenColor = MetaDB.getWhiteboardPenColor(this, getParentDid()).fromPreferences(sharedPrefs);\n-        if (whiteboardPenColor != null) {\n-            mWhiteboard.setPenColor(whiteboardPenColor);\n-        }\n-\n-        mWhiteboard.setOnPaintColorChangeListener(color -> MetaDB.storeWhiteboardPenColor(this, getParentDid(), !CardAppearance.isInNightMode(sharedPrefs), color));\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        if (mGestureProcessor.isBound(Gesture.SWIPE_UP, Gesture.SWIPE_DOWN, Gesture.SWIPE_RIGHT)) {\n-            mHasDrawerSwipeConflicts = true;\n-            super.disableDrawerSwipe();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    @CheckResult\n-    Whiteboard getWhiteboard() {\n-        return mWhiteboard;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public AudioView getAudioView() {\n-        return mMicToolBar;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public boolean hasDrawerSwipeConflicts() {\n-        return mHasDrawerSwipeConflicts;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements SubMenuProvider {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_suspend;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_suspend_card) {\n-                return suspendCard();\n-            } else if (itemId == R.id.action_suspend_note) {\n-                return suspendNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements SubMenuProvider {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_bury;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_bury_card) {\n-                return buryCard();\n-            } else if (itemId == R.id.action_bury_note) {\n-                return buryNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements SubMenuProvider {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_reschedule_card) {\n-                showRescheduleCardDialog();\n-                return true;\n-            } else if (itemId == R.id.action_reset_card_progress) {\n-                showResetCardDialog();\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_schedule;\n-        }\n-    }\n-\n-    private interface SubMenuProvider extends MenuItem.OnMenuItemClickListener {\n-        @MenuRes int getSubMenu();\n-        boolean hasSubMenu();\n-    }\n-\n-    public ReviewerJavaScriptFunction javaScriptFunction() {\n-        return new ReviewerJavaScriptFunction();\n-    }\n-\n-    public class ReviewerJavaScriptFunction extends JavaScriptFunction {\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetNewCardCount() {\n-            return mNewCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetLrnCardCount() {\n-            return mLrnCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetRevCardCount() {\n-            return mRevCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public int ankiGetETA() {\n-            return mEta;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex bb9623c9f..ceddfae16 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -597,22 +607,28 @@ public class Reviewer extends AbstractFlashcardViewer {\n             menu.findItem(R.id.action_select_tts).setVisible(true);\n         }\n         // Setup bury / suspend providers\n-        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_suspend), new SuspendProvider(this));\n-        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_bury), new BuryProvider(this));\n+        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n+        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n+        MenuItemCompat.setActionProvider(suspend_icon, new SuspendProvider(this));\n+        MenuItemCompat.setActionProvider(bury_icon, new BuryProvider(this));\n         if (suspendNoteAvailable()) {\n-            menu.findItem(R.id.action_suspend).setIcon(R.drawable.ic_action_suspend_dropdown);\n-            menu.findItem(R.id.action_suspend).setTitle(R.string.menu_suspend);\n+            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n+            suspend_icon.setTitle(R.string.menu_suspend);\n         } else {\n-            menu.findItem(R.id.action_suspend).setIcon(R.drawable.ic_action_suspend);\n-            menu.findItem(R.id.action_suspend).setTitle(R.string.menu_suspend_card);\n+            suspend_icon.setIcon(R.drawable.ic_action_suspend);\n+            suspend_icon.setTitle(R.string.menu_suspend_card);\n         }\n         if (buryNoteAvailable()) {\n-            menu.findItem(R.id.action_bury).setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);\n-            menu.findItem(R.id.action_bury).setTitle(R.string.menu_bury);\n+            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);\n+            bury_icon.setTitle(R.string.menu_bury);\n         } else {\n-            menu.findItem(R.id.action_bury).setIcon(R.drawable.ic_flip_to_back_white_24dp);\n-            menu.findItem(R.id.action_bury).setTitle(R.string.menu_bury_card);\n+            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24dp);\n+            bury_icon.setTitle(R.string.menu_bury_card);\n         }\n+        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n+        bury_icon.getIcon().mutate().setAlpha(alpha);\n+        suspend_icon.getIcon().mutate().setAlpha(alpha);\n+\n         MenuItemCompat.setActionProvider(menu.findItem(R.id.action_schedule), new ScheduleProvider(this));\n         return super.onCreateOptionsMenu(menu);\n     }\n", "next_change": {"commit": "3763d6d0bc27900a9aa808f4b7fc3b3e68053d74", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex ceddfae16..7aa368970 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -636,7 +677,34 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n     @Override\n     public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        return mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event);\n+        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n+            return true;\n+        }\n+\n+        if (!AndroidUiUtils.isRunningOnTv(this)) {\n+            return false;\n+        }\n+\n+        // Process DPAD Up/Down to focus the TV Controls\n+        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n+            return false;\n+        }\n+\n+        // HACK: This shouldn't be required, as the navigation should handle this.\n+        if (isDrawerOpen()) {\n+            return false;\n+        }\n+\n+\n+        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n+        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n+        // I couldn't get either to work\n+        if (view == null) {\n+            return false;\n+        }\n+\n+        view.requestFocus();\n+        return true;\n     }\n \n     @Override\n", "next_change": {"commit": "65ce8b1286f936f3d1d106b68463dfa384918a3e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 7aa368970..0bf053673 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -709,9 +845,6 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n     @Override\n     public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyUp(keyCode, event);\n-        }\n         if (mProcessor.onKeyUp(keyCode, event)) {\n             return true;\n         }\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex 0bf053673..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1517 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.Manifest;\n-import android.animation.Animator;\n-import android.animation.AnimatorListenerAdapter;\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.content.res.ColorStateList;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.text.SpannableString;\n-import android.text.style.UnderlineSpan;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.webkit.WebView;\n-import android.webkit.JavascriptInterface;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-import android.widget.TextView;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.MenuRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.PluralsRes;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.view.menu.MenuBuilder;\n-import androidx.appcompat.app.ActionBar;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.content.res.ResourcesCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.cardviewer.Gesture;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.FullScreenMode;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.async.TaskManager;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AndroidUiUtils;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.utils.ViewGroupUtils;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Collections;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout mColorPalette;\n-\n-    // TODO: Consider extracting to ViewModel\n-    // Card counts\n-    private SpannableString mNewCount;\n-    private SpannableString mLrnCount;\n-    private SpannableString mRevCount;\n-\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-\n-    private boolean mPrefHideDueCount;\n-\n-    // ETA\n-    private int mEta;\n-    private boolean mPrefShowETA;\n-\n-\n-    // Preferences from the collection\n-    private boolean mShowRemainingCardCount;\n-\n-    private final ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    @VisibleForTesting\n-    protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-    \n-    private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n-\n-    /** We need to listen for and handle reschedules / resets very similarly */\n-    class ScheduleCollectionTaskListener extends NextCardHandler<Computation<Card[]>> {\n-\n-        private final @PluralsRes int mToastResourceId;\n-\n-\n-        protected ScheduleCollectionTaskListener(@PluralsRes int toastResourceId) {\n-            mToastResourceId = toastResourceId;\n-        }\n-\n-\n-        @Override\n-        public void onPostExecute(Computation<Card[]> result) {\n-            super.onPostExecute(result);\n-            invalidateOptionsMenu();\n-            int cardCount = result.getValue().length;\n-            UIUtils.showThemedToast(Reviewer.this,\n-                    getResources().getQuantityString(mToastResourceId, cardCount, cardCount), true);\n-        }\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(END);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        mColorPalette = findViewById(R.id.whiteboard_editor);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected WebView createWebView() {\n-        WebView ret = super.createWebView();\n-        if (AndroidUiUtils.isRunningOnTv(this)) {\n-            ret.setFocusable(false);\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    protected void recreateWebView() {\n-        super.recreateWebView();\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        if (extras == null || !extras.containsKey(\"deckId\")) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-        long did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(FullScreenMode fullscreenMode) {\n-        switch (fullscreenMode) {\n-            case BUTTONS_ONLY:\n-                return R.layout.reviewer_fullscreen;\n-            case FULLSCREEN_ALL_GONE:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected boolean fitsSystemWindows() {\n-        return !getFullscreenMode().isFullScreenReview();\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        getCol().startTimebox();\n-        TaskManager.launchCollectionTask(new CollectionTask.GetCard(), new AnswerCardHandler(false));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            setFullScreen(this);\n-        }\n-\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        // 100ms was not enough on my device (Honor 9 Lite -  Android Pie)\n-        delayedHide(1000);\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            Timber.i(\"Reviewer:: Home button pressed\");\n-            closeReviewer(RESULT_OK, true);\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.i(\"Reviewer:: Undo button pressed\");\n-            if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                mWhiteboard.undo();\n-            } else {\n-                undo();\n-            }\n-        } else if (itemId == R.id.action_reset_card_progress) {\n-            Timber.i(\"Reviewer:: Reset progress button pressed\");\n-            showResetCardDialog();\n-        } else if (itemId == R.id.action_mark_card) {\n-            Timber.i(\"Reviewer:: Mark button pressed\");\n-            onMark(mCurrentCard);\n-        } else if (itemId == R.id.action_replay) {\n-            Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-            playSounds(true);\n-        } else if (itemId == R.id.action_toggle_mic_tool_bar) {\n-            Timber.i(\"Reviewer:: Record mic\");\n-            // Check permission to record and request if not granted\n-            openOrToggleMicToolbar();\n-        } else if (itemId == R.id.action_tag) {\n-            Timber.i(\"Reviewer:: Tag button pressed\");\n-            showTagsDialog();\n-        } else if (itemId == R.id.action_edit) {\n-            Timber.i(\"Reviewer:: Edit note button pressed\");\n-            editCard();\n-            return true;\n-        } else if (itemId == R.id.action_bury) {\n-            Timber.i(\"Reviewer:: Bury button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Bury card due to no submenu\");\n-                buryCard();\n-            }\n-        } else if (itemId == R.id.action_suspend) {\n-            Timber.i(\"Reviewer:: Suspend button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Suspend card due to no submenu\");\n-                suspendCard();\n-            }\n-        } else if (itemId == R.id.action_delete) {\n-            Timber.i(\"Reviewer:: Delete note button pressed\");\n-            showDeleteNoteDialog();\n-        } else if (itemId == R.id.action_change_whiteboard_pen_color) {\n-            Timber.i(\"Reviewer:: Pen Color button pressed\");\n-            if (mColorPalette.getVisibility() == View.GONE) {\n-                mColorPalette.setVisibility(View.VISIBLE);\n-            } else {\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else if (itemId == R.id.action_save_whiteboard) {\n-            Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                try {\n-                    String savedWhiteboardFileName = mWhiteboard.saveWhiteboard(getCol().getTime()).getPath();\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                } catch (Exception e) {\n-                    Timber.w(e);\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                }\n-            }\n-        } else if (itemId == R.id.action_clear_whiteboard) {\n-            Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-        } else if (itemId == R.id.action_hide_whiteboard) {// toggle whiteboard visibility\n-            Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-            setWhiteboardVisibility(!mShowWhiteboard);\n-            refreshActionBar();\n-        } else if (itemId == R.id.action_toggle_whiteboard) {\n-            toggleWhiteboard();\n-        } else if (itemId == R.id.action_search_dictionary) {\n-            Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-            lookUpOrSelectText();\n-        } else if (itemId == R.id.action_open_deck_options) {\n-            Intent i = new Intent(this, DeckOptions.class);\n-            startActivityForResultWithAnimation(i, DECK_OPTIONS, FADE);\n-        } else if (itemId == R.id.action_select_tts) {\n-            Timber.i(\"Reviewer:: Select TTS button pressed\");\n-            showSelectTtsDialogue();\n-        } else if (itemId == R.id.action_add_note_reviewer) {\n-            Timber.i(\"Reviewer:: Add note button pressed\");\n-            addNote();\n-        } else if (itemId == R.id.action_flag_zero) {\n-            Timber.i(\"Reviewer:: No flag\");\n-            onFlag(mCurrentCard, FLAG_NONE);\n-        } else if (itemId == R.id.action_flag_one) {\n-            Timber.i(\"Reviewer:: Flag one\");\n-            onFlag(mCurrentCard, FLAG_RED);\n-        } else if (itemId == R.id.action_flag_two) {\n-            Timber.i(\"Reviewer:: Flag two\");\n-            onFlag(mCurrentCard, FLAG_ORANGE);\n-        } else if (itemId == R.id.action_flag_three) {\n-            Timber.i(\"Reviewer:: Flag three\");\n-            onFlag(mCurrentCard, FLAG_GREEN);\n-        } else if (itemId == R.id.action_flag_four) {\n-            Timber.i(\"Reviewer:: Flag four\");\n-            onFlag(mCurrentCard, FLAG_BLUE);\n-        } else if (itemId == R.id.action_flag_five) {\n-            Timber.i(\"Reviewer:: Flag five\");\n-            onFlag(mCurrentCard, FLAG_PINK);\n-        } else if (itemId == R.id.action_flag_six) {\n-            Timber.i(\"Reviewer:: Flag six\");\n-            onFlag(mCurrentCard, FLAG_TURQUOISE);\n-        } else if (itemId == R.id.action_flag_seven) {\n-            Timber.i(\"Reviewer:: Flag seven\");\n-            onFlag(mCurrentCard, FLAG_PURPLE);\n-        } else if (itemId == R.id.action_card_info) {\n-            Timber.i(\"Card Viewer:: Card Info\");\n-            openCardInfo();\n-        } else {\n-            return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void toggleWhiteboard() {\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            mColorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    @Override\n-    protected void replayVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        // COULD_BE_BETTER: this shows \"Failed\" if nothing was recorded\n-\n-        mMicToolBar.togglePlay();\n-    }\n-\n-\n-    @Override\n-    protected void recordVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        mMicToolBar.toggleRecord();\n-    }\n-\n-\n-    /**\n-     *\n-     * @return Whether the mic toolbar is usable\n-     */\n-    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-    @VisibleForTesting\n-    public boolean openMicToolbar() {\n-        if (mMicToolBar == null || mMicToolBar.getVisibility() != View.VISIBLE) {\n-            openOrToggleMicToolbar();\n-        }\n-        return mMicToolBar != null;\n-    }\n-\n-\n-    protected void openOrToggleMicToolbar() {\n-        if (!Permissions.canRecordAudio(this)) {\n-            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.RECORD_AUDIO},\n-                    REQUEST_AUDIO_PERMISSION);\n-        } else {\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.ic_play_arrow_white_24dp, R.drawable.ic_pause_white_24dp,\n-                        R.drawable.ic_stop_white_24dp, R.drawable.ic_rec, R.drawable.ic_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n-        if ((requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days ->\n-            TaskManager.launchCollectionTask(new CollectionTask.RescheduleCards(Collections.singletonList(mCurrentCard.getId()), days), new ScheduleCollectionTaskListener(R.plurals.reschedule_cards_dialog_acknowledge));\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            TaskManager.launchCollectionTask(new CollectionTask.ResetCards(Collections.singletonList(mCurrentCard.getId())),\n-                    new ScheduleCollectionTaskListener(R.plurals.reset_cards_dialog_acknowledge));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, START);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public boolean onMenuOpened(int featureId, Menu menu) {\n-        new Handler().post(() -> {\n-            for (int i = 0; i < menu.size(); i++) {\n-                MenuItem menuItem = menu.getItem(i);\n-                shouldUseDefaultColor(menuItem);\n-            }\n-        });\n-        return super.onMenuOpened(featureId, menu);\n-    }\n-\n-    /**\n-     * This Method changes the color of icon if user taps in overflow button.\n-     */\n-    private void shouldUseDefaultColor(MenuItem menuItem) {\n-        Drawable drawable = menuItem.getIcon();\n-\n-        if (drawable != null && !menuItem.hasSubMenu() && !isFlagResource(menuItem.getItemId())) {\n-            drawable.mutate();\n-            drawable.setTint(ResourcesCompat.getColor(getResources(), R.color.material_blue_600, null));\n-        }\n-    }\n-\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public void onPanelClosed(int featureId, @NonNull Menu menu) {\n-        new Handler().postDelayed(this::refreshActionBar, 100);\n-    }\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-\n-        displayIconsOnTv(menu);\n-        displayIcons(menu);\n-\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_border_white);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        // 1643 - currently null on a TV\n-        @Nullable MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (flag_icon != null) {\n-            if (mCurrentCard != null) {\n-                switch (mCurrentCard.userFlag()) {\n-                    case 1:\n-                        flag_icon.setIcon(R.drawable.ic_flag_red);\n-                        break;\n-                    case 2:\n-                        flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                        break;\n-                    case 3:\n-                        flag_icon.setIcon(R.drawable.ic_flag_green);\n-                        break;\n-                    case 4:\n-                        flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                        break;\n-                    case 5:\n-                        flag_icon.setIcon(R.drawable.ic_flag_pink);\n-                        break;\n-                    case 6:\n-                        flag_icon.setIcon(R.drawable.ic_flag_turquoise);\n-                        break;\n-                    case 7:\n-                        flag_icon.setIcon(R.drawable.ic_flag_purple);\n-                        break;\n-                    default:\n-                        flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                        break;\n-                }\n-            }\n-            flag_icon.getIcon().mutate().setAlpha(alpha);\n-        }\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.eraser;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-        undoIcon.getActionView().setEnabled(undoEnabled);\n-        if (colIsOpen()) { // Required mostly because there are tests where `col` is null\n-            undoIcon.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        if (undoEnabled) {\n-            mOnboarding.onUndoButtonEnabled();\n-        }\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-\n-        setupSubMenu(menu, R.id.action_suspend, new SuspendProvider(this));\n-        setupSubMenu(menu, R.id.action_bury, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_pause_circle_outline);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        setupSubMenu(menu, R.id.action_schedule, new ScheduleProvider(this));\n-        mOnboarding.onCreate();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\")\n-    private void displayIcons(Menu menu) {\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-        }catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons in Over flow menu\");\n-        }\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\") // setOptionalIconsVisible\n-    private void displayIconsOnTv(Menu menu) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return;\n-        }\n-\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-\n-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-                for (int i = 0; i < menu.size(); i++) {\n-                    MenuItem m = menu.getItem(i);\n-\n-                    if (m == null || isFlagResource(m.getItemId())) {\n-                        continue;\n-                    }\n-\n-                    int color = Themes.getColorFromAttr(this, R.attr.navDrawerItemColor);\n-                    MenuItemCompat.setIconTintList(m, ColorStateList.valueOf(color));\n-                }\n-            }\n-\n-        } catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons\");\n-        }\n-    }\n-\n-\n-    private boolean isFlagResource(int itemId) {\n-        return itemId == R.id.action_flag_seven\n-                || itemId == R.id.action_flag_six\n-                || itemId == R.id.action_flag_five\n-                || itemId == R.id.action_flag_four\n-                || itemId == R.id.action_flag_three\n-                || itemId == R.id.action_flag_two\n-                || itemId == R.id.action_flag_one;\n-    }\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyDown(keyCode, event);\n-        }\n-\n-        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n-            return true;\n-        }\n-\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return false;\n-        }\n-\n-        // Process DPAD Up/Down to focus the TV Controls\n-        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n-            return false;\n-        }\n-\n-        // HACK: This shouldn't be required, as the navigation should handle this.\n-        if (isDrawerOpen()) {\n-            return false;\n-        }\n-\n-\n-        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n-        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n-        // I couldn't get either to work\n-        if (view == null) {\n-            return false;\n-        }\n-\n-        view.requestFocus();\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    private <T extends ActionProvider & SubMenuProvider> void setupSubMenu(Menu menu, @IdRes int parentMenu, T subMenuProvider) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            MenuItemCompat.setActionProvider(menu.findItem(parentMenu), subMenuProvider);\n-            return;\n-        }\n-\n-        // Don't do anything if the menu is hidden (bury for example)\n-        if (!subMenuProvider.hasSubMenu()) {\n-            return;\n-        }\n-\n-        // 7227 - If we're running on a TV, then we can't show submenus until AOSP is fixed\n-        menu.removeItem(parentMenu);\n-        int count = menu.size();\n-        // move the menu to the bottom of the page\n-        getMenuInflater().inflate(subMenuProvider.getSubMenu(), menu);\n-        for (int i = 0; i < menu.size() - count; i++) {\n-            MenuItem item = menu.getItem(count + i);\n-            item.setOnMenuItemClickListener(subMenuProvider);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected boolean canAccessScheduler() {\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void performReload() {\n-        getCol().getSched().deferReset();\n-        TaskManager.launchCollectionTask(new CollectionTask.GetCard(), new AnswerCardHandler(false));\n-    }\n-\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        mOnboarding.onAnswerShown();\n-        int buttonCount;\n-        try {\n-            buttonCount = mSched.answerButtons(mCurrentCard);\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        int[] backgroundIds;\n-        if (animationEnabled()) {\n-            backgroundIds = new int [] {\n-                    R.attr.againButtonRippleRef,\n-                    R.attr.hardButtonRippleRef,\n-                    R.attr.goodButtonRippleRef,\n-                    R.attr.easyButtonRippleRef};\n-        } else {\n-            backgroundIds = new int [] {\n-                    R.attr.againButtonRef,\n-                    R.attr.hardButtonRef,\n-                    R.attr.goodButtonRef,\n-                    R.attr.easyButtonRef};\n-        }\n-        final int[] background = Themes.getResFromAttr(this, backgroundIds);\n-        final int[] textColor = Themes.getColorFromAttr(this, new int [] {\n-                R.attr.againButtonTextColor,\n-                R.attr.hardButtonTextColor,\n-                R.attr.goodButtonTextColor,\n-                R.attr.easyButtonTextColor});\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = super.restorePreferences();\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        this.mProcessor.setup();\n-        mPrefFullscreenReview = FullScreenMode.isFullScreenReview(preferences);\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    protected void updateActionBar() {\n-        super.updateActionBar();\n-        updateScreenCounts();\n-    }\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        super.updateActionBar();\n-        ActionBar actionBar = getSupportActionBar();\n-        Counts counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            if (mPrefShowETA) {\n-                mEta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), mEta * 60));\n-            }\n-        }\n-\n-\n-        mNewCount = new SpannableString(String.valueOf(counts.getNew()));\n-        mLrnCount = new SpannableString(String.valueOf(counts.getLrn()));\n-        mRevCount = new SpannableString(String.valueOf(counts.getRev()));\n-        if (mPrefHideDueCount) {\n-            mRevCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case NEW:\n-                mNewCount.setSpan(new UnderlineSpan(), 0, mNewCount.length(), 0);\n-                break;\n-            case LRN:\n-                mLrnCount.setSpan(new UnderlineSpan(), 0, mLrnCount.length(), 0);\n-                break;\n-            case REV:\n-                mRevCount.setSpan(new UnderlineSpan(), 0, mRevCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(mNewCount);\n-        mTextBarLearn.setText(mLrnCount);\n-        mTextBarReview.setText(mRevCount);\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        delayedHide(100);\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void displayCardAnswer() {\n-        delayedHide(100);\n-        super.displayCardAnswer();\n-    }\n-\n-    @Override\n-    protected void initLayout() {\n-        mTextBarNew = findViewById(R.id.new_number);\n-        mTextBarLearn = findViewById(R.id.learn_number);\n-        mTextBarReview = findViewById(R.id.review_number);\n-\n-        super.initLayout();\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-    }\n-\n-    @Override\n-    protected void switchTopBarVisibility(int visible) {\n-        super.switchTopBarVisibility(visible);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-    protected void restoreCollectionPreferences() {\n-        super.restoreCollectionPreferences();\n-        mShowRemainingCardCount = getCol().get_config_boolean(\"dueCounts\");\n-    }\n-\n-    @Override\n-    protected boolean onSingleTap() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected void onFling() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    protected final Handler mFullScreenHandler = new Handler() {\n-        @Override\n-        public void handleMessage(Message msg) {\n-            if (mPrefFullscreenReview) {\n-                setFullScreen(Reviewer.this);\n-            }\n-        }\n-    };\n-\n-    /** Hide the navigation if in full-screen mode after a given period of time */\n-    protected void delayedHide(int delayMillis) {\n-        Timber.d(\"Fullscreen delayed hide in %dms\", delayMillis);\n-        mFullScreenHandler.removeMessages(0);\n-        mFullScreenHandler.sendEmptyMessageDelayed(0, delayMillis);\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private void setFullScreen(final AbstractFlashcardViewer a) {\n-        // Set appropriate flags to enable Sticky Immersive mode.\n-        a.getWindow().getDecorView().setSystemUiVisibility(\n-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE\n-                        //| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // temporarily disabled due to #5245\n-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\n-                        | View.SYSTEM_UI_FLAG_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_LOW_PROFILE\n-                        | View.SYSTEM_UI_FLAG_IMMERSIVE\n-        );\n-        // Show / hide the Action bar together with the status bar\n-        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(a);\n-        FullScreenMode fullscreenMode = FullScreenMode.fromPreference(prefs);\n-        a.getWindow().setStatusBarColor(Themes.getColorFromAttr(a, R.attr.colorPrimaryDark));\n-        View decorView = a.getWindow().getDecorView();\n-        decorView.setOnSystemUiVisibilityChangeListener\n-                (flags -> {\n-                    final View toolbar = a.findViewById(R.id.toolbar);\n-                    final View answerButtons = a.findViewById(R.id.answer_options_layout);\n-                    final View topbar = a.findViewById(R.id.top_bar);\n-                    if (toolbar == null || topbar == null || answerButtons == null) {\n-                        return;\n-                    }\n-                    // Note that system bars will only be \"visible\" if none of the\n-                    // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.\n-                    boolean visible = (flags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-                    Timber.d(\"System UI visibility change. Visible: %b\", visible);\n-                    if (visible) {\n-                        showViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            showViewWithAnimation(topbar);\n-                            showViewWithAnimation(answerButtons);\n-                        }\n-                    } else {\n-                        hideViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            hideViewWithAnimation(topbar);\n-                            hideViewWithAnimation(answerButtons);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    private static final int ANIMATION_DURATION = 200;\n-    private static final float TRANSPARENCY = 0.90f;\n-\n-\n-    private void showViewWithAnimation(final View view) {\n-        view.setAlpha(0.0f);\n-        view.setVisibility(View.VISIBLE);\n-        view.animate().alpha(TRANSPARENCY).setDuration(ANIMATION_DURATION).setListener(null);\n-    }\n-\n-    private void hideViewWithAnimation(final View view) {\n-        view.animate()\n-                .alpha(0f)\n-                .setDuration(ANIMATION_DURATION)\n-                .setListener(new AnimatorListenerAdapter() {\n-                    @Override\n-                    public void onAnimationEnd(Animator animation) {\n-                        view.setVisibility(View.GONE);\n-                    }\n-                });\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private boolean isImmersiveSystemUiVisible(AnkiActivity activity) {\n-        return (activity.getWindow().getDecorView().getSystemUiVisibility() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-    }\n-\n-    private void createWhiteboard() {\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(this);\n-        mWhiteboard = Whiteboard.createInstance(this, true, this);\n-\n-        // We use the pen color of the selected deck at the time the whiteboard is enabled.\n-        // This is how all other whiteboard settings are\n-        Integer whiteboardPenColor = MetaDB.getWhiteboardPenColor(this, getParentDid()).fromPreferences(sharedPrefs);\n-        if (whiteboardPenColor != null) {\n-            mWhiteboard.setPenColor(whiteboardPenColor);\n-        }\n-\n-        mWhiteboard.setOnPaintColorChangeListener(color -> MetaDB.storeWhiteboardPenColor(this, getParentDid(), !CardAppearance.isInNightMode(sharedPrefs), color));\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        if (mGestureProcessor.isBound(Gesture.SWIPE_UP, Gesture.SWIPE_DOWN, Gesture.SWIPE_RIGHT)) {\n-            mHasDrawerSwipeConflicts = true;\n-            super.disableDrawerSwipe();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    @CheckResult\n-    Whiteboard getWhiteboard() {\n-        return mWhiteboard;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public AudioView getAudioView() {\n-        return mMicToolBar;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public boolean hasDrawerSwipeConflicts() {\n-        return mHasDrawerSwipeConflicts;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements SubMenuProvider {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_suspend;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_suspend_card) {\n-                return suspendCard();\n-            } else if (itemId == R.id.action_suspend_note) {\n-                return suspendNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements SubMenuProvider {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_bury;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_bury_card) {\n-                return buryCard();\n-            } else if (itemId == R.id.action_bury_note) {\n-                return buryNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements SubMenuProvider {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_reschedule_card) {\n-                showRescheduleCardDialog();\n-                return true;\n-            } else if (itemId == R.id.action_reset_card_progress) {\n-                showResetCardDialog();\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_schedule;\n-        }\n-    }\n-\n-    private interface SubMenuProvider extends MenuItem.OnMenuItemClickListener {\n-        @MenuRes int getSubMenu();\n-        boolean hasSubMenu();\n-    }\n-\n-    public ReviewerJavaScriptFunction javaScriptFunction() {\n-        return new ReviewerJavaScriptFunction();\n-    }\n-\n-    public class ReviewerJavaScriptFunction extends JavaScriptFunction {\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetNewCardCount() {\n-            return mNewCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetLrnCardCount() {\n-            return mLrnCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetRevCardCount() {\n-            return mRevCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public int ankiGetETA() {\n-            return mEta;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "052b1c1a12e688f336d73647b68e27194ef049d3", "message": "Merge commit", "committedDate": null}, {"oid": "806410f0e13d01d55bac641c9bd606833f9ab067", "committedDate": "2020-05-24 17:51:17 -0500", "message": "Extract Peripheral Keymap"}, {"oid": "c529371b2b9431018f168536c054d67aaaceb60b", "committedDate": "2020-05-24 17:51:17 -0500", "message": "Peripheral Input Mappings: convert code to config"}, {"oid": "5aca79273b4df934e30cd59ae1a6418d0de13ac9", "committedDate": "2020-06-01 17:28:09 -0500", "message": "Whiteboard: Continue Drawing if UI is shown"}, {"oid": "8fa42c4683f6b01ac1f3805e014e324b0d06a5dc", "committedDate": "2020-06-03 10:52:56 -0500", "message": "Improve opening deck package from Firefox"}, {"oid": "44ea5d66c7ac3dcec765d7ca645a98e03bb2eee4", "committedDate": "2020-06-09 13:52:14 -0500", "message": "Add mic tool bar to reviewer"}, {"oid": "bd641a86a179f4a4f2431e110f2f74d732b2002d", "committedDate": "2020-06-11 11:30:22 -0500", "message": "Turn off undo during slow control block"}, {"oid": "b1135ff3cbd8d536a0175e7b9b156fdb88585e1b", "committedDate": "2020-06-12 23:28:18 -0500", "message": "Remove unused parameter in saveCollectionInBackground"}, {"oid": "ced164afe1e5e4cf758c2295fda18e4395527047", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Add \"Edit tags\" to review menu"}, {"oid": "41167c4b53cb9648bbd78a2dcb0ed32b3458ef73", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Refresh card in Reviewer after tags are changed"}, {"oid": "034d7f28ff2b44deeacb089b96ca29e96520bf88", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Add gesture support for Reviewer's tag feature"}, {"oid": "e541b3ede91ca0bf8b1995deb32bd1a8f28ac1fb", "committedDate": "2020-06-23 11:38:19 -0500", "message": "Remove mSchedResetDone"}, {"oid": "f27b0ba079258f4d15ec8701f5f1e91563234b50", "committedDate": "2020-06-23 11:38:19 -0500", "message": "reset -> planifyReset"}, {"oid": "6d413c3d24c40f1e267229a474759548dfdaf7c3", "committedDate": "2020-06-25 15:51:20 -0500", "message": "Mutate Drawables before mutating alpha"}, {"oid": "7574ad576813e609baf204561d5495bf5b30e2f8", "committedDate": "2020-06-25 15:51:20 -0500", "message": "NF: Use theme constants for alpha values"}, {"oid": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "committedDate": "2020-06-25 20:31:38 -0500", "message": "Save whiteboard while reviewing"}, {"oid": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "committedDate": "2020-06-28 11:48:26 -0500", "message": "Change whiteboard pen color while reviewing"}, {"oid": "b91a511d46b57a88b2a000ca2f6a2375dfbe3bdd", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Task type becomes an enum"}, {"oid": "017cb41d04e55b284f5e11410c50f63d2b368d38", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Remove TASK_TYPE from enum name"}, {"oid": "38b28aa472ccc706c5e80ae260d70e070ec87705", "committedDate": "2020-07-14 16:06:17 -0500", "message": "Load SVG in compat mode for lower APIs"}, {"oid": "0dba81bdef77c234dd4d9a90e1ee89e6c0dc827f", "committedDate": "2020-07-20 19:51:47 -0500", "message": "getUserFlag->userFlag"}, {"oid": "03aa2f4cd0aea7032cc93d27d8676be51154db3c", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: import static com.ichi2.async.CollectionTask.TaskData;"}, {"oid": "1df6f2510ed5c6d410b98c8955a0c230e1ffb309", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: TaskData in a separate file"}, {"oid": "fdadd0f6ef21863c7d8318e089b3d92320cc84d6", "committedDate": "2020-07-23 11:26:40 -0500", "message": "NF: avoid new Object[] in queries"}, {"oid": "1593af8a2f950ca61676f91e2e9a36004d55ff10", "committedDate": "2020-07-25 12:27:22 -0500", "message": "Whiteboard: Add Toggle for Pen Color"}, {"oid": "1990ab81616a4f7efaa260b24f18833863631fc3", "committedDate": "2020-07-29 10:49:24 -0500", "message": "Pen color & save whiteboard - hide if disabled"}, {"oid": "5dfaf9012e6c38f4c601ccfc61131176a1fe11ee", "committedDate": "2020-07-29 10:49:24 -0500", "message": "\"Enable Whiteboard\" - hide if disabled"}, {"oid": "937d3027a35f3af8c478b2066c8f35d1627710ee", "committedDate": "2020-07-29 10:49:24 -0500", "message": "Reviewer: Add tests to ensure app bar consistency"}, {"oid": "2f0af8ff7c5cc18d850aa1fc8c1bdd2c39a6bb1c", "committedDate": "2020-08-08 09:05:50 -0500", "message": "NF: Listener as separate file"}, {"oid": "09931324c60760a157fc450e210981f664abb809", "committedDate": "2020-08-17 10:56:47 -0500", "message": "During slow operation, bury/suspend get correct alpha"}, {"oid": "5408ceaef7eef4db61b4064e5997099700913ed8", "committedDate": "2020-08-17 10:56:47 -0500", "message": "NF: factorize findItem"}, {"oid": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "committedDate": "2020-08-23 16:11:57 -0500", "message": "NF: Use col's time instead of `new SystemTime`"}, {"oid": "34e64b767c2d9348d083a8835d02eb9b74d23580", "committedDate": "2020-08-24 11:18:36 -0500", "message": "Time box opened at correct time"}, {"oid": "e6e3ca34ff92a55fd39d4523dc86a09afa21b865", "committedDate": "2020-09-06 17:08:04 -0500", "message": "Disable fullscreen in Previewer"}, {"oid": "4915505729adfd441b43c529684b2b9e1843644b", "committedDate": "2020-09-06 18:36:55 -0500", "message": "Extract performReload to Reviewer"}, {"oid": "bea7c15e3e2830897b8617471ddd257f1fea9bd4", "committedDate": "2020-09-07 11:23:23 -0500", "message": "NF: restorePreferences: get preferences from super"}, {"oid": "08bb0597601de2995c81e16ee6b187b68a60a49a", "committedDate": "2020-09-07 11:23:23 -0500", "message": "Counts moved from AbstractFlashcardViewer to Reviewer"}, {"oid": "3666002970af46cb6a17d106b9911f980dc77044", "committedDate": "2020-09-13 19:16:40 -0500", "message": "Correct #7076"}, {"oid": "6fe67dfce162038b912f35011c8354dc72ba5339", "committedDate": "2020-09-13 19:16:40 -0500", "message": "NF: updateScreenCounts -> updateActionBar"}, {"oid": "721edd9f369640334bbf5cbb8047537a70d696d9", "committedDate": "2020-09-13 19:16:40 -0500", "message": "Previewer show deck name"}, {"oid": "8039a189ac17813fb0903a3318e2f52487ab683b", "committedDate": "2020-09-17 14:17:15 -0500", "message": "Reviewer buttons now respect safe display setting"}, {"oid": "5850b7e0240ccdf52e8f6f334eafc57463851998", "committedDate": "2020-09-21 10:24:18 -0500", "message": "NF: remove warning UnnecessaryLocalVariable"}, {"oid": "b6ab21bf0086676013450fb09eb786944aac4a4a", "committedDate": "2020-09-22 09:13:07 -0500", "message": "NF: represents counts as a class"}, {"oid": "1b167377ea83a0b25c42fb5f423977948861539c", "committedDate": "2020-09-22 09:13:07 -0500", "message": "NF: represent counts's index as enum"}, {"oid": "3763d6d0bc27900a9aa808f4b7fc3b3e68053d74", "committedDate": "2020-09-22 09:17:52 -0500", "message": "Enable TV Support for Reviewer"}, {"oid": "c55947a68e37e88503151a7121e68c4246ee281f", "committedDate": "2020-09-22 09:17:52 -0500", "message": "TV: Add Icons to Menu"}, {"oid": "c99c91041d851085d037fb39424c5f8545eb721d", "committedDate": "2020-09-22 09:17:52 -0500", "message": "Android TV: Work around AOSP Menu Bug"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "4935ac517deb2d784bba0a9f7793fd2e65f99712", "committedDate": "2020-09-23 11:19:42 -0500", "message": "NF: Sort imports"}, {"oid": "ae684d50cf1e4b84423f087dc1180c4dc1df90ed", "committedDate": "2020-09-24 00:20:35 -0500", "message": "Fix Dark Icons in Light Mode"}, {"oid": "9e4efa56d39ca2fdb5b0afac0747f807b91cba36", "committedDate": "2020-09-24 00:20:35 -0500", "message": "LINT: Improve compat - setIconTintList"}, {"oid": "975a902915821a23623b20e8daeff9fc681b92cd", "committedDate": "2020-09-24 09:30:56 -0500", "message": "NF: Remove warning about useless type in generic class constructors"}, {"oid": "42b92180120040299e590634f5b03d6f352c0a4f", "committedDate": "2020-09-24 11:41:08 -0500", "message": "NF: remove useless casts"}, {"oid": "0b23ca26293d5834775f39ede7dbd55c627fc3f6", "committedDate": "2020-09-30 10:51:24 -0500", "message": "NF: use enum for direction"}, {"oid": "ada67bc3d304193eab15d42badaafe9863d340cf", "committedDate": "2020-10-14 06:06:10 -0500", "message": "Adjust resoure reference usage to handle future non-final state"}, {"oid": "46075e2ccc93a40e3b64c39333263184f43fbe07", "committedDate": "2020-10-28 11:56:29 -0500", "message": "Add Card Info to Reviewer"}, {"oid": "9c8182dde2ed45a0c0de69214097ac10c85bd14a", "committedDate": "2020-11-09 13:08:37 -0500", "message": "Handle App.onCreate not executing after restore"}, {"oid": "d52c31b31ffa1d86ac35e18e0a1da13e225880c3", "committedDate": "2020-11-10 06:36:07 -0500", "message": "Undo in reviewer state what will be undone"}, {"oid": "f016ec5eff15092cddf94231d9028cb040128027", "committedDate": "2020-11-19 02:22:25 +0000", "message": "NF: editCard always return true"}, {"oid": "50ff61b7737d2b265e41d24d3a67f511957d6f56", "committedDate": "2020-11-20 07:28:46 -0500", "message": "Add Keyboard shortcut: Check Pronunciation"}, {"oid": "cce056d89cb1cc4176faf3a4b4be5f9bd8c31283", "committedDate": "2020-12-08 09:27:51 -0500", "message": "BugFix - Previewer: Display same card after edit"}, {"oid": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "committedDate": "2020-12-08 09:34:56 -0500", "message": "Persist Whiteboard Pen Color"}, {"oid": "7b607d2ee38fad34102f3dbc033e2b4d225e7943", "committedDate": "2020-12-08 13:07:30 -0500", "message": "NF: split AnswerCard in GetCard and GetAndAnswerCard"}, {"oid": "23158d37a7743112e6122fb67e0bfa8c618c1eb9", "committedDate": "2020-12-09 11:44:05 -0500", "message": "NF: avoid useless type conversion list to array"}, {"oid": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "committedDate": "2020-12-09 12:17:48 -0500", "message": "NF: Move static part of CollectionTask to other class"}, {"oid": "24443a327ed060dc31f4c16c88a3553d50d7ad05", "committedDate": "2020-12-09 13:40:58 -0500", "message": "Bump minSdkVersion to 21, purge related lower-API workarounds"}, {"oid": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: Add Type Task, type CollectionTask and TaskListener"}, {"oid": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "committedDate": "2020-12-12 17:14:13 -0500", "message": "Remove legacy Whiteboard settings (#7858)"}, {"oid": "34c87ba75f980d82cb215aa33293209f72ee8eed", "committedDate": "2020-12-13 08:30:34 -0500", "message": "NF: remove useless casts, and related warning"}, {"oid": "d3e0dcfd9db849d2093ce5ef0bc513ec11995f48", "committedDate": "2020-12-20 13:21:31 -0500", "message": "removed useless comments"}, {"oid": "be70f9ae13bac500a7454842faf27df9c7bd34bf", "committedDate": "2020-12-20 13:21:31 -0500", "message": "Togglewhiteboard: basic functionality seems to work"}, {"oid": "e034b3851f1b7de0f5864d3c7f830e19de4e5d87", "committedDate": "2021-01-23 14:59:29 -0500", "message": "A bit of misc cleanup"}, {"oid": "7459828a32d0713bea0fd427b78856ba701bf9db", "committedDate": "2021-01-28 09:17:50 -0500", "message": "Reviewer: Resume fullscreen after interaction"}, {"oid": "0b869c7bcd3aacfce7587704ba03f52b993979a7", "committedDate": "2021-03-24 14:32:35 -0500", "message": "Timber all exceptions catched not re-thrown"}, {"oid": "7351e8481615bb2edd181153a6d9db8c429cf776", "committedDate": "2021-03-28 20:38:59 +0200", "message": "fix: make undo icon in menus to be RTL compliant."}, {"oid": "a18fc25f8babb93ba73abcd9f30c6ab172793026", "committedDate": "2021-04-02 13:59:50 -0500", "message": "NF: Split Dismiss task"}, {"oid": "48eaec826892b940182fb6bdee7a53c2d44ea53e", "committedDate": "2021-04-02 13:59:50 -0500", "message": "NF: remove the enum DismissType"}, {"oid": "eb665dea6aebc138ab7dc773181c39e828efa90a", "committedDate": "2021-04-03 13:41:02 -0500", "message": "Call super method in DeckPicker.onRequestPermissionResult"}, {"oid": "2d344bfb26b7a97e3173c8db4461a0def36e496f", "committedDate": "2021-04-03 19:44:26 -0500", "message": "dynamically enable software render on all Reviewer and Info views"}, {"oid": "5fa8827e0503f775d81704868cbd20d64fe554b0", "committedDate": "2021-04-07 22:39:02 -0500", "message": "Reverse Activity transition for RTL language (#8470)"}, {"oid": "81aee9505593db591235e8744a3967c90cf89f98", "committedDate": "2021-04-07 23:29:23 -0500", "message": "infra: ignored tests: Audio Recording Shortcuts"}, {"oid": "164200255997ac4750493118c24cec649191b630", "committedDate": "2021-04-10 07:53:08 -0500", "message": "m prefix non-public, non-static fields #8387 (#8532)"}, {"oid": "a5a68b0fbecc837980174ca35f9ebf364ecc54b8", "committedDate": "2021-04-10 17:00:02 +0100", "message": "NF: @PluralRes on getToastResourceId"}, {"oid": "d8c66722e7c9fdabf35cfa795cdfc6a59ef66f88", "committedDate": "2021-04-23 22:59:42 -0500", "message": "NF: simplify ScheduleCollectionTaskListener"}, {"oid": "85c332ee3237b7aed14e006ef9609d708b96a514", "committedDate": "2021-04-23 22:59:42 -0500", "message": "NF: Remove a variable used a single time"}, {"oid": "0c544371db268cb520e1f89dbc7aa2f499153452", "committedDate": "2021-04-25 12:25:39 -0500", "message": "Convert google material design icons"}, {"oid": "a04e79f50575f3e05da488f7223b2f804508c325", "committedDate": "2021-04-29 18:02:58 -0500", "message": "NF: AnswerCardHandler is child"}, {"oid": "9ade194166473303cf9a42c89e05725fdcb792d1", "committedDate": "2021-04-29 18:05:29 -0500", "message": "NF: dismiss return whether the task succeeded"}, {"oid": "4fd0a2b6253f1650032d951b76d3591edbb13dd4", "committedDate": "2021-04-29 18:14:02 -0500", "message": "NF: simplify selectDeckFromExtra code"}, {"oid": "9b502cbacb9214632493abd30e118fb51080dc31", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize buryCard"}, {"oid": "6bf673072d8590c820098e2c61406db22697dc0d", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize suspendCard"}, {"oid": "1d13f5ab2491c1800eb91d27b31a9cd769e54bbf", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize suspendNote"}, {"oid": "eaf51cd53a6dc565b90352060116b87b84ff96fa", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize buryNote"}, {"oid": "910ed30408fcfd28b38e7ef5b9bd826db58b263a", "committedDate": "2021-05-01 09:14:17 -0500", "message": "Convert remaining PNG files to SVG where possible  (#8707)"}, {"oid": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "committedDate": "2021-05-01 16:33:55 -0500", "message": "WhiteBoard : Improve UX - color, width, (#8715)"}, {"oid": "42ab45ce31c43f8b9d05129303d42c1fb506b488", "committedDate": "2021-06-19 22:48:41 -0500", "message": "nf[Gestures]: extract fling gestures"}, {"oid": "eea1e3227805017d850cae48e16b636838666a4e", "committedDate": "2021-06-24 22:58:48 -0500", "message": "nf: refactor disableDrawerSwipeOnConflicts"}, {"oid": "0b1b8073eedff37982b2467a3575f4993138a27a", "committedDate": "2021-06-24 23:17:29 -0500", "message": "Added incon in action_bar overflow menu"}, {"oid": "f692b10de3bbc75e37075b4cc42b04cbada3bef6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename `other` to `value`"}, {"oid": "22e0854ccc348a1ac395e1b9a73245a34621545f", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename PairWithBoolean to Computation"}, {"oid": "8f423418a4b5aa3c754d94fdcf04017ea602894c", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: use getVlaue instead of mValue"}, {"oid": "259bc73dc31f3527d35c133dbc247b3c98517b7d", "committedDate": "2021-07-03 11:47:27 -0500", "message": "NF: SCREEN_MODE use constants"}, {"oid": "17fb1032c3fc622630c81405369093c8f5e8d841", "committedDate": "2021-07-16 12:24:15 -0500", "message": "nf: Add enum: FullScreenMode"}, {"oid": "94ae96cee6b95ac00282e1bfd885c387f1c3631a", "committedDate": "2021-07-16 12:24:15 -0500", "message": "fix: borders on fullscreen Reviewer"}, {"oid": "36f19cb5017f1707a1b8dafe5da300155dffbcdb", "committedDate": "2021-07-16 13:48:10 -0500", "message": "fix: reviewer fullscreen ui"}, {"oid": "341e453ae469ca14405ba54fdd79fc77b1eeef76", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on handlers"}, {"oid": "5dd818a24706a4d48efb901c525063be85a5de56", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on UI Visibility"}, {"oid": "37b924539e93597a65e7750bc260428b4837dced", "committedDate": "2021-08-04 20:45:34 -0500", "message": "feat: pink, turquoise & purple flags"}, {"oid": "7cb435f0c64462a623a603ff89ae275962952cb1", "committedDate": "2021-08-11 23:06:21 +0200", "message": "Implement onboarding for Reviewer"}, {"oid": "a607e46055ad967d587fb26b0c9a824759dfe3c4", "committedDate": "2021-08-18 16:12:27 -0500", "message": "Compat saveImage: return Uri instead path"}, {"oid": "060357b99f0cc510f319d3aa6f242c9783e3bffa", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf using strongly typed get_config"}, {"oid": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Extracted createInstance in a method of whiteboard"}, {"oid": "840dbe4dca484b8ef7baa5d5d4800f519f2c07f9", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Changed WeakReference to AnkiActivity in whiteboard to let other activities use whiteboard view"}, {"oid": "c965c7daafd716ee73dd8cd32c8152a48ebc1d5a", "committedDate": "2021-08-31 13:00:50 -0500", "message": "fix: Ignore key presses if answer field focused"}, {"oid": "65ce8b1286f936f3d1d106b68463dfa384918a3e", "committedDate": "2021-08-31 13:00:50 -0500", "message": "Remove duplicate preferences"}, {"oid": "8d4d9016057ed58e7d5b014b1b75734b467743fd", "committedDate": "2021-10-13 11:31:32 -0500", "message": "refactor: extract `Collection` to parameter"}, {"oid": "9b33f44fc864f1e61ac8e793d9ddc8f10f33ee7f", "committedDate": "2021-10-13 11:31:32 -0500", "message": "refactor: AnswerButtons"}, {"oid": "cf5458895631166c601720132a2caf533b31756e", "committedDate": "2021-10-14 09:13:56 -0500", "message": "feat(Auto-answer): allow user selection of action"}, {"oid": "562cfac72209132f9f22ff707276d0a46c3ecfbc", "committedDate": "2021-10-18 12:10:56 -0500", "message": "Computation: add \"out\" constraint"}, {"oid": "88740fa355e20096cdb620f5cf0f2f8caf5daec1", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert AnswerCardHandler async style"}, {"oid": "c88bc2e14bf2691c597b8702f701801c99632e2a", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert ScheduleCollectionTask async style"}, {"oid": "cb57ff16f3d8131cfd797b2e2f4a2771419adb9b", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert RescheduleRepositionReset async style"}, {"oid": "6aacb38fc115bfdf7c038f74aa0c9757ebf446a0", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert GetCard async style"}, {"oid": "a316393d837034884fd4ceacef44572111f93ea5", "committedDate": "2021-10-18 12:10:56 -0500", "message": "sched: Extract Next Card functionality to pair"}, {"oid": "a8f17f64771b79e8b83c8b1630f689594150d3e0", "committedDate": "2021-10-21 08:32:26 -0500", "message": "refactor: extract mSpeakText to mTTs.isEnabled"}, {"oid": "81d1d134863b8ab2c0560f9f11148b6a91996c0d", "committedDate": "2021-10-22 08:59:35 -0500", "message": "fix(handler): deprecation"}, {"oid": "7646ad4a7569b2c26a7f65ee3b6b3189ba99a035", "committedDate": "2021-10-23 07:55:39 -0500", "message": "refactor: extract AnswerTimer from CardViewer"}, {"oid": "d2d37ae3ae272200f73a75cb9b4966d423386c44", "committedDate": "2021-10-23 07:55:39 -0500", "message": "refactor: extract mAnswerTimer to Reviewer"}, {"oid": "e53370e6ea4a4fbf124e9e4056754791d6235589", "committedDate": "2021-10-24 09:29:13 -0500", "message": "refactor: extract EaseButton from CardViewer"}, {"oid": "8ffd19d6cac86d79d20c95a09c0dda83d121e1ee", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Whiteboard from CardViewer"}, {"oid": "f04ffba5fd4be1ad442bd4a1b012b99e13b3a0e5", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Audio Recorder from CardViewer"}, {"oid": "66300a61a4c91227423308b6492964a7403dd7eb", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Flag/Mark from CardViewer"}, {"oid": "a56bd548e6d37bf1d9b746559b43b54198d1b9ca", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract toggleMark from CardViewer"}, {"oid": "1c0fa70b13d270cd2f230c0fb87d9e9347e75320", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract NoteService.isMarked"}, {"oid": "80b74bbed2198030c7823dcb4af2d1e83259ef1d", "committedDate": "2021-10-26 10:04:26 -0500", "message": "JS API to Kotlin"}, {"oid": "ae2b26febb9abb25861425e53f29854b24bef7e3", "committedDate": "2021-10-31 13:31:08 -0500", "message": "removed current card from constructor and access directly from activity"}, {"oid": "e599145b41d85b148286e920edd7a77cfd5c64f0", "committedDate": "2021-11-10 07:29:11 -0500", "message": "refactor: remove FunctionalInterfaces.Consumer"}, {"oid": "cffaf251d40be3c2e1babb28e06f37c5fde206e2", "committedDate": "2022-02-20 18:05:09 -0500", "message": "Remove lookup dictionary (#10341)"}, {"oid": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "committedDate": "2022-03-24 08:21:29 -0500", "message": "Rename Reviewer.java to .kt"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2Mjk5Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429162993", "body": "Nit: `@DrawableRes` if this needs to exist", "bodyText": "Nit: @DrawableRes if this needs to exist", "bodyHTML": "<p dir=\"auto\">Nit: <code>@DrawableRes</code> if this needs to exist</p>", "author": "david-allison-1", "createdAt": "2020-05-22T10:15:07Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java", "diffHunk": "@@ -431,21 +431,29 @@ public boolean onCreateOptionsMenu(Menu menu) {\n             }\n         }\n \n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n-            // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_eraser_variant_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-        } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_eraser_variant_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-        } else if (colIsOpen() && getCol().undoAvailable()) {\n-            menu.findItem(R.id.action_undo).setIcon(R.drawable.ic_undo_white_24dp);\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+        // Undo button\n+        int undoIcon;", "originalCommit": "14c9f6af08f3c6fc9b814c5be8636613b5a21496", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwMjY0OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429402648", "bodyText": "Thanks. I didn't know this annotation", "author": "Arthur-Milchior", "createdAt": "2020-05-22T18:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2Mjk5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "500a421fd53021424407cb6fc519b47d2792521a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex dd3f78516..73df40156 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -432,7 +432,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         }\n \n         // Undo button\n-        int undoIcon;\n+        @DrawableRes int undoIcon;\n         boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard is here and strokes have been added at some point\n", "next_change": {"commit": "c432c854a77f728bdec36e23c06f69fc02cc276a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 73df40156..7ecfe317f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -433,20 +435,22 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n         // Undo button\n         @DrawableRes int undoIcon;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n+        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n+            // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n+            undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n+            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+        } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n+            // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n+            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+        } else if (colIsOpen() && getCol().undoAvailable()) {\n+            undoIcon = R.drawable.ic_undo_white_24dp;\n+            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n         } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n+            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n         }\n-        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n-        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n         // White board button\n         if (mPrefWhiteboard) {\n", "next_change": {"commit": "4df47eb1e552de1918c80651163b11efe103c10f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 7ecfe317f..403c14f13 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -435,22 +435,25 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n         // Undo button\n         @DrawableRes int undoIcon;\n+        boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.undoSize() > 0) {\n             // Whiteboard undo queue non-empty. Switch the undo icon to a whiteboard specific one.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+            undoEnabled = true;\n         } else if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+            undoEnabled = false;\n         } else if (colIsOpen() && getCol().undoAvailable()) {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(true).getIcon().setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+            undoEnabled = true;\n         } else {\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            menu.findItem(R.id.action_undo).setEnabled(false).getIcon().setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+            undoEnabled = false;\n         }\n+        int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n+        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().setAlpha(alpha);\n \n         // White board button\n         if (mPrefWhiteboard) {\n", "next_change": {"commit": "2ce9d1bd6d39e24167496c73981e94b9fa614699", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 403c14f13..74e6de472 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -444,12 +444,15 @@ public class Reviewer extends AbstractFlashcardViewer {\n             // Whiteboard undo queue empty, but user has added strokes to it for current card. Disable undo button.\n             undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n             undoEnabled = false;\n-        } else if (colIsOpen() && getCol().undoAvailable()) {\n-            undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = true;\n         } else {\n+            // We can arrive here even if `mShowWhiteboard &&\n+            // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = false;\n+            if (colIsOpen() && getCol().undoAvailable()) {\n+                undoEnabled = true;\n+            } else {\n+                undoEnabled = false;\n+            }\n         }\n         int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n", "next_change": {"commit": "f741531f20a1adc0989ebc078c502802e18b10df", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 74e6de472..beaf2a147 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -448,11 +448,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n             // We can arrive here even if `mShowWhiteboard &&\n             // mWhiteboard != null` if no stroke had ever been made\n             undoIcon = R.drawable.ic_undo_white_24dp;\n-            if (colIsOpen() && getCol().undoAvailable()) {\n-                undoEnabled = true;\n-            } else {\n-                undoEnabled = false;\n-            }\n+            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n         }\n         int alpha = (undoEnabled) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n         menu.findItem(R.id.action_undo).setIcon(undoIcon);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "052b1c1a12e688f336d73647b68e27194ef049d3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex dd3f78516..c0932f0db 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -432,7 +434,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         }\n \n         // Undo button\n-        int undoIcon;\n+        @DrawableRes int undoIcon;\n         boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard is here and strokes have been added at some point\n", "next_change": {"commit": "09931324c60760a157fc450e210981f664abb809", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex c0932f0db..e758da514 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -432,6 +532,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 break;\n             }\n         }\n+        menu.findItem(R.id.action_flag).getIcon().mutate().setAlpha(alpha);\n \n         // Undo button\n         @DrawableRes int undoIcon;\n", "next_change": {"commit": "5408ceaef7eef4db61b4064e5997099700913ed8", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex e758da514..ceddfae16 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -505,61 +505,67 @@ public class Reviewer extends AbstractFlashcardViewer {\n         // NOTE: This is called every time a new question is shown via invalidate options menu\n         getMenuInflater().inflate(R.menu.reviewer, menu);\n         mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n+        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n+        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n         if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            menu.findItem(R.id.action_mark_card).setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white_24dp);\n+            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white_24dp);\n         } else {\n-            menu.findItem(R.id.action_mark_card).setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_outline_white_24dp);\n+            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_outline_white_24dp);\n         }\n-        menu.findItem(R.id.action_mark_card).getIcon().mutate().setAlpha(alpha);\n+        markCardIcon.getIcon().mutate().setAlpha(alpha);\n \n+        MenuItem flag_icon = menu.findItem(R.id.action_flag);\n         if (mCurrentCard != null) {\n             switch (mCurrentCard.userFlag()) {\n             case 1:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_red);\n+                flag_icon.setIcon(R.drawable.ic_flag_red);\n                 break;\n             case 2:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_orange);\n+                flag_icon.setIcon(R.drawable.ic_flag_orange);\n                 break;\n             case 3:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_green);\n+                flag_icon.setIcon(R.drawable.ic_flag_green);\n                 break;\n             case 4:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_blue);\n+                flag_icon.setIcon(R.drawable.ic_flag_blue);\n                 break;\n             default:\n-                menu.findItem(R.id.action_flag).setIcon(R.drawable.ic_flag_transparent);\n+                flag_icon.setIcon(R.drawable.ic_flag_transparent);\n                 break;\n             }\n         }\n-        menu.findItem(R.id.action_flag).getIcon().mutate().setAlpha(alpha);\n+        flag_icon.getIcon().mutate().setAlpha(alpha);\n \n         // Undo button\n-        @DrawableRes int undoIcon;\n+        @DrawableRes int undoIconId;\n         boolean undoEnabled;\n         if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n             // Whiteboard is here and strokes have been added at some point\n-            undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n+            undoIconId = R.drawable.ic_eraser_variant_white_24dp;\n             undoEnabled = !mWhiteboard.undoEmpty();\n         } else {\n             // We can arrive here even if `mShowWhiteboard &&\n             // mWhiteboard != null` if no stroke had ever been made\n-            undoIcon = R.drawable.ic_undo_white_24dp;\n+            undoIconId = R.drawable.ic_undo_white_24dp;\n             undoEnabled = (colIsOpen() && getCol().undoAvailable());\n         }\n         int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        menu.findItem(R.id.action_undo).setIcon(undoIcon);\n-        menu.findItem(R.id.action_undo).setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n+        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n+        undoIcon.setIcon(undoIconId);\n+        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n \n+        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n+        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n+        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n         // White board button\n         if (mPrefWhiteboard) {\n             // Configure the whiteboard related items in the action bar\n-            menu.findItem(R.id.action_toggle_whiteboard).setTitle(R.string.disable_whiteboard);\n+            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n             // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            menu.findItem(R.id.action_toggle_whiteboard).setVisible(true);\n+            toggle_whiteboard_icon.setVisible(true);\n \n             if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_hide_whiteboard).setVisible(true);\n+                hide_whiteboard_icon.setVisible(true);\n             }\n             if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex ceddfae16..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1017 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.app.Activity;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anim.ActivityTransitionAnimation;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.async.TaskListener;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Collection.DismissType;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anki.reviewer.CardMarker.FLAG_NONE;\n-import static com.ichi2.anki.cardviewer.ViewerCommand.COMMAND_NOTHING;\n-import static com.ichi2.async.CollectionTask.TASK_TYPE.*;\n-import com.ichi2.async.TaskData;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mBlackWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout colorPalette;\n-\n-    private ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    private TaskListener mRescheduleCardHandler = new ScheduleCollectionTaskListener() {\n-        protected int getToastResourceId() {\n-            return R.plurals.reschedule_cards_dialog_acknowledge;\n-        }\n-    };\n-\n-    private TaskListener mResetProgressCardHandler = new ScheduleCollectionTaskListener() {\n-        protected int getToastResourceId() {\n-            return R.plurals.reset_cards_dialog_acknowledge;\n-        }\n-    };\n-\n-    @VisibleForTesting\n-    protected PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-\n-    /** We need to listen for and handle reschedules / resets very similarly */\n-    abstract class ScheduleCollectionTaskListener extends NextCardHandler {\n-\n-        abstract protected int getToastResourceId();\n-\n-\n-        @Override\n-        public void onPostExecute(TaskData result) {\n-            super.onPostExecute(result);\n-            invalidateOptionsMenu();\n-            int cardCount = result.getObjArray().length;\n-            UIUtils.showThemedToast(Reviewer.this,\n-                    getResources().getQuantityString(getToastResourceId(), cardCount, cardCount), true);\n-        }\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(ActivityTransitionAnimation.RIGHT);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        colorPalette = (LinearLayout) findViewById(R.id.whiteboard_pen_color);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        long did = Long.MIN_VALUE;\n-        if (extras != null) {\n-            did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-        }\n-\n-        if(did == Long.MIN_VALUE) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(int fullscreenMode) {\n-        if (CompatHelper.getSdkVersion() < Build.VERSION_CODES.KITKAT) {\n-            fullscreenMode = 0;     // The specific fullscreen layouts are only applicable for immersive mode\n-        }\n-        switch (fullscreenMode) {\n-            case 1:\n-                return R.layout.reviewer_fullscreen;\n-            case 2:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        CollectionTask.launchCollectionTask(ANSWER_CARD, mAnswerCardHandler(false),\n-                new TaskData(null, 0));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<Activity>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            CompatHelper.getCompat().setFullScreen(this);\n-        }\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        switch (item.getItemId()) {\n-\n-            case android.R.id.home:\n-                Timber.i(\"Reviewer:: Home button pressed\");\n-                closeReviewer(RESULT_OK, true);\n-                break;\n-\n-            case R.id.action_undo:\n-                Timber.i(\"Reviewer:: Undo button pressed\");\n-                if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                    mWhiteboard.undo();\n-                } else {\n-                    undo();\n-                }\n-                break;\n-\n-            case R.id.action_reset_card_progress:\n-                Timber.i(\"Reviewer:: Reset progress button pressed\");\n-                showResetCardDialog();\n-                break;\n-\n-            case R.id.action_mark_card:\n-                Timber.i(\"Reviewer:: Mark button pressed\");\n-                onMark(mCurrentCard);\n-                break;\n-\n-            case R.id.action_replay:\n-                Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-                playSounds(true);\n-                break;\n-\n-            case R.id.action_toggle_mic_tool_bar:\n-                Timber.i(\"Reviewer:: Record mic\");\n-                // Check permission to record and request if not granted\n-                if (!Permissions.canRecordAudio(this)) {\n-                    ActivityCompat.requestPermissions(this, new String[]{android.Manifest.permission.RECORD_AUDIO},\n-                            REQUEST_AUDIO_PERMISSION);\n-                } else {\n-                    toggleMicToolBar();\n-                }\n-                break;\n-\n-            case R.id.action_tag:\n-                Timber.i(\"Reviewer:: Tag button pressed\");\n-                showTagsDialog();\n-                break;\n-\n-            case R.id.action_edit:\n-                Timber.i(\"Reviewer:: Edit note button pressed\");\n-                return editCard();\n-\n-            case R.id.action_bury:\n-                Timber.i(\"Reviewer:: Bury button pressed\");\n-                if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                    Timber.d(\"Bury card due to no submenu\");\n-                    dismiss(DismissType.BURY_CARD);\n-                }\n-                break;\n-\n-            case R.id.action_suspend:\n-                Timber.i(\"Reviewer:: Suspend button pressed\");\n-                if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                    Timber.d(\"Suspend card due to no submenu\");\n-                    dismiss(DismissType.SUSPEND_CARD);\n-                }\n-                break;\n-\n-            case R.id.action_delete:\n-                Timber.i(\"Reviewer:: Delete note button pressed\");\n-                showDeleteNoteDialog();\n-                break;\n-\n-            case R.id.action_change_whiteboard_pen_color:\n-                Timber.i(\"Reviewer:: Pen Color button pressed\");\n-                if (colorPalette.getVisibility() == View.GONE) {\n-                    colorPalette.setVisibility(View.VISIBLE);\n-                } else {\n-                    colorPalette.setVisibility(View.GONE);\n-                }\n-                break;\n-\n-            case R.id.action_save_whiteboard:\n-                Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-                if (mWhiteboard != null) {\n-                    try {\n-                        String savedWhiteboardFileName = mWhiteboard.saveWhiteboard();\n-                        UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                    } catch (Exception e) {\n-                        UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                    }\n-                }\n-                break;\n-\n-            case R.id.action_clear_whiteboard:\n-                Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-                if (mWhiteboard != null) {\n-                    mWhiteboard.clear();\n-                }\n-                break;\n-\n-            case R.id.action_hide_whiteboard:\n-                // toggle whiteboard visibility\n-                Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-                setWhiteboardVisibility(!mShowWhiteboard);\n-                refreshActionBar();\n-                break;\n-\n-            case R.id.action_toggle_whiteboard:\n-                toggleWhiteboard();\n-                break;\n-\n-            case R.id.action_search_dictionary:\n-                Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-                lookUpOrSelectText();\n-                break;\n-\n-            case R.id.action_open_deck_options:\n-                Intent i = new Intent(this, DeckOptions.class);\n-                startActivityForResultWithAnimation(i, DECK_OPTIONS, ActivityTransitionAnimation.FADE);\n-                break;\n-\n-            case R.id.action_select_tts:\n-                Timber.i(\"Reviewer:: Select TTS button pressed\");\n-                showSelectTtsDialogue();\n-                break;\n-\n-            case R.id.action_add_note_reviewer:\n-                Timber.i(\"Reviewer:: Add note button pressed\");\n-                addNote();\n-                break;\n-\n-            case R.id.action_flag_zero:\n-                Timber.i(\"Reviewer:: No flag\");\n-                onFlag(mCurrentCard, FLAG_NONE);\n-                break;\n-            case R.id.action_flag_one:\n-                Timber.i(\"Reviewer:: Flag one\");\n-                onFlag(mCurrentCard, FLAG_RED);\n-                break;\n-            case R.id.action_flag_two:\n-                Timber.i(\"Reviewer:: Flag two\");\n-                onFlag(mCurrentCard, FLAG_ORANGE);\n-                break;\n-            case R.id.action_flag_three:\n-                Timber.i(\"Reviewer:: Flag three\");\n-                onFlag(mCurrentCard, FLAG_GREEN);\n-                break;\n-            case R.id.action_flag_four:\n-                Timber.i(\"Reviewer:: Flag four\");\n-                onFlag(mCurrentCard, FLAG_BLUE);\n-                break;\n-            default:\n-                return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    protected void toggleWhiteboard() {\n-        // toggle whiteboard enabled state (and show/hide whiteboard item in action bar)\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            colorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.av_play, R.drawable.av_pause,\n-                        R.drawable.av_stop, R.drawable.av_rec, R.drawable.av_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult (int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        if ( (requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days ->\n-            CollectionTask.launchCollectionTask(DISMISS_MULTI, mRescheduleCardHandler,\n-                    new TaskData(new Object[]{new long[]{mCurrentCard.getId()},\n-                    Collection.DismissType.RESCHEDULE_CARDS, days})\n-            );\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            CollectionTask.launchCollectionTask(DISMISS_MULTI, mResetProgressCardHandler,\n-                    new TaskData(new Object[]{new long[]{mCurrentCard.getId()}, Collection.DismissType.RESET_CARDS}));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, ActivityTransitionAnimation.LEFT);\n-    }\n-\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white_24dp);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_outline_white_24dp);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (mCurrentCard != null) {\n-            switch (mCurrentCard.userFlag()) {\n-            case 1:\n-                flag_icon.setIcon(R.drawable.ic_flag_red);\n-                break;\n-            case 2:\n-                flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                break;\n-            case 3:\n-                flag_icon.setIcon(R.drawable.ic_flag_green);\n-                break;\n-            case 4:\n-                flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                break;\n-            default:\n-                flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                break;\n-            }\n-        }\n-        flag_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.ic_eraser_variant_white_24dp;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white_24dp;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                colorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-        MenuItemCompat.setActionProvider(suspend_icon, new SuspendProvider(this));\n-        MenuItemCompat.setActionProvider(bury_icon, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24dp);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_schedule), new ScheduleProvider(this));\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        return mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event);\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyUp(keyCode, event);\n-        }\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        int buttonCount;\n-        try {\n-            buttonCount = mSched.answerButtons(mCurrentCard);\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        final int[] background = Themes.getResFromAttr(this, new int [] {\n-                R.attr.againButtonRef,\n-                R.attr.hardButtonRef,\n-                R.attr.goodButtonRef,\n-                R.attr.easyButtonRef});\n-        final int[] textColor = Themes.getColorFromAttr(this, new int [] {\n-                R.attr.againButtonTextColor,\n-                R.attr.hardButtonTextColor,\n-                R.attr.goodButtonTextColor,\n-                R.attr.easyButtonTextColor});\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        super.restorePreferences();\n-        this.mProcessor.setup();\n-        //Is this line necessary? Can we not use the return value from the call to super?\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-        mBlackWhiteboard = preferences.getBoolean(\"blackWhiteboard\", true);\n-        mPrefFullscreenReview = Integer.parseInt(preferences.getString(\"fullscreenMode\", \"0\")) > 0;\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    // Create the whiteboard\n-    private void createWhiteboard() {\n-        mWhiteboard = new Whiteboard(this, isInNightMode(), mBlackWhiteboard);\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-        mWhiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = findViewById(R.id.whiteboard);\n-        fl.addView(mWhiteboard);\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && CompatHelper.getCompat().isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-        mWhiteboard.setEnabled(true);\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-        boolean gesturesEnabled = AnkiDroidApp.initiateGestures(preferences);\n-        if (gesturesEnabled) {\n-            int gestureSwipeUp = Integer.parseInt(preferences.getString(\"gestureSwipeUp\", \"9\"));\n-            int gestureSwipeDown = Integer.parseInt(preferences.getString(\"gestureSwipeDown\", \"0\"));\n-            int gestureSwipeRight = Integer.parseInt(preferences.getString(\"gestureSwipeRight\", \"17\"));\n-            if (gestureSwipeUp != COMMAND_NOTHING ||\n-                    gestureSwipeDown != COMMAND_NOTHING ||\n-                    gestureSwipeRight != COMMAND_NOTHING) {\n-                mHasDrawerSwipeConflicts = true;\n-                super.disableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        boolean bury = getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-        return bury;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements MenuItem.OnMenuItemClickListener {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(R.menu.reviewer_suspend, subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            switch (item.getItemId()) {\n-                case R.id.action_suspend_card:\n-                    dismiss(DismissType.SUSPEND_CARD);\n-                    return true;\n-                case R.id.action_suspend_note:\n-                    dismiss(DismissType.SUSPEND_NOTE);\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements MenuItem.OnMenuItemClickListener {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(R.menu.reviewer_bury, subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            switch (item.getItemId()) {\n-                case R.id.action_bury_card:\n-                    dismiss(DismissType.BURY_CARD);\n-                    return true;\n-                case R.id.action_bury_note:\n-                    dismiss(DismissType.BURY_NOTE);\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements MenuItem.OnMenuItemClickListener {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(R.menu.reviewer_schedule, subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            switch (item.getItemId()) {\n-                case R.id.action_reschedule_card:\n-                    showRescheduleCardDialog();\n-                    return true;\n-                case R.id.action_reset_card_progress:\n-                    showResetCardDialog();\n-                    return true;\n-                default:\n-                    return false;\n-            }\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "052b1c1a12e688f336d73647b68e27194ef049d3", "message": "Merge commit", "committedDate": null}, {"oid": "806410f0e13d01d55bac641c9bd606833f9ab067", "committedDate": "2020-05-24 17:51:17 -0500", "message": "Extract Peripheral Keymap"}, {"oid": "c529371b2b9431018f168536c054d67aaaceb60b", "committedDate": "2020-05-24 17:51:17 -0500", "message": "Peripheral Input Mappings: convert code to config"}, {"oid": "5aca79273b4df934e30cd59ae1a6418d0de13ac9", "committedDate": "2020-06-01 17:28:09 -0500", "message": "Whiteboard: Continue Drawing if UI is shown"}, {"oid": "8fa42c4683f6b01ac1f3805e014e324b0d06a5dc", "committedDate": "2020-06-03 10:52:56 -0500", "message": "Improve opening deck package from Firefox"}, {"oid": "44ea5d66c7ac3dcec765d7ca645a98e03bb2eee4", "committedDate": "2020-06-09 13:52:14 -0500", "message": "Add mic tool bar to reviewer"}, {"oid": "bd641a86a179f4a4f2431e110f2f74d732b2002d", "committedDate": "2020-06-11 11:30:22 -0500", "message": "Turn off undo during slow control block"}, {"oid": "b1135ff3cbd8d536a0175e7b9b156fdb88585e1b", "committedDate": "2020-06-12 23:28:18 -0500", "message": "Remove unused parameter in saveCollectionInBackground"}, {"oid": "ced164afe1e5e4cf758c2295fda18e4395527047", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Add \"Edit tags\" to review menu"}, {"oid": "41167c4b53cb9648bbd78a2dcb0ed32b3458ef73", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Refresh card in Reviewer after tags are changed"}, {"oid": "034d7f28ff2b44deeacb089b96ca29e96520bf88", "committedDate": "2020-06-18 20:13:08 -0500", "message": "Add gesture support for Reviewer's tag feature"}, {"oid": "e541b3ede91ca0bf8b1995deb32bd1a8f28ac1fb", "committedDate": "2020-06-23 11:38:19 -0500", "message": "Remove mSchedResetDone"}, {"oid": "f27b0ba079258f4d15ec8701f5f1e91563234b50", "committedDate": "2020-06-23 11:38:19 -0500", "message": "reset -> planifyReset"}, {"oid": "6d413c3d24c40f1e267229a474759548dfdaf7c3", "committedDate": "2020-06-25 15:51:20 -0500", "message": "Mutate Drawables before mutating alpha"}, {"oid": "7574ad576813e609baf204561d5495bf5b30e2f8", "committedDate": "2020-06-25 15:51:20 -0500", "message": "NF: Use theme constants for alpha values"}, {"oid": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "committedDate": "2020-06-25 20:31:38 -0500", "message": "Save whiteboard while reviewing"}, {"oid": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "committedDate": "2020-06-28 11:48:26 -0500", "message": "Change whiteboard pen color while reviewing"}, {"oid": "b91a511d46b57a88b2a000ca2f6a2375dfbe3bdd", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Task type becomes an enum"}, {"oid": "017cb41d04e55b284f5e11410c50f63d2b368d38", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Remove TASK_TYPE from enum name"}, {"oid": "38b28aa472ccc706c5e80ae260d70e070ec87705", "committedDate": "2020-07-14 16:06:17 -0500", "message": "Load SVG in compat mode for lower APIs"}, {"oid": "0dba81bdef77c234dd4d9a90e1ee89e6c0dc827f", "committedDate": "2020-07-20 19:51:47 -0500", "message": "getUserFlag->userFlag"}, {"oid": "03aa2f4cd0aea7032cc93d27d8676be51154db3c", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: import static com.ichi2.async.CollectionTask.TaskData;"}, {"oid": "1df6f2510ed5c6d410b98c8955a0c230e1ffb309", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: TaskData in a separate file"}, {"oid": "fdadd0f6ef21863c7d8318e089b3d92320cc84d6", "committedDate": "2020-07-23 11:26:40 -0500", "message": "NF: avoid new Object[] in queries"}, {"oid": "1593af8a2f950ca61676f91e2e9a36004d55ff10", "committedDate": "2020-07-25 12:27:22 -0500", "message": "Whiteboard: Add Toggle for Pen Color"}, {"oid": "1990ab81616a4f7efaa260b24f18833863631fc3", "committedDate": "2020-07-29 10:49:24 -0500", "message": "Pen color & save whiteboard - hide if disabled"}, {"oid": "5dfaf9012e6c38f4c601ccfc61131176a1fe11ee", "committedDate": "2020-07-29 10:49:24 -0500", "message": "\"Enable Whiteboard\" - hide if disabled"}, {"oid": "937d3027a35f3af8c478b2066c8f35d1627710ee", "committedDate": "2020-07-29 10:49:24 -0500", "message": "Reviewer: Add tests to ensure app bar consistency"}, {"oid": "2f0af8ff7c5cc18d850aa1fc8c1bdd2c39a6bb1c", "committedDate": "2020-08-08 09:05:50 -0500", "message": "NF: Listener as separate file"}, {"oid": "09931324c60760a157fc450e210981f664abb809", "committedDate": "2020-08-17 10:56:47 -0500", "message": "During slow operation, bury/suspend get correct alpha"}, {"oid": "5408ceaef7eef4db61b4064e5997099700913ed8", "committedDate": "2020-08-17 10:56:47 -0500", "message": "NF: factorize findItem"}, {"oid": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "committedDate": "2020-08-23 16:11:57 -0500", "message": "NF: Use col's time instead of `new SystemTime`"}, {"oid": "34e64b767c2d9348d083a8835d02eb9b74d23580", "committedDate": "2020-08-24 11:18:36 -0500", "message": "Time box opened at correct time"}, {"oid": "e6e3ca34ff92a55fd39d4523dc86a09afa21b865", "committedDate": "2020-09-06 17:08:04 -0500", "message": "Disable fullscreen in Previewer"}, {"oid": "4915505729adfd441b43c529684b2b9e1843644b", "committedDate": "2020-09-06 18:36:55 -0500", "message": "Extract performReload to Reviewer"}, {"oid": "bea7c15e3e2830897b8617471ddd257f1fea9bd4", "committedDate": "2020-09-07 11:23:23 -0500", "message": "NF: restorePreferences: get preferences from super"}, {"oid": "08bb0597601de2995c81e16ee6b187b68a60a49a", "committedDate": "2020-09-07 11:23:23 -0500", "message": "Counts moved from AbstractFlashcardViewer to Reviewer"}, {"oid": "3666002970af46cb6a17d106b9911f980dc77044", "committedDate": "2020-09-13 19:16:40 -0500", "message": "Correct #7076"}, {"oid": "6fe67dfce162038b912f35011c8354dc72ba5339", "committedDate": "2020-09-13 19:16:40 -0500", "message": "NF: updateScreenCounts -> updateActionBar"}, {"oid": "721edd9f369640334bbf5cbb8047537a70d696d9", "committedDate": "2020-09-13 19:16:40 -0500", "message": "Previewer show deck name"}, {"oid": "8039a189ac17813fb0903a3318e2f52487ab683b", "committedDate": "2020-09-17 14:17:15 -0500", "message": "Reviewer buttons now respect safe display setting"}, {"oid": "5850b7e0240ccdf52e8f6f334eafc57463851998", "committedDate": "2020-09-21 10:24:18 -0500", "message": "NF: remove warning UnnecessaryLocalVariable"}, {"oid": "b6ab21bf0086676013450fb09eb786944aac4a4a", "committedDate": "2020-09-22 09:13:07 -0500", "message": "NF: represents counts as a class"}, {"oid": "1b167377ea83a0b25c42fb5f423977948861539c", "committedDate": "2020-09-22 09:13:07 -0500", "message": "NF: represent counts's index as enum"}, {"oid": "3763d6d0bc27900a9aa808f4b7fc3b3e68053d74", "committedDate": "2020-09-22 09:17:52 -0500", "message": "Enable TV Support for Reviewer"}, {"oid": "c55947a68e37e88503151a7121e68c4246ee281f", "committedDate": "2020-09-22 09:17:52 -0500", "message": "TV: Add Icons to Menu"}, {"oid": "c99c91041d851085d037fb39424c5f8545eb721d", "committedDate": "2020-09-22 09:17:52 -0500", "message": "Android TV: Work around AOSP Menu Bug"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "4935ac517deb2d784bba0a9f7793fd2e65f99712", "committedDate": "2020-09-23 11:19:42 -0500", "message": "NF: Sort imports"}, {"oid": "ae684d50cf1e4b84423f087dc1180c4dc1df90ed", "committedDate": "2020-09-24 00:20:35 -0500", "message": "Fix Dark Icons in Light Mode"}, {"oid": "9e4efa56d39ca2fdb5b0afac0747f807b91cba36", "committedDate": "2020-09-24 00:20:35 -0500", "message": "LINT: Improve compat - setIconTintList"}, {"oid": "975a902915821a23623b20e8daeff9fc681b92cd", "committedDate": "2020-09-24 09:30:56 -0500", "message": "NF: Remove warning about useless type in generic class constructors"}, {"oid": "42b92180120040299e590634f5b03d6f352c0a4f", "committedDate": "2020-09-24 11:41:08 -0500", "message": "NF: remove useless casts"}, {"oid": "0b23ca26293d5834775f39ede7dbd55c627fc3f6", "committedDate": "2020-09-30 10:51:24 -0500", "message": "NF: use enum for direction"}, {"oid": "ada67bc3d304193eab15d42badaafe9863d340cf", "committedDate": "2020-10-14 06:06:10 -0500", "message": "Adjust resoure reference usage to handle future non-final state"}, {"oid": "46075e2ccc93a40e3b64c39333263184f43fbe07", "committedDate": "2020-10-28 11:56:29 -0500", "message": "Add Card Info to Reviewer"}, {"oid": "9c8182dde2ed45a0c0de69214097ac10c85bd14a", "committedDate": "2020-11-09 13:08:37 -0500", "message": "Handle App.onCreate not executing after restore"}, {"oid": "d52c31b31ffa1d86ac35e18e0a1da13e225880c3", "committedDate": "2020-11-10 06:36:07 -0500", "message": "Undo in reviewer state what will be undone"}, {"oid": "f016ec5eff15092cddf94231d9028cb040128027", "committedDate": "2020-11-19 02:22:25 +0000", "message": "NF: editCard always return true"}, {"oid": "50ff61b7737d2b265e41d24d3a67f511957d6f56", "committedDate": "2020-11-20 07:28:46 -0500", "message": "Add Keyboard shortcut: Check Pronunciation"}, {"oid": "cce056d89cb1cc4176faf3a4b4be5f9bd8c31283", "committedDate": "2020-12-08 09:27:51 -0500", "message": "BugFix - Previewer: Display same card after edit"}, {"oid": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "committedDate": "2020-12-08 09:34:56 -0500", "message": "Persist Whiteboard Pen Color"}, {"oid": "7b607d2ee38fad34102f3dbc033e2b4d225e7943", "committedDate": "2020-12-08 13:07:30 -0500", "message": "NF: split AnswerCard in GetCard and GetAndAnswerCard"}, {"oid": "23158d37a7743112e6122fb67e0bfa8c618c1eb9", "committedDate": "2020-12-09 11:44:05 -0500", "message": "NF: avoid useless type conversion list to array"}, {"oid": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "committedDate": "2020-12-09 12:17:48 -0500", "message": "NF: Move static part of CollectionTask to other class"}, {"oid": "24443a327ed060dc31f4c16c88a3553d50d7ad05", "committedDate": "2020-12-09 13:40:58 -0500", "message": "Bump minSdkVersion to 21, purge related lower-API workarounds"}, {"oid": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: Add Type Task, type CollectionTask and TaskListener"}, {"oid": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "committedDate": "2020-12-12 17:14:13 -0500", "message": "Remove legacy Whiteboard settings (#7858)"}, {"oid": "34c87ba75f980d82cb215aa33293209f72ee8eed", "committedDate": "2020-12-13 08:30:34 -0500", "message": "NF: remove useless casts, and related warning"}, {"oid": "d3e0dcfd9db849d2093ce5ef0bc513ec11995f48", "committedDate": "2020-12-20 13:21:31 -0500", "message": "removed useless comments"}, {"oid": "be70f9ae13bac500a7454842faf27df9c7bd34bf", "committedDate": "2020-12-20 13:21:31 -0500", "message": "Togglewhiteboard: basic functionality seems to work"}, {"oid": "e034b3851f1b7de0f5864d3c7f830e19de4e5d87", "committedDate": "2021-01-23 14:59:29 -0500", "message": "A bit of misc cleanup"}, {"oid": "7459828a32d0713bea0fd427b78856ba701bf9db", "committedDate": "2021-01-28 09:17:50 -0500", "message": "Reviewer: Resume fullscreen after interaction"}, {"oid": "0b869c7bcd3aacfce7587704ba03f52b993979a7", "committedDate": "2021-03-24 14:32:35 -0500", "message": "Timber all exceptions catched not re-thrown"}, {"oid": "7351e8481615bb2edd181153a6d9db8c429cf776", "committedDate": "2021-03-28 20:38:59 +0200", "message": "fix: make undo icon in menus to be RTL compliant."}, {"oid": "a18fc25f8babb93ba73abcd9f30c6ab172793026", "committedDate": "2021-04-02 13:59:50 -0500", "message": "NF: Split Dismiss task"}, {"oid": "48eaec826892b940182fb6bdee7a53c2d44ea53e", "committedDate": "2021-04-02 13:59:50 -0500", "message": "NF: remove the enum DismissType"}, {"oid": "eb665dea6aebc138ab7dc773181c39e828efa90a", "committedDate": "2021-04-03 13:41:02 -0500", "message": "Call super method in DeckPicker.onRequestPermissionResult"}, {"oid": "2d344bfb26b7a97e3173c8db4461a0def36e496f", "committedDate": "2021-04-03 19:44:26 -0500", "message": "dynamically enable software render on all Reviewer and Info views"}, {"oid": "5fa8827e0503f775d81704868cbd20d64fe554b0", "committedDate": "2021-04-07 22:39:02 -0500", "message": "Reverse Activity transition for RTL language (#8470)"}, {"oid": "81aee9505593db591235e8744a3967c90cf89f98", "committedDate": "2021-04-07 23:29:23 -0500", "message": "infra: ignored tests: Audio Recording Shortcuts"}, {"oid": "164200255997ac4750493118c24cec649191b630", "committedDate": "2021-04-10 07:53:08 -0500", "message": "m prefix non-public, non-static fields #8387 (#8532)"}, {"oid": "a5a68b0fbecc837980174ca35f9ebf364ecc54b8", "committedDate": "2021-04-10 17:00:02 +0100", "message": "NF: @PluralRes on getToastResourceId"}, {"oid": "d8c66722e7c9fdabf35cfa795cdfc6a59ef66f88", "committedDate": "2021-04-23 22:59:42 -0500", "message": "NF: simplify ScheduleCollectionTaskListener"}, {"oid": "85c332ee3237b7aed14e006ef9609d708b96a514", "committedDate": "2021-04-23 22:59:42 -0500", "message": "NF: Remove a variable used a single time"}, {"oid": "0c544371db268cb520e1f89dbc7aa2f499153452", "committedDate": "2021-04-25 12:25:39 -0500", "message": "Convert google material design icons"}, {"oid": "a04e79f50575f3e05da488f7223b2f804508c325", "committedDate": "2021-04-29 18:02:58 -0500", "message": "NF: AnswerCardHandler is child"}, {"oid": "9ade194166473303cf9a42c89e05725fdcb792d1", "committedDate": "2021-04-29 18:05:29 -0500", "message": "NF: dismiss return whether the task succeeded"}, {"oid": "4fd0a2b6253f1650032d951b76d3591edbb13dd4", "committedDate": "2021-04-29 18:14:02 -0500", "message": "NF: simplify selectDeckFromExtra code"}, {"oid": "9b502cbacb9214632493abd30e118fb51080dc31", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize buryCard"}, {"oid": "6bf673072d8590c820098e2c61406db22697dc0d", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize suspendCard"}, {"oid": "1d13f5ab2491c1800eb91d27b31a9cd769e54bbf", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize suspendNote"}, {"oid": "eaf51cd53a6dc565b90352060116b87b84ff96fa", "committedDate": "2021-04-30 13:30:44 -0500", "message": "NF: factorize buryNote"}, {"oid": "910ed30408fcfd28b38e7ef5b9bd826db58b263a", "committedDate": "2021-05-01 09:14:17 -0500", "message": "Convert remaining PNG files to SVG where possible  (#8707)"}, {"oid": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "committedDate": "2021-05-01 16:33:55 -0500", "message": "WhiteBoard : Improve UX - color, width, (#8715)"}, {"oid": "42ab45ce31c43f8b9d05129303d42c1fb506b488", "committedDate": "2021-06-19 22:48:41 -0500", "message": "nf[Gestures]: extract fling gestures"}, {"oid": "eea1e3227805017d850cae48e16b636838666a4e", "committedDate": "2021-06-24 22:58:48 -0500", "message": "nf: refactor disableDrawerSwipeOnConflicts"}, {"oid": "0b1b8073eedff37982b2467a3575f4993138a27a", "committedDate": "2021-06-24 23:17:29 -0500", "message": "Added incon in action_bar overflow menu"}, {"oid": "f692b10de3bbc75e37075b4cc42b04cbada3bef6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename `other` to `value`"}, {"oid": "22e0854ccc348a1ac395e1b9a73245a34621545f", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename PairWithBoolean to Computation"}, {"oid": "8f423418a4b5aa3c754d94fdcf04017ea602894c", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: use getVlaue instead of mValue"}, {"oid": "259bc73dc31f3527d35c133dbc247b3c98517b7d", "committedDate": "2021-07-03 11:47:27 -0500", "message": "NF: SCREEN_MODE use constants"}, {"oid": "17fb1032c3fc622630c81405369093c8f5e8d841", "committedDate": "2021-07-16 12:24:15 -0500", "message": "nf: Add enum: FullScreenMode"}, {"oid": "94ae96cee6b95ac00282e1bfd885c387f1c3631a", "committedDate": "2021-07-16 12:24:15 -0500", "message": "fix: borders on fullscreen Reviewer"}, {"oid": "36f19cb5017f1707a1b8dafe5da300155dffbcdb", "committedDate": "2021-07-16 13:48:10 -0500", "message": "fix: reviewer fullscreen ui"}, {"oid": "341e453ae469ca14405ba54fdd79fc77b1eeef76", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on handlers"}, {"oid": "5dd818a24706a4d48efb901c525063be85a5de56", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on UI Visibility"}, {"oid": "37b924539e93597a65e7750bc260428b4837dced", "committedDate": "2021-08-04 20:45:34 -0500", "message": "feat: pink, turquoise & purple flags"}, {"oid": "7cb435f0c64462a623a603ff89ae275962952cb1", "committedDate": "2021-08-11 23:06:21 +0200", "message": "Implement onboarding for Reviewer"}, {"oid": "a607e46055ad967d587fb26b0c9a824759dfe3c4", "committedDate": "2021-08-18 16:12:27 -0500", "message": "Compat saveImage: return Uri instead path"}, {"oid": "060357b99f0cc510f319d3aa6f242c9783e3bffa", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf using strongly typed get_config"}, {"oid": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Extracted createInstance in a method of whiteboard"}, {"oid": "840dbe4dca484b8ef7baa5d5d4800f519f2c07f9", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Changed WeakReference to AnkiActivity in whiteboard to let other activities use whiteboard view"}, {"oid": "c965c7daafd716ee73dd8cd32c8152a48ebc1d5a", "committedDate": "2021-08-31 13:00:50 -0500", "message": "fix: Ignore key presses if answer field focused"}, {"oid": "65ce8b1286f936f3d1d106b68463dfa384918a3e", "committedDate": "2021-08-31 13:00:50 -0500", "message": "Remove duplicate preferences"}, {"oid": "8d4d9016057ed58e7d5b014b1b75734b467743fd", "committedDate": "2021-10-13 11:31:32 -0500", "message": "refactor: extract `Collection` to parameter"}, {"oid": "9b33f44fc864f1e61ac8e793d9ddc8f10f33ee7f", "committedDate": "2021-10-13 11:31:32 -0500", "message": "refactor: AnswerButtons"}, {"oid": "cf5458895631166c601720132a2caf533b31756e", "committedDate": "2021-10-14 09:13:56 -0500", "message": "feat(Auto-answer): allow user selection of action"}, {"oid": "562cfac72209132f9f22ff707276d0a46c3ecfbc", "committedDate": "2021-10-18 12:10:56 -0500", "message": "Computation: add \"out\" constraint"}, {"oid": "88740fa355e20096cdb620f5cf0f2f8caf5daec1", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert AnswerCardHandler async style"}, {"oid": "c88bc2e14bf2691c597b8702f701801c99632e2a", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert ScheduleCollectionTask async style"}, {"oid": "cb57ff16f3d8131cfd797b2e2f4a2771419adb9b", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert RescheduleRepositionReset async style"}, {"oid": "6aacb38fc115bfdf7c038f74aa0c9757ebf446a0", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert GetCard async style"}, {"oid": "a316393d837034884fd4ceacef44572111f93ea5", "committedDate": "2021-10-18 12:10:56 -0500", "message": "sched: Extract Next Card functionality to pair"}, {"oid": "a8f17f64771b79e8b83c8b1630f689594150d3e0", "committedDate": "2021-10-21 08:32:26 -0500", "message": "refactor: extract mSpeakText to mTTs.isEnabled"}, {"oid": "81d1d134863b8ab2c0560f9f11148b6a91996c0d", "committedDate": "2021-10-22 08:59:35 -0500", "message": "fix(handler): deprecation"}, {"oid": "7646ad4a7569b2c26a7f65ee3b6b3189ba99a035", "committedDate": "2021-10-23 07:55:39 -0500", "message": "refactor: extract AnswerTimer from CardViewer"}, {"oid": "d2d37ae3ae272200f73a75cb9b4966d423386c44", "committedDate": "2021-10-23 07:55:39 -0500", "message": "refactor: extract mAnswerTimer to Reviewer"}, {"oid": "e53370e6ea4a4fbf124e9e4056754791d6235589", "committedDate": "2021-10-24 09:29:13 -0500", "message": "refactor: extract EaseButton from CardViewer"}, {"oid": "8ffd19d6cac86d79d20c95a09c0dda83d121e1ee", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Whiteboard from CardViewer"}, {"oid": "f04ffba5fd4be1ad442bd4a1b012b99e13b3a0e5", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Audio Recorder from CardViewer"}, {"oid": "66300a61a4c91227423308b6492964a7403dd7eb", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract Flag/Mark from CardViewer"}, {"oid": "a56bd548e6d37bf1d9b746559b43b54198d1b9ca", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract toggleMark from CardViewer"}, {"oid": "1c0fa70b13d270cd2f230c0fb87d9e9347e75320", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract NoteService.isMarked"}, {"oid": "80b74bbed2198030c7823dcb4af2d1e83259ef1d", "committedDate": "2021-10-26 10:04:26 -0500", "message": "JS API to Kotlin"}, {"oid": "ae2b26febb9abb25861425e53f29854b24bef7e3", "committedDate": "2021-10-31 13:31:08 -0500", "message": "removed current card from constructor and access directly from activity"}, {"oid": "e599145b41d85b148286e920edd7a77cfd5c64f0", "committedDate": "2021-11-10 07:29:11 -0500", "message": "refactor: remove FunctionalInterfaces.Consumer"}, {"oid": "cffaf251d40be3c2e1babb28e06f37c5fde206e2", "committedDate": "2022-02-20 18:05:09 -0500", "message": "Remove lookup dictionary (#10341)"}, {"oid": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "committedDate": "2022-03-24 08:21:29 -0500", "message": "Rename Reviewer.java to .kt"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MzIzOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6233#discussion_r429163239", "body": "```suggestion\r\n    /** @return Whether there are strokes to undo */\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** @return Whethere there are strokes to undo */\n          \n          \n            \n                /** @return Whether there are strokes to undo */", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* @return <span class=\"x x-first x-last\">Whethere</span> there are strokes to undo <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-c\"><span class=\"pl-c\">/*</span>* @return <span class=\"x x-first x-last\">Whether</span> there are strokes to undo <span class=\"pl-c\">*/</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "david-allison-1", "createdAt": "2020-05-22T10:15:46Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -218,6 +218,11 @@ public int undoSize() {\n         return mUndo.size();\n     }\n \n+    /** @return Whethere there are strokes to undo */", "originalCommit": "14c9f6af08f3c6fc9b814c5be8636613b5a21496", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "500a421fd53021424407cb6fc519b47d2792521a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6ac1a424c..d74a28554 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -218,7 +218,7 @@ public class Whiteboard extends View {\n         return mUndo.size();\n     }\n \n-    /** @return Whethere there are strokes to undo */\n+    /** @return Whether there are strokes to undo */\n     public boolean undoEmpty() {\n         return mUndo.empty();\n     }\n", "next_change": {"commit": "c432c854a77f728bdec36e23c06f69fc02cc276a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex d74a28554..75e6d92ee 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -218,11 +218,6 @@ public class Whiteboard extends View {\n         return mUndo.size();\n     }\n \n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n     /**\n      * @return true if the undo queue has had any strokes added to it since the last clear\n      */\n", "next_change": {"commit": "5b805e62975071b7436f1eefc9ac17d771bc93eb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 75e6d92ee..d74a28554 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -218,6 +218,11 @@ public class Whiteboard extends View {\n         return mUndo.size();\n     }\n \n+    /** @return Whether there are strokes to undo */\n+    public boolean undoEmpty() {\n+        return mUndo.empty();\n+    }\n+\n     /**\n      * @return true if the undo queue has had any strokes added to it since the last clear\n      */\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "052b1c1a12e688f336d73647b68e27194ef049d3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6ac1a424c..d74a28554 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -218,7 +218,7 @@ public class Whiteboard extends View {\n         return mUndo.size();\n     }\n \n-    /** @return Whethere there are strokes to undo */\n+    /** @return Whether there are strokes to undo */\n     public boolean undoEmpty() {\n         return mUndo.empty();\n     }\n", "next_change": {"commit": "24a01ecfe55797fdb2011f49fb2c903b1528f075", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex d74a28554..94395fe77 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -211,12 +232,6 @@ public class Whiteboard extends View {\n         }\n     }\n \n-    /**\n-     * @return the number of strokes currently on the undo queue\n-     */\n-    public int undoSize() {\n-        return mUndo.size();\n-    }\n \n     /** @return Whether there are strokes to undo */\n     public boolean undoEmpty() {\n", "next_change": {"commit": "840dbe4dca484b8ef7baa5d5d4800f519f2c07f9", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 94395fe77..6b14ccbfe 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -227,8 +277,8 @@ public class Whiteboard extends View {\n     public void undo() {\n         mUndo.pop();\n         mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n+        if (undoEmpty() && mAnkiActivity != null) {\n+            mAnkiActivity.supportInvalidateOptionsMenu();\n         }\n     }\n \n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 6b14ccbfe..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,637 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-    @Nullable\n-    private static WhiteboardMultiTouchMethods mWhiteboardMultiTouchMethods;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final AnkiActivity mAnkiActivity;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    private final Boolean mHandleMultiTouch;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AnkiActivity activity, Boolean handleMultiTouch, boolean inverted) {\n-        super(activity, null);\n-\n-        mAnkiActivity = activity;\n-        mHandleMultiTouch = handleMultiTouch;\n-\n-        Button whitePenColorButton = activity.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = activity.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-            whitePenColorButton.setVisibility(View.GONE);\n-            blackPenColorButton.setOnClickListener(this::onClick);\n-            mForegroundColor = Color.BLACK;\n-        } else {\n-            blackPenColorButton.setVisibility(View.GONE);\n-            whitePenColorButton.setOnClickListener(this::onClick);\n-            mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = activity.findViewById(R.id.whiteboard_editor);\n-\n-        activity.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        activity.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        activity.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        activity.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        activity.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mAnkiActivity).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AnkiActivity context, boolean handleMultiTouch, @Nullable WhiteboardMultiTouchMethods whiteboardMultiTouchMethods) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(context);\n-        Whiteboard whiteboard = new Whiteboard(context, handleMultiTouch, isInNightMode(sharedPrefs));\n-\n-        mWhiteboardMultiTouchMethods = whiteboardMultiTouchMethods;\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = context.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mAnkiActivity != null) {\n-                            mAnkiActivity.supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (mHandleMultiTouch && event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mAnkiActivity != null) {\n-            mAnkiActivity.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mAnkiActivity != null) {\n-            mAnkiActivity.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mAnkiActivity != null) {\n-            mAnkiActivity.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            if (mSecondFingerWithinTapTolerance && mWhiteboardMultiTouchMethods != null) {\n-                mWhiteboardMultiTouchMethods.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            if (dy != 0 && mWhiteboardMultiTouchMethods != null) {\n-                mWhiteboardMultiTouchMethods.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mAnkiActivity, getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mAnkiActivity).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "052b1c1a12e688f336d73647b68e27194ef049d3", "message": "Merge commit", "committedDate": null}, {"oid": "5aca79273b4df934e30cd59ae1a6418d0de13ac9", "committedDate": "2020-06-01 17:28:09 -0500", "message": "Whiteboard: Continue Drawing if UI is shown"}, {"oid": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "committedDate": "2020-06-25 20:31:38 -0500", "message": "Save whiteboard while reviewing"}, {"oid": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "committedDate": "2020-06-28 11:48:26 -0500", "message": "Change whiteboard pen color while reviewing"}, {"oid": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "committedDate": "2020-08-23 16:11:57 -0500", "message": "NF: Use col's time instead of `new SystemTime`"}, {"oid": "3e8148c2deb5cea4afb1e7de2b7523d8f6244a91", "committedDate": "2020-08-30 18:24:56 -0500", "message": "Supress lint for Whiteboard View"}, {"oid": "bd2fb549a2e827068ae3d3bd03623d4a549fe16d", "committedDate": "2020-09-21 09:32:28 -0500", "message": "NF: remove useless mInvertedColors"}, {"oid": "bf209dc67aa56c94d84a173d10aa415fb4470aaf", "committedDate": "2020-09-21 09:32:28 -0500", "message": "NF: remove useless member mMonochrome"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "4935ac517deb2d784bba0a9f7793fd2e65f99712", "committedDate": "2020-09-23 11:19:42 -0500", "message": "NF: Sort imports"}, {"oid": "42b92180120040299e590634f5b03d6f352c0a4f", "committedDate": "2020-09-24 11:41:08 -0500", "message": "NF: remove useless casts"}, {"oid": "69dba64459dc466daad2d81012c55b9d66b721bb", "committedDate": "2020-10-02 11:17:10 -0500", "message": "API 29 Dependency Updates (#7332)"}, {"oid": "ada67bc3d304193eab15d42badaafe9863d340cf", "committedDate": "2020-10-14 06:06:10 -0500", "message": "Adjust resoure reference usage to handle future non-final state"}, {"oid": "2ca67492ab0086e02e9fecc9085102399e6cfdec", "committedDate": "2020-12-08 09:34:56 -0500", "message": "TEST: Add tests for getForegroundColor"}, {"oid": "24a01ecfe55797fdb2011f49fb2c903b1528f075", "committedDate": "2020-12-08 09:34:56 -0500", "message": "LINT: Fix Whiteboard Lint Errors"}, {"oid": "9597e35418e8923a12cfe5915dad2f71fa4d5aa5", "committedDate": "2020-12-08 09:34:56 -0500", "message": "NF: Extract setPenColor"}, {"oid": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "committedDate": "2020-12-08 09:34:56 -0500", "message": "Persist Whiteboard Pen Color"}, {"oid": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "committedDate": "2020-12-12 17:14:13 -0500", "message": "Remove legacy Whiteboard settings (#7858)"}, {"oid": "591407338b226ecadd93f33446a807514d228d0f", "committedDate": "2021-03-03 15:52:33 -0500", "message": "Add support for S Pen erase to whiteboard (#8138)"}, {"oid": "164200255997ac4750493118c24cec649191b630", "committedDate": "2021-04-10 07:53:08 -0500", "message": "m prefix non-public, non-static fields #8387 (#8532)"}, {"oid": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "committedDate": "2021-05-01 16:33:55 -0500", "message": "WhiteBoard : Improve UX - color, width, (#8715)"}, {"oid": "b6ccfd9aae9721a40f121a06979bfc80ec1c49cc", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: extract DisplayUtils.getDisplayDimensions"}, {"oid": "9bdf38906bd7954fd443bf92de4199f42a00c1d6", "committedDate": "2021-08-08 13:20:25 -0500", "message": "Use MediaStore to save whiteboard for API > 28"}, {"oid": "a607e46055ad967d587fb26b0c9a824759dfe3c4", "committedDate": "2021-08-18 16:12:27 -0500", "message": "Compat saveImage: return Uri instead path"}, {"oid": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Extracted createInstance in a method of whiteboard"}, {"oid": "840dbe4dca484b8ef7baa5d5d4800f519f2c07f9", "committedDate": "2021-08-25 08:52:08 -0500", "message": "Changed WeakReference to AnkiActivity in whiteboard to let other activities use whiteboard view"}, {"oid": "250097f54e0bf28371770275b613bc0e5e5b3248", "committedDate": "2021-08-27 08:15:20 -0500", "message": "nf: Avoid use of field prefixes for variable names"}, {"oid": "e546c9ac7bfc2d33afee48da4e3e77666a438149", "committedDate": "2021-08-27 08:19:38 -0500", "message": "nf: Use isEmpty in place of checking size to be zero when possible"}, {"oid": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "committedDate": "2021-10-09 16:59:56 -0500", "message": "Rename Whiteboard.java to .kt"}]}, {"oid": "500a421fd53021424407cb6fc519b47d2792521a", "url": "https://github.com/ankidroid/Anki-Android/commit/500a421fd53021424407cb6fc519b47d2792521a", "message": "NF: factorize undoEnabled", "committedDate": "2020-05-22T18:51:12Z", "type": "forcePushed"}, {"oid": "c432c854a77f728bdec36e23c06f69fc02cc276a", "url": "https://github.com/ankidroid/Anki-Android/commit/c432c854a77f728bdec36e23c06f69fc02cc276a", "message": "NF: factorize undoIcon", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "4df47eb1e552de1918c80651163b11efe103c10f", "url": "https://github.com/ankidroid/Anki-Android/commit/4df47eb1e552de1918c80651163b11efe103c10f", "message": "NF: Factorize undoEnabled", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "2ce9d1bd6d39e24167496c73981e94b9fa614699", "url": "https://github.com/ankidroid/Anki-Android/commit/2ce9d1bd6d39e24167496c73981e94b9fa614699", "message": "NF: Factorize undoIcon", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "f741531f20a1adc0989ebc078c502802e18b10df", "url": "https://github.com/ankidroid/Anki-Android/commit/f741531f20a1adc0989ebc078c502802e18b10df", "message": "NF: Factorize undoEnabled", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "961752b37709879baf096e59839cc809791e80a6", "url": "https://github.com/ankidroid/Anki-Android/commit/961752b37709879baf096e59839cc809791e80a6", "message": "UndoStack.empty()", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "5b805e62975071b7436f1eefc9ac17d771bc93eb", "url": "https://github.com/ankidroid/Anki-Android/commit/5b805e62975071b7436f1eefc9ac17d771bc93eb", "message": "whiteboard: undoEmpty", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "180011e78b8ea800f39377a521fbef622cea0c59", "url": "https://github.com/ankidroid/Anki-Android/commit/180011e78b8ea800f39377a521fbef622cea0c59", "message": "NF: Factorize whiteboard undos\n\nNote that !mWhiteboard.undoEmpty() implies\nmWhiteboard.isUndoModeActive(), so the code actions is not changed\n\nThere are four cases to consider:\n\n* Either there is no white board shown; in which case we go to the\n\"else\" part of the code, as before\n* Either there is a whiteboard, but no stroke has ever been made. In\n  the previous code, both condition fails. In the new code, the first\n  condition fails. In both case, we go to the else part of the code.\n* Either there is some actions to undo; in which case in the previous\n  code, the first condition is satisfied; in the new code the first\n  and the second conditions are satisfied; so in both case we execute:\n  ```\n            undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n            undoEnabled = true;\n```\n* Either strokes have been made, and all have been undone. In this\ncase, in the previous code the first condition fail and the second\nsuceed. In the new code the first condition succeed and the second\nfail. In both case, we execute:\n```\n            undoIcon = R.drawable.ic_eraser_variant_white_24dp;\n            undoEnabled = false;\n```", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "9072e73998718d4563bea3859fc52fe43d0befce", "url": "https://github.com/ankidroid/Anki-Android/commit/9072e73998718d4563bea3859fc52fe43d0befce", "message": "NF: factorize undoIcon", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "a12a4c8a5138295576be3a2849af1737ff0a2891", "url": "https://github.com/ankidroid/Anki-Android/commit/a12a4c8a5138295576be3a2849af1737ff0a2891", "message": "NF: factorize undoEnabled", "committedDate": "2020-05-22T19:28:55Z", "type": "commit"}, {"oid": "a12a4c8a5138295576be3a2849af1737ff0a2891", "url": "https://github.com/ankidroid/Anki-Android/commit/a12a4c8a5138295576be3a2849af1737ff0a2891", "message": "NF: factorize undoEnabled", "committedDate": "2020-05-22T19:28:55Z", "type": "forcePushed"}]}