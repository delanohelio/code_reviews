{"pr_number": 6362, "pr_title": "Improve Card Browser Performance: Time to view first card", "pr_author": "Arthur-Milchior", "pr_createdAt": "2020-06-04T20:26:17Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6362", "merge_commit": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MTU2NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435541565", "body": "You can remove this comment now", "bodyText": "You can remove this comment now", "bodyHTML": "<p dir=\"auto\">You can remove this comment now</p>", "author": "david-allison-1", "createdAt": "2020-06-04T20:51:57Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java", "diffHunk": "@@ -1003,81 +998,4 @@ public static Integer ordForMid(Collection col, Map<Long, Integer> fields, long\n      * The methods below are not in LibAnki.", "originalCommit": "3b638b1e5356ea1642c12d14b517aec3b13c5c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0OTMxNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435549315", "bodyText": "Right.\u00a0I didn't pay attention to it", "author": "Arthur-Milchior", "createdAt": "2020-06-04T21:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MTU2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fb983f23d1bdd251c2d5c8e28e1970ef5cbc0571", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\nindex 63c1a7bca..654c54a46 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n", "chunk": "@@ -992,10 +992,4 @@ public class Finder {\n         }\n         return dupes;\n     }\n-\n-    /*\n-     * ***********************************************************\n-     * The methods below are not in LibAnki.\n-     * ***********************************************************\n-     */\n }\n", "next_change": {"commit": "783609ad81e5b933cd8b93bdc4a5d8ed0596029e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\nindex 654c54a46..7d7c789ad 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n", "chunk": "@@ -992,4 +997,86 @@ public class Finder {\n         }\n         return dupes;\n     }\n+\n+    /*\n+     * ***********************************************************\n+     * The methods below are not in LibAnki.\n+     * ***********************************************************\n+     */\n+\n+    public List<Map<String, String>> findCardsForCardBrowser(String query, boolean _order) {\n+        return _findCardsForCardBrowser(query, _order);\n+    }\n+\n+\n+    public List<Map<String, String>> findCardsForCardBrowser(String query, String _order) {\n+        return _findCardsForCardBrowser(query, _order);\n+    }\n+\n+\n+    /** Return a list of card ids for QUERY */\n+    private List<Map<String, String>> _findCardsForCardBrowser(String query, Object _order) {\n+        String[] tokens = _tokenize(query);\n+        Pair<String, String[]> res1 = _where(tokens);\n+        String preds = res1.first;\n+        String[] args = res1.second;\n+        List<Map<String, String>> res = new ArrayList<>();\n+        if (preds == null) {\n+            return res;\n+        }\n+        Pair<String, Boolean> res2 = _order instanceof Boolean ? _order((Boolean) _order) : _order((String) _order);\n+        String order = res2.first;\n+        boolean rev = res2.second;\n+        String sql = _queryForCardBrowser(preds, order);\n+        try (Cursor cur = mCol.getDb().getDatabase().query(sql, args)) {\n+            CollectionTask task = CollectionTask.getInstance();\n+            while (cur.moveToNext()) {\n+                // cancel if the launching task was cancelled. \n+                if (task.isCancelled()){\n+                    Timber.i(\"_findCardsForCardBrowser() cancelled...\");\n+                    return new ArrayList<>();\n+                }                \n+                Map<String, String> card = new HashMap<>();\n+                card.put(CardBrowser.ID, cur.getString(0));\n+                card.put(CardBrowser.SFLD, cur.getString(1));\n+                long did = cur.getLong(2);\n+                card.put(CardBrowser.DECK, mCol.getDecks().name(did));\n+                int queue = cur.getInt(3);\n+                String tags = cur.getString(4);\n+                card.put(CardBrowser.TAGS, tags);\n+                res.add(card);\n+                // add placeholder for question and answer\n+                card.put(CardBrowser.QUESTION, null);\n+                card.put(CardBrowser.ANSWER, null);\n+                card.put(CardBrowser.FLAGS, (new Integer(Card.intToFlag(cur.getInt(5)))).toString());\n+                card.put(CardBrowser.SUSPENDED, queue == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n+            }\n+        } catch (SQLException e) {\n+            // invalid grouping\n+            Timber.e(\"Invalid grouping, sql: \" + sql);\n+            return new ArrayList<>();\n+        }\n+        if (rev) {\n+            Collections.reverse(res);\n+        }\n+        return res;\n+    }\n+    \n+    /**\n+     * A copy of _query() with a custom SQL query specific to the AnkiDroid card browser.\n+     */\n+    private String _queryForCardBrowser(String preds, String order) {\n+        String sql = \"select c.id, n.sfld, c.did, c.queue, n.tags, c.flags from cards c, notes n where c.nid=n.id and \";\n+        // combine with preds\n+        if (!TextUtils.isEmpty(preds)) {\n+            sql += \"(\" + preds + \")\";\n+        } else {\n+            sql += \"1\";\n+        }\n+        // order\n+        if (!TextUtils.isEmpty(order)) {\n+            sql += \" \" + order;\n+        }\n+        return sql;\n+    }\n }\n", "next_change": {"commit": "baa0ac4c03547dec5b71c44cf30a88b79cac434a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\nindex 7d7c789ad..654c54a46 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n", "chunk": "@@ -997,86 +992,4 @@ public class Finder {\n         }\n         return dupes;\n     }\n-\n-    /*\n-     * ***********************************************************\n-     * The methods below are not in LibAnki.\n-     * ***********************************************************\n-     */\n-\n-    public List<Map<String, String>> findCardsForCardBrowser(String query, boolean _order) {\n-        return _findCardsForCardBrowser(query, _order);\n-    }\n-\n-\n-    public List<Map<String, String>> findCardsForCardBrowser(String query, String _order) {\n-        return _findCardsForCardBrowser(query, _order);\n-    }\n-\n-\n-    /** Return a list of card ids for QUERY */\n-    private List<Map<String, String>> _findCardsForCardBrowser(String query, Object _order) {\n-        String[] tokens = _tokenize(query);\n-        Pair<String, String[]> res1 = _where(tokens);\n-        String preds = res1.first;\n-        String[] args = res1.second;\n-        List<Map<String, String>> res = new ArrayList<>();\n-        if (preds == null) {\n-            return res;\n-        }\n-        Pair<String, Boolean> res2 = _order instanceof Boolean ? _order((Boolean) _order) : _order((String) _order);\n-        String order = res2.first;\n-        boolean rev = res2.second;\n-        String sql = _queryForCardBrowser(preds, order);\n-        try (Cursor cur = mCol.getDb().getDatabase().query(sql, args)) {\n-            CollectionTask task = CollectionTask.getInstance();\n-            while (cur.moveToNext()) {\n-                // cancel if the launching task was cancelled. \n-                if (task.isCancelled()){\n-                    Timber.i(\"_findCardsForCardBrowser() cancelled...\");\n-                    return new ArrayList<>();\n-                }                \n-                Map<String, String> card = new HashMap<>();\n-                card.put(CardBrowser.ID, cur.getString(0));\n-                card.put(CardBrowser.SFLD, cur.getString(1));\n-                long did = cur.getLong(2);\n-                card.put(CardBrowser.DECK, mCol.getDecks().name(did));\n-                int queue = cur.getInt(3);\n-                String tags = cur.getString(4);\n-                card.put(CardBrowser.TAGS, tags);\n-                res.add(card);\n-                // add placeholder for question and answer\n-                card.put(CardBrowser.QUESTION, null);\n-                card.put(CardBrowser.ANSWER, null);\n-                card.put(CardBrowser.FLAGS, (new Integer(Card.intToFlag(cur.getInt(5)))).toString());\n-                card.put(CardBrowser.SUSPENDED, queue == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n-            }\n-        } catch (SQLException e) {\n-            // invalid grouping\n-            Timber.e(\"Invalid grouping, sql: \" + sql);\n-            return new ArrayList<>();\n-        }\n-        if (rev) {\n-            Collections.reverse(res);\n-        }\n-        return res;\n-    }\n-    \n-    /**\n-     * A copy of _query() with a custom SQL query specific to the AnkiDroid card browser.\n-     */\n-    private String _queryForCardBrowser(String preds, String order) {\n-        String sql = \"select c.id, n.sfld, c.did, c.queue, n.tags, c.flags from cards c, notes n where c.nid=n.id and \";\n-        // combine with preds\n-        if (!TextUtils.isEmpty(preds)) {\n-            sql += \"(\" + preds + \")\";\n-        } else {\n-            sql += \"1\";\n-        }\n-        // order\n-        if (!TextUtils.isEmpty(order)) {\n-            sql += \" \" + order;\n-        }\n-        return sql;\n-    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\nindex 63c1a7bca..654c54a46 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n", "chunk": "@@ -992,10 +992,4 @@ public class Finder {\n         }\n         return dupes;\n     }\n-\n-    /*\n-     * ***********************************************************\n-     * The methods below are not in LibAnki.\n-     * ***********************************************************\n-     */\n }\n", "next_change": {"commit": "b5706047c87060370d8fbb7cc23b3fc872103b57", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java b/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\ndeleted file mode 100644\nindex 654c54a46..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java\n+++ /dev/null\n", "chunk": "@@ -1,995 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2012 Norbert Nagold <norbert.nagold@gmail.com>                         *\n- * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Houssam Salem <houssam.salem.au@gmail.com>                        *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-\n-package com.ichi2.libanki;\n-\n-import android.database.Cursor;\n-import android.database.SQLException;\n-import android.text.TextUtils;\n-\n-import android.util.Pair;\n-\n-import com.ichi2.anki.CardBrowser;\n-import com.ichi2.async.CollectionTask;\n-\n-import com.ichi2.utils.JSONArray;\n-import com.ichi2.utils.JSONObject;\n-\n-import java.text.Normalizer;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeMap;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import timber.log.Timber;\n-\n-@SuppressWarnings({\"PMD.ExcessiveClassLength\", \"PMD.AvoidThrowingRawExceptionTypes\",\"PMD.AvoidReassigningParameters\",\"PMD.NPathComplexity\",\"PMD.MethodNamingConventions\"})\n-public class Finder {\n-\n-    private static final Pattern fPropPattern = Pattern.compile(\"(^.+?)(<=|>=|!=|=|<|>)(.+?$)\");\n-    private static final Pattern fNidsPattern = Pattern.compile(\"[^0-9,]\");\n-    private static final Pattern fMidPattern = Pattern.compile(\"[^0-9]\");\n-\n-    private Collection mCol;\n-\n-\n-    public Finder(Collection col) {\n-        mCol = col;\n-    }\n-\n-\n-    /*\n-     * NOTE: The python version of findCards can accept a boolean, a string, or no value for the _order parameter. The\n-     * type of _order also determines which _order() method is used. To maintain type safety, we expose the three valid\n-     * options here and safely type-cast accordingly at run-time.\n-     */\n-\n-    /** Return a list of card ids for QUERY */\n-    public List<Long> findCards(String query, String _order) {\n-        return _findCards(query, _order);\n-    }\n-\n-\n-    public List<Long> findCards(String query, boolean _order) {\n-        return _findCards(query, _order);\n-    }\n-\n-\n-    private List<Long> _findCards(String query, Object _order) {\n-        String[] tokens = _tokenize(query);\n-        Pair<String, String[]> res1 = _where(tokens);\n-        String preds = res1.first;\n-        String[] args = res1.second;\n-        List<Long> res = new ArrayList<>();\n-        if (preds == null) {\n-            return res;\n-        }\n-        Pair<String, Boolean> res2 = _order instanceof Boolean ? _order((Boolean) _order) : _order((String) _order);\n-        String order = res2.first;\n-        boolean rev = res2.second;\n-        String sql = _query(preds, order);\n-        try (Cursor cur = mCol.getDb().getDatabase().query(sql, args)) {\n-            while (cur.moveToNext()) {\n-                res.add(cur.getLong(0));\n-            }\n-        } catch (SQLException e) {\n-            // invalid grouping\n-            return new ArrayList<>();\n-        }\n-        if (rev) {\n-            Collections.reverse(res);\n-        }\n-        return res;\n-    }\n-\n-\n-    public List<Long> findNotes(String query) {\n-        String[] tokens = _tokenize(query);\n-        Pair<String, String[]> res1 = _where(tokens);\n-        String preds = res1.first;\n-        String[] args = res1.second;\n-        List<Long> res = new ArrayList<>();\n-        if (preds == null) {\n-            return res;\n-        }\n-        if (\"\".equals(preds)) {\n-            preds = \"1\";\n-        } else {\n-            preds = \"(\" + preds + \")\";\n-        }\n-        String sql = \"select distinct(n.id) from cards c, notes n where c.nid=n.id and \" + preds;\n-        try (Cursor cur = mCol.getDb().getDatabase().query(sql, args)) {\n-            while (cur.moveToNext()) {\n-                res.add(cur.getLong(0));\n-            }\n-        } catch (SQLException e) {\n-            // invalid grouping\n-            return new ArrayList<>();\n-        }\n-        return res;\n-    }\n-\n-\n-    /**\n-     * Tokenizing\n-     * ***********************************************************\n-     */\n-\n-    public String[] _tokenize(String query) {\n-        char inQuote = 0;\n-        List<String> tokens = new ArrayList<>();\n-        String token = \"\";\n-        for (int i = 0; i < query.length(); ++i) {\n-            // quoted text\n-            char c = query.charAt(i);\n-            if (c == '\\'' || c == '\"') {\n-                if (inQuote != 0) {\n-                    if (c == inQuote) {\n-                        inQuote = 0;\n-                    } else {\n-                        token += c;\n-                    }\n-                } else if (token.length() != 0) {\n-                    // quotes are allowed to start directly after a :\n-                    if (token.endsWith(\":\")) {\n-                        inQuote = c;\n-                    } else {\n-                        token += c;\n-                    }\n-                } else {\n-                    inQuote = c;\n-                }\n-                // separator\n-            } else if (c == ' ') {\n-                if (inQuote != 0) {\n-                    token += c;\n-                } else if (token.length() != 0) {\n-                    // space marks token finished\n-                    tokens.add(token);\n-                    token = \"\";\n-                }\n-                // nesting\n-            } else if (c == '(' || c == ')') {\n-                if (inQuote != 0) {\n-                    token += c;\n-                } else {\n-                    if (c == ')' && token.length() != 0) {\n-                        tokens.add(token);\n-                        token = \"\";\n-                    }\n-                    tokens.add(String.valueOf(c));\n-                }\n-                // negation\n-            } else if (c == '-') {\n-                if (token.length() != 0) {\n-                    token += c;\n-                } else if (tokens.size() == 0 || !\"-\".equals(tokens.get(tokens.size() - 1))) {\n-                    tokens.add(\"-\");\n-                }\n-                // normal character\n-            } else {\n-                token += c;\n-            }\n-        }\n-        // if we finished in a token, add it\n-        if (token.length() != 0) {\n-            tokens.add(token);\n-        }\n-        return tokens.toArray(new String[tokens.size()]);\n-    }\n-\n-\n-    /**\n-     * Query building\n-     * ***********************************************************\n-     */\n-\n-    /**\n-     * LibAnki creates a dictionary and operates on it with an inner function inside _where().\n-     * AnkiDroid combines the two in this class instead.\n-     */\n-    public class SearchState {\n-        public boolean isnot;\n-        public boolean isor;\n-        public boolean join;\n-        public String q = \"\";\n-        public boolean bad;\n-        \n-        public void add(String txt) {\n-            add(txt, true);\n-        }\n-\n-        public void add(String txt, boolean wrap) {\n-            // failed command?\n-            if (TextUtils.isEmpty(txt)) {\n-                // if it was to be negated then we can just ignore it\n-                if (isnot) {\n-                    isnot = false;\n-                    return;\n-                } else {\n-                    bad = true;\n-                    return;\n-                }\n-            } else if (\"skip\".equals(txt)) {\n-                return;\n-            }\n-            // do we need a conjunction?\n-            if (join) {\n-                if (isor) {\n-                    q += \" or \";\n-                    isor = false;\n-                } else {\n-                    q += \" and \";\n-                }\n-            }\n-            if (isnot) {\n-                q += \" not \";\n-                isnot = false;\n-            }\n-            if (wrap) {\n-                txt = \"(\" + txt + \")\";\n-            }\n-            q += txt;\n-            join = true;\n-        }\n-    }\n-\n-\n-    private Pair<String, String[]> _where(String[] tokens) {\n-        // state and query\n-        SearchState s = new SearchState();\n-        List<String> args = new ArrayList<>();\n-        for (String token : tokens) {\n-            if (s.bad) {\n-                return new Pair<>(null, null);\n-            }\n-            // special tokens\n-            if (\"-\".equals(token)) {\n-                s.isnot = true;\n-            } else if (\"or\".equalsIgnoreCase(token)) {\n-                s.isor = true;\n-            } else if (\"(\".equals(token)) {\n-                s.add(token, false);\n-                s.join = false;\n-            } else if (\")\".equals(token)) {\n-                s.q += \")\";\n-                // commands\n-            } else if (token.contains(\":\")) {\n-                String[] spl = token.split(\":\", 2);\n-                String cmd = spl[0].toLowerCase(Locale.US);\n-                String val = spl[1];\n-                \n-                if (\"added\".equals(cmd)) {\n-                    s.add(_findAdded(val));\n-                } else if (\"card\".equals(cmd)) {\n-                    s.add(_findTemplate(val));\n-                } else if (\"deck\".equals(cmd)) {\n-                    s.add(_findDeck(val));\n-                } else if (\"flag\".equals(cmd)) {\n-                    s.add(_findFlag(val));\n-                } else if (\"mid\".equals(cmd)) {\n-                    s.add(_findMid(val));\n-                } else if (\"nid\".equals(cmd)) {\n-                    s.add(_findNids(val));\n-                } else if (\"cid\".equals(cmd)) {\n-                    s.add(_findCids(val));\n-                } else if (\"note\".equals(cmd)) {\n-                    s.add(_findModel(val));\n-                } else if (\"prop\".equals(cmd)) {\n-                    s.add(_findProp(val));\n-                } else if (\"rated\".equals(cmd)) {\n-                    s.add(_findRated(val));\n-                } else if (\"tag\".equals(cmd)) {\n-                    s.add(_findTag(val, args));\n-                } else if (\"dupe\".equals(cmd)) {\n-                    s.add(_findDupes(val));\n-                } else if (\"is\".equals(cmd)) {\n-                    s.add(_findCardState(val));\n-                } else {\n-                    s.add(_findField(cmd, val));\n-                }\n-            // normal text search\n-            } else {\n-                s.add(_findText(token, args));\n-            }\n-        }\n-        if (s.bad) {\n-            return new Pair<>(null, null);\n-        }\n-        return new Pair<>(s.q, args.toArray(new String[args.size()]));\n-    }\n-\n-\n-    private String _query(String preds, String order) {\n-        // can we skip the note table?\n-        String sql;\n-        if (!preds.contains(\"n.\") && !order.contains(\"n.\")) {\n-            sql = \"select c.id from cards c where \";\n-        } else {\n-            sql = \"select c.id from cards c, notes n where c.nid=n.id and \";\n-        }\n-        // combine with preds\n-        if (!TextUtils.isEmpty(preds)) {\n-            sql += \"(\" + preds + \")\";\n-        } else {\n-            sql += \"1\";\n-        }\n-        // order\n-        if (!TextUtils.isEmpty(order)) {\n-            sql += \" \" + order;\n-        }\n-        return sql;\n-    }\n-\n-\n-    /**\n-     * Ordering\n-     * ***********************************************************\n-     */\n-\n-    /*\n-     * NOTE: In the python code, _order() follows a code path based on:\n-     * - Empty order string (no order)\n-     * - order = False (no order)\n-     * - Non-empty order string (custom order)\n-     * - order = True (built-in order)\n-     * The python code combines all code paths in one function. In Java, we must overload the method\n-     * in order to consume either a String (no order, custom order) or a Boolean (no order, built-in order).\n-     */\n-    \n-    private Pair<String, Boolean> _order(String order) {\n-        if (TextUtils.isEmpty(order)) {\n-            return _order(false);\n-        } else {\n-            // custom order string provided\n-            return new Pair<>(\" order by \" + order, false);\n-        }\n-    }\n-    \n-    private Pair<String, Boolean> _order(Boolean order) {\n-        if (!order) {\n-            return new Pair<>(\"\", false);\n-        }\n-        // use deck default\n-        String type = mCol.getConf().getString(\"sortType\");\n-        String sort = null;\n-        if (type.startsWith(\"note\")) {\n-            if (type.startsWith(\"noteCrt\")) {\n-                sort = \"n.id, c.ord\";\n-            } else if (type.startsWith(\"noteMod\")) {\n-                sort = \"n.mod, c.ord\";\n-            } else if (type.startsWith(\"noteFld\")) {\n-                sort = \"n.sfld COLLATE NOCASE, c.ord\";\n-            }\n-        } else if (type.startsWith(\"card\")) {\n-            if (type.startsWith(\"cardMod\")) {\n-                sort = \"c.mod\";\n-            } else if (type.startsWith(\"cardReps\")) {\n-                sort = \"c.reps\";\n-            } else if (type.startsWith(\"cardDue\")) {\n-                sort = \"c.type, c.due\";\n-            } else if (type.startsWith(\"cardEase\")) {\n-                sort = \"c.type == \" + Consts.CARD_TYPE_NEW + \", c.factor\";\n-            } else if (type.startsWith(\"cardLapses\")) {\n-                sort = \"c.lapses\";\n-            } else if (type.startsWith(\"cardIvl\")) {\n-                sort = \"c.ivl\";\n-            }\n-        }\n-        if (sort == null) {\n-            // deck has invalid sort order; revert to noteCrt\n-            sort = \"n.id, c.ord\";\n-        }\n-        boolean sortBackwards = mCol.getConf().getBoolean(\"sortBackwards\");\n-        return new Pair<>(\" ORDER BY \" + sort, sortBackwards);\n-    }\n-\n-\n-    /**\n-     * Commands\n-     * ***********************************************************\n-     */\n-\n-    private String _findTag(String val, List<String> args) {\n-        if (\"none\".equals(val)) {\n-            return \"n.tags = \\\"\\\"\";\n-        }\n-        val = val.replace(\"*\", \"%\");\n-        if (!val.startsWith(\"%\")) {\n-            val = \"% \" + val;\n-        }\n-        if (!val.endsWith(\"%\") || val.endsWith(\"\\\\%\")) {\n-            val += \" %\";\n-        }\n-        args.add(val);\n-        return \"n.tags like ? escape '\\\\'\";\n-    }\n-\n-\n-    private String _findCardState(String val) {\n-        int n;\n-        if (\"review\".equals(val) || \"new\".equals(val) || \"learn\".equals(val)) {\n-            if (\"review\".equals(val)) {\n-                n = 2;\n-            } else if (\"new\".equals(val)) {\n-                n = 0;\n-            } else {\n-                return \"queue IN (1, \" + Consts.QUEUE_TYPE_DAY_LEARN_RELEARN + \")\";\n-            }\n-            return \"type = \" + n;\n-        } else if (\"suspended\".equals(val)) {\n-            return \"c.queue = \" + Consts.QUEUE_TYPE_SUSPENDED;\n-        } else if (\"buried\".equals(val)) {\n-            return \"c.queue = \" + Consts.QUEUE_TYPE_SIBLING_BURIED;\n-        } else if (\"due\".equals(val)) {\n-            return \"(c.queue in (\" + Consts.QUEUE_TYPE_REV + \",\" + Consts.QUEUE_TYPE_DAY_LEARN_RELEARN + \") and c.due <= \" + mCol.getSched().getToday() +\n-                    \") or (c.queue = \" + Consts.QUEUE_TYPE_LRN + \" and c.due <= \" + mCol.getSched().getDayCutoff() + \")\";\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private String _findFlag(String val) {\n-        int flag;\n-        switch (val) {\n-        case \"0\":\n-            flag = 0;\n-            break;\n-        case \"1\":\n-            flag = 1;\n-            break;\n-        case \"2\":\n-            flag = 2;\n-            break;\n-        case \"3\":\n-            flag = 3;\n-            break;\n-        case \"4\":\n-            flag = 4;\n-            break;\n-        default:\n-            return null;\n-        }\n-        int mask = 0b111; // 2**3 -1 in Anki\n-        return \"(c.flags & \"+mask+\") == \" + flag;\n-    }\n-\n-    private String _findRated(String val) {\n-        // days(:optional_ease)\n-        String[] r = val.split(\":\");\n-        int days;\n-        try {\n-            days = Integer.parseInt(r[0]);\n-        } catch (NumberFormatException e) {\n-            return null;\n-        }\n-        days = Math.min(days, 31);\n-        // ease\n-        String ease = \"\";\n-        if (r.length > 1) {\n-            if (!Arrays.asList(\"1\", \"2\", \"3\", \"4\").contains(r[1])) {\n-                return null;\n-            }\n-            ease = \"and ease=\" + r[1];\n-        }\n-        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n-        return \"c.id in (select cid from revlog where id>\" + cutoff + \" \" + ease + \")\";\n-    }\n-\n-\n-    private String _findAdded(String val) {\n-        int days;\n-        try {\n-            days = Integer.parseInt(val);\n-        } catch (NumberFormatException e) {\n-            return null;\n-        }\n-        long cutoff = (mCol.getSched().getDayCutoff() - 86400 * days) * 1000;\n-        return \"c.id > \" + cutoff;\n-    }\n-\n-\n-    private String _findProp(String _val) {\n-        // extract\n-        Matcher m = fPropPattern.matcher(_val);\n-        if (!m.matches()) {\n-            return null;\n-        }\n-        String prop = m.group(1).toLowerCase(Locale.US);\n-        String cmp = m.group(2);\n-        String sval = m.group(3);\n-        int val;\n-        // is val valid?\n-        try {\n-            if (\"ease\".equals(prop)) {\n-                // LibAnki does this below, but we do it here to avoid keeping a separate float value.\n-                val = (int)(Double.parseDouble(sval) * 1000);\n-            } else {\n-                val = Integer.parseInt(sval);\n-            }\n-        } catch (NumberFormatException e) {\n-            return null;\n-        }\n-        // is prop valid?\n-        if (!Arrays.asList(\"due\", \"ivl\", \"reps\", \"lapses\", \"ease\").contains(prop)) {\n-            return null;\n-        }\n-        // query\n-        String q = \"\";\n-        if (\"due\".equals(prop)) {\n-            val += mCol.getSched().getToday();\n-            // only valid for review/daily learning\n-            q = \"(c.queue in (\" + Consts.QUEUE_TYPE_REV + \",\" + Consts.QUEUE_TYPE_DAY_LEARN_RELEARN + \")) and \";\n-        } else if (\"ease\".equals(prop)) {\n-            prop = \"factor\";\n-            // already done: val = int(val*1000)\n-        }\n-        q += \"(\" + prop + \" \" + cmp + \" \" + val + \")\";\n-        return q;\n-    }\n-\n-\n-    private String _findText(String val, List<String> args) {\n-        val = val.replace(\"*\", \"%\");\n-        args.add(\"%\" + val + \"%\");\n-        args.add(\"%\" + val + \"%\");\n-        return \"(n.sfld like ? escape '\\\\' or n.flds like ? escape '\\\\')\";\n-    }\n-\n-\n-    private String _findNids(String val) {\n-        if (fNidsPattern.matcher(val).find()) {\n-            return null;\n-        }\n-        return \"n.id in (\" + val + \")\";\n-    }\n-\n-\n-    private String _findCids(String val) {\n-        if (fNidsPattern.matcher(val).find()) {\n-            return null;\n-        }\n-        return \"c.id in (\" + val + \")\";\n-    }\n-\n-\n-    private String _findMid(String val) {\n-        if (fMidPattern.matcher(val).find()) {\n-            return null;\n-        }\n-        return \"n.mid = \" + val;\n-    }\n-\n-\n-    private String _findModel(String val) {\n-        LinkedList<Long> ids = new LinkedList<>();\n-        for (JSONObject m : mCol.getModels().all()) {\n-            String modelName = m.getString(\"name\");\n-            modelName = Normalizer.normalize(modelName, Normalizer.Form.NFC);\n-            if (modelName.equalsIgnoreCase(val)) {\n-                ids.add(m.getLong(\"id\"));\n-            }\n-        }\n-        return \"n.mid in \" + Utils.ids2str(ids);\n-    }\n-\n-\n-    private List<Long> dids(Long did) {\n-        if (did == null) {\n-            return null;\n-        }\n-        TreeMap<String, Long> children = mCol.getDecks().children(did);\n-        List<Long> res = new ArrayList<>();\n-        res.add(did);\n-        res.addAll(children.values());\n-        return res;\n-    }\n-\n-\n-    public String _findDeck(String val) {\n-        // if searching for all decks, skip\n-        if (\"*\".equals(val)) {\n-            return \"skip\";\n-            // deck types\n-        } else if (\"filtered\".equals(val)) {\n-            return \"c.odid\";\n-        }\n-        List<Long> ids = null;\n-        // current deck?\n-        if (\"current\".equalsIgnoreCase(val)) {\n-            ids = dids(mCol.getDecks().selected());\n-        } else if (!val.contains(\"*\")) {\n-            // single deck\n-            ids = dids(mCol.getDecks().id(val, false));\n-        } else {\n-            // wildcard\n-            ids = new ArrayList<>();\n-            val = val.replace(\"*\", \".*\");\n-            val = val.replace(\"+\", \"\\\\+\");\n-            for (JSONObject d : mCol.getDecks().all()) {\n-                String deckName = d.getString(\"name\");\n-                deckName = Normalizer.normalize(deckName, Normalizer.Form.NFC);\n-                if (deckName.matches(\"(?i)\" + val)) {\n-                    for (long id : dids(d.getLong(\"id\"))) {\n-                        if (!ids.contains(id)) {\n-                            ids.add(id);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if (ids == null || ids.size() == 0) {\n-            return null;\n-        }\n-        String sids = Utils.ids2str(ids);\n-        return \"c.did in \" + sids + \" or c.odid in \" + sids;\n-    }\n-\n-\n-    private String _findTemplate(String val) {\n-        // were we given an ordinal number?\n-        Integer num = null;\n-        try {\n-            num = Integer.parseInt(val) - 1;\n-        } catch (NumberFormatException e) {\n-            num = null;\n-        }\n-        if (num != null) {\n-            return \"c.ord = \" + num;\n-        }\n-        // search for template names\n-        List<String> lims = new ArrayList<>();\n-        for (JSONObject m : mCol.getModels().all()) {\n-            JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-            for (int ti = 0; ti < tmpls.length(); ++ti) {\n-                JSONObject t = tmpls.getJSONObject(ti);\n-                String templateName = t.getString(\"name\");\n-                Normalizer.normalize(templateName, Normalizer.Form.NFC);\n-                if (templateName.equalsIgnoreCase(val)) {\n-                    if (m.getInt(\"type\") == Consts.MODEL_CLOZE) {\n-                        // if the user has asked for a cloze card, we want\n-                        // to give all ordinals, so we just limit to the\n-                        // model instead\n-                        lims.add(\"(n.mid = \" + m.getLong(\"id\") + \")\");\n-                    } else {\n-                        lims.add(\"(n.mid = \" + m.getLong(\"id\") + \" and c.ord = \" +\n-                                t.getInt(\"ord\") + \")\");\n-                    }\n-                }\n-            }\n-        }\n-        return TextUtils.join(\" or \", lims.toArray(new String[lims.size()]));\n-    }\n-\n-\n-    private String _findField(String field, String val) {\n-        /*\n-         * We need two expressions to query the cards: One that will use JAVA REGEX syntax and another\n-         * that should use SQLITE LIKE clause syntax.\n-         */\n-        String sqlVal = val\n-                .replace(\"%\",\"\\\\%\") // For SQLITE, we escape all % signs\n-                .replace(\"*\",\"%\"); // And then convert the * into non-escaped % signs\n-\n-        /*\n-         * The following three lines make sure that only _ and * are valid wildcards.\n-         * Any other characters are enclosed inside the \\Q \\E markers, which force\n-         * all meta-characters in between them to lose their special meaning\n-         */\n-        String javaVal = val\n-                    .replace(\"_\",\"\\\\E.\\\\Q\")\n-                    .replace(\"*\",\"\\\\E.*\\\\Q\");\n-        /*\n-         * For the pattern, we use the javaVal expression that uses JAVA REGEX syntax\n-         */\n-        Pattern pattern = Pattern.compile(\"\\\\Q\" + javaVal + \"\\\\E\", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n-\n-        // find models that have that field\n-        Map<Long, Object[]> mods = new HashMap<>();\n-        for (JSONObject m : mCol.getModels().all()) {\n-            JSONArray flds = m.getJSONArray(\"flds\");\n-            for (int fi = 0; fi < flds.length(); ++fi) {\n-                JSONObject f = flds.getJSONObject(fi);\n-                String fieldName = f.getString(\"name\");\n-                fieldName = Normalizer.normalize(fieldName, Normalizer.Form.NFC);\n-                if (fieldName.equalsIgnoreCase(field)) {\n-                    mods.put(m.getLong(\"id\"), new Object[] { m, f.getInt(\"ord\") });\n-                }\n-            }\n-        }\n-        if (mods.isEmpty()) {\n-            // nothing has that field\n-            return null;\n-        }\n-        LinkedList<Long> nids = new LinkedList<>();\n-        try (Cursor cur = mCol.getDb().getDatabase().query(\n-                \"select id, mid, flds from notes where mid in \" +\n-                        Utils.ids2str(new LinkedList<>(mods.keySet())) +\n-                        \" and flds like ? escape '\\\\'\", new String[] {\"%\" + sqlVal + \"%\"})) {\n-            /*\n-             * Here we use the sqlVal expression, that is required for LIKE syntax in sqllite.\n-             * There is no problem with special characters, because only % and _ are special\n-             * characters in this syntax.\n-             */\n-\n-            while (cur.moveToNext()) {\n-                String[] flds = Utils.splitFields(cur.getString(2));\n-                int ord = (Integer)mods.get(cur.getLong(1))[1];\n-                String strg = flds[ord];\n-                if (pattern.matcher(strg).matches()) {\n-                    nids.add(cur.getLong(0));\n-                }\n-            }\n-        }\n-        if (nids.isEmpty()) {\n-            return \"0\";\n-        }\n-        return \"n.id in \" + Utils.ids2str(nids);\n-    }\n-\n-\n-    private String _findDupes(String val) {\n-        // caller must call stripHTMLMedia on passed val\n-        String[] split = val.split(\",\", 1);\n-        if (split.length != 2) {\n-            return null;\n-        }\n-        String mid = split[0];\n-        val = split[1];\n-        String csum = Long.toString(Utils.fieldChecksum(val));\n-        List<Long> nids = new ArrayList<>();\n-        try (Cursor cur = mCol.getDb().getDatabase().query(\n-                \"select id, flds from notes where mid=? and csum=?\",\n-                new String[] {mid, csum})) {\n-            long nid = cur.getLong(0);\n-            String flds = cur.getString(1);\n-            if (Utils.stripHTMLMedia(Utils.splitFields(flds)[0]).equals(val)) {\n-                nids.add(nid);\n-            }\n-        }\n-        return \"n.id in \" +  Utils.ids2str(nids);\n-    }\n-\n-\n-    /**\n-     * Find and replace\n-     * ***********************************************************\n-     */\n-\n-    /**\n-     * Find and replace fields in a note\n-     *\n-     * @param col The collection to search into.\n-     * @param nids The cards to be searched for.\n-     * @param src The original text to find.\n-     * @param dst The text to change to.\n-     * @return Number of notes with fields that were updated.\n-     */\n-    public static int findReplace(Collection col, List<Long> nids, String src, String dst) {\n-        return findReplace(col, nids, src, dst, false, null, true);\n-    }\n-\n-    /**\n-     * Find and replace fields in a note\n-     *\n-     * @param col The collection to search into.\n-     * @param nids The cards to be searched for.\n-     * @param src The original text to find.\n-     * @param dst The text to change to.\n-     * @param regex If true, the src is treated as a regex. Default = false.\n-     * @return Number of notes with fields that were updated.\n-     */\n-    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean regex) {\n-        return findReplace(col, nids, src, dst, regex, null, true);\n-    }\n-\n-    /**\n-     * Find and replace fields in a note\n-     *\n-     * @param col The collection to search into.\n-     * @param nids The cards to be searched for.\n-     * @param src The original text to find.\n-     * @param dst The text to change to.\n-     * @param field Limit the search to specific field. If null, it searches all fields.\n-     * @return Number of notes with fields that were updated.\n-     */\n-    public static int findReplace(Collection col, List<Long> nids, String src, String dst, String field) {\n-        return findReplace(col, nids, src, dst, false, field, true);\n-    }\n-\n-    /**\n-     * Find and replace fields in a note\n-     *\n-     * @param col The collection to search into.\n-     * @param nids The cards to be searched for.\n-     * @param src The original text to find.\n-     * @param dst The text to change to.\n-     * @param isRegex If true, the src is treated as a regex. Default = false.\n-     * @param field Limit the search to specific field. If null, it searches all fields.\n-     * @param fold If true the search is case-insensitive. Default = true.\n-     * @return Number of notes with fields that were updated. */\n-    public static int findReplace(Collection col, List<Long> nids, String src, String dst, boolean isRegex,\n-            String field, boolean fold) {\n-        Map<Long, Integer> mmap = new HashMap<>();\n-        if (field != null) {\n-            for (JSONObject m : col.getModels().all()) {\n-                JSONArray flds = m.getJSONArray(\"flds\");\n-                for (int fi = 0; fi < flds.length(); ++fi) {\n-                    JSONObject f = flds.getJSONObject(fi);\n-                    if (f.getString(\"name\").equalsIgnoreCase(field)) {\n-                        mmap.put(m.getLong(\"id\"), f.getInt(\"ord\"));\n-                    }\n-                }\n-            }\n-            if (mmap.isEmpty()) {\n-                return 0;\n-            }\n-        }\n-        // find and gather replacements\n-        if (!isRegex) {\n-            src = Pattern.quote(src);\n-            dst = dst.replace(\"\\\\\", \"\\\\\\\\\");\n-        }\n-        if (fold) {\n-            src = \"(?i)\" + src;\n-        }\n-        Pattern regex = Pattern.compile(src);\n-\n-        ArrayList<Object[]> d = new ArrayList<>();\n-        String snids = Utils.ids2str(nids);\n-        nids = new ArrayList<>();\n-        try (Cursor cur = col.getDb().getDatabase().query(\n-                \"select id, mid, flds from notes where id in \" + snids, null)) {\n-            while (cur.moveToNext()) {\n-                String flds = cur.getString(2);\n-                String origFlds = flds;\n-                // does it match?\n-                String[] sflds = Utils.splitFields(flds);\n-                if (field != null) {\n-                    long mid = cur.getLong(1);\n-                    if (!mmap.containsKey(mid)) {\n-                        // note doesn't have that field\n-                        continue;\n-                    }\n-                    int ord = mmap.get(mid);\n-                    sflds[ord] = regex.matcher(sflds[ord]).replaceAll(dst);\n-                } else {\n-                    for (int i = 0; i < sflds.length; ++i) {\n-                        sflds[i] = regex.matcher(sflds[i]).replaceAll(dst);\n-                    }\n-                }\n-                flds = Utils.joinFields(sflds);\n-                if (!flds.equals(origFlds)) {\n-                    long nid = cur.getLong(0);\n-                    nids.add(nid);\n-                    d.add(new Object[] { flds, Utils.intTime(), col.usn(), nid }); // order based on query below\n-                }\n-            }\n-        }\n-        if (d.isEmpty()) {\n-            return 0;\n-        }\n-        // replace\n-        col.getDb().executeMany(\"update notes set flds=?,mod=?,usn=? where id=?\", d);\n-        long[] pnids = Utils.toPrimitive(nids);\n-        col.updateFieldCache(pnids);\n-        col.genCards(pnids);\n-        return d.size();\n-    }\n-\n-\n-    public List<String> fieldNames(Collection col) {\n-        return fieldNames(col, true);\n-    }\n-\n-    public List<String> fieldNames(Collection col, boolean downcase) {\n-        Set<String> fields = new HashSet<>();\n-        List<String> names = new ArrayList<>();\n-        for (JSONObject m : col.getModels().all()) {\n-            JSONArray flds = m.getJSONArray(\"flds\");\n-            for (int fi = 0; fi < flds.length(); ++fi) {\n-                JSONObject f = flds.getJSONObject(fi);\n-                if (!fields.contains(f.getString(\"name\").toLowerCase(Locale.US))) {\n-                    names.add(f.getString(\"name\"));\n-                    fields.add(f.getString(\"name\").toLowerCase(Locale.US));\n-                }\n-            }\n-        }\n-        if (downcase) {\n-            return new ArrayList<>(fields);\n-        }\n-        return names;\n-    }\n-\n-\n-    /**\n-     * Find duplicates\n-     * ***********************************************************\n-     */\n-\n-    public static Integer ordForMid(Collection col, Map<Long, Integer> fields, long mid, String fieldName) {\n-        if (!fields.containsKey(mid)) {\n-            JSONObject model = col.getModels().get(mid);\n-            JSONArray flds = model.getJSONArray(\"flds\");\n-            for (int c = 0; c < flds.length(); c++) {\n-                JSONObject f = flds.getJSONObject(c);\n-                if (f.getString(\"name\").equalsIgnoreCase(fieldName)) {\n-                    fields.put(mid, c);\n-                    break;\n-                }\n-            }\n-        }\n-        return fields.get(mid);\n-    }\n-\n-\n-    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName) {\n-        return findDupes(col, fieldName, \"\");\n-    }\n-\n-\n-    /**\n-     * @return List of Pair(\"dupestr\", List[nids])\n-     */\n-    public static List<Pair<String, List<Long>>> findDupes(Collection col, String fieldName, String search) {\n-        // limit search to notes with applicable field name\n-    \tif (!TextUtils.isEmpty(search)) {\n-            search = \"(\" + search + \") \";\n-    \t}\n-        search += \"'\" + fieldName + \":*'\";\n-        // go through notes\n-        Map<String, List<Long>> vals = new HashMap<>();\n-        List<Pair<String, List<Long>>> dupes = new ArrayList<>();\n-        Map<Long, Integer> fields = new HashMap<>();\n-        try (Cursor cur = col.getDb().getDatabase().query(\n-                \"select id, mid, flds from notes where id in \" + Utils.ids2str(col.findNotes(search)), null)) {\n-            while (cur.moveToNext()) {\n-                long nid = cur.getLong(0);\n-                long mid = cur.getLong(1);\n-                String[] flds = Utils.splitFields(cur.getString(2));\n-                Integer ord = ordForMid(col, fields, mid, fieldName);\n-                if (ord == null) {\n-                    continue;\n-                }\n-                String val = flds[fields.get(mid)];\n-                val = Utils.stripHTMLMedia(val);\n-                // empty does not count as duplicate\n-                if (TextUtils.isEmpty(val)) {\n-                    continue;\n-                }\n-                if (!vals.containsKey(val)) {\n-                    vals.put(val, new ArrayList<Long>());\n-                }\n-                vals.get(val).add(nid);\n-                if (vals.get(val).size() == 2) {\n-                    dupes.add(new Pair<>(val, vals.get(val)));\n-                }\n-            }\n-        }\n-        return dupes;\n-    }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "message": "Merge commit", "committedDate": null}, {"oid": "098219caf305f055003b43eb6967ed486adb0ad7", "committedDate": "2020-06-08 10:01:44 -0500", "message": "LINT: Finder - CheckResult on methods"}, {"oid": "2d00fff26e2f2fc487d91019a686454d16029c7c", "committedDate": "2020-06-08 10:01:44 -0500", "message": "Finder: make \"is:buried\" return manually buried"}, {"oid": "e4543a40de9b69a8533bddb0346ee3c3e0c34b91", "committedDate": "2020-07-01 12:21:57 -0500", "message": "LINT: InnerClassMayBeStatic"}, {"oid": "0cb1d97ca9b5ca5ab5174629603655506f9ffad2", "committedDate": "2020-07-06 00:59:42 -0500", "message": "NF: card search: cancelling checked more often"}, {"oid": "c126ac42a5eac08fba6d54d531c0821df0193c68", "committedDate": "2020-07-21 15:50:01 -0500", "message": "NF: Deck type"}, {"oid": "31439eed2dcd6b4442c9a381d8650035b5bf27ff", "committedDate": "2020-08-21 11:29:10 -0500", "message": "NF: replace 86400 by SECONDS_PER_DAY"}, {"oid": "410d8801fce12c44897aea1554a8e1c88c54c194", "committedDate": "2020-08-22 14:28:46 -0500", "message": "NF: uses col's time everywhere"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "63f82fa2a58ab7f04260dc0eaabe6702ed4155fe", "committedDate": "2020-09-23 11:14:48 -0500", "message": "NF: Remove warning about dangling comment"}, {"oid": "4935ac517deb2d784bba0a9f7793fd2e65f99712", "committedDate": "2020-09-23 11:19:42 -0500", "message": "NF: Sort imports"}, {"oid": "975a902915821a23623b20e8daeff9fc681b92cd", "committedDate": "2020-09-24 09:30:56 -0500", "message": "NF: Remove warning about useless type in generic class constructors"}, {"oid": "5e3f0959ff0f4d09717df4acf964762ac0f6322b", "committedDate": "2020-09-30 17:57:53 -0500", "message": "NF: remove warning if with common part"}, {"oid": "47dd6596f3e4a3da45d145365f739b241c83d1ed", "committedDate": "2020-10-04 16:25:33 -0500", "message": "Lint: if replaceable with switch"}, {"oid": "9bfa7a9237d2cfc6c6dadc2d24290d5f082bacc8", "committedDate": "2020-10-07 20:20:39 -0500", "message": "NF: iterate on JSONArray"}, {"oid": "cce351437a05dd9f10e638e4b7c47887b28c3965", "committedDate": "2020-10-14 16:14:43 -0500", "message": "NF: CancelListener"}, {"oid": "7cbb33c7bbe0ba5e35f641f0d02c78bc5b955895", "committedDate": "2020-10-23 09:06:05 -0500", "message": "added logic to return exact match for a deck if it exists before a wildcard leads to a regex search in Finder.java"}, {"oid": "829122c12a1a1c7ab8b46551d436775381b1ba6e", "committedDate": "2020-10-23 09:06:05 -0500", "message": "Update AnkiDroid/src/main/java/com/ichi2/libanki/Finder.java"}, {"oid": "363e477bd9b77535c8a194dcf117129b1255df04", "committedDate": "2020-10-24 13:38:53 -0500", "message": "NF: optimize genCard"}, {"oid": "8c045d031307fd809ed2680b3347f29b9c5cf4e8", "committedDate": "2020-10-25 22:50:58 +0000", "message": "NF: Timber result of query compilation during search"}, {"oid": "79999799f739c7fadb7d124e52a3dbcf199e0723", "committedDate": "2020-10-26 10:19:03 -0500", "message": "NF: Use interface instead of CollectionTask in libanki"}, {"oid": "191d96ca622cbdb1f9b2780559fd4be3c2768549", "committedDate": "2020-10-26 11:05:32 -0500", "message": "correct error"}, {"oid": "fbfc55419cbc57c6522e57e774c4129ab8a0e83f", "committedDate": "2020-10-26 11:05:32 -0500", "message": "NF: split updateFieldCache"}, {"oid": "419d8a6b9046e42ba1d3b08933bb0e6bce342cf8", "committedDate": "2020-10-26 11:05:32 -0500", "message": "NF: genCard avoid an array"}, {"oid": "9bb16784193c8fda61c66e3d1cccb7ecc732b1b4", "committedDate": "2020-10-28 22:40:58 -0500", "message": "NF: Optimize by removing stripHTMLMedia when it is useless"}, {"oid": "6c7ae480a5dce3bbf13f58ce6a8bb5120c039b12", "committedDate": "2020-10-28 22:55:14 -0500", "message": "Cases default"}, {"oid": "046a18dc6155f88e1d6a8bbac3b1aec451fa45e8", "committedDate": "2020-11-05 03:16:04 +0000", "message": "NF: remove some unused methods"}, {"oid": "5afdb30df7c421b0de3fb4403fe41e8b382a7fb6", "committedDate": "2020-11-06 16:29:03 +0000", "message": "NF: query query"}, {"oid": "dbaf6549ec268333b20d160a0c40962d3135ba0d", "committedDate": "2020-11-20 07:54:40 -0500", "message": "Show partial result in browser before showing all"}, {"oid": "9103930e7c95d765056b784336c28356751379be", "committedDate": "2020-11-20 07:54:40 -0500", "message": "NF: comment query"}, {"oid": "6c4702de766fdc2a2f41f01a879503d2dc584e49", "committedDate": "2020-11-23 05:24:00 +0000", "message": "NF: isCancelled easier"}, {"oid": "c056b806f63ddb6de293a4c9048cb67b60c6ea9d", "committedDate": "2020-12-08 13:10:27 -0500", "message": "NF: ordForMid also save when a field name is absent"}, {"oid": "5128cc2c756ce1434367eb58807650581f26c661", "committedDate": "2020-12-09 11:27:39 -0500", "message": "NF: init capacity of list, map and set"}, {"oid": "7faaf5a868e4ea6fbb839ff1d98f713ea50eaf2a", "committedDate": "2021-01-11 11:15:33 -0500", "message": "NF: factorize test for cloze/std type"}, {"oid": "52c46a2e0cea90cc46f47ca756acb9a834dcbeac", "committedDate": "2021-01-11 11:15:33 -0500", "message": "NF: add Model instead of JSONObject"}, {"oid": "caf3d806cba189d762237f59ab7acd3cb4623596", "committedDate": "2021-02-13 20:45:27 -0500", "message": "NF: split id into id_dont_create"}, {"oid": "0b869c7bcd3aacfce7587704ba03f52b993979a7", "committedDate": "2021-03-24 14:32:35 -0500", "message": "Timber all exceptions catched not re-thrown"}, {"oid": "300bb0b666ef2035bfc7eaf7306e48e8722dcc8a", "committedDate": "2021-04-13 20:12:07 +0200", "message": "NF: rename: id_dont_create -> id_for_name"}, {"oid": "3dafbb2953546654a858c3e5f08ed2b99f9b7ee1", "committedDate": "2021-04-14 17:30:26 -0500", "message": "NF: Refactor `Finder`"}, {"oid": "37b924539e93597a65e7750bc260428b4837dced", "committedDate": "2021-08-04 20:45:34 -0500", "message": "feat: pink, turquoise & purple flags"}, {"oid": "060357b99f0cc510f319d3aa6f242c9783e3bffa", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf using strongly typed get_config"}, {"oid": "e546c9ac7bfc2d33afee48da4e3e77666a438149", "committedDate": "2021-08-27 08:19:38 -0500", "message": "nf: Use isEmpty in place of checking size to be zero when possible"}, {"oid": "27dbaeed881d3a1ef7b775311dabdf0780d3fc7f", "committedDate": "2021-09-04 09:47:41 -0500", "message": "NF: uses hash set/map which take size as init istead of capacity (#8339)"}, {"oid": "b0cb2174c467f769393d063944344fd5b927679a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: Introduce SortOrder class"}, {"oid": "1b3c687bfc7a4da0df1a1a90ebbc680f65650b6a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "feat(v16): implement findCards in backend"}, {"oid": "18595046d4a869d3f88f3f8773c770e17c577e29", "committedDate": "2022-03-03 11:45:06 -0500", "message": "NF: replace tab by spaces"}, {"oid": "b2883c03efdae925446a70564eab3a2a4b47e2ea", "committedDate": "2022-04-29 13:56:20 -0500", "message": "Add support for hierarchy tag (#10966)"}, {"oid": "e4da0eb9da6c79a14f80bdc0afc28f6d9ad5294c", "committedDate": "2022-06-07 19:59:23 -0500", "message": "refactor: Extract `Time` from `Collection` (#11563)"}, {"oid": "36c52773efdfcf2fb7f074d38083409cadad4845", "committedDate": "2022-07-19 18:06:19 -0500", "message": "NF: findOneCardByNote"}, {"oid": "70b1c15d72d6a1b8aac9273584daa00b48888d71", "committedDate": "2022-08-20 17:15:37 -0500", "message": "Fix failing test when new schema enabled"}, {"oid": "b5706047c87060370d8fbb7cc23b3fc872103b57", "committedDate": "2022-08-23 20:47:16 -0500", "message": "refactor: Rename Finder.java to .kt"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MjUyMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435542520", "body": "Nit: Could you move to the top of the class and fix the spacing around the  `=`", "bodyText": "Nit: Could you move to the top of the class and fix the spacing around the  =", "bodyHTML": "<p dir=\"auto\">Nit: Could you move to the top of the class and fix the spacing around the  <code>=</code></p>", "author": "david-allison-1", "createdAt": "2020-06-04T20:53:41Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1481,7 +1481,9 @@ public void onClick(View v) {\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c) {\n+    private static Pattern sMarkedPattern= Pattern.compile(\".*[Mm]arked.*\");", "originalCommit": "3b638b1e5356ea1642c12d14b517aec3b13c5c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0OTQyNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435549426", "bodyText": "If you want. I find it better to have it close to its usage, but that's okay with me", "author": "Arthur-Milchior", "createdAt": "2020-06-04T21:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MjUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0OTU3Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435549576", "bodyText": "Except that the change should occur in another PR. I'll do it there", "author": "Arthur-Milchior", "createdAt": "2020-06-04T21:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MjUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1NjEzNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435556135", "bodyText": "Except that the change should occur in another PR. I'll do it there\n\nThere's really no need unless you want to", "author": "david-allison-1", "createdAt": "2020-06-04T21:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MjUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzcyNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435573725", "bodyText": "My point was that sMarkedPattern was in #6358\nSo it's the natural place to follow your request. I actual force pushed this change on #6358", "author": "Arthur-Milchior", "createdAt": "2020-06-04T21:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MjUyMA=="}], "type": "inlineReview", "revised_code": {"commit": "19a0e6bcff769fb2a79b4b0350d28774b7ceb335", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 55a90b1d1..8b349e74c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,8 +1482,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    private static Pattern sMarkedPattern= Pattern.compile(\".*[Mm]arked.*\");\n-\n     public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n         // render question and answer\n         Map<String, String> qa = c._getQA(true, true);\n", "next_change": {"commit": "783609ad81e5b933cd8b93bdc4a5d8ed0596029e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 8b349e74c..a0a1ba715 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1482,7 +1481,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n+    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c) {\n         // render question and answer\n         Map<String, String> qa = c._getQA(true, true);\n         // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n", "next_change": {"commit": "e6e96b8a762942a18b24787a4ec3e91d6070479b", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex a0a1ba715..b73bbb906 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,7 +1482,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c) {\n+    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n         // render question and answer\n         Map<String, String> qa = c._getQA(true, true);\n         // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n", "next_change": {"commit": "7fccc05cde4e26216a73054bd61bd5278c507f6d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex b73bbb906..057645b49 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1482,64 +1469,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n-        // render question and answer\n-        Map<String, String> qa = c._getQA(true, true);\n-        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-            HashMap<String, String> qaFull = c._getQA(true, false);\n-            if (\"\".equals(qa.get(\"q\"))) {\n-                qa.put(\"q\", qaFull.get(\"q\"));\n-            }\n-            if (\"\".equals(qa.get(\"a\"))) {\n-                qa.put(\"a\", qaFull.get(\"a\"));\n-            }\n-        }\n-        // update the original hash map to include rendered question & answer\n-        String q = qa.get(\"q\");\n-        String a = qa.get(\"a\");\n-        // remove the question from the start of the answer if it exists\n-        if (a.startsWith(q)) {\n-            a = a.replaceFirst(Pattern.quote(q), \"\");\n-        }\n-        // put all of the fields in except for those that have already been pulled out straight from the\n-        // database\n-        item.put(ANSWER, formatQA(a, context));\n-        item.put(CARD, c.template().optString(\"name\"));\n-        item.put(DUE, c.getDueString());\n-        if (c.getType() == Consts.CARD_TYPE_NEW) {\n-            item.put(EASE, context.getString(R.string.card_browser_ease_new_card));\n-        } else {\n-            item.put(EASE, (c.getFactor()/10)+\"%\");\n-        }\n-\n-        Note note = c.note();\n-        item.put(CHANGED, LanguageUtil.getShortDateFormatFromS(c.getMod()));\n-        item.put(CREATED, LanguageUtil.getShortDateFormatFromMs(note.getId()));\n-        item.put(EDITED, LanguageUtil.getShortDateFormatFromS(note.getMod()));\n-        // interval\n-        switch (c.getType()) {\n-            case Consts.CARD_TYPE_NEW:\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_new_card));\n-                break;\n-            case Consts.CARD_TYPE_LRN :\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_learning_card));\n-                break;\n-            default:\n-                item.put(INTERVAL, Utils.roundedTimeSpanUnformatted(context, c.getIvl()*86400));\n-                break;\n-        }\n-        item.put(LAPSES, Integer.toString(c.getLapses()));\n-        item.put(NOTE, c.model().optString(\"name\"));\n-        item.put(QUESTION, formatQA(q, context));\n-        item.put(REVIEWS, Integer.toString(c.getReps()));\n-        String tags = note.stringTags();\n-        item.put(TAGS, tags);\n-        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n-        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n-    }\n-\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": {"commit": "2114aeedad26a5384d6d6a46289f72e405f8c9e9", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 057645b49..826edafd6 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1469,6 +1482,66 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n+    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n+        // render question and answer\n+        Map<String, String> qa = c._getQA(true, true);\n+        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n+        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n+            HashMap<String, String> qaFull = c._getQA(true, false);\n+            if (\"\".equals(qa.get(\"q\"))) {\n+                qa.put(\"q\", qaFull.get(\"q\"));\n+            }\n+            if (\"\".equals(qa.get(\"a\"))) {\n+                qa.put(\"a\", qaFull.get(\"a\"));\n+            }\n+        }\n+        // update the original hash map to include rendered question & answer\n+        String q = qa.get(\"q\");\n+        String a = qa.get(\"a\");\n+        // remove the question from the start of the answer if it exists\n+        if (a.startsWith(q)) {\n+            a = a.replaceFirst(Pattern.quote(q), \"\");\n+        }\n+        // put all of the fields in except for those that have already been pulled out straight from the\n+        // database\n+        item.put(ANSWER, formatQA(a, context));\n+        item.put(CARD, c.template().optString(\"name\"));\n+        item.put(DUE, c.getDueString());\n+        if (c.getType() == Consts.CARD_TYPE_NEW) {\n+            item.put(EASE, context.getString(R.string.card_browser_ease_new_card));\n+        } else {\n+            item.put(EASE, (c.getFactor()/10)+\"%\");\n+        }\n+\n+        Note note = c.note();\n+        item.put(CHANGED, LanguageUtil.getShortDateFormatFromS(c.getMod()));\n+        item.put(CREATED, LanguageUtil.getShortDateFormatFromMs(note.getId()));\n+        item.put(EDITED, LanguageUtil.getShortDateFormatFromS(note.getMod()));\n+        // interval\n+        switch (c.getType()) {\n+            case Consts.CARD_TYPE_NEW:\n+                item.put(INTERVAL, context.getString(R.string.card_browser_interval_new_card));\n+                break;\n+            case Consts.CARD_TYPE_LRN :\n+                item.put(INTERVAL, context.getString(R.string.card_browser_interval_learning_card));\n+                break;\n+            default:\n+                item.put(INTERVAL, Utils.roundedTimeSpanUnformatted(context, c.getIvl()*86400));\n+                break;\n+        }\n+        item.put(LAPSES, Integer.toString(c.getLapses()));\n+        item.put(NOTE, c.model().optString(\"name\"));\n+        item.put(QUESTION, formatQA(q, context));\n+        item.put(REVIEWS, Integer.toString(c.getReps()));\n+        String tags = note.stringTags();\n+        item.put(TAGS, tags);\n+        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n+        item.put(FLAGS, (Integer.toString(c.getUserFlag())));\n+        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n+        item.put(DECK, col.getDecks().name(c.getDid()));\n+        item.put(SFLD, note.getSFld());\n+    }\n+\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 55a90b1d1..9f719f63b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,8 +1474,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    private static Pattern sMarkedPattern= Pattern.compile(\".*[Mm]arked.*\");\n-\n     public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n         // render question and answer\n         Map<String, String> qa = c._getQA(true, true);\n", "next_change": {"commit": "d4267b868d9b4e584d186f667de2f48636b333be", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 9f719f63b..5d4f67fbc 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1468,13 +1468,13 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             mUndoSnackbar = UIUtils.showSnackbar(CardBrowser.this, String.format(getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n                 @Override\n                 public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(CollectionTask.TASK_TYPE_UNDO, mUndoHandler);\n+                    CollectionTask.launchCollectionTask(UNDO, mUndoHandler);\n                 }\n             }, mCardsListView, null);\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n+    public static void updateSearchItemQA(Context context, CardCache item, Card c, Collection col) {\n         // render question and answer\n         Map<String, String> qa = c._getQA(true, true);\n         // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n", "next_change": {"commit": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 5d4f67fbc..33f2d76d3 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1474,7 +1457,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, CardCache item, Card c, Collection col) {\n+    public static void updateSearchItemQA(Context context, CardCache item, Card c) {\n         // render question and answer\n         Map<String, String> qa = c._getQA(true, true);\n         // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n", "next_change": {"commit": "25668235083fa2e4c0716fb177f0ed756d5f18f1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 33f2d76d3..c99b207c2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1457,7 +1457,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, CardCache item, Card c) {\n+    public static void updateSearchItemQA(CardCache item, Card c) {\n+        Context context = AnkiDroidApp.getInstance();\n         // render question and answer\n         Map<String, String> qa = c._getQA(true, true);\n         // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n", "next_change": {"commit": "216580a8bfebb2e94d3ee973e9c16dea5b45f6a2", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex c99b207c2..ff5257111 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1457,7 +1457,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(CardCache item, Card c) {\n+    public static void updateSearchItemQA(CardCache item) {\n+        Card c = item.getCard();\n         Context context = AnkiDroidApp.getInstance();\n         // render question and answer\n         Map<String, String> qa = c._getQA(true, true);\n", "next_change": {"commit": "474450d513e379802bca25b64e9d2dccfa7dc105", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex ff5257111..de54a7132 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1457,31 +1457,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(CardCache item) {\n-        Card c = item.getCard();\n-        Context context = AnkiDroidApp.getInstance();\n-        // render question and answer\n-        Map<String, String> qa = c._getQA(true, true);\n-        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-            HashMap<String, String> qaFull = c._getQA(true, false);\n-            if (\"\".equals(qa.get(\"q\"))) {\n-                qa.put(\"q\", qaFull.get(\"q\"));\n-            }\n-            if (\"\".equals(qa.get(\"a\"))) {\n-                qa.put(\"a\", qaFull.get(\"a\"));\n-            }\n-        }\n-        String q = qa.get(\"q\");\n-        String a = qa.get(\"a\");\n-        // remove the question from the start of the answer if it exists\n-        if (a.startsWith(q)) {\n-            a = a.replaceFirst(Pattern.quote(q), \"\");\n-        }\n-        item.put(ANSWER, formatQA(a, context));\n-        item.put(QUESTION, formatQA(q, context));\n-    }\n-\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": {"commit": "7383c6809f93d6fd931a8f3bec4b43c9c488b19f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex de54a7132..a773d50b5 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1404,56 +1436,71 @@ public class CardBrowser extends NavigationDrawerActivity implements\n      * @param updatedCardTags Mapping note id -> updated tags\n      */\n     private void updateCardsInList(List<Card> cards, Map<Long, String> updatedCardTags) {\n-        Map<Long, Integer> idToPos = getPositionMap(getCards());\n+        List<CardCache> cardList = getCards();\n+        Map<Long, Integer> idToPos = getPositionMap(cardList);\n         for (Card c : cards) {\n             // get position in the mCards search results HashMap\n-            int pos = idToPos.containsKey(c.getId()) ? idToPos.get(c.getId()) : -1;\n-            if (pos < 0 || pos >= getCardCount()) {\n+            Integer pos = idToPos.get(c.getId());\n+            if (pos == null || pos >= getCardCount()) {\n                 continue;\n             }\n-            CardCache card = getCards().get(pos);\n             // update Q & A etc\n-            card.load(true);\n+            cardList.get(pos).load(true, mColumn1Index, mColumn2Index);\n         }\n \n         updateList();\n     }\n \n-    private TaskListener mUpdateCardHandler = new ListenerWithProgressBarCloseOnFalse(\"Card Browser - mUpdateCardHandler.onPostExecute()\"){\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+\n+    private static class UpdateCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public UpdateCardHandler(CardBrowser browser) {\n+            super(\"Card Browser - UpdateCardHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n+        }\n+\n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            updateCardInList(value.getCard(), value.getString());\n+        public void actualOnProgressUpdate(@NonNull CardBrowser browser, TaskData value) {\n+            browser.updateCardInList(value.getCard(), value.getString());\n         }\n \n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n+        protected void actualOnValidPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n         }\n     };\n \n-    private TaskListener mChangeDeckHandler = new ListenerWithProgressBarCloseOnFalse(\"Card Browser - mChangeDeckHandler.onPostExecute()\") {\n+    private ChangeDeckHandler changeDeckHandler() {\n+        return new ChangeDeckHandler(this);\n+    }\n+    private static class ChangeDeckHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public ChangeDeckHandler(CardBrowser browser) {\n+            super(\"Card Browser - changeDeckHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n+        protected void actualOnValidPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n \n-            searchCards();\n-            endMultiSelectMode();\n-            mCardsAdapter.notifyDataSetChanged();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.searchCards();\n+            browser.endMultiSelectMode();\n+            browser.mCardsAdapter.notifyDataSetChanged();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n \n             if (!result.getBoolean()) {\n-                Timber.i(\"mChangeDeckHandler failed, not offering undo\");\n-                displayCouldNotChangeDeck();\n+                Timber.i(\"changeDeckHandler failed, not offering undo\");\n+                browser.displayCouldNotChangeDeck();\n                 return;\n             }\n             // snackbar to offer undo\n-            String deckName = getCol().getDecks().name(mNewDid);\n-            mUndoSnackbar = UIUtils.showSnackbar(CardBrowser.this, String.format(getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n+            String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n                 @Override\n                 public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, mUndoHandler);\n+                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);\n                 }\n-            }, mCardsListView, null);\n+            }, browser.mCardsListView, null);\n         }\n     };\n \n", "next_change": {"commit": "715357c31701ffe4d1f87d8278be7c622fd25f60", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex a773d50b5..5f2682430 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1502,7 +1523,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n                 }\n             }, browser.mCardsListView, null);\n         }\n-    };\n+    }\n+\n \n     @CheckResult\n     private static String formatQA(String text, Context context) {\n", "next_change": {"commit": "c0595464b0b205d704b293f64543e5f54e4b2612", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 5f2682430..e015758c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1516,12 +1578,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n-                @Override\n-                public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);\n-                }\n-            }, browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex e015758c7..7ea57886b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1578,7 +1726,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> TaskManager.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 7ea57886b..ed1747b0a 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1726,7 +1716,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> TaskManager.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION,\n+                                                         R.string.undo, v -> TaskManager.launchCollectionTask(new CollectionTask.Undo(), browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "bd8f85f29633812b249152b8e4dac986d89ae49f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex ed1747b0a..9da7f8009 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1709,15 +1759,20 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             browser.mCardsAdapter.notifyDataSetChanged();\n             browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n \n-            if (!result.getBoolean()) {\n+            if (!result.succeeded()) {\n                 Timber.i(\"changeDeckHandler failed, not offering undo\");\n                 browser.displayCouldNotChangeDeck();\n                 return;\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION,\n-                                                         R.string.undo, v -> TaskManager.launchCollectionTask(new CollectionTask.Undo(), browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(\n+                    browser,\n+                    String.format(browser.getString(R.string.changed_deck_message), deckName),\n+                    SNACKBAR_DURATION,\n+                    R.string.undo,\n+                    v -> TaskManager.launchCollectionTask(new UndoService.Undo().toDelegate(), browser.mUndoHandler),\n+                    browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "0fd0f558c49c728f0eca73a7f5059125cb0a638c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\ndeleted file mode 100644\nindex 9da7f8009..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ /dev/null\n", "chunk": "@@ -1,2973 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *\n- * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-\n-package com.ichi2.anki;\n-\n-import android.app.AlertDialog;\n-import android.content.BroadcastReceiver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.IntentFilter;\n-import android.content.SharedPreferences;\n-import android.graphics.Typeface;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.SystemClock;\n-\n-import androidx.activity.result.ActivityResultLauncher;\n-import androidx.activity.result.contract.ActivityResultContracts;\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import com.google.android.material.snackbar.Snackbar;\n-\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.widget.SearchView;\n-import android.text.TextUtils;\n-import android.util.Pair;\n-import android.util.TypedValue;\n-import android.view.KeyEvent;\n-import android.view.LayoutInflater;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.view.WindowManager;\n-import android.widget.AbsListView;\n-import android.widget.AdapterView;\n-import android.widget.AdapterView.OnItemSelectedListener;\n-import android.widget.ArrayAdapter;\n-import android.widget.BaseAdapter;\n-import android.widget.CheckBox;\n-import android.widget.ListView;\n-import android.widget.Spinner;\n-import android.widget.TextView;\n-\n-import com.afollestad.materialdialogs.MaterialDialog;\n-import com.ichi2.anki.dialogs.CardBrowserMySearchesDialog;\n-import com.ichi2.anki.dialogs.CardBrowserOrderDialog;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.dialogs.DeckSelectionDialog;\n-import com.ichi2.anki.dialogs.IntegerDialog;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.dialogs.SimpleMessageDialog;\n-import com.ichi2.anki.dialogs.tags.TagsDialog;\n-import com.ichi2.anki.dialogs.tags.TagsDialogFactory;\n-import com.ichi2.anki.dialogs.tags.TagsDialogListener;\n-import com.ichi2.anki.receiver.SdCardReceiver;\n-import com.ichi2.anki.servicelayer.SchedulerService;\n-import com.ichi2.anki.servicelayer.UndoService;\n-import com.ichi2.anki.widgets.DeckDropDownAdapter;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.async.TaskListenerWithContext;\n-import com.ichi2.async.TaskManager;\n-import com.ichi2.compat.Compat;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.Deck;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.ui.CardBrowserSearchView;\n-import com.ichi2.upgrade.Upgrade;\n-import com.ichi2.utils.FunctionalInterfaces;\n-import com.ichi2.utils.HashUtil;\n-import com.ichi2.utils.LanguageUtil;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import com.ichi2.utils.JSONException;\n-import com.ichi2.utils.JSONObject;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.CardBrowser.Column.*;\n-import static com.ichi2.libanki.stats.Stats.SECONDS_PER_DAY;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-import static com.ichi2.utils.LanguageUtil.getLocaleCompat;\n-\n-public class CardBrowser extends NavigationDrawerActivity implements\n-        DeckDropDownAdapter.SubtitleListener,\n-        DeckSelectionDialog.DeckSelectionListener,\n-        TagsDialogListener {\n-\n-    @Override\n-    public void onDeckSelected(@Nullable DeckSelectionDialog.SelectableDeck deck) {\n-        if (deck == null) {\n-            return;\n-        }\n-        long deckId = deck.getDeckId();\n-        mDeckSpinnerSelection.initializeActionBarDeckSpinner(this.getSupportActionBar());\n-        mDeckSpinnerSelection.selectDeckById(deckId, true);\n-        selectDeckAndSave(deckId);\n-    }\n-\n-\n-    enum Column {\n-        QUESTION,\n-        ANSWER,\n-        FLAGS,\n-        SUSPENDED,\n-        MARKED,\n-        SFLD,\n-        DECK,\n-        TAGS,\n-        ID,\n-        CARD,\n-        DUE,\n-        EASE,\n-        CHANGED,\n-        CREATED,\n-        EDITED,\n-        INTERVAL,\n-        LAPSES,\n-        NOTE_TYPE,\n-        REVIEWS\n-    }\n-\n-    /** List of cards in the browser.\n-    * When the list is changed, the position member of its elements should get changed.*/\n-    @NonNull\n-    private final CardCollection<CardCache> mCards = new CardCollection<>();\n-    public DeckSpinnerSelection mDeckSpinnerSelection;\n-    @VisibleForTesting\n-    public ListView mCardsListView;\n-    private CardBrowserSearchView mSearchView;\n-    private MultiColumnListAdapter mCardsAdapter;\n-    private String mSearchTerms;\n-    private String mRestrictOnDeck;\n-    private int mCurrentFlag;\n-\n-    private TagsDialogFactory mTagsDialogFactory;\n-\n-    private MenuItem mSearchItem;\n-    private MenuItem mSaveSearchItem;\n-    private MenuItem mMySearchesItem;\n-    private MenuItem mPreviewItem;\n-\n-    private Snackbar mUndoSnackbar;\n-\n-    public static Card sCardBrowserCard;\n-\n-    // card that was clicked (not marked)\n-    private long mCurrentCardId;\n-\n-    private int mOrder;\n-    private boolean mOrderAsc;\n-    private int mColumn1Index;\n-    private int mColumn2Index;\n-\n-    //DEFECT: Doesn't need to be a local\n-    /** The next deck for the \"Change Deck\" operation */\n-    private long mNewDid;\n-\n-    /** The query which is currently in the search box, potentially null. Only set when search box was open */\n-    private String mTempSearchQuery;\n-\n-    ActivityResultLauncher<Intent> mOnEditCardActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onEditCardActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        if (result.getResultCode() != RESULT_CANCELED) {\n-            Timber.i(\"CardBrowser:: CardBrowser: Saving card...\");\n-            TaskManager.launchCollectionTask(new CollectionTask.UpdateNote(sCardBrowserCard, false, false),\n-                    updateCardHandler());\n-        }\n-        Intent data = result.getData();\n-        if (data != null &&\n-                (data.getBooleanExtra(\"reloadRequired\", false) || data.getBooleanExtra(\"noteChanged\", false))) {\n-            // if reloadRequired or noteChanged flag was sent from note editor then reload card list\n-            searchCards();\n-            mShouldRestoreScroll = true;\n-            // in use by reviewer?\n-            if (getReviewerCardId() == mCurrentCardId) {\n-                mReloadRequired = true;\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    ActivityResultLauncher<Intent> mOnAddNoteActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onAddNoteActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        if (result.getResultCode() == RESULT_OK) {\n-            if (mSearchView != null) {\n-                mSearchTerms = mSearchView.getQuery().toString();\n-                searchCards();\n-            } else {\n-                Timber.w(\"Note was added from browser and on return mSearchView == null\");\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    ActivityResultLauncher<Intent> mOnPreviewCardsActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onPreviewCardsActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        // Previewing can now perform an \"edit\", so it can pass on a reloadRequired\n-        Intent data = result.getData();\n-        if (data != null &&\n-                (data.getBooleanExtra(\"reloadRequired\", false) || data.getBooleanExtra(\"noteChanged\", false))) {\n-            searchCards();\n-            if (getReviewerCardId() == mCurrentCardId) {\n-                mReloadRequired = true;\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    private static final int DEFAULT_FONT_SIZE_RATIO = 100;\n-    // Should match order of R.array.card_browser_order_labels\n-    public static final int CARD_ORDER_NONE = 0;\n-    private static final String[] fSortTypes = new String[] {\n-        \"\",\n-        \"noteFld\",\n-        \"noteCrt\",\n-        \"noteMod\",\n-        \"cardMod\",\n-        \"cardDue\",\n-        \"cardIvl\",\n-        \"cardEase\",\n-        \"cardReps\",\n-        \"cardLapses\"};\n-    private static final Column[] COLUMN1_KEYS = {QUESTION, SFLD};\n-\n-    // list of available keys in mCards corresponding to the column names in R.array.browser_column2_headings.\n-    // Note: the last 6 are currently hidden\n-    private static final Column[] COLUMN2_KEYS = {ANSWER,\n-        CARD,\n-        DECK,\n-        NOTE_TYPE,\n-        QUESTION,\n-        TAGS,\n-        LAPSES,\n-        REVIEWS,\n-        INTERVAL,\n-        EASE,\n-        DUE,\n-        CHANGED,\n-        CREATED,\n-        EDITED,\n-    };\n-    private long mLastRenderStart = 0;\n-    private TextView mActionBarTitle;\n-    private boolean mReloadRequired = false;\n-    private boolean mInMultiSelectMode = false;\n-    private final @NonNull Set<CardCache> mCheckedCards = Collections.synchronizedSet(new LinkedHashSet<>());\n-    private int mLastSelectedPosition;\n-    @Nullable\n-    private Menu mActionBarMenu;\n-\n-    private static final int SNACKBAR_DURATION = 8000;\n-\n-\n-    // Values related to persistent state data\n-    private static final long ALL_DECKS_ID = 0L;\n-    private static final String PERSISTENT_STATE_FILE = \"DeckPickerState\";\n-    private static final String LAST_DECK_ID_KEY = \"lastDeckId\";\n-\n-    public static final int CARD_NOT_AVAILABLE = -1;\n-    private long mOldCardId = 0;\n-    private int mOldCardTopOffset = 0;\n-    private boolean mShouldRestoreScroll = false;\n-    private boolean mPostAutoScroll = false;\n-\n-    private final Onboarding.CardBrowser mOnboarding = new Onboarding.CardBrowser(this);\n-\n-    /**\n-     * Broadcast that informs us when the sd card is about to be unmounted\n-     */\n-    private BroadcastReceiver mUnmountReceiver = null;\n-\n-    private final MaterialDialog.ListCallbackSingleChoice mOrderDialogListener =\n-            (materialDialog, view, which, charSequence) -> {\n-                changeCardOrder(which);\n-                return true;\n-            };\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)\n-    protected void changeCardOrder(int which) {\n-        if (which != mOrder) {\n-            mOrder = which;\n-            mOrderAsc = false;\n-            if (mOrder == 0) {\n-                // if the sort value in the card browser was changed, then perform a new search\n-                getCol().set_config(\"sortType\", fSortTypes[1]);\n-                AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()\n-                        .putBoolean(\"cardBrowserNoSorting\", true)\n-                        .apply();\n-            } else {\n-                getCol().set_config(\"sortType\", fSortTypes[mOrder]);\n-                AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()\n-                        .putBoolean(\"cardBrowserNoSorting\", false)\n-                        .apply();\n-            }\n-            getCol().set_config(\"sortBackwards\", mOrderAsc);\n-            searchCards();\n-        } else if (which != CARD_ORDER_NONE) {\n-            // if the same element is selected again, reverse the order\n-            mOrderAsc = !mOrderAsc;\n-            getCol().set_config(\"sortBackwards\", mOrderAsc);\n-            mCards.reverse();\n-            updateList();\n-        }\n-        // To update the collection\n-        getCol().getDb().setMod(true);\n-    }\n-\n-\n-    private RepositionCardHandler repositionCardHandler() {\n-        return new RepositionCardHandler(this);\n-    }\n-\n-    private static class RepositionCardHandler extends TaskListenerWithContext<CardBrowser, Object, Computation<? extends Card[]>> {\n-        public RepositionCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::RepositionCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::RepositionCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reposition_card_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private ResetProgressCardHandler resetProgressCardHandler() {\n-        return new ResetProgressCardHandler(this);\n-    }\n-    private static class ResetProgressCardHandler extends TaskListenerWithContext<CardBrowser, Object, Computation<? extends Card[]>>{\n-        public ResetProgressCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::ResetProgressCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::ResetProgressCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reset_cards_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private RescheduleCardHandler rescheduleCardHandler() {\n-        return new RescheduleCardHandler(this);\n-    }\n-    private static class RescheduleCardHandler extends TaskListenerWithContext<CardBrowser, Card, Computation<? extends Card[]>>{\n-        public RescheduleCardHandler (CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::RescheduleCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::RescheduleCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reschedule_cards_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private final CardBrowserMySearchesDialog.MySearchesDialogListener mMySearchesDialogListener =\n-            new CardBrowserMySearchesDialog.MySearchesDialogListener() {\n-        @Override\n-        public void onSelection(String searchName) {\n-            Timber.d(\"OnSelection using search named: %s\", searchName);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            Timber.d(\"SavedFilters are %s\", savedFiltersObj == null ? null : savedFiltersObj.toString());\n-            if (savedFiltersObj != null) {\n-                mSearchTerms = savedFiltersObj.optString(searchName);\n-                Timber.d(\"OnSelection using search terms: %s\", mSearchTerms);\n-                mSearchView.setQuery(mSearchTerms, false);\n-                mSearchItem.expandActionView();\n-                searchCards();\n-            }\n-        }\n-\n-        @Override\n-        public void onRemoveSearch(String searchName) {\n-            Timber.d(\"OnRemoveSelection using search named: %s\", searchName);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            if (savedFiltersObj != null && savedFiltersObj.has(searchName)) {\n-                savedFiltersObj.remove(searchName);\n-                getCol().set_config(\"savedFilters\", savedFiltersObj);\n-                getCol().flush();\n-                if (savedFiltersObj.length() == 0) {\n-                    mMySearchesItem.setVisible(false);\n-                }\n-            }\n-\n-        }\n-\n-        @Override\n-        public void onSaveSearch(String searchName, String searchTerms) {\n-            if (TextUtils.isEmpty(searchName)) {\n-                UIUtils.showThemedToast(CardBrowser.this,\n-                        getString(R.string.card_browser_list_my_searches_new_search_error_empty_name), true);\n-                return;\n-            }\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            boolean should_save = false;\n-            if (savedFiltersObj == null) {\n-                savedFiltersObj = new JSONObject();\n-                savedFiltersObj.put(searchName, searchTerms);\n-                should_save = true;\n-            } else if (!savedFiltersObj.has(searchName)) {\n-                savedFiltersObj.put(searchName, searchTerms);\n-                should_save = true;\n-            } else {\n-                UIUtils.showThemedToast(CardBrowser.this,\n-                                        getString(R.string.card_browser_list_my_searches_new_search_error_dup), true);\n-            }\n-            if (should_save) {\n-                getCol().set_config(\"savedFilters\", savedFiltersObj);\n-                getCol().flush();\n-                mSearchView.setQuery(\"\", false);\n-                mMySearchesItem.setVisible(true);\n-            }\n-        }\n-    };\n-\n-\n-    private void onSearch() {\n-        mSearchTerms = mSearchView.getQuery().toString();\n-        if (mSearchTerms.length() == 0) {\n-            mSearchView.setQueryHint(getResources().getString(R.string.deck_conf_cram_search));\n-        }\n-        searchCards();\n-    }\n-\n-    private List<Long> getSelectedCardIds() {\n-        List<Long> ids = new ArrayList<>(mCheckedCards.size());\n-        for (CardCache cardPosition : mCheckedCards) {\n-            ids.add(cardPosition.getId());\n-        }\n-        return ids;\n-    }\n-\n-    private boolean canPerformCardInfo() {\n-        return checkedCardCount() == 1;\n-    }\n-\n-    private boolean canPerformMultiSelectEditNote() {\n-        //The noteId is not currently available. Only allow if a single card is selected for now.\n-        return checkedCardCount() == 1;\n-    }\n-\n-\n-    /**\n-     * Change Deck\n-     * @param deckPosition NOT the did. The index in the DISPLAYED Deck list to change the decks to.\n-     * grep: changeDeck\n-     */\n-    @VisibleForTesting\n-    void moveSelectedCardsToDeck(int deckPosition) {\n-        List<Long> ids = getSelectedCardIds();\n-\n-        Deck selectedDeck = getValidDecksForChangeDeck().get(deckPosition);\n-\n-        try {\n-            //#5932 - can't be dynamic\n-            if (Decks.isDynamic(selectedDeck)) {\n-                Timber.w(\"Attempted to change cards to dynamic deck. Cancelling operation.\");\n-                displayCouldNotChangeDeck();\n-                return;\n-            }\n-        } catch (Exception e) {\n-            displayCouldNotChangeDeck();\n-            Timber.e(e);\n-            return;\n-        }\n-\n-        mNewDid = selectedDeck.getLong(\"id\");\n-\n-        Timber.i(\"Changing selected cards to deck: %d\", mNewDid);\n-\n-        if (ids.isEmpty()) {\n-            endMultiSelectMode();\n-            mCardsAdapter.notifyDataSetChanged();\n-            return;\n-        }\n-\n-        if (ids.contains(getReviewerCardId())) {\n-            mReloadRequired = true;\n-        }\n-\n-        executeChangeCollectionTask(ids, mNewDid);\n-    }\n-\n-\n-    private void displayCouldNotChangeDeck() {\n-        UIUtils.showThemedToast(this, getString(R.string.card_browser_deck_change_error), true);\n-    }\n-\n-\n-    @VisibleForTesting\n-    Long getLastDeckId() {\n-        SharedPreferences state = getSharedPreferences(PERSISTENT_STATE_FILE,0);\n-        if (!state.contains(LAST_DECK_ID_KEY)) {\n-            return null;\n-        }\n-        return state.getLong(LAST_DECK_ID_KEY, -1);\n-    }\n-\n-    public static void clearLastDeckId() {\n-        Context context = AnkiDroidApp.getInstance();\n-        context.getSharedPreferences(PERSISTENT_STATE_FILE,0).edit().remove(LAST_DECK_ID_KEY).apply();\n-    }\n-\n-    private void saveLastDeckId(Long id) {\n-        if (id == null) {\n-            clearLastDeckId();\n-            return;\n-        }\n-        getSharedPreferences(PERSISTENT_STATE_FILE, 0).edit().putLong(LAST_DECK_ID_KEY, id).apply();\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        mTagsDialogFactory = new TagsDialogFactory(this).attachToActivity(this);\n-        super.onCreate(savedInstanceState);\n-        Timber.d(\"onCreate()\");\n-        if (wasLoadedFromExternalTextActionItem() && !Permissions.hasStorageAccessPermission(this)) {\n-            Timber.w(\"'Card Browser' Action item pressed before storage permissions granted.\");\n-            UIUtils.showThemedToast(this, getString(R.string.intent_handler_failed_no_storage_permission), false);\n-            displayDeckPickerForPermissionsDialog();\n-            return;\n-        }\n-        setContentView(R.layout.card_browser);\n-        initNavigationDrawer(findViewById(android.R.id.content));\n-        startLoadingCollection();\n-\n-        // for intent coming from search query js api\n-        if (getIntent().getStringExtra(\"search_query\") != null) {\n-            mSearchTerms = getIntent().getStringExtra(\"search_query\");\n-            searchCards();\n-        }\n-\n-        mOnboarding.onCreate();\n-    }\n-\n-    // Finish initializing the activity after the collection has been correctly loaded\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        Timber.d(\"onCollectionLoaded()\");\n-        registerExternalStorageListener();\n-\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-\n-        // Load reference to action bar title\n-        mActionBarTitle = findViewById(R.id.toolbar_title);\n-\n-        mOrder = CARD_ORDER_NONE;\n-        String colOrder = getCol().get_config_string(\"sortType\");\n-        for (int c = 0; c < fSortTypes.length; ++c) {\n-            if (fSortTypes[c].equals(colOrder)) {\n-                mOrder = c;\n-                break;\n-            }\n-        }\n-        if (mOrder == 1 && preferences.getBoolean(\"cardBrowserNoSorting\", false)) {\n-            mOrder = 0;\n-        }\n-        //This upgrade should already have been done during\n-        //setConf. However older version of AnkiDroid didn't call\n-        //upgradeJSONIfNecessary during setConf, which means the\n-        //conf saved may still have this bug.\n-        mOrderAsc = Upgrade.upgradeJSONIfNecessary(getCol(), \"sortBackwards\", false);\n-\n-        mCards.reset();\n-        mCardsListView = findViewById(R.id.card_browser_list);\n-        // Create a spinner for column1\n-        Spinner cardsColumn1Spinner = findViewById(R.id.browser_column1_spinner);\n-        ArrayAdapter<CharSequence> column1Adapter = ArrayAdapter.createFromResource(this,\n-                R.array.browser_column1_headings, android.R.layout.simple_spinner_item);\n-        column1Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n-        cardsColumn1Spinner.setAdapter(column1Adapter);\n-        mColumn1Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt(\"cardBrowserColumn1\", 0);\n-        cardsColumn1Spinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n-            @Override\n-            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {\n-                // If a new column was selected then change the key used to map from mCards to the column TextView\n-                if (pos != mColumn1Index) {\n-                    mColumn1Index = pos;\n-                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()\n-                            .putInt(\"cardBrowserColumn1\", mColumn1Index).apply();\n-                    Column[] fromMap = mCardsAdapter.getFromMapping();\n-                    fromMap[0] = COLUMN1_KEYS[mColumn1Index];\n-                    mCardsAdapter.setFromMapping(fromMap);\n-                }\n-            }\n-\n-            @Override\n-            public void onNothingSelected(AdapterView<?> parent) {\n-                // Do Nothing\n-            }\n-        });\n-        // Load default value for column2 selection\n-        mColumn2Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt(\"cardBrowserColumn2\", 0);\n-        // Setup the column 2 heading as a spinner so that users can easily change the column type\n-        Spinner cardsColumn2Spinner = findViewById(R.id.browser_column2_spinner);\n-        ArrayAdapter<CharSequence> column2Adapter = ArrayAdapter.createFromResource(this,\n-                R.array.browser_column2_headings, android.R.layout.simple_spinner_item);\n-        column2Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n-        cardsColumn2Spinner.setAdapter(column2Adapter);\n-        // Create a new list adapter with updated column map any time the user changes the column\n-        cardsColumn2Spinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n-            @Override\n-            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {\n-                // If a new column was selected then change the key used to map from mCards to the column TextView\n-                if (pos != mColumn2Index) {\n-                    mColumn2Index = pos;\n-                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()\n-                            .putInt(\"cardBrowserColumn2\", mColumn2Index).apply();\n-                    Column[] fromMap = mCardsAdapter.getFromMapping();\n-                    fromMap[1] = COLUMN2_KEYS[mColumn2Index];\n-                    mCardsAdapter.setFromMapping(fromMap);\n-                }\n-            }\n-\n-            @Override\n-            public void onNothingSelected(AdapterView<?> parent) {\n-                // Do Nothing\n-            }\n-        });\n-        // get the font and font size from the preferences\n-        int sflRelativeFontSize = preferences.getInt(\"relativeCardBrowserFontSize\", DEFAULT_FONT_SIZE_RATIO);\n-        String sflCustomFont = preferences.getString(\"browserEditorFont\", \"\");\n-        Column[] columnsContent = {COLUMN1_KEYS[mColumn1Index], COLUMN2_KEYS[mColumn2Index]};\n-        // make a new list adapter mapping the data in mCards to column1 and column2 of R.layout.card_item_browser\n-        mCardsAdapter = new MultiColumnListAdapter(\n-                this,\n-                R.layout.card_item_browser,\n-                columnsContent,\n-                new int[] {R.id.card_sfld, R.id.card_column2},\n-                sflRelativeFontSize,\n-                sflCustomFont);\n-        // link the adapter to the main mCardsListView\n-        mCardsListView.setAdapter(mCardsAdapter);\n-        // make the items (e.g. question & answer) render dynamically when scrolling\n-        mCardsListView.setOnScrollListener(new RenderOnScroll());\n-        // set the spinner index\n-        cardsColumn1Spinner.setSelection(mColumn1Index);\n-        cardsColumn2Spinner.setSelection(mColumn2Index);\n-\n-\n-        mCardsListView.setOnItemClickListener((parent, view, position, id) -> {\n-            if (mInMultiSelectMode) {\n-                // click on whole cell triggers select\n-                CheckBox cb = view.findViewById(R.id.card_checkbox);\n-                cb.toggle();\n-                onCheck(position, view);\n-            } else {\n-                // load up the card selected on the list\n-                long clickedCardId = getCards().get(position).getId();\n-                saveScrollingState(position);\n-                openNoteEditorForCard(clickedCardId);\n-            }\n-        });\n-\n-        mCardsListView.setOnItemLongClickListener((adapterView, view, position, id) -> {\n-            if (mInMultiSelectMode) {\n-                boolean hasChanged = false;\n-                for (int i = Math.min(mLastSelectedPosition, position); i <= Math.max(mLastSelectedPosition, position); i++) {\n-                    CardCache card = (CardCache) mCardsListView.getItemAtPosition(i);\n-\n-                    // Add to the set of checked cards\n-                    hasChanged |= mCheckedCards.add(card);\n-                }\n-                if (hasChanged) {\n-                    onSelectionChanged();\n-                }\n-            } else {\n-                mLastSelectedPosition = position;\n-                saveScrollingState(position);\n-                loadMultiSelectMode();\n-\n-                // click on whole cell triggers select\n-                CheckBox cb = view.findViewById(R.id.card_checkbox);\n-                cb.toggle();\n-                onCheck(position, view);\n-                recenterListView(view);\n-                mCardsAdapter.notifyDataSetChanged();\n-            }\n-            return true;\n-        });\n-\n-        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n-\n-        long deckId = getCol().getDecks().selected();\n-        mDeckSpinnerSelection = new DeckSpinnerSelection(this, col, this.findViewById(R.id.toolbar_spinner));\n-        mDeckSpinnerSelection.setShowAllDecks(true);\n-        mDeckSpinnerSelection.initializeActionBarDeckSpinner(this.getSupportActionBar());\n-        selectDeckAndSave(deckId);\n-\n-        // If a valid value for last deck exists then use it, otherwise use libanki selected deck\n-        if (getLastDeckId() != null && getLastDeckId() == ALL_DECKS_ID) {\n-            selectAllDecks();\n-        } else  if (getLastDeckId() != null && getCol().getDecks().get(getLastDeckId(), false) != null) {\n-            mDeckSpinnerSelection.selectDeckById(getLastDeckId(), false);\n-        } else {\n-            mDeckSpinnerSelection.selectDeckById(getCol().getDecks().selected(), false);\n-        }\n-    }\n-\n-    public void selectDeckAndSave(long deckId) {\n-        mDeckSpinnerSelection.selectDeckById(deckId, true);\n-        if (deckId == ALL_DECKS_ID) {\n-            mRestrictOnDeck = \"\";\n-        } else {\n-            String deckName = getCol().getDecks().name(deckId);\n-            mRestrictOnDeck = \"deck:\\\"\" + deckName + \"\\\" \";\n-        }\n-        saveLastDeckId(deckId);\n-        searchCards();\n-    }\n-\n-\n-\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        // NOTE: These are all active when typing in the search - doesn't matter as all need CTRL\n-\n-        switch (keyCode) {\n-            /* Ctrl+A - Select All */\n-            case KeyEvent.KEYCODE_A: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+A - Select All\");\n-                    onSelectAll();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_E: {\n-                // Ctrl+Shift+E: Export (TODO)\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+E: Add Note\");\n-                    addNoteFromCardBrowser();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_D: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+D: Change Deck\");\n-                    showChangeDeckDialog();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_K: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+K: Toggle Mark\");\n-                    toggleMark();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_R: {\n-                if (event.isCtrlPressed() && event.isAltPressed()) {\n-                    Timber.i(\"Ctrl+Alt+R - Reschedule\");\n-                    rescheduleSelectedCards();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_FORWARD_DEL: {\n-                Timber.i(\"Delete pressed - Delete Selected Note\");\n-                deleteSelectedNote();\n-                return true;\n-            }\n-        }\n-        return super.onKeyDown(keyCode, event);\n-    }\n-\n-    /** All the notes of the selected cards will be marked\n-     * If one or more card is unmarked, all will be marked,\n-     * otherwise, they will be unmarked */\n-    private void toggleMark() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Not marking cards - nothing selected\");\n-            return;\n-        }\n-\n-        TaskManager.launchCollectionTask(new CollectionTask.MarkNoteMulti(getSelectedCardIds()),\n-                markCardHandler());\n-    }\n-\n-\n-    @VisibleForTesting\n-    void selectAllDecks() {\n-        mDeckSpinnerSelection.selectDropDownItem(0);\n-        mRestrictOnDeck = \"\";\n-        saveLastDeckId(ALL_DECKS_ID);\n-        searchCards();\n-    }\n-\n-\n-    /** Opens the note editor for a card.\n-     * We use the Card ID to specify the preview target */\n-    public void openNoteEditorForCard(long cardId) {\n-        mCurrentCardId = cardId;\n-        sCardBrowserCard = getCol().getCard(mCurrentCardId);\n-        // start note editor using the card we just loaded\n-        Intent editCard = new Intent(this, NoteEditor.class)\n-                .putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_EDIT)\n-                .putExtra(NoteEditor.EXTRA_CARD_ID, sCardBrowserCard.getId());\n-        this.launchActivityForResultWithAnimation(editCard, mOnEditCardActivityResult, START);\n-        //#6432 - FIXME - onCreateOptionsMenu crashes if receiving an activity result from edit card when in multiselect\n-        endMultiSelectMode();\n-    }\n-\n-    private void openNoteEditorForCurrentlySelectedNote() {\n-        try {\n-            //Just select the first one. It doesn't particularly matter if there's a multiselect occurring.\n-            openNoteEditorForCard(getSelectedCardIds().get(0));\n-        } catch (Exception e) {\n-            Timber.w(e, \"Error Opening Note Editor\");\n-            UIUtils.showThemedToast(this, getString(R.string.multimedia_editor_something_wrong), false);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected void onStop() {\n-        Timber.d(\"onStop()\");\n-        // cancel rendering the question and answer, which has shared access to mCards\n-        super.onStop();\n-        if (!isFinishing()) {\n-            WidgetStatus.update(this);\n-            UIUtils.saveCollectionInBackground();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected void onDestroy() {\n-        Timber.d(\"onDestroy()\");\n-        invalidate();\n-        super.onDestroy();\n-        if (mUnmountReceiver != null) {\n-            unregisterReceiver(mUnmountReceiver);\n-        }\n-    }\n-\n-\n-    @Override\n-    public void onBackPressed() {\n-        if (isDrawerOpen()) {\n-            super.onBackPressed();\n-        } else if (mInMultiSelectMode) {\n-            endMultiSelectMode();\n-        } else {\n-            Timber.i(\"Back key pressed\");\n-            Intent data = new Intent();\n-            if (mReloadRequired) {\n-                // Add reload flag to result intent so that schedule reset when returning to note editor\n-                data.putExtra(\"reloadRequired\", true);\n-            }\n-            closeCardBrowser(RESULT_OK, data);\n-        }\n-    }\n-\n-    @Override\n-    protected void onPause() {\n-        super.onPause();\n-        // If the user entered something into the search, but didn't press \"search\", clear this.\n-        // It's confusing if the bar is shown with a query that does not relate to the data on the screen\n-        mTempSearchQuery = null;\n-        if (mPostAutoScroll) {\n-            mPostAutoScroll = false;\n-        }\n-    }\n-\n-    @Override\n-    protected void onResume() {\n-        Timber.d(\"onResume()\");\n-        super.onResume();\n-        selectNavigationItem(R.id.nav_browser);\n-    }\n-\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(final Menu menu) {\n-        Timber.d(\"onCreateOptionsMenu()\");\n-        mActionBarMenu = menu;\n-        if (!mInMultiSelectMode) {\n-            // restore drawer click listener and icon\n-            restoreDrawerIcon();\n-            getMenuInflater().inflate(R.menu.card_browser, menu);\n-            mSaveSearchItem = menu.findItem(R.id.action_save_search);\n-            mSaveSearchItem.setVisible(false); //the searchview's query always starts empty.\n-            mMySearchesItem = menu.findItem(R.id.action_list_my_searches);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            mMySearchesItem.setVisible(savedFiltersObj != null && savedFiltersObj.length() > 0);\n-            mSearchItem = menu.findItem(R.id.action_search);\n-            mSearchItem.setOnActionExpandListener(new MenuItem.OnActionExpandListener() {\n-                @Override\n-                public boolean onMenuItemActionExpand(MenuItem item) {\n-                    return true;\n-                }\n-\n-                @Override\n-                public boolean onMenuItemActionCollapse(MenuItem item) {\n-                    // SearchView doesn't support empty queries so we always reset the search when collapsing\n-                    mSearchTerms = \"\";\n-                    mSearchView.setQuery(mSearchTerms, false);\n-                    searchCards();\n-                    // invalidate options menu so that disappeared icons would appear again\n-                    supportInvalidateOptionsMenu();\n-                    mTempSearchQuery = null;\n-                    return true;\n-                }\n-            });\n-            mSearchView = (CardBrowserSearchView) mSearchItem.getActionView();\n-            mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n-                @Override\n-                public boolean onQueryTextChange(String newText) {\n-                    if (mSearchView.shouldIgnoreValueChange()) {\n-                        return true;\n-                    }\n-                    mSaveSearchItem.setVisible(!TextUtils.isEmpty(newText));\n-                    mTempSearchQuery = newText;\n-                    return true;\n-                }\n-\n-                @Override\n-                public boolean onQueryTextSubmit(String query) {\n-                    onSearch();\n-                    mSearchView.clearFocus();\n-                    return true;\n-                }\n-            });\n-            // Fixes #6500 - keep the search consistent if coming back from note editor\n-            // Fixes #9010 - consistent search after drawer change calls supportInvalidateOptionsMenu (mTempSearchQuery)\n-            if (!TextUtils.isEmpty(mTempSearchQuery) || !TextUtils.isEmpty(mSearchTerms)) {\n-                mSearchItem.expandActionView(); // This calls mSearchView.setOnSearchClickListener\n-                String toUse = !TextUtils.isEmpty(mTempSearchQuery) ? mTempSearchQuery : mSearchTerms;\n-                mSearchView.setQuery(toUse, false);\n-            }\n-            mSearchView.setOnSearchClickListener(v -> {\n-                // Provide SearchView with the previous search terms\n-                mSearchView.setQuery(mSearchTerms, false);\n-            });\n-        } else {\n-            // multi-select mode\n-            getMenuInflater().inflate(R.menu.card_browser_multiselect, menu);\n-            showBackIcon();\n-        }\n-\n-        if (mActionBarMenu != null && mActionBarMenu.findItem(R.id.action_undo) != null) {\n-            MenuItem undo =  mActionBarMenu.findItem(R.id.action_undo);\n-            undo.setVisible(getCol().undoAvailable());\n-            undo.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        // Maybe we were called from ACTION_PROCESS_TEXT.\n-        // In that case we already fill in the search.\n-        Intent intent = getIntent();\n-        Compat compat = CompatHelper.getCompat();\n-        if (compat.ACTION_PROCESS_TEXT.equals(intent.getAction())) {\n-            CharSequence search = intent.getCharSequenceExtra(compat.EXTRA_PROCESS_TEXT);\n-            if (search != null && search.length() != 0) {\n-                Timber.i(\"CardBrowser :: Called with search intent: %s\", search.toString());\n-                mSearchView.setQuery(search, true);\n-                intent.setAction(Intent.ACTION_DEFAULT);\n-            }\n-        }\n-\n-        mPreviewItem = menu.findItem(R.id.action_preview);\n-        onSelectionChanged();\n-        updatePreviewMenuItem();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-    @Override\n-    protected void onNavigationPressed() {\n-        if (mInMultiSelectMode) {\n-            endMultiSelectMode();\n-        } else {\n-            super.onNavigationPressed();\n-        }\n-    }\n-\n-\n-    private void displayDeckPickerForPermissionsDialog() {\n-        //TODO: Combine this with class: IntentHandler after both are well-tested\n-        Intent deckPicker = new Intent(this, DeckPicker.class);\n-        deckPicker.setAction(Intent.ACTION_MAIN);\n-        deckPicker.addCategory(Intent.CATEGORY_LAUNCHER);\n-        deckPicker.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-        startActivityWithAnimation(deckPicker, FADE);\n-        AnkiActivity.finishActivityWithFade(this);\n-        finishActivityWithFade(this);\n-        this.setResult(RESULT_CANCELED);\n-    }\n-\n-\n-    private boolean wasLoadedFromExternalTextActionItem() {\n-        Intent intent = this.getIntent();\n-        if (intent == null) {\n-            return false;\n-        }\n-        //API 23: Replace with Intent.ACTION_PROCESS_TEXT\n-        return \"android.intent.action.PROCESS_TEXT\".equalsIgnoreCase(intent.getAction());\n-    }\n-\n-    private void updatePreviewMenuItem() {\n-        if (mPreviewItem == null) {\n-            return;\n-        }\n-        mPreviewItem.setVisible(getCardCount() > 0);\n-    }\n-\n-    /** Returns the number of cards that are visible on the screen */\n-    public int getCardCount() {\n-        return getCards().size();\n-    }\n-\n-\n-    private void updateMultiselectMenu() {\n-        Timber.d(\"updateMultiselectMenu()\");\n-        if (mActionBarMenu == null || mActionBarMenu.findItem(R.id.action_suspend_card) == null) {\n-            return;\n-        }\n-\n-        if (!mCheckedCards.isEmpty()) {\n-            TaskManager.cancelAllTasks(CollectionTask.CheckCardSelection.class);\n-            TaskManager.launchCollectionTask(new CollectionTask.CheckCardSelection(mCheckedCards),\n-                    mCheckSelectedCardsHandler);\n-        }\n-\n-        mActionBarMenu.findItem(R.id.action_select_all).setVisible(!hasSelectedAllCards());\n-        //Note: Theoretically should not happen, as this should kick us back to the menu\n-        mActionBarMenu.findItem(R.id.action_select_none).setVisible(hasSelectedCards());\n-        mActionBarMenu.findItem(R.id.action_edit_note).setVisible(canPerformMultiSelectEditNote());\n-        mActionBarMenu.findItem(R.id.action_view_card_info).setVisible(canPerformCardInfo());\n-    }\n-\n-\n-    private boolean hasSelectedCards() {\n-        return !mCheckedCards.isEmpty();\n-    }\n-\n-    private boolean hasSelectedAllCards() {\n-        return checkedCardCount() >= getCardCount(); //must handle 0.\n-    }\n-\n-\n-    @VisibleForTesting\n-    public void flagTask (int flag) {\n-        TaskManager.launchCollectionTask(\n-                new CollectionTask.Flag(getSelectedCardIds(), flag),\n-                flagCardHandler());\n-    }\n-\n-    /** Updates flag icon color and cards shown with given color */\n-    private void selectionWithFlagTask(int flag) {\n-        mCurrentFlag = flag;\n-        filterByFlag();\n-    }\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-\n-        // dismiss undo-snackbar if shown to avoid race condition\n-        // (when another operation will be performed on the model, it will undo the latest operation)\n-        if (mUndoSnackbar != null && mUndoSnackbar.isShown())\n-            mUndoSnackbar.dismiss();\n-\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            endMultiSelectMode();\n-            return true;\n-        } else if (itemId == R.id.action_add_note_from_card_browser) {\n-            addNoteFromCardBrowser();\n-            return true;\n-        } else if (itemId == R.id.action_save_search) {\n-            String searchTerms = mSearchView.getQuery().toString();\n-            showDialogFragment(CardBrowserMySearchesDialog.newInstance(null, mMySearchesDialogListener,\n-                    searchTerms, CardBrowserMySearchesDialog.CARD_BROWSER_MY_SEARCHES_TYPE_SAVE));\n-            return true;\n-        } else if (itemId == R.id.action_list_my_searches) {\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            HashMap<String, String> savedFilters;\n-            if (savedFiltersObj != null) {\n-                savedFilters = HashUtil.HashMapInit(savedFiltersObj.length());\n-                for (String searchName : savedFiltersObj) {\n-                    savedFilters.put(searchName, savedFiltersObj.optString(searchName));\n-                }\n-            } else {\n-                savedFilters = HashUtil.HashMapInit(0);\n-            }\n-            showDialogFragment(CardBrowserMySearchesDialog.newInstance(savedFilters, mMySearchesDialogListener,\n-                    \"\", CardBrowserMySearchesDialog.CARD_BROWSER_MY_SEARCHES_TYPE_LIST));\n-            return true;\n-        } else if (itemId == R.id.action_sort_by_size) {\n-            showDialogFragment(CardBrowserOrderDialog\n-                    .newInstance(mOrder, mOrderAsc, mOrderDialogListener));\n-            return true;\n-        } else if (itemId == R.id.action_show_marked) {\n-            mSearchTerms = \"tag:marked\";\n-            mSearchView.setQuery(\"\", false);\n-            mSearchView.setQueryHint(getResources().getString(R.string.card_browser_show_marked));\n-            searchCards();\n-            return true;\n-        } else if (itemId == R.id.action_show_suspended) {\n-            mSearchTerms = \"is:suspended\";\n-            mSearchView.setQuery(\"\", false);\n-            mSearchView.setQueryHint(getResources().getString(R.string.card_browser_show_suspended));\n-            searchCards();\n-            return true;\n-        } else if (itemId == R.id.action_search_by_tag) {\n-            showTagsDialog();\n-            return true;\n-        } else if (itemId == R.id.action_flag_zero) {\n-            flagTask(0);\n-            return true;\n-        } else if (itemId == R.id.action_flag_one) {\n-            flagTask(1);\n-            return true;\n-        } else if (itemId == R.id.action_flag_two) {\n-            flagTask(2);\n-            return true;\n-        } else if (itemId == R.id.action_flag_three) {\n-            flagTask(3);\n-            return true;\n-        } else if (itemId == R.id.action_flag_four) {\n-            flagTask(4);\n-            return true;\n-        } else if (itemId == R.id.action_flag_five) {\n-            flagTask(5);\n-            return true;\n-        } else if (itemId == R.id.action_flag_six) {\n-            flagTask(6);\n-            return true;\n-        } else if (itemId == R.id.action_flag_seven) {\n-            flagTask(7);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_zero) {\n-            selectionWithFlagTask(0);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_one) {\n-            selectionWithFlagTask(1);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_two) {\n-            selectionWithFlagTask(2);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_three) {\n-            selectionWithFlagTask(3);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_four) {\n-            selectionWithFlagTask(4);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_five) {\n-            selectionWithFlagTask(5);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_six) {\n-            selectionWithFlagTask(6);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_seven) {\n-            selectionWithFlagTask(7);\n-            return true;\n-        } else if (itemId == R.id.action_delete_card) {\n-            deleteSelectedNote();\n-            return true;\n-        } else if (itemId == R.id.action_mark_card) {\n-            toggleMark();\n-\n-            return true;\n-        } else if (itemId == R.id.action_suspend_card) {\n-            TaskManager.launchCollectionTask(new CollectionTask.SuspendCardMulti(getSelectedCardIds()),\n-                    suspendCardHandler());\n-\n-            return true;\n-        } else if (itemId == R.id.action_change_deck) {\n-            showChangeDeckDialog();\n-            return true;\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.w(\"CardBrowser:: Undo pressed\");\n-            onUndo();\n-            return true;\n-        } else if (itemId == R.id.action_select_none) {\n-            onSelectNone();\n-            return true;\n-        } else if (itemId == R.id.action_select_all) {\n-            onSelectAll();\n-            return true;\n-        } else if (itemId == R.id.action_preview) {\n-            onPreview();\n-            return true;\n-        } else if (itemId == R.id.action_reset_cards_progress) {\n-            Timber.i(\"NoteEditor:: Reset progress button pressed\");\n-            onResetProgress();\n-            return true;\n-        } else if (itemId == R.id.action_reschedule_cards) {\n-            Timber.i(\"CardBrowser:: Reschedule button pressed\");\n-            rescheduleSelectedCards();\n-            return true;\n-        } else if (itemId == R.id.action_reposition_cards) {\n-            Timber.i(\"CardBrowser:: Reposition button pressed\");\n-\n-            // Only new cards may be repositioned\n-            List<Long> cardIds = getSelectedCardIds();\n-            for (long cardId : cardIds) {\n-                if (getCol().getCard(cardId).getQueue() != Consts.QUEUE_TYPE_NEW) {\n-                    SimpleMessageDialog dialog = SimpleMessageDialog.newInstance(\n-                            getString(R.string.vague_error),\n-                            getString(R.string.reposition_card_not_new_error),\n-                            false);\n-                    showDialogFragment(dialog);\n-                    return false;\n-                }\n-            }\n-\n-            IntegerDialog repositionDialog = new IntegerDialog();\n-            repositionDialog.setArgs(\n-                    getString(R.string.reposition_card_dialog_title),\n-                    getString(R.string.reposition_card_dialog_message),\n-                    5);\n-            repositionDialog.setCallbackRunnable(position -> repositionCardsNoValidation(cardIds, position));\n-            showDialogFragment(repositionDialog);\n-            return true;\n-        } else if (itemId == R.id.action_edit_note) {\n-            openNoteEditorForCurrentlySelectedNote();\n-\n-\n-            return super.onOptionsItemSelected(item);\n-        } else if (itemId == R.id.action_view_card_info) {\n-            List<Long> selectedCardIds = getSelectedCardIds();\n-            if (!selectedCardIds.isEmpty()) {\n-                Intent intent = new Intent(this, CardInfo.class);\n-                intent.putExtra(\"cardId\", selectedCardIds.get(0));\n-                startActivityWithAnimation(intent, FADE);\n-            }\n-            return true;\n-        }\n-        return super.onOptionsItemSelected(item);\n-    }\n-\n-\n-    protected void deleteSelectedNote() {\n-        if (!mInMultiSelectMode) {\n-            return;\n-        }\n-        TaskManager.launchCollectionTask(new CollectionTask.DeleteNoteMulti(getSelectedCardIds()),\n-                                            mDeleteNoteHandler);\n-\n-        mCheckedCards.clear();\n-        endMultiSelectMode();\n-        mCardsAdapter.notifyDataSetChanged();\n-    }\n-\n-\n-    @VisibleForTesting\n-    void onUndo() {\n-        if (getCol().undoAvailable()) {\n-            new UndoService.Undo().runWithHandler(mUndoHandler);\n-        }\n-    }\n-\n-\n-    protected void onResetProgress() {\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getString(R.string.reset_card_dialog_title);\n-        String message = getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"CardBrowser:: ResetProgress button pressed\");\n-            resetProgressNoConfirm(getSelectedCardIds());\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    @VisibleForTesting\n-    void resetProgressNoConfirm(List<Long> cardIds) {\n-        TaskManager.launchCollectionTask(new SchedulerService.ResetCards(cardIds).toDelegate(), resetProgressCardHandler());\n-    }\n-\n-\n-    @VisibleForTesting\n-    void repositionCardsNoValidation(List<Long> cardIds, Integer position) {\n-        TaskManager.launchCollectionTask(new SchedulerService.RepositionCards(cardIds, position).toDelegate(),\n-                                            repositionCardHandler());\n-    }\n-\n-\n-    protected void onPreview() {\n-        Intent previewer = getPreviewIntent();\n-        this.launchActivityForResultWithoutAnimation(previewer, mOnPreviewCardsActivityResult);\n-    }\n-\n-\n-    @NonNull\n-    @VisibleForTesting\n-    Intent getPreviewIntent() {\n-        if (mInMultiSelectMode && checkedCardCount() > 1) {\n-            // Multiple cards have been explicitly selected, so preview only those cards\n-            int index = 0;\n-            return getPreviewIntent(index, Utils.toPrimitive(getSelectedCardIds()));\n-        } else {\n-            // Preview all cards, starting from the one that is currently selected\n-            int startIndex = mCheckedCards.isEmpty() ? 0 : mCheckedCards.iterator().next().getPosition();\n-            return getPreviewIntent(startIndex, getAllCardIds());\n-        }\n-    }\n-\n-\n-    @NonNull\n-    private Intent getPreviewIntent(int index, long[] selectedCardIds) {\n-        return Previewer.getPreviewIntent(CardBrowser.this, index, selectedCardIds);\n-    }\n-\n-\n-    private void rescheduleSelectedCards() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Attempted reschedule - no cards selected\");\n-            return;\n-        }\n-\n-        List<Long> selectedCardIds = getSelectedCardIds();\n-        FunctionalInterfaces.Consumer<Integer> consumer = newDays -> rescheduleWithoutValidation(selectedCardIds, newDays);\n-        RescheduleDialog rescheduleDialog;\n-        if (selectedCardIds.size() == 1) {\n-            long cardId = selectedCardIds.get(0);\n-            Card selected = getCol().getCard(cardId);\n-            rescheduleDialog = RescheduleDialog.rescheduleSingleCard(getResources(), selected, consumer);\n-        } else {\n-            rescheduleDialog = RescheduleDialog.rescheduleMultipleCards(getResources(),\n-                    consumer,\n-                    selectedCardIds.size());\n-        }\n-        showDialogFragment(rescheduleDialog);\n-    }\n-\n-\n-    @VisibleForTesting\n-    void rescheduleWithoutValidation(List<Long> selectedCardIds, Integer newDays) {\n-        TaskManager.launchCollectionTask(new SchedulerService.RescheduleCards(selectedCardIds, newDays).toDelegate(),\n-            rescheduleCardHandler());\n-    }\n-\n-\n-    private void showChangeDeckDialog() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Not showing Change Deck - No Cards\");\n-            return;\n-        }\n-\n-        AlertDialog.Builder builderSingle = new AlertDialog.Builder(this);\n-        builderSingle.setTitle(getString(R.string.move_all_to_deck));\n-\n-        //WARNING: changeDeck depends on this index, so any changes should be reflected there.\n-        final ArrayAdapter<String> arrayAdapter = new ArrayAdapter<>(this, R.layout.dropdown_deck_item);\n-        for (Deck deck : getValidDecksForChangeDeck()) {\n-            try {\n-                arrayAdapter.add(deck.getString(\"name\"));\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-            }\n-        }\n-\n-        builderSingle.setNegativeButton(getString(R.string.dialog_cancel), (dialog, which) -> dialog.dismiss());\n-        builderSingle.setAdapter(arrayAdapter, (dialog, which) -> moveSelectedCardsToDeck(which));\n-        builderSingle.show();\n-    }\n-\n-\n-    @VisibleForTesting\n-    Intent getAddNoteIntent() {\n-        Intent intent = new Intent(CardBrowser.this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_ADD);\n-        Long did = getLastDeckId();\n-        if (did != null && did > 0) {\n-            intent.putExtra(NoteEditor.EXTRA_DID, (long) did);\n-        }\n-        intent.putExtra(NoteEditor.EXTRA_TEXT_FROM_SEARCH_VIEW, mSearchTerms);\n-        return intent;\n-    }\n-\n-    private void addNoteFromCardBrowser() {\n-        this.launchActivityForResultWithAnimation(getAddNoteIntent(), mOnAddNoteActivityResult, START);\n-    }\n-\n-\n-    // We spawn CollectionTasks that may create memory pressure, this transmits it so polling isCancelled sees the pressure\n-    @Override\n-    public void onTrimMemory(int pressureLevel) {\n-        super.onTrimMemory(pressureLevel);\n-        TaskManager.cancelCurrentlyExecutingTask();\n-    }\n-\n-    private long getReviewerCardId() {\n-        if (getIntent().hasExtra(\"currentCard\")) {\n-            return getIntent().getExtras().getLong(\"currentCard\");\n-        } else {\n-            return -1;\n-        }\n-    }\n-\n-    private void showTagsDialog() {\n-        TagsDialog dialog = mTagsDialogFactory.newTagsDialog().withArguments(\n-                TagsDialog.DialogType.FILTER_BY_TAG, new ArrayList<>(0), new ArrayList<>(getCol().getTags().all()));\n-        showDialogFragment(dialog);\n-    }\n-\n-    @Override\n-    public void onSaveInstanceState(@NonNull Bundle savedInstanceState) {\n-        // Save current search terms\n-        savedInstanceState.putString(\"mSearchTerms\", mSearchTerms);\n-        savedInstanceState.putLong(\"mOldCardId\", mOldCardId);\n-        savedInstanceState.putInt(\"mOldCardTopOffset\", mOldCardTopOffset);\n-        savedInstanceState.putBoolean(\"mShouldRestoreScroll\", mShouldRestoreScroll);\n-        savedInstanceState.putBoolean(\"mPostAutoScroll\", mPostAutoScroll);\n-        savedInstanceState.putInt(\"mLastSelectedPosition\", mLastSelectedPosition);\n-        savedInstanceState.putBoolean(\"mInMultiSelectMode\", mInMultiSelectMode);\n-        super.onSaveInstanceState(savedInstanceState);\n-    }\n-\n-    @Override\n-    public void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {\n-        super.onRestoreInstanceState(savedInstanceState);\n-        mSearchTerms = savedInstanceState.getString(\"mSearchTerms\");\n-        mOldCardId = savedInstanceState.getLong(\"mOldCardId\");\n-        mOldCardTopOffset = savedInstanceState.getInt(\"mOldCardTopOffset\");\n-        mShouldRestoreScroll = savedInstanceState.getBoolean(\"mShouldRestoreScroll\");\n-        mPostAutoScroll = savedInstanceState.getBoolean(\"mPostAutoScroll\");\n-        mLastSelectedPosition = savedInstanceState.getInt(\"mLastSelectedPosition\");\n-        mInMultiSelectMode = savedInstanceState.getBoolean(\"mInMultiSelectMode\");\n-        searchCards();\n-    }\n-\n-    private void invalidate() {\n-        TaskManager.cancelAllTasks(CollectionTask.SearchCards.class);\n-        TaskManager.cancelAllTasks(CollectionTask.RenderBrowserQA.class);\n-        TaskManager.cancelAllTasks(CollectionTask.CheckCardSelection.class);\n-        mCards.clear();\n-        mCheckedCards.clear();\n-    }\n-\n-    /** Currently unused - to be used in #7676 */\n-    private void forceRefreshSearch() {\n-        searchCards();\n-    }\n-\n-\n-    private void searchCards() {\n-        // cancel the previous search & render tasks if still running\n-        invalidate();\n-        String searchText;\n-        if (mSearchTerms == null) {\n-            mSearchTerms = \"\";\n-        }\n-        if (!\"\".equals(mSearchTerms) && (mSearchView != null)) {\n-            mSearchView.setQuery(mSearchTerms, false);\n-            mSearchItem.expandActionView();\n-        }\n-        if (mSearchTerms.contains(\"deck:\")) {\n-            searchText = \"(\" + mSearchTerms + \")\";\n-        } else {\n-            if (!\"\".equals(mSearchTerms))\n-                searchText = mRestrictOnDeck + \"(\" + mSearchTerms + \")\";\n-            else\n-                searchText = mRestrictOnDeck;\n-        }\n-        if (colIsOpen() && mCardsAdapter!= null) {\n-            // clear the existing card list\n-            mCards.reset();\n-            mCardsAdapter.notifyDataSetChanged();\n-            //  estimate maximum number of cards that could be visible (assuming worst-case minimum row height of 20dp)\n-            // Perform database query to get all card ids\n-            TaskManager.launchCollectionTask(new CollectionTask.SearchCards(searchText,\n-                            (mOrder != CARD_ORDER_NONE),\n-                            numCardsToRender(),\n-                            mColumn1Index,\n-                            mColumn2Index),\n-                    mSearchCardsHandler\n-            );\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    protected int numCardsToRender() {\n-        return (int) Math.ceil(mCardsListView.getHeight() /\n-                TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, getResources().getDisplayMetrics())) + 5;\n-    }\n-\n-    private void updateList() {\n-        if (colIsOpen() && mCardsAdapter!= null) {\n-            mCardsAdapter.notifyDataSetChanged();\n-            mDeckSpinnerSelection.notifyDataSetChanged();\n-            onSelectionChanged();\n-            updatePreviewMenuItem();\n-        }\n-    }\n-\n-    /**\n-     * @return text to be used in the subtitle of the drop-down deck selector\n-     */\n-    public String getSubtitleText() {\n-        int count = getCardCount();\n-        return getResources().getQuantityString(R.plurals.card_browser_subtitle, count, count);\n-    }\n-\n-\n-    private static Map<Long, Integer> getPositionMap(CardCollection<CardCache> list) {\n-        Map<Long, Integer> positions = HashUtil.HashMapInit(list.size());\n-        for (int i = 0; i < list.size(); i++) {\n-            positions.put(list.get(i).getId(), i);\n-        }\n-        return positions;\n-    }\n-\n-    // convenience method for updateCardsInList(...)\n-    private void updateCardInList(Card card) {\n-        List<Card> cards = new ArrayList<>(1);\n-        cards.add(card);\n-        updateCardsInList(cards);\n-    }\n-\n-    /** Returns the decks which are valid targets for \"Change Deck\" */\n-    @VisibleForTesting\n-    List<Deck> getValidDecksForChangeDeck() {\n-        List<Deck> nonDynamicDecks = new ArrayList<>(mDeckSpinnerSelection.getDropDownDecks().size());\n-        for (Deck d : mDeckSpinnerSelection.getDropDownDecks()) {\n-            if (Decks.isDynamic(d)) {\n-                continue;\n-            }\n-            nonDynamicDecks.add(d);\n-        }\n-        return nonDynamicDecks;\n-    }\n-\n-\n-    @Override\n-    public void onSelectedTags(List<String> selectedTags, int option) {\n-        //TODO: Duplication between here and CustomStudyDialog:onSelectedTags\n-        mSearchView.setQuery(\"\", false);\n-        String tags = selectedTags.toString();\n-        mSearchView.setQueryHint(getResources().getString(R.string.CardEditorTags,\n-                tags.substring(1, tags.length() - 1)));\n-        StringBuilder sb = new StringBuilder();\n-        switch (option) {\n-            case 1:\n-                sb.append(\"is:new \");\n-                break;\n-            case 2:\n-                sb.append(\"is:due \");\n-                break;\n-            default:\n-                // Logging here might be appropriate : )\n-                break;\n-        }\n-        int i = 0;\n-        for (String tag : selectedTags) {\n-            if (i != 0) {\n-                sb.append(\"or \");\n-            } else {\n-                sb.append(\"(\"); // Only if we really have selected tags\n-            }\n-            // 7070: quote tags so brackets are properly escaped\n-            sb.append(\"tag:\").append(\"'\").append(tag).append(\"'\").append(\" \");\n-            i++;\n-        }\n-        if (i > 0) {\n-            sb.append(\")\"); // Only if we added anything to the tag list\n-        }\n-        mSearchTerms = sb.toString();\n-        searchCards();\n-    }\n-\n-\n-    /** Updates search terms to only show cards with selected flag. */\n-    private void filterByFlag() {\n-        mSearchView.setQuery(\"\", false);\n-        String flagSearchTerm = \"flag:\" + mCurrentFlag;\n-        if (mSearchTerms.contains(\"flag:\")) {\n-            mSearchTerms = mSearchTerms.replaceFirst(\"flag:.\", flagSearchTerm);\n-        }\n-        else if (!mSearchTerms.isEmpty()) {\n-            mSearchTerms = flagSearchTerm + \" \" + mSearchTerms;\n-        } else {\n-            mSearchTerms = flagSearchTerm;\n-        }\n-        searchCards();\n-    }\n-\n-\n-    private static abstract class ListenerWithProgressBar<Progress, Result> extends TaskListenerWithContext<CardBrowser, Progress, Result>{\n-        public ListenerWithProgressBar(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            browser.showProgressBar();\n-        }\n-    }\n-\n-    /** Does not leak Card Browser. */\n-    private static abstract class ListenerWithProgressBarCloseOnFalse<Progress, Result extends Computation<?>> extends ListenerWithProgressBar<Progress, Result> {\n-        private final String mTimber;\n-        public ListenerWithProgressBarCloseOnFalse(String timber, CardBrowser browser) {\n-            super(browser);\n-            mTimber = timber;\n-        }\n-\n-        public ListenerWithProgressBarCloseOnFalse(CardBrowser browser) {\n-            this(null, browser);\n-\t\t}\n-\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Result result) {\n-            if (mTimber != null) {\n-                Timber.d(mTimber);\n-            }\n-            if (result.succeeded()) {\n-                actualOnValidPostExecute(browser, result);\n-            } else {\n-                browser.closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-            }\n-        }\n-\n-        protected abstract void actualOnValidPostExecute(CardBrowser browser, Result result);\n-    }\n-\n-    /**\n-     * @param cards Cards that were changed\n-     */\n-    private void updateCardsInList(List<Card> cards) {\n-        CardCollection<CardCache> cardList = getCards();\n-        Map<Long, Integer> idToPos = getPositionMap(cardList);\n-        for (Card c : cards) {\n-            // get position in the mCards search results HashMap\n-            Integer pos = idToPos.get(c.getId());\n-            if (pos == null || pos >= getCardCount()) {\n-                continue;\n-            }\n-            // update Q & A etc\n-            cardList.get(pos).load(true, mColumn1Index, mColumn2Index);\n-        }\n-\n-        updateList();\n-    }\n-\n-    private UpdateCardHandler updateCardHandler() {\n-        return new UpdateCardHandler(this);\n-    }\n-\n-    private static class UpdateCardHandler extends ListenerWithProgressBarCloseOnFalse<Card, Computation<?>> {\n-        public UpdateCardHandler(CardBrowser browser) {\n-            super(\"Card Browser - UpdateCardHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Card value) {\n-            browser.updateCardInList(value);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-    private static class ChangeDeckHandler extends ListenerWithProgressBarCloseOnFalse<Object, Computation<? extends Card[]>> {\n-        public ChangeDeckHandler(CardBrowser browser) {\n-            super(\"Card Browser - changeDeckHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n-        }\n-\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> result) {\n-            browser.hideProgressBar();\n-\n-            browser.searchCards();\n-            browser.endMultiSelectMode();\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-\n-            if (!result.succeeded()) {\n-                Timber.i(\"changeDeckHandler failed, not offering undo\");\n-                browser.displayCouldNotChangeDeck();\n-                return;\n-            }\n-            // snackbar to offer undo\n-            String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(\n-                    browser,\n-                    String.format(browser.getString(R.string.changed_deck_message), deckName),\n-                    SNACKBAR_DURATION,\n-                    R.string.undo,\n-                    v -> TaskManager.launchCollectionTask(new UndoService.Undo().toDelegate(), browser.mUndoHandler),\n-                    browser.mCardsListView, null);\n-        }\n-    }\n-\n-\n-    @CheckResult\n-    private static String formatQA(String text, Context context) {\n-        boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n-        return formatQAInternal(text, showFilenames);\n-    }\n-\n-\n-    /**\n-     * @param txt The text to strip HTML, comments, tags and media from\n-     * @param showFileNames Whether [sound:foo.mp3] should be rendered as \" foo.mp3 \" or  \" \"\n-     * @return The formatted string\n-     */\n-    @VisibleForTesting\n-    @CheckResult\n-    static String formatQAInternal(String txt, boolean showFileNames) {\n-        /* Strips all formatting from the string txt for use in displaying question/answer in browser */\n-        String s = txt;\n-        s = s.replaceAll(\"<!--.*?-->\", \"\");\n-        s = s.replace(\"<br>\", \" \");\n-        s = s.replace(\"<br />\", \" \");\n-        s = s.replace(\"<div>\", \" \");\n-        s = s.replace(\"\\n\", \" \");\n-        s = showFileNames ? Utils.stripSoundMedia(s) : Utils.stripSoundMedia(s, \" \");\n-        s = s.replaceAll(\"\\\\[\\\\[type:[^]]+]]\", \"\");\n-        s = showFileNames ? Utils.stripHTMLMedia(s) : Utils.stripHTMLMedia(s, \" \");\n-        s = s.trim();\n-        return s;\n-    }\n-\n-    /**\n-     * Removes cards from view. Doesn't delete them in model (database).\n-     */\n-    @SuppressWarnings(\"SameParameterValue\")\n-    private void removeNotesView(Card[] cards, boolean reorderCards) {\n-        List<Long> cardIds = new ArrayList<>(cards.length);\n-        for (Card c : cards) {\n-            cardIds.add(c.getId());\n-        }\n-        removeNotesView(cardIds, reorderCards);\n-    }\n-\n-    /**\n-     * Removes cards from view. Doesn't delete them in model (database).\n-     * @param reorderCards Whether to rearrange the positions of checked items (DEFECT: Currently deselects all)\n-     */\n-    private void removeNotesView(java.util.Collection<Long> cardsIds, boolean reorderCards) {\n-        long reviewerCardId = getReviewerCardId();\n-        CardCollection<CardCache> oldMCards = getCards();\n-        Map<Long, Integer> idToPos = getPositionMap(oldMCards);\n-        Set<Long> idToRemove = new HashSet<>();\n-        for (Long cardId : cardsIds) {\n-            if (cardId == reviewerCardId) {\n-                mReloadRequired = true;\n-            }\n-            if (idToPos.containsKey(cardId)) {\n-                idToRemove.add(cardId);\n-            }\n-        }\n-\n-        List<CardCache> newMCards = new ArrayList<>(oldMCards.size());\n-        int pos = 0;\n-        for (CardCache card: oldMCards) {\n-            if (!idToRemove.contains(card.getId())) {\n-                newMCards.add(new CardCache(card, pos++));\n-            }\n-        }\n-        mCards.replaceWith(newMCards);\n-\n-        if (reorderCards) {\n-            //Suboptimal from a UX perspective, we should reorder\n-            //but this is only hit on a rare sad path and we'd need to rejig the data structures to allow an efficient\n-            //search\n-            Timber.w(\"Removing current selection due to unexpected removal of cards\");\n-            onSelectNone();\n-        }\n-\n-        updateList();\n-    }\n-\n-    private SuspendCardHandler suspendCardHandler() {\n-        return new SuspendCardHandler(this);\n-    }\n-\n-    private static class SuspendCardHandler extends ListenerWithProgressBarCloseOnFalse<Void, Computation<? extends Card[]>> {\n-        public SuspendCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> cards) {\n-            browser.updateCardsInList(Arrays.asList(cards.getValue()));\n-            browser.hideProgressBar();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-    private FlagCardHandler flagCardHandler(){\n-        return new FlagCardHandler(this);\n-    }\n-    private static class FlagCardHandler extends SuspendCardHandler {\n-        public FlagCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-    }\n-\n-\n-    private MarkCardHandler markCardHandler() {\n-        return new MarkCardHandler(this);\n-    }\n-    private static class MarkCardHandler extends ListenerWithProgressBarCloseOnFalse<Void, Computation<? extends Card[]>> {\n-        public MarkCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> cards) {\n-            browser.updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards.getValue()))));\n-            browser.hideProgressBar();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-\n-    private final DeleteNoteHandler mDeleteNoteHandler = new DeleteNoteHandler(this);\n-    private static class DeleteNoteHandler extends ListenerWithProgressBarCloseOnFalse<Card[], Computation<?>> {\n-        public DeleteNoteHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        private int mCardsDeleted = -1;\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            super.actualOnPreExecute(browser);\n-            browser.invalidate();\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Card[] cards) {\n-            //we don't need to reorder cards here as we've already deselected all notes,\n-            browser.removeNotesView(cards, false);\n-            mCardsDeleted = cards.length;\n-        }\n-\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            browser.hideProgressBar();\n-            browser.mActionBarTitle.setText(String.format(getLocaleCompat(browser.getResources()), \"%d\", browser.checkedCardCount()));\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-            // snackbar to offer undo\n-            String deletedMessage = browser.getResources().getQuantityString(R.plurals.card_browser_cards_deleted, mCardsDeleted, mCardsDeleted);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, deletedMessage, SNACKBAR_DURATION,\n-                    R.string.undo, v -> new UndoService.Undo().runWithHandler(browser.mUndoHandler),\n-                    browser.mCardsListView, null);\n-            browser.searchCards();\n-        }\n-    }\n-\n-\n-\n-    private final UndoHandler mUndoHandler = new UndoHandler(this);\n-    private static class UndoHandler extends ListenerWithProgressBarCloseOnFalse<Card, Computation<?>> {\n-        public UndoHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            Timber.d(\"Card Browser - mUndoHandler.actualOnPostExecute(CardBrowser browser)\");\n-            browser.hideProgressBar();\n-            // reload whole view\n-            browser.forceRefreshSearch();\n-            browser.endMultiSelectMode();\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-            browser.updatePreviewMenuItem();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-\n-    private final SearchCardsHandler mSearchCardsHandler = new SearchCardsHandler(this);\n-    @VisibleForTesting\n-    class SearchCardsHandler extends ListenerWithProgressBar<List<CardCache>, List<CardCache>> {\n-        public SearchCardsHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, List<CardCache> cards) {\n-            // Need to copy the list into a new list, because the original list is modified, and\n-            // ListAdapter crash\n-            mCards.replaceWith(new ArrayList<>(cards));\n-            updateList();\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, List<CardCache> result) {\n-            if (result != null) {\n-                mCards.replaceWith(result);\n-                updateList();\n-                handleSearchResult();\n-            }\n-            if (mShouldRestoreScroll) {\n-                mShouldRestoreScroll = false;\n-                int newPosition = getNewPositionOfSelectedCard();\n-                boolean isRestorePossible = (newPosition != CARD_NOT_AVAILABLE);\n-                if (isRestorePossible) {\n-                    autoScrollTo(newPosition);\n-                }\n-            }\n-            updatePreviewMenuItem();\n-            hideProgressBar();\n-        }\n-\n-\n-        private void handleSearchResult() {\n-            Timber.i(\"CardBrowser:: Completed doInBackgroundSearchCards Successfully\");\n-            updateList();\n-            \n-            if ((mSearchView == null) || mSearchView.isIconified()) {\n-                return;\n-            }\n-\n-            if (hasSelectedAllDecks()) {\n-                UIUtils.showSimpleSnackbar(CardBrowser.this, getSubtitleText(), true);\n-                return;\n-            }\n-\n-            //If we haven't selected all decks, allow the user the option to search all decks.\n-            String displayText;\n-            if (getCardCount() == 0) {\n-                displayText = getString(R.string.card_browser_no_cards_in_deck, getSelectedDeckNameForUi());\n-            } else {\n-                displayText = getSubtitleText();\n-            }\n-            View root = CardBrowser.this.findViewById(R.id.root_layout);\n-            UIUtils.showSnackbar(CardBrowser.this,\n-                    displayText,\n-                    SNACKBAR_DURATION,\n-                    R.string.card_browser_search_all_decks,\n-                    (v) -> searchAllDecks(),\n-                    root,\n-                    null);\n-\n-        }\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            super.actualOnCancelled(browser);\n-            hideProgressBar();\n-        }\n-    }\n-\n-\n-    private void saveScrollingState(int position) {\n-        mOldCardId = getCards().get(position).getId();\n-        mOldCardTopOffset = calculateTopOffset(position);\n-    }\n-\n-    private void autoScrollTo(int newPosition) {\n-        mCardsListView.setSelectionFromTop(newPosition, mOldCardTopOffset);\n-        mPostAutoScroll = true;\n-    }\n-\n-    private int calculateTopOffset(int cardPosition) {\n-        int firstVisiblePosition = mCardsListView.getFirstVisiblePosition();\n-        View v = mCardsListView.getChildAt(cardPosition - firstVisiblePosition);\n-        return (v == null) ? 0 : v.getTop();\n-    }\n-\n-    private int getNewPositionOfSelectedCard() {\n-        if (mCards.size() == 0) {\n-            return CARD_NOT_AVAILABLE;\n-        }\n-        for (CardCache card : mCards) {\n-            if (card.getId() == mOldCardId) {\n-                return card.mPosition;\n-            }\n-        }\n-        return CARD_NOT_AVAILABLE;\n-    }\n-\n-    public boolean hasSelectedAllDecks() {\n-        Long lastDeckId = getLastDeckId();\n-        return lastDeckId != null && lastDeckId == ALL_DECKS_ID;\n-    }\n-\n-\n-    public void searchAllDecks() {\n-        //all we need to do is select all decks\n-        selectAllDecks();\n-    }\n-\n-    /**\n-     * Returns the current deck name, \"All Decks\" if all decks are selected, or \"Unknown\"\n-     * Do not use this for any business logic, as this will return inconsistent data\n-     * with the collection.\n-     */\n-    public String getSelectedDeckNameForUi() {\n-        try {\n-            Long lastDeckId = getLastDeckId();\n-            if (lastDeckId == null) {\n-                return getString(R.string.card_browser_unknown_deck_name);\n-            }\n-            if (lastDeckId == ALL_DECKS_ID) {\n-                return getString(R.string.card_browser_all_decks);\n-            }\n-            return getCol().getDecks().name(lastDeckId);\n-        } catch (Exception e) {\n-            Timber.w(e, \"Unable to get selected deck name\");\n-            return getString(R.string.card_browser_unknown_deck_name);\n-        }\n-    }\n-\n-    private final RenderQAHandler mRenderQAHandler = new RenderQAHandler(this);\n-    private static class RenderQAHandler extends TaskListenerWithContext<CardBrowser, Integer, Pair<CardCollection<CardBrowser.CardCache>, List<Long>>>{\n-        public RenderQAHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Integer value) {\n-            // Note: This is called every time a card is rendered.\n-            // It blocks the long-click callback while the task is running, so usage of the task should be minimized\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-        }\n-\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"Starting Q&A background rendering\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Pair<CardCollection<CardBrowser.CardCache>, List<Long>> value) {\n-            List<Long> cardsIdsToHide = value.second;\n-            if (cardsIdsToHide != null) {\n-                    try {\n-                        if (!cardsIdsToHide.isEmpty()) {\n-                            Timber.i(\"Removing %d invalid cards from view\", cardsIdsToHide.size());\n-                            browser.removeNotesView(cardsIdsToHide, true);\n-                        }\n-                    } catch (Exception e) {\n-                        Timber.e(e, \"failed to hide cards\");\n-                    }\n-                browser.hideProgressBar();\n-                browser.mCardsAdapter.notifyDataSetChanged();\n-                Timber.d(\"Completed doInBackgroundRenderBrowserQA Successfuly\");\n-            } else {\n-                // Might want to do something more proactive here like show a message box?\n-                Timber.e(\"doInBackgroundRenderBrowserQA was not successful... continuing anyway\");\n-            }\n-        }\n-\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-\n-    private final CheckSelectedCardsHandler mCheckSelectedCardsHandler = new CheckSelectedCardsHandler(this);\n-    private static class CheckSelectedCardsHandler extends ListenerWithProgressBar<Void, Pair<Boolean, Boolean>> {\n-        public CheckSelectedCardsHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Pair<Boolean, Boolean> result) {\n-            if (result == null) {\n-                return;\n-            }\n-            browser.hideProgressBar();\n-\n-            if (browser.mActionBarMenu != null) {\n-                boolean hasUnsuspended = result.first;\n-                boolean hasUnmarked = result.second;\n-\n-                setMenuIcons(browser, hasUnsuspended, hasUnmarked, browser.mActionBarMenu);\n-            }\n-        }\n-\n-\n-        protected void setMenuIcons(@NonNull Context browser, boolean hasUnsuspended, boolean hasUnmarked, @NonNull Menu actionBarMenu) {\n-            int title;\n-            int icon;\n-            if (hasUnsuspended) {\n-                title = R.string.card_browser_suspend_card;\n-                icon = R.drawable.ic_pause_circle_outline;\n-            } else {\n-                title = R.string.card_browser_unsuspend_card;\n-                icon = R.drawable.ic_pause_circle_filled;\n-            }\n-            MenuItem suspend_item = actionBarMenu.findItem(R.id.action_suspend_card);\n-            suspend_item.setTitle(browser.getString(title));\n-            suspend_item.setIcon(icon);\n-\n-            if (hasUnmarked) {\n-                title = R.string.card_browser_mark_card;\n-                icon = R.drawable.ic_star_border_white;\n-            } else {\n-                title = R.string.card_browser_unmark_card;\n-                icon = R.drawable.ic_star_white;\n-            }\n-            MenuItem mark_item = actionBarMenu.findItem(R.id.action_mark_card);\n-            mark_item.setTitle(browser.getString(title));\n-            mark_item.setIcon(icon);\n-        }\n-\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            super.actualOnCancelled(browser);\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-    @SuppressWarnings(\"SameParameterValue\")\n-    private void closeCardBrowser(int result) {\n-        closeCardBrowser(result, null);\n-    }\n-\n-    private void closeCardBrowser(int result, Intent data) {\n-        // Set result and finish\n-        setResult(result, data);\n-        finishWithAnimation(END);\n-    }\n-\n-    /**\n-     * Render the second column whenever the user stops scrolling\n-     */\n-    @VisibleForTesting\n-    public final class RenderOnScroll implements AbsListView.OnScrollListener {\n-        @Override\n-        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n-            // Show the progress bar if scrolling to given position requires rendering of the question / answer\n-            int lastVisibleItem = firstVisibleItem + visibleItemCount - 1;\n-            CardCollection<CardCache> cards = getCards();\n-            // List is never cleared, only reset to a new list. So it's safe here.\n-            int size = cards.size();\n-            if (size > 0 && visibleItemCount <= 0) {\n-                // According to Mike, there used to be 5 to 10 report by hour on the beta version. All with\n-                // > com.ichi2.anki.exception.ManuallyReportedException: Useless onScroll call, with size 0 firstVisibleItem 0,\n-                // > lastVisibleItem 0 and visibleItemCount 0.\n-\n-                // This change ensure that we log more specifically case where #8821 could have occured. That is, there are cards but we\n-                // are asked to display nothing.\n-\n-                // Note that this is not a bug. The fact that `visibleItemCount` is equal to 0 is actually authorized by the method we\n-                // override and mentionned in the javadoc. It perfectly makes sens to get this order, since it can be used to know that we\n-                // can delete some elements from the cache for example, since nothing is displayed.\n-\n-                // It would be interesting to know how often it occurs, but it is not a bug.\n-                AnkiDroidApp.sendExceptionReport(\"CardBrowser Scroll Issue 8821\", \"In a search result of \" + size + \" cards, with totalItemCount = \" + totalItemCount + \", somehow we got \" + visibleItemCount + \" elements to display.\");\n-            }\n-            // In all of those cases, there is nothing to do:\n-            if (size <= 0 ||\n-                    firstVisibleItem >= size ||\n-                    lastVisibleItem >= size ||\n-                    visibleItemCount <= 0\n-            ) {\n-                return;\n-            }\n-            boolean firstLoaded = cards.get(firstVisibleItem).isLoaded();\n-            // Note: max value of lastVisibleItem is totalItemCount, so need to subtract 1\n-            boolean lastLoaded = cards.get(lastVisibleItem).isLoaded();\n-            if (!firstLoaded || !lastLoaded) {\n-                if (!mPostAutoScroll) {\n-                    showProgressBar();\n-                }\n-                // Also start rendering the items on the screen every 300ms while scrolling\n-                long currentTime = SystemClock.elapsedRealtime();\n-                if ((currentTime - mLastRenderStart > 300 || lastVisibleItem + 1 >= totalItemCount)) {\n-                    mLastRenderStart = currentTime;\n-                    TaskManager.cancelAllTasks(CollectionTask.RenderBrowserQA.class);\n-                    TaskManager.launchCollectionTask(renderBrowserQAParams(firstVisibleItem, visibleItemCount, cards), mRenderQAHandler);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void onScrollStateChanged(AbsListView listView, int scrollState) {\n-            // TODO: Try change to RecyclerView as currently gets stuck a lot when using scrollbar on right of ListView\n-            // Start rendering the question & answer every time the user stops scrolling\n-            if (mPostAutoScroll) {\n-                mPostAutoScroll = false;\n-            }\n-            if (scrollState == SCROLL_STATE_IDLE) {\n-                int startIdx = listView.getFirstVisiblePosition();\n-                int numVisible = listView.getLastVisiblePosition() - startIdx;\n-                TaskManager.launchCollectionTask(renderBrowserQAParams(startIdx - 5, 2 * numVisible + 5, getCards()), mRenderQAHandler);\n-            }\n-        }\n-    }\n-\n-\n-    @NonNull\n-    protected CollectionTask.RenderBrowserQA renderBrowserQAParams(int firstVisibleItem, int visibleItemCount, CardCollection<CardCache> cards) {\n-        return new CollectionTask.RenderBrowserQA(cards, firstVisibleItem, visibleItemCount, mColumn1Index, mColumn2Index);\n-    }\n-\n-\n-    private final class MultiColumnListAdapter extends BaseAdapter {\n-        private final int mResource;\n-        private Column[] mFromKeys;\n-        private final int[] mToIds;\n-        private float mOriginalTextSize = -1.0f;\n-        private final int mFontSizeScalePcent;\n-        private Typeface mCustomTypeface = null;\n-        private final LayoutInflater mInflater;\n-\n-        public MultiColumnListAdapter(Context context, int resource, Column[] from, int[] to,\n-                                      int fontSizeScalePcent, String customFont) {\n-            mResource = resource;\n-            mFromKeys = from;\n-            mToIds = to;\n-            mFontSizeScalePcent = fontSizeScalePcent;\n-            if (!\"\".equals(customFont)) {\n-                mCustomTypeface = AnkiFont.getTypeface(context, customFont);\n-            }\n-            mInflater = LayoutInflater.from(context);\n-        }\n-\n-\n-        public View getView(int position, View convertView, ViewGroup parent) {\n-            // Get the main container view if it doesn't already exist, and call bindView\n-            View v;\n-            if (convertView == null) {\n-                v = mInflater.inflate(mResource, parent, false);\n-                final int count = mToIds.length;\n-                final View[] columns = new View[count];\n-                for (int i = 0; i < count; i++) {\n-                    columns[i] = v.findViewById(mToIds[i]);\n-                }\n-                v.setTag(columns);\n-            } else {\n-                v = convertView;\n-            }\n-            bindView(position, v);\n-            return v;\n-        }\n-\n-\n-        private void bindView(final int position, final View v) {\n-            // Draw the content in the columns\n-            View[] columns = (View[]) v.getTag();\n-            final CardCache card = getCards().get(position);\n-            for (int i = 0; i < mToIds.length; i++) {\n-                TextView col = (TextView) columns[i];\n-                // set font for column\n-                setFont(col);\n-                // set text for column\n-                col.setText(card.getColumnHeaderText(mFromKeys[i]));\n-            }\n-            // set card's background color\n-            final int backgroundColor = Themes.getColorFromAttr(CardBrowser.this, card.getColor());\n-            v.setBackgroundColor(backgroundColor);\n-            // setup checkbox to change color in multi-select mode\n-            final CheckBox checkBox = v.findViewById(R.id.card_checkbox);\n-            // if in multi-select mode, be sure to show the checkboxes\n-            if(mInMultiSelectMode) {\n-                checkBox.setVisibility(View.VISIBLE);\n-                checkBox.setChecked(mCheckedCards.contains(card));\n-                // this prevents checkboxes from showing an animation from selected -> unselected when\n-                // checkbox was selected, then selection mode was ended and now restarted\n-                checkBox.jumpDrawablesToCurrentState();\n-            } else {\n-                checkBox.setChecked(false);\n-                checkBox.setVisibility(View.GONE);\n-            }\n-            // change bg color on check changed\n-            checkBox.setOnClickListener(view -> onCheck(position, v));\n-        }\n-\n-        private void setFont(TextView v) {\n-            // Set the font and font size for a TextView v\n-            float currentSize = v.getTextSize();\n-            if (mOriginalTextSize < 0) {\n-                mOriginalTextSize = v.getTextSize();\n-            }\n-            // do nothing when pref is 100% and apply scaling only once\n-            if (mFontSizeScalePcent != 100 && Math.abs(mOriginalTextSize - currentSize) < 0.1) {\n-                // getTextSize returns value in absolute PX so use that in the setter\n-                v.setTextSize(TypedValue.COMPLEX_UNIT_PX, mOriginalTextSize * (mFontSizeScalePcent / 100.0f));\n-            }\n-\n-            if (mCustomTypeface != null) {\n-                v.setTypeface(mCustomTypeface);\n-            }\n-        }\n-\n-        public void setFromMapping(Column[] from) {\n-            mFromKeys = from;\n-            notifyDataSetChanged();\n-        }\n-\n-\n-        public Column[] getFromMapping() {\n-            return mFromKeys;\n-        }\n-\n-\n-        @Override\n-        public int getCount() {\n-            return getCardCount();\n-        }\n-\n-\n-        @Override\n-        public CardCache getItem(int position) {\n-            return getCards().get(position);\n-        }\n-\n-\n-        @Override\n-        public long getItemId(int position) {\n-            return position;\n-        }\n-\n-    }\n-\n-\n-    private void onCheck(int position, View cell) {\n-        CheckBox checkBox = cell.findViewById(R.id.card_checkbox);\n-        CardCache card = getCards().get(position);\n-\n-        if (checkBox.isChecked()) {\n-            mCheckedCards.add(card);\n-        } else {\n-            mCheckedCards.remove(card);\n-        }\n-\n-       onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting\n-    void onSelectAll() {\n-        mCheckedCards.addAll(mCards.unsafeGetWrapped());\n-        onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting\n-    void onSelectNone() {\n-        mCheckedCards.clear();\n-        onSelectionChanged();\n-    }\n-\n-    private void onSelectionChanged() {\n-        Timber.d(\"onSelectionChanged()\");\n-        try {\n-            if (!mInMultiSelectMode && !mCheckedCards.isEmpty()) {\n-                //If we have selected cards, load multiselect\n-                loadMultiSelectMode();\n-            } else if (mInMultiSelectMode && mCheckedCards.isEmpty()) {\n-                //If we don't have cards, unload multiselect\n-                endMultiSelectMode();\n-            }\n-\n-            //If we're not in mutliselect, we can select cards if there are cards to select\n-            if (!mInMultiSelectMode && this.mActionBarMenu != null) {\n-                MenuItem selectAll = mActionBarMenu.findItem(R.id.action_select_all);\n-                selectAll.setVisible(mCards != null && cardCount() != 0);\n-            }\n-\n-            if (!mInMultiSelectMode) {\n-                return;\n-            }\n-\n-            updateMultiselectMenu();\n-            mActionBarTitle.setText(String.format(getLocaleCompat(getResources()), \"%d\", checkedCardCount()));\n-        } finally {\n-            if (colIsOpen() && mCardsAdapter != null) {\n-                mCardsAdapter.notifyDataSetChanged();\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Reloads the data of the cards, taking on their current values from the database.\n-     */\n-    protected void reloadCards(Card[] cards) {\n-        if (cards == null || cards.length == 0) {\n-            return;\n-        }\n-\n-        Set<Long> cardIds = new HashSet<>();\n-        for (Card c : cards) {\n-            cardIds.add(c.getId());\n-        }\n-\n-        for (CardCache props : mCards) {\n-            if (cardIds.contains(props.getId())) {\n-                props.reload();\n-            }\n-        }\n-        mCardsAdapter.notifyDataSetChanged();\n-    }\n-\n-    @VisibleForTesting\n-    CardCollection<CardCache> getCards() {\n-        mCards.ensureValidValue();\n-        return mCards;\n-    }\n-\n-    private long[] getAllCardIds() {\n-        long[] l = new long[mCards.size()];\n-        for (int i = 0; i < mCards.size(); i++) {\n-            l[i] = mCards.get(i).getId();\n-        }\n-        return l;\n-    }\n-\n-    // This could be better: use a wrapper class PositionAware<T> to store the position so it's\n-    // no longer a responsibility of CardCache and we can guarantee it's consistent just by using this collection\n-    /** A position-aware collection to ensure consistency between the position of items and the collection */\n-    public static class CardCollection<T extends PositionAware> implements Iterable<T> {\n-        private List<T> mWrapped = new ArrayList<>(0);\n-\n-        public int size() {\n-            return mWrapped.size();\n-        }\n-\n-        public T get(int index) {\n-            return mWrapped.get(index);\n-        }\n-\n-\n-        public void reset() {\n-            mWrapped = new ArrayList<>(0);\n-        }\n-\n-\n-        public void replaceWith(List<T> value) {\n-            mWrapped = value;\n-        }\n-\n-        public void reverse() {\n-            Collections.reverse(mWrapped);\n-            int position = 0;\n-            for (int i = 0; i < mWrapped.size(); i++) {\n-                mWrapped.get(i).setPosition(position++);\n-            }\n-        }\n-\n-\n-        @NonNull\n-        @Override\n-        public Iterator<T> iterator() {\n-            return mWrapped.iterator();\n-        }\n-\n-        public java.util.Collection<T> unsafeGetWrapped() {\n-            return mWrapped;\n-        }\n-\n-\n-        public void ensureValidValue() {\n-            if (mWrapped == null) {\n-                reset();\n-            }\n-        }\n-\n-\n-        public void clear() {\n-            mWrapped.clear();\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    interface PositionAware {\n-        int getPosition();\n-        void setPosition(int value);\n-    }\n-\n-    public static class CardCache extends Card.Cache implements PositionAware {\n-        private boolean mLoaded = false;\n-        private Pair<String, String> mQa = null;\n-        private int mPosition;\n-\n-        public CardCache(long id, Collection col, int position) {\n-            super(col, id);\n-            mPosition = position;\n-        }\n-\n-        protected CardCache(CardCache cache, int position) {\n-            super(cache);\n-            mLoaded = cache.mLoaded;\n-            mQa = cache.mQa;\n-            mPosition = position;\n-        }\n-\n-        public int getPosition() {\n-            return mPosition;\n-        }\n-\n-\n-        @Override\n-        public void setPosition(int value) {\n-            mPosition = value;\n-        }\n-\n-\n-        /** clear all values except ID.*/\n-        public void reload() {\n-            super.reload();\n-            mLoaded = false;\n-            mQa = null;\n-        }\n-\n-        /**\n-         * Get the background color of items in the card list based on the Card\n-         * @return index into TypedArray specifying the background color\n-         */\n-        private int getColor() {\n-            int flag = getCard().userFlag();\n-            switch (flag) {\n-                case 1:\n-                    return R.attr.flagRed;\n-                case 2:\n-                    return R.attr.flagOrange;\n-                case 3:\n-                    return R.attr.flagGreen;\n-                case 4:\n-                    return R.attr.flagBlue;\n-                case 5:\n-                    return R.attr.flagPink;\n-                case 6:\n-                    return R.attr.flagTurquoise;\n-                case 7:\n-                    return R.attr.flagPurple;\n-                default:\n-                    if (getCard().note().hasTag(\"marked\")) {\n-                        return R.attr.markedColor;\n-                    } else {\n-                        if (getCard().getQueue() == Consts.QUEUE_TYPE_SUSPENDED) {\n-                            return R.attr.suspendedColor;\n-                        } else {\n-                            return android.R.attr.colorBackground;\n-                        }\n-                    }\n-            }\n-        }\n-\n-        public String getColumnHeaderText(Column key) {\n-            switch (key) {\n-            case FLAGS:\n-                return (Integer.valueOf(getCard().userFlag())).toString();\n-            case SUSPENDED:\n-                return getCard().getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\";\n-            case MARKED:\n-                return getCard().note().hasTag(\"marked\") ? \"marked\" : null;\n-            case SFLD:\n-                return getCard().note().getSFld();\n-            case DECK:\n-                return getCol().getDecks().name(getCard().getDid());\n-            case TAGS:\n-                return getCard().note().stringTags();\n-            case CARD:\n-                return getCard().template().optString(\"name\");\n-            case DUE:\n-                return getCard().getDueString();\n-            case EASE:\n-                if (getCard().getType() == Consts.CARD_TYPE_NEW) {\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_new_card);\n-                } else {\n-                    return (getCard().getFactor()/10)+\"%\";\n-                }\n-            case CHANGED:\n-                return LanguageUtil.getShortDateFormatFromS(getCard().getMod());\n-            case CREATED:\n-                return LanguageUtil.getShortDateFormatFromMs(getCard().note().getId());\n-            case EDITED:\n-                return LanguageUtil.getShortDateFormatFromS(getCard().note().getMod());\n-            case INTERVAL:\n-                switch (getCard().getType()) {\n-                case Consts.CARD_TYPE_NEW:\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_new_card);\n-                case Consts.CARD_TYPE_LRN :\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_learning_card);\n-                default:\n-                    return Utils.roundedTimeSpanUnformatted(AnkiDroidApp.getInstance(), getCard().getIvl()*SECONDS_PER_DAY);\n-                }\n-            case LAPSES:\n-                return Integer.toString(getCard().getLapses());\n-            case NOTE_TYPE:\n-                return getCard().model().optString(\"name\");\n-            case REVIEWS:\n-                return Integer.toString(getCard().getReps());\n-            case QUESTION:\n-                updateSearchItemQA();\n-                return mQa.first;\n-            case ANSWER:\n-                updateSearchItemQA();\n-                return mQa.second;\n-            default:\n-                return null;\n-            }\n-        }\n-\n-        /** pre compute the note and question/answer.  It can safely\n-            be called twice without doing extra work. */\n-        public void load(boolean reload, int column1Index, int column2Index) {\n-            if (reload) {\n-                reload();\n-            }\n-            getCard().note();\n-            if (\n-                COLUMN1_KEYS[column1Index] == QUESTION ||\n-                COLUMN2_KEYS[column2Index] == QUESTION ||\n-                COLUMN2_KEYS[column2Index] == ANSWER\n-                // First column can not be the answer. If it were to\n-                // change, this code should also be changed.\n-                ) {\n-                updateSearchItemQA();\n-            }\n-            mLoaded = true;\n-        }\n-\n-        public boolean isLoaded() {\n-            return mLoaded;\n-        }\n-\n-        /**\n-           Reload question and answer. Use browser format. If it's empty\n-           uses non-browser format. If answer starts by question, remove\n-           question.\n-        */\n-        public void updateSearchItemQA() {\n-            if (mQa != null) {\n-                return;\n-            }\n-            // render question and answer\n-            Map<String, String> qa = getCard()._getQA(true, true);\n-            // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-            if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-                HashMap<String, String> qaFull = getCard()._getQA(true, false);\n-                if (\"\".equals(qa.get(\"q\"))) {\n-                    qa.put(\"q\", qaFull.get(\"q\"));\n-                }\n-                if (\"\".equals(qa.get(\"a\"))) {\n-                    qa.put(\"a\", qaFull.get(\"a\"));\n-                }\n-            }\n-            // update the original hash map to include rendered question & answer\n-            String q = qa.get(\"q\");\n-            String a = qa.get(\"a\");\n-            // remove the question from the start of the answer if it exists\n-            if (a.startsWith(q)) {\n-                a = a.substring(q.length());\n-            }\n-            a = formatQA(a, AnkiDroidApp.getInstance());\n-            q = formatQA(q, AnkiDroidApp.getInstance());\n-            mQa = new Pair<>(q, a);\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n-            }\n-            if (obj == null) {\n-                return false;\n-            }\n-            if (getClass() != obj.getClass()) {\n-                return false;\n-            }\n-            return getId() == ((CardCache) obj).getId();\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Long.valueOf(getId()).hashCode();\n-        }\n-    }\n-\n-    /**\n-     * Show/dismiss dialog when sd card is ejected/remounted (collection is saved by SdCardReceiver)\n-     */\n-    private void registerExternalStorageListener() {\n-        if (mUnmountReceiver == null) {\n-            mUnmountReceiver = new BroadcastReceiver() {\n-                @Override\n-                public void onReceive(Context context, Intent intent) {\n-                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {\n-                        finishWithoutAnimation();\n-                    }\n-                }\n-            };\n-            IntentFilter iFilter = new IntentFilter();\n-            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);\n-            registerReceiver(mUnmountReceiver, iFilter);\n-        }\n-    }\n-\n-    /**\n-     * The views expand / contract when switching between multi-select mode so we manually\n-     * adjust so that the vertical position of the given view is maintained\n-     */\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    private void recenterListView(@NonNull View view) {\n-        final int position = mCardsListView.getPositionForView(view);\n-        // Get the current vertical position of the top of the selected view\n-        final int top = view.getTop();\n-        final Handler handler = new Handler();\n-        // Post to event queue with some delay to give time for the UI to update the layout\n-        handler.postDelayed(() -> {\n-            // Scroll to the same vertical position before the layout was changed\n-            mCardsListView.setSelectionFromTop(position, top);\n-        }, 10);\n-    }\n-\n-    /**\n-     * Turn on Multi-Select Mode so that the user can select multiple cards at once.\n-     */\n-    private void loadMultiSelectMode() {\n-        if (mInMultiSelectMode) {\n-            return;\n-        }\n-        Timber.d(\"loadMultiSelectMode()\");\n-        // set in multi-select mode\n-        mInMultiSelectMode = true;\n-        // show title and hide spinner\n-        mActionBarTitle.setVisibility(View.VISIBLE);\n-        mActionBarTitle.setText(String.valueOf(checkedCardCount()));\n-        mDeckSpinnerSelection.setSpinnerVisibility(View.GONE);\n-        // reload the actionbar using the multi-select mode actionbar\n-        supportInvalidateOptionsMenu();\n-    }\n-\n-    /**\n-     * Turn off Multi-Select Mode and return to normal state\n-     */\n-    private void endMultiSelectMode() {\n-        Timber.d(\"endMultiSelectMode()\");\n-        mCheckedCards.clear();\n-        mInMultiSelectMode = false;\n-        // If view which was originally selected when entering multi-select is visible then maintain its position\n-        View view = mCardsListView.getChildAt(mLastSelectedPosition - mCardsListView.getFirstVisiblePosition());\n-        if (view != null) {\n-            recenterListView(view);\n-        }\n-        // update adapter to remove check boxes\n-        mCardsAdapter.notifyDataSetChanged();\n-        // update action bar\n-        supportInvalidateOptionsMenu();\n-        mDeckSpinnerSelection.setSpinnerVisibility(View.VISIBLE);\n-        mActionBarTitle.setVisibility(View.GONE);\n-    }\n-\n-    @VisibleForTesting\n-    public int checkedCardCount() {\n-        return mCheckedCards.size();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean isInMultiSelectMode() {\n-        return mInMultiSelectMode;\n-    }\n-\n-    @VisibleForTesting()\n-    long cardCount() {\n-        return mCards.size();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-     boolean isShowingSelectAll() {\n-        return mActionBarMenu != null && mActionBarMenu.findItem(R.id.action_select_all).isVisible();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean isShowingSelectNone() {\n-        return mActionBarMenu != null &&\n-                mActionBarMenu.findItem(R.id.action_select_none) != null && //\n-                mActionBarMenu.findItem(R.id.action_select_none).isVisible();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void clearCardData(int position) {\n-        mCards.get(position).reload();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void rerenderAllCards() {\n-        TaskManager.launchCollectionTask(renderBrowserQAParams(0, mCards.size()-1, getCards()), mRenderQAHandler);\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    long[] getCardIds() {\n-        CardCache[] cardsCopy = mCards.unsafeGetWrapped().toArray(new CardCache[0]);\n-        long[] ret = new long[cardsCopy.length];\n-        for (int i = 0; i < cardsCopy.length; i++) {\n-            ret[i] = cardsCopy[i].getId();\n-        }\n-        return ret;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void checkCardsAtPositions(int... positions) {\n-        for (int position : positions) {\n-            if (position >= mCards.size()) {\n-                throw new IllegalStateException(\n-                        String.format(Locale.US, \"Attempted to check card at index %d. %d cards available\",\n-                                position, mCards.size()));\n-            }\n-            mCheckedCards.add(getCards().get(position));\n-        }\n-        onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean hasCheckedCardAtPosition(int i) {\n-        return mCheckedCards.contains(getCards().get(i));\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public int getChangeDeckPositionFromId(long deckId) {\n-        List<Deck> decks = getValidDecksForChangeDeck();\n-        for (int i = 0; i < decks.size(); i++) {\n-            Deck deck = decks.get(i);\n-            if (deck.getLong(\"id\") == deckId) {\n-                return i;\n-            }\n-        }\n-        throw new IllegalStateException(String.format(Locale.US, \"Deck %d not found\", deckId));\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public List<Long> getCheckedCardIds() {\n-        List<Long> cardIds = new ArrayList<>(mCheckedCards.size());\n-        for (CardCache card : mCheckedCards) {\n-            long id = card.getId();\n-            cardIds.add(id);\n-        }\n-        return cardIds;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE) //should only be called from changeDeck()\n-    void executeChangeCollectionTask(List<Long> ids, long newDid) {\n-        mNewDid = newDid; //line required for unit tests, not necessary, but a noop in regular call.\n-        TaskManager.launchCollectionTask(\n-                new CollectionTask.ChangeDeckMulti(ids, newDid),\n-                new ChangeDeckHandler(this));\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public CardCache getPropertiesForCardId(long cardId) {\n-        for (CardCache props : mCards) {\n-            long id = props.getId();\n-            if (id == cardId) {\n-                return props;\n-            }\n-        }\n-        throw new IllegalStateException(String.format(Locale.US, \"Card '%d' not found\", cardId));\n-    }\n-\n-\n-    @VisibleForTesting\n-    void filterByTag(String... tags) {\n-        onSelectedTags(Arrays.asList(tags), 0);\n-    }\n-\n-    @VisibleForTesting\n-    @SuppressWarnings(\"SameParameterValue\")\n-    void filterByFlag(int flag) {\n-        mCurrentFlag = flag;\n-        filterByFlag();\n-    }\n-\n-    @VisibleForTesting\n-    void replaceSelectionWith(int[] positions) {\n-        mCheckedCards.clear();\n-        checkCardsAtPositions(positions);\n-    }\n-\n-    @VisibleForTesting\n-    @SuppressWarnings(\"SameParameterValue\")\n-    void searchCards(String searchQuery) {\n-        mSearchTerms = searchQuery;\n-        searchCards();\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "message": "Merge commit", "committedDate": null}, {"oid": "775aa05336a8b02a44434facc0eca6db09d21ae1", "committedDate": "2020-06-08 08:23:17 -0500", "message": "hasSelectedSingleNoteId: Handle concurrency issue"}, {"oid": "6e0f09f950205347663b058830806de64c6e87c7", "committedDate": "2020-06-08 08:23:17 -0500", "message": "hasSelectedSingleNoteId: concurrency fix"}, {"oid": "24056efa63638e8e8ac252f5d9399f2231b996f1", "committedDate": "2020-06-11 11:25:18 -0500", "message": "Remove buggy implementation: hasSelectedSingleNoteId"}, {"oid": "238d935bbcb41e198a9f512d81abc06f40901b30", "committedDate": "2020-06-11 11:25:18 -0500", "message": "Browser: Allow user to change note type if editing"}, {"oid": "5bb384a3aff953bed4d7ce1243bd74e5febfa45e", "committedDate": "2020-06-11 11:25:18 -0500", "message": "NF: Rename NOTE to NOTE_TYPE"}, {"oid": "b1135ff3cbd8d536a0175e7b9b156fdb88585e1b", "committedDate": "2020-06-12 23:28:18 -0500", "message": "Remove unused parameter in saveCollectionInBackground"}, {"oid": "de280d8fa079636e232fe1b8ffe703aabc0ab054", "committedDate": "2020-06-20 20:14:33 -0500", "message": "Keep displaying search terms after editing card"}, {"oid": "8236599b1db98f774a45c4f84de308e16affd0c3", "committedDate": "2020-06-20 20:14:33 -0500", "message": "CardBrowser: Hide Progress Bar if tasks cancelled"}, {"oid": "cf720e0c56ff05a63590a5f86697444c01f02515", "committedDate": "2020-06-29 15:25:38 -0500", "message": "Reload CardBrowser but not reviewer when note edited"}, {"oid": "b91a511d46b57a88b2a000ca2f6a2375dfbe3bdd", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Task type becomes an enum"}, {"oid": "017cb41d04e55b284f5e11410c50f63d2b368d38", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Remove TASK_TYPE from enum name"}, {"oid": "6a7f8d895eaaa08df21998a02c09a7c754ddeb97", "committedDate": "2020-07-05 08:46:49 -0500", "message": "cancelTask(type) cancel all tasks of given type"}, {"oid": "c18a421db5329cf3f2b86e62a819e5a116265f60", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: cancelTask to cancelCurrentlyExecutingTask"}, {"oid": "0dba81bdef77c234dd4d9a90e1ee89e6c0dc827f", "committedDate": "2020-07-20 19:51:47 -0500", "message": "getUserFlag->userFlag"}, {"oid": "c126ac42a5eac08fba6d54d531c0821df0193c68", "committedDate": "2020-07-21 15:50:01 -0500", "message": "NF: Deck type"}, {"oid": "03aa2f4cd0aea7032cc93d27d8676be51154db3c", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: import static com.ichi2.async.CollectionTask.TaskData;"}, {"oid": "1df6f2510ed5c6d410b98c8955a0c230e1ffb309", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: TaskData in a separate file"}, {"oid": "6d8d7d4abdc604c7edc5ed97da47b57cb9b076a1", "committedDate": "2020-07-25 15:14:56 -0500", "message": "NF: listener's onProgressUpdate take a single element"}, {"oid": "2f0af8ff7c5cc18d850aa1fc8c1bdd2c39a6bb1c", "committedDate": "2020-08-08 09:05:50 -0500", "message": "NF: Listener as separate file"}, {"oid": "d4267b868d9b4e584d186f667de2f48636b333be", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: create type cardCache"}, {"oid": "e00b4f587d88ef102e20dadc03689f22976b75b2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: replace ID by \"id\"."}, {"oid": "b6e9594f93f40946d6f0b934fbac71aa0a85acf4", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: reload in CardCache"}, {"oid": "3d5b1f8c596931244f79f8a4e0916c345e39903d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: reload CardCache in updateCardsInList"}, {"oid": "f6b4230e354e2965089317b68124bf15bfa54b84", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: id in CardCache"}, {"oid": "0ed0b26615da7a6bca6313471ceda4e1162656b0", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardClass has card accessor"}, {"oid": "cf059ad47c4889a7d01586d4800c7bf080136fed", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: move getFlagOrDefault in CardClass"}, {"oid": "ad60a300fb9dff4d0b957dec653c8b0576652005", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: getColor, get variable when needed"}, {"oid": "0a9fead54f040d70b39bb83596c51ca2f02f54f9", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify flag"}, {"oid": "59df407e8574d70e86a010c5e5edad0976cede1d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify getFlagOrDefault to use card"}, {"oid": "397cc318f49494a4bfb6c14b13bbe5da4f64c187", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove getFlagOrDefault"}, {"oid": "ca5cde170d69b80e198b1534808c1db0a9eff192", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: getColor in CardClass"}, {"oid": "cd8ae0d2b27e452af7e4c4d8cde4bbcabbfb63e9", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses card feature in color"}, {"oid": "0b65cb3645f6f1ec21c054616b6f12b4c565b278", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: cardProperties renamed to card"}, {"oid": "f9b4463d1fccb380b92b7c6c0b10597fd3bace09", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: introduce variable text_for_column in bindView"}, {"oid": "cee32b600bae5bdaf33c5fb2c84db8414ce4dff2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses content instead than setText"}, {"oid": "4a0d565455507e4b0a9123f13a6d23c539788df7", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache deal with loading"}, {"oid": "40af31415bc356b207b0eb07921d62fc3c57eda3", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: FLAGS in content"}, {"oid": "5f63aeea4bb6e6f1958f78c0fea980a942f33ad6", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: SUSPENDED in content"}, {"oid": "2d9bb9a08928843e01b7adb39df61f67b0eefeb5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: MARKED in Content"}, {"oid": "d5f109e6cada59c76b7167b50aae2002e556dfe6", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused sMarkedPattern"}, {"oid": "0a4218fe7c17fee8a4cf38a0cdb3fc45cf8d770f", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: SFLD in content"}, {"oid": "7d454e131c800ea1bfb826b3acffc74f1a9a324d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: DECK in content"}, {"oid": "2ede85b0dda0d29139e6266b787e580cd5530a94", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: TAGS in content"}, {"oid": "3beace334a38147d9160673983aaa7c06e7d6253", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CARD in content"}, {"oid": "d8e0e3bf68ec037a563a0efb62c5d94fffec0693", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: DUE in content"}, {"oid": "3e56bcaaaff8361dca7a2788057808cace6f518a", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: EASE in content"}, {"oid": "e66a43034b0aae17d9d1bbbad84f98f52b348953", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CHANGED in content"}, {"oid": "548170633037c3968947f28ff008b35f622112d5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CREATED in content"}, {"oid": "b3551b17d8d763824e886fefbc080c4565193399", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: EDITED in content"}, {"oid": "fe98ebdcbc1e1ff0b9999dc3d574ff64c43e28dc", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: INTERVAL in Content"}, {"oid": "17d9b916e4cfc4e6c3cc552f04dc72038450e8e1", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: LAPSES in content"}, {"oid": "b696126cdfb39e7e967088855a64f98995742d29", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: NOTE_TYPE in content"}, {"oid": "cffe326a64e97452f9d0ad296e00b56636dd3807", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: REVIEWS in content"}, {"oid": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused paramater, varilable and comment"}, {"oid": "25668235083fa2e4c0716fb177f0ed756d5f18f1", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: context is got directly in updateSearchItemQA"}, {"oid": "216580a8bfebb2e94d3ee973e9c16dea5b45f6a2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: updateSearchItemQA don't take card, but get it from CardCache"}, {"oid": "474450d513e379802bca25b64e9d2dccfa7dc105", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: Question/Answer in Content"}, {"oid": "0d83a8a8070a1f750aded8e2f35e4f90689da7ce", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: To get card browser value, uses only .content"}, {"oid": "cebb0704f32af078181a041bd3f5d2378e5705ad", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify slightly code"}, {"oid": "f4981c1a84187ffaf956e9bc0d3e995e083019ed", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache does not inherits HashMap"}, {"oid": "ab32f45cbef06a9f3f964512c0536eabfb54c290", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: use enum for column"}, {"oid": "23d64c43221e83f1ca9b1dd0987e47a570a1f33c", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: don't compute question/answer if it's not used"}, {"oid": "5f21fa7f1b58effc22372ae7bbbbd22f398a2d3d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache have hash and equals"}, {"oid": "23caa8ecb5b24de130671b569ab6fc649480e4b5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: cardCache constructor takes position"}, {"oid": "607f9dc344b11f2a770f5b119878da67c8d2e4e0", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: throw exception before adding to set"}, {"oid": "2ea7d9a79284cbf6464e6be6a5286a2965859475", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: mCheckedCardPositions becomes a list of CardCache"}, {"oid": "89a9718449d95b6f59d17c0109e2f711f5c46b5b", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses checkedCardCount when possible"}, {"oid": "58b46cca4aebc46f1f2467e331ae2526130adc13", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: use empty instead of size"}, {"oid": "8f3628f0fda73538b3a8e8739411d34b07239716", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove an always false condition"}, {"oid": "f51427dc57c0249f225dafd7c5d776c5a9172767", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: updateCardsInList more clear"}, {"oid": "ac2d979c2e394e61bcba9a6efe36d755ea7472ca", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: indicates that getPositionMap is static"}, {"oid": "3be7f0e1c8e7bc5bc9102d3bfe93f4e9219110a2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: ensure updateCardsInList iterate on a single list of card"}, {"oid": "84448a30d968bdca49b143b560cc2ee928296e17", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: RepositionCardHandler with context"}, {"oid": "9130f8046b512b111966c0a029b47f24a53d7106", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: ResetCardHandler with context"}, {"oid": "0da8d61fd274449fd11bdc5a6a8d3f7e531b389b", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: RescheduleCardHandler with context"}, {"oid": "964cc28b2a74cabe9473c0f96b4b84874dd9240e", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: factorize mCheckSelectedCardsHandler"}, {"oid": "6d828ea8e9001ed918a561daa6c60aa864927ad0", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: Factorize selected card handler"}, {"oid": "7383c6809f93d6fd931a8f3bec4b43c9c488b19f", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: ListenerWithProgressBar with context"}, {"oid": "eabd3b8eff2df7a51e9a44fd8919092781080f31", "committedDate": "2020-08-19 14:19:18 -0500", "message": "onTrimMemory call super"}, {"oid": "31439eed2dcd6b4442c9a381d8650035b5bf27ff", "committedDate": "2020-08-21 11:29:10 -0500", "message": "NF: replace 86400 by SECONDS_PER_DAY"}, {"oid": "e2cf422fb9c2f6b42afb09fe812daa38534068aa", "committedDate": "2020-08-22 22:33:15 +0200", "message": "NF: copy a list to ensure it does not change."}, {"oid": "1fe7e7d8bfe176e941fad8480da164ada7932319", "committedDate": "2020-08-28 16:00:39 -0500", "message": "NF: correct creation of card cache"}, {"oid": "d22c2b2ff1e3e7e38c4a6e83f3da9bb4a9362249", "committedDate": "2020-08-29 22:34:54 -0500", "message": "Second column of browser repaired"}, {"oid": "1562a65403d5ded875451f01b46fe77bead42764", "committedDate": "2020-08-30 09:45:59 -0500", "message": "NF: invalidate browser"}, {"oid": "566d0864718738a781190304cda800fa7ce5e0c9", "committedDate": "2020-08-30 09:45:59 -0500", "message": "Delete a card invalidate the brwosre"}, {"oid": "c11da9873ff0934f6f3f28d1c9a23f76af951581", "committedDate": "2020-09-06 18:36:55 -0500", "message": "Added \"Edit Note\" to Previewer"}, {"oid": "392eff78a581986b8afc1d751eebc931d1767036", "committedDate": "2020-09-06 18:40:40 -0500", "message": "Cards are displayed in card browser after return from background"}, {"oid": "32a4e06304dcafc47d7048586c482bbbd209a84d", "committedDate": "2020-09-06 18:40:40 -0500", "message": "NF: alow to cancel Task_type_Check_Card_selection"}, {"oid": "ff5156f8f524b62be48b222eb206b68d0cc4bd26", "committedDate": "2020-09-12 14:38:16 -0500", "message": "Allow searches on tags containing brackets"}, {"oid": "890ef6c5835e1acde92edc6af8a36a64dcc90601", "committedDate": "2020-09-19 03:48:07 +0200", "message": "Fix NullPointerException on invalidate()"}, {"oid": "715357c31701ffe4d1f87d8278be7c622fd25f60", "committedDate": "2020-09-20 23:27:15 -0500", "message": "NF: remove useless semicolons"}, {"oid": "a833d04dedf1185d5e4934dc6d037802014f686d", "committedDate": "2020-09-21 07:18:25 -0500", "message": "NF: remove unboxing warning"}, {"oid": "48c102f1d45d48c930606e08267fe4a5d42a06b5", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+A: \"Select All\""}, {"oid": "287dc8c963e3779db7585ee65c98ab2223c85d24", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+E: \"Add Note\""}, {"oid": "79f580c7f6786a5d3b49a5c2ab34ab12cccff2b5", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+D: \"Change Deck\""}, {"oid": "943d30d9caa109a5545c934e269769225b727ff1", "committedDate": "2020-09-21 08:58:08 -0500", "message": "NF: Refactor showChangeDeckDialog"}, {"oid": "54982f3c6abcab9d4eaf61e6c0569db21f3203ca", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+K: \"Toggle Mark\""}, {"oid": "1d77e154b49d300831a6c1888e01f799a9d30a95", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+Alt+R: \"Reschedule\""}, {"oid": "9bfbb028cc6e2e069859d2833ab20aeec5d4e571", "committedDate": "2020-09-21 08:58:08 -0500", "message": "DOCS: CardBrowsert onKeyDown: Add warning"}, {"oid": "41daedf82d490a1dc74d1afa2130cf79de26fe67", "committedDate": "2020-09-21 10:23:05 -0500", "message": "NF: remove warning DefaultAnnotationParam"}, {"oid": "a4d1643b4723b8d4bd43ff375e0e061baa2a2a5a", "committedDate": "2020-09-21 12:21:31 -0500", "message": "NF: Remove warning about useless int instead of advanced loop"}, {"oid": "c0595464b0b205d704b293f64543e5f54e4b2612", "committedDate": "2020-09-22 09:09:16 -0500", "message": "NF: remove warning Convert2Lambda"}, {"oid": "cef2394efe6d7347643cd796cd5ed8105c692b9a", "committedDate": "2020-09-22 09:12:07 -0500", "message": "NF: uses Equals() for string"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "6359569144205e2d8338fcdc6571ead7fc19bcea", "committedDate": "2020-09-23 16:55:49 -0500", "message": "NF: remove wraning of values that are clearly not null"}, {"oid": "975a902915821a23623b20e8daeff9fc681b92cd", "committedDate": "2020-09-24 09:30:56 -0500", "message": "NF: Remove warning about useless type in generic class constructors"}, {"oid": "42b92180120040299e590634f5b03d6f352c0a4f", "committedDate": "2020-09-24 11:41:08 -0500", "message": "NF: remove useless casts"}, {"oid": "a079a61fc0e7dc06437c851026b29266868aef9b", "committedDate": "2020-09-28 08:29:08 -0500", "message": "NF: suppress warning of redundant escape when it does not seems redundant"}, {"oid": "1d4ec27fc2e0e64f5ba599369d2a633d49686f68", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: Extract class CardCollection"}, {"oid": "c5e92a4c315932cbbdb392f146fe7de28a029d99", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: CardBrowser - Extract methods"}, {"oid": "68ee9e1ebd348a728754632b5c8741c2a45d1f41", "committedDate": "2020-09-28 11:24:51 -0500", "message": "Regression Test: Browser - Preview after sorting"}, {"oid": "7bfa728086d70278433ae76a1655ee573de8b835", "committedDate": "2020-09-28 11:24:51 -0500", "message": "[BugFix] Preview reverse cards correctly"}, {"oid": "fe6a93e79014acd6ae7ae04ca34447f4cb3bc0a3", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: CardBrowser - Improve comments"}, {"oid": "0b23ca26293d5834775f39ede7dbd55c627fc3f6", "committedDate": "2020-09-30 10:51:24 -0500", "message": "NF: use enum for direction"}, {"oid": "8fd630afcaf2a114d32e76ecb6982d995c1a73d2", "committedDate": "2020-10-04 13:53:44 -0500", "message": "Display cards deleted when deleting notes"}, {"oid": "517b5a15ea15761fc0a816cb35daa53ec3910438", "committedDate": "2020-10-04 16:25:33 -0500", "message": "Lint: Use valueOf instead of new"}, {"oid": "ada67bc3d304193eab15d42badaafe9863d340cf", "committedDate": "2020-10-14 06:06:10 -0500", "message": "Adjust resoure reference usage to handle future non-final state"}, {"oid": "99ab89ed6fb3bb0c568db544a76ae9928ce79db7", "committedDate": "2020-10-14 13:58:41 -0500", "message": "Add Filter by flag icon to card browser"}, {"oid": "456daa33af9c099a52d05ecba69b47ed9a4d1944", "committedDate": "2020-10-14 16:20:04 -0500", "message": "Remember scroll position in CardBrowser"}, {"oid": "7bfc313ea25f3ba79f99662795387abed64dfd78", "committedDate": "2020-10-18 11:46:46 -0500", "message": "NF: replace string cancel by dialog_cancel"}, {"oid": "a0120f327d806aea5b08f231bc21f6f0f0cdb782", "committedDate": "2020-10-19 18:16:06 -0500", "message": "NF: Refactor changeDeck naming and variables"}, {"oid": "dd57f7cec478de2fff2c9b437dc9946317bd509c", "committedDate": "2020-10-19 18:16:06 -0500", "message": "NF: Add tests for \"add note\" target deck"}, {"oid": "97c5739ae4bd8b73a56c7bbf29759c278209b775", "committedDate": "2020-10-19 18:16:06 -0500", "message": "Use Browser's Selected Deck when adding note"}, {"oid": "8e2ea03689701afc5a6a629f298ed4b8ee668a61", "committedDate": "2020-10-21 06:32:30 -0500", "message": "NF: remove duplicate \"Tags: %1$s\""}, {"oid": "68ca357ebfc5adbdf40c72e18cd574a1e8d5e94f", "committedDate": "2020-10-23 13:33:05 -0500", "message": "Add \"Card Info\" screen"}, {"oid": "7c882bbb8a848c0bb2a6bb897a3767151e91f76d", "committedDate": "2020-10-25 22:26:29 +0000", "message": "NF: remove duplicate \"(new)\""}, {"oid": "34167abea29fd4d8419a7478022be4e31e5fa01e", "committedDate": "2020-10-26 01:51:44 +0000", "message": "NF: remove duplicate search"}, {"oid": "23f9d804f22cb87af322c279db7804b943f8d503", "committedDate": "2020-10-28 22:37:47 -0500", "message": "NF: save current search to avoid doing it twice"}, {"oid": "81237e0f7122659cd50767949d6e921183d26ddd", "committedDate": "2020-11-03 20:09:18 +0000", "message": "NF: uses for-loop if possible"}, {"oid": "5524e7a6442efad0b8f5440e4c8c0b8cd7c718cd", "committedDate": "2020-11-05 05:30:10 +0000", "message": "NF. remove an unused paramater"}, {"oid": "9c8182dde2ed45a0c0de69214097ac10c85bd14a", "committedDate": "2020-11-09 13:08:37 -0500", "message": "Handle App.onCreate not executing after restore"}, {"oid": "eb84e4ed4bda37fa8f59c8e3b655beb2c79b1b2e", "committedDate": "2020-11-13 09:17:40 -0500", "message": "NF: Remove Specific Error String"}, {"oid": "3dd23578b50498b9fbd1c3b9ad07c5f352944d96", "committedDate": "2020-11-14 08:32:02 -0500", "message": "Revert: \"NF: save current search to avoid doing it twice\""}, {"oid": "383aa2493ef332cdebf42bf6bebe415ddefa6307", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Rename checkedCardsAtPositions"}, {"oid": "78beef4bc78a9bbea9cf51e30f24a9a42e577c19", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: extract repositionCardsNoValidation"}, {"oid": "97757073161bf5982bde6ee23874bf9798609224", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract rescheduleWithoutValidation"}, {"oid": "e5cdc91a9b424c98d84bd738bb291f5cfe6538b5", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract onResetProgress"}, {"oid": "c153719c40ae2f706d866d935827d835fd82235f", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract resetProgressNoConfirm"}, {"oid": "057be86c6b6cd0e99df65b40f78e3558328bd865", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: checkCardsAtPositions - accept varargs"}, {"oid": "0389d60b51827c189cff119eececd94cec89256e", "committedDate": "2020-11-15 07:36:02 -0500", "message": "Refresh Card Browser data on reposition"}, {"oid": "43b06bc7856e19263153ff95f64a0ae8ecec7efe", "committedDate": "2020-11-15 07:36:02 -0500", "message": "Show undo menu on reset, reposition and resched"}, {"oid": "ebba0a01b1f2a8b0e6996539f1d0daac0470c201", "committedDate": "2020-11-15 07:36:02 -0500", "message": "BugFix: Undo - Ensure data in grid is updated"}, {"oid": "dbaf6549ec268333b20d160a0c40962d3135ba0d", "committedDate": "2020-11-20 07:54:40 -0500", "message": "Show partial result in browser before showing all"}, {"oid": "4f2e7f6226246f7626c15234f5d947a6a02c7a74", "committedDate": "2020-11-22 17:41:07 -0500", "message": "NF: Extract setMenuIcons"}, {"oid": "831b8f1be882ff5d43b30ed77f637dadbc3cafc6", "committedDate": "2020-11-22 17:41:07 -0500", "message": "Fix crash if mActionBarMenu is null"}, {"oid": "3e17cca53b9feec8032bc07d6be9f2690dabb1de", "committedDate": "2020-12-02 08:40:06 -0500", "message": "Browser shortcuts: Fix switch fall-through"}, {"oid": "94b3919547fab325239d52d1a9f07d15ddeeb738", "committedDate": "2020-12-02 08:40:06 -0500", "message": "NF: Extract deleteSelectedNote"}, {"oid": "bdef0a8f063d0343c6d747759b0acbd2bb8a4d55", "committedDate": "2020-12-02 08:40:06 -0500", "message": "Card Browser: Add \"Delete\" Shortcut"}, {"oid": "2d1e8714db8cc6e066341d27ad638a5818b0c65a", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: Remove a unused map"}, {"oid": "b0a841366a02673f7ec35e5d197ad7633d247f16", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: remove duplicate if"}, {"oid": "4d37cf273c758b9d873f4a54ba6454f1e143a94a", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: Remove useless parameter"}, {"oid": "fb56df4c0be4d3b333a75beccb9c3568328ba190", "committedDate": "2020-12-08 09:27:51 -0500", "message": "NF: Extract method: getPreviewIntent"}, {"oid": "cce056d89cb1cc4176faf3a4b4be5f9bd8c31283", "committedDate": "2020-12-08 09:27:51 -0500", "message": "BugFix - Previewer: Display same card after edit"}, {"oid": "5128cc2c756ce1434367eb58807650581f26c661", "committedDate": "2020-12-09 11:27:39 -0500", "message": "NF: init capacity of list, map and set"}, {"oid": "ec80d4eb9fb57fd538bccdc8c7e52b8545c4af3e", "committedDate": "2020-12-09 11:44:05 -0500", "message": "NF: Dismiss_multi first argument is List<Long>"}, {"oid": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "committedDate": "2020-12-09 12:17:48 -0500", "message": "NF: Move static part of CollectionTask to other class"}, {"oid": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: Add Type Task, type CollectionTask and TaskListener"}, {"oid": "930bd70272c2acda40e3da35e1ed454b91176a1b", "committedDate": "2020-12-12 14:14:20 +0100", "message": "NF: correct typing of tasks"}, {"oid": "67d636de3f071d2ca87fb4a80447ffd8a03a7d35", "committedDate": "2020-12-13 08:25:34 -0500", "message": "NF: remove redundant if warning"}, {"oid": "ba6051f93e29a4ed3ebb58fe591ddcaef532d2db", "committedDate": "2021-01-23 14:59:29 -0500", "message": "Fix some deprecations"}, {"oid": "0c858ce63b151e82a81866d7e7e652c850d6b621", "committedDate": "2021-03-20 13:05:08 +0100", "message": "Select many option in Card browser"}, {"oid": "6bb12e744843ba3a4d7f1a30e39f735dd8389a5c", "committedDate": "2021-03-20 13:05:08 +0100", "message": "Removed the lastselectedposition from itemclicklistener"}, {"oid": "33f9b63573ede5b40f1c31f74aaa0c6bb30c65e1", "committedDate": "2021-03-24 13:00:21 -0500", "message": "Save/restore card browser multi-select state during Activity lifecycle (#8306)"}, {"oid": "3de33abda7a436ef8c71bcf03c78fda497d78ce2", "committedDate": "2021-03-25 15:43:52 +0000", "message": "NF: use enum for TagsDialog type instead of ints"}, {"oid": "007ad994758eb9525a533512a486f617d6450f82", "committedDate": "2021-03-26 09:42:38 -0500", "message": "NF: refactor TagsDialog to listener interface (#8341)"}, {"oid": "db9260c03143d3770ede4b39db9e15727a69b4cf", "committedDate": "2021-03-27 09:32:18 -0500", "message": "Use browser search text as first field when adding new note  (#8345)"}, {"oid": "34c9f25038d24e3bf9f338fa307b1bcb3610b5ba", "committedDate": "2021-04-03 08:29:29 -0500", "message": "Prevent OR CardBrowser query from bypassing RestrictOnDeck (#8414)"}, {"oid": "5fa8827e0503f775d81704868cbd20d64fe554b0", "committedDate": "2021-04-07 22:39:02 -0500", "message": "Reverse Activity transition for RTL language (#8470)"}, {"oid": "5542ad6ea5f212c04ae8dd93e19626832c25b11d", "committedDate": "2021-04-08 10:08:22 -0500", "message": "chore: Fix usage of Throwable.printStackTrace"}, {"oid": "1d0ad0613b6961d290f0a83832a16dd7fdd62ca3", "committedDate": "2021-04-10 19:45:03 +0100", "message": "NF: MultiColumnListAdapter's getCard return `CardCache`"}, {"oid": "246fba3811d60dd3f302e50210393da3c8a39016", "committedDate": "2021-04-14 07:49:34 -0500", "message": "Display Order of cards in Card Browser corrected"}, {"oid": "9c2e7788262006017c7939fa514072e915efeded", "committedDate": "2021-04-14 07:49:34 -0500", "message": "Unit Test to check display order is persistant on restart"}, {"oid": "00abc059f60fd18ddc9e77d2425436a3cad044ed", "committedDate": "2021-04-14 13:00:45 -0500", "message": "NF: Convert Deck methods to return List"}, {"oid": "d63f8ebaa7ba1693f220d0115cbbb30481f5cbbb", "committedDate": "2021-04-16 10:43:24 -0500", "message": "refactor: Open Previewer from CardBrowser using new Activity APIs"}, {"oid": "b58dd95ff8649dea7e71f103ec2a8dec01bdb0d0", "committedDate": "2021-04-24 06:07:18 +0200", "message": "Fix: Prevent crash on long pressing at end of card browser (#8665)"}, {"oid": "d9dcbb987004d86b4af464d957d6fe1b1dca7267", "committedDate": "2021-04-24 22:31:29 -0500", "message": "refactor: Use androidx Activity APIs in CardBrowser"}, {"oid": "a5dbe4bd129b7760aa8fdcab4fd5e322c59e648b", "committedDate": "2021-04-24 22:31:29 -0500", "message": "fix: Restore no animation settings to start Previewer from CardBrowser"}, {"oid": "0c544371db268cb520e1f89dbc7aa2f499153452", "committedDate": "2021-04-25 12:25:39 -0500", "message": "Convert google material design icons"}, {"oid": "1aa3041789b3a8d29cb48b3204d74ea72ec16b60", "committedDate": "2021-04-29 19:46:40 -0500", "message": "NF: Move TagsDialog to its own package"}, {"oid": "a10214b2ec7061bc46863467ed32a73b81b1f355", "committedDate": "2021-04-30 14:53:54 -0500", "message": "Ensure that CheckCardSelection gets only checked cards"}, {"oid": "72d6b996514a3a547b8ef823fa441ba7297d9f4d", "committedDate": "2021-05-01 09:12:17 -0500", "message": "NF: refactor TagsDialog to use factory"}, {"oid": "8954b35fd0535b65355f398a9938260c11ec21a0", "committedDate": "2021-05-01 09:12:17 -0500", "message": "NF: move TagsDialogListener to a new file"}, {"oid": "aa1c65121804bc9440dd2a0ccd7f9d34af9f4abe", "committedDate": "2021-05-04 12:50:02 -0500", "message": "Card Browser, NoteEditor And Statistics : Improve \"Search Deck\" UX  (#8644)"}, {"oid": "5a9f8fac1f968379c46757c944fbb397412baf4a", "committedDate": "2021-05-04 15:56:52 -0500", "message": "Speed up card browser"}, {"oid": "123d1451ed953a55e7724bf114fe885b42b13b9c", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: reverse condition. Quick return instead of imbrication"}, {"oid": "300b396c2cffd8e08e794729d0afe56422d2a020", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: reverse condition. Quick return instead of imbrication"}, {"oid": "7dd2b7895807c12b1f730894e13fd9512ffdcf38", "committedDate": "2021-05-14 17:38:33 -0500", "message": "Consider scrolling with 0 cards."}, {"oid": "a1ef99fa872362e58b9f9c8deb8fbf1d3c50bc4a", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: send exception report if on scroll was cancelled"}, {"oid": "6b31d01de6752f9d36648a9f56093c58970e841b", "committedDate": "2021-05-16 13:29:52 -0500", "message": "NF: More specific exception for useless scroll call (#8844)"}, {"oid": "3c9783d0b65e6272d861750214776d0ab7a55617", "committedDate": "2021-05-22 17:13:17 -0500", "message": "lint: de-lint CardBrowser"}, {"oid": "80a2ef5172039f0c0d64ab251a409cd294b2fb3e", "committedDate": "2021-05-22 17:13:17 -0500", "message": "fix(CardBrowser): protect mCardsAdapter uses w/colOpen + null check"}, {"oid": "6d96bbebd62346f049666e2d4c12af3fdf58def3", "committedDate": "2021-05-23 10:24:30 -0500", "message": "Uses correct locale"}, {"oid": "30ad7fc0321bc95189980f979875087c43af8a46", "committedDate": "2021-06-01 22:54:41 -0500", "message": "NF: duplicate call to mSearchView.setQuery"}, {"oid": "a5363a2082c16261910bab0847941c4aa5ee07c2", "committedDate": "2021-06-01 22:54:41 -0500", "message": "fix: don't clear text when opening nav bar"}, {"oid": "1bdd80e9b17c2c3954bda1b3b0235870a5ad53c3", "committedDate": "2021-06-01 23:02:34 -0500", "message": "Fix for empty search results and wrong card count (#8998)"}, {"oid": "7d02438912756a3bfdbf34ddaf5cc6540e9d5f09", "committedDate": "2021-06-02 13:20:50 -0500", "message": "Test for card browser changing color when card flag changes (#8800)"}, {"oid": "532c25266e299ba7d55313d23ffe60a0d8b16e49", "committedDate": "2021-06-04 10:56:14 -0500", "message": "NF: CardBrowser create numCardsToRender"}, {"oid": "034ec28daa1ba4ac922cc77d1ff274c3d739edde", "committedDate": "2021-06-19 23:54:44 -0500", "message": "NF: remove usage of CardGetter/PairWithCard"}, {"oid": "becea6decc0023dedf3fd20c7c82f2592bb17cdb", "committedDate": "2021-06-19 23:54:44 -0500", "message": "NF: delete unused classes CardGetter/PairWithCard"}, {"oid": "34ed57bde71765358351e61803d373a90c7d30cb", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: remove BooleanGetter"}, {"oid": "f692b10de3bbc75e37075b4cc42b04cbada3bef6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename `other` to `value`"}, {"oid": "d3bbcfc9ec280c7e45a64ab5ab54550b697b04b6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename getBoolean to Success"}, {"oid": "22e0854ccc348a1ac395e1b9a73245a34621545f", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename PairWithBoolean to Computation"}, {"oid": "8f423418a4b5aa3c754d94fdcf04017ea602894c", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: use getVlaue instead of mValue"}, {"oid": "c84cf4b151cfe460fd820d4cdf90c5daec4f43e1", "committedDate": "2021-07-16 09:37:14 -0500", "message": "Fix CardBrowser shows wrong deck"}, {"oid": "341e453ae469ca14405ba54fdd79fc77b1eeef76", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on handlers"}, {"oid": "79981a009745916ce9fffeed9cee9bb74f4ee3e3", "committedDate": "2021-07-31 09:15:04 -0500", "message": "fix lint: WrongConstant"}, {"oid": "37b924539e93597a65e7750bc260428b4837dced", "committedDate": "2021-08-04 20:45:34 -0500", "message": "feat: pink, turquoise & purple flags"}, {"oid": "12f24b93a16d1ad2313a79d14b47d290ce7d486c", "committedDate": "2021-08-05 15:27:23 -0500", "message": "js api to search card"}, {"oid": "d08acb24174f60f3f380b909beb1c0ae83d12411", "committedDate": "2021-08-11 23:06:21 +0200", "message": "Implement onboarding for CardBrowser"}, {"oid": "263c09b2e25ad37faec52da110084102c6a9e0b5", "committedDate": "2021-08-22 16:45:21 -0500", "message": "nf: DeckSpinnerSelection: extract collection deps"}, {"oid": "2529e8ccd4c4cfa33e116b27f515363152626793", "committedDate": "2021-08-22 16:45:21 -0500", "message": "nf: DeckSpinnerSelection: extract spinner"}, {"oid": "485934feb600efaa936bf6e40c1e729802691b53", "committedDate": "2021-08-22 16:45:21 -0500", "message": "fix: Display Note Editor title"}, {"oid": "60301a3db2a78990a49e0f71309a8798039d72c3", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: add set_config & remove_config"}, {"oid": "060357b99f0cc510f319d3aa6f242c9783e3bffa", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf using strongly typed get_config"}, {"oid": "d44f6196ef3f10e3f5ccfc952ec846a36e2449fd", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf objects using get_config"}, {"oid": "1ff3ff7570944e5f80d0a2f6caea13a3dcb44fd7", "committedDate": "2021-08-22 17:53:20 -0500", "message": "nf: fix nullability bug"}, {"oid": "e546c9ac7bfc2d33afee48da4e3e77666a438149", "committedDate": "2021-08-27 08:19:38 -0500", "message": "nf: Use isEmpty in place of checking size to be zero when possible"}, {"oid": "27dbaeed881d3a1ef7b775311dabdf0780d3fc7f", "committedDate": "2021-09-04 09:47:41 -0500", "message": "NF: uses hash set/map which take size as init istead of capacity (#8339)"}, {"oid": "562cfac72209132f9f22ff707276d0a46c3ecfbc", "committedDate": "2021-10-18 12:10:56 -0500", "message": "Computation: add \"out\" constraint"}, {"oid": "c88bc2e14bf2691c597b8702f701801c99632e2a", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert ScheduleCollectionTask async style"}, {"oid": "cb57ff16f3d8131cfd797b2e2f4a2771419adb9b", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert RescheduleRepositionReset async style"}, {"oid": "bd8f85f29633812b249152b8e4dac986d89ae49f", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert Undo async style"}, {"oid": "a316393d837034884fd4ceacef44572111f93ea5", "committedDate": "2021-10-18 12:10:56 -0500", "message": "sched: Extract Next Card functionality to pair"}, {"oid": "a757225878819325cb40dc832428dba7fe6128f4", "committedDate": "2021-10-18 12:33:34 -0500", "message": "fix(card-browser): Don't always show default deck"}, {"oid": "81d1d134863b8ab2c0560f9f11148b6a91996c0d", "committedDate": "2021-10-22 08:59:35 -0500", "message": "fix(handler): deprecation"}, {"oid": "1c0fa70b13d270cd2f230c0fb87d9e9347e75320", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract NoteService.isMarked"}, {"oid": "28736a6345e42d67a54991df3260f352d5459229", "committedDate": "2021-10-31 11:16:39 -0500", "message": "nf(eco-compat): rename _getQA to render_output"}, {"oid": "9bfceb3ac837201461d9a4d349a756d747bdbdb2", "committedDate": "2021-10-31 11:16:39 -0500", "message": "feat(eco-compat): render_output returns class"}, {"oid": "b0cb2174c467f769393d063944344fd5b927679a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: Introduce SortOrder class"}, {"oid": "442d57cead6c340f42437241c068da2270d92cb9", "committedDate": "2021-10-31 13:32:07 -0500", "message": "fix(search): V16 compat with bracketed tag search"}, {"oid": "019c32c32827080d1de8259c0212b9057d46c3bc", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: extract SearchCardsResult"}, {"oid": "1b3c687bfc7a4da0df1a1a90ebbc680f65650b6a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "feat(v16): implement findCards in backend"}, {"oid": "2b0b7c47ac79615a79e777987f13c94c187ee71f", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: move mShowAllDecks to final, add it in constructor"}, {"oid": "0b74559ff47c09f863d3ad9bc025581782e1c442", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: alwaysShowDefault is final. Move it to constructor"}, {"oid": "447d1ea5e049330a445f731ea64cd483c9e4f705", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: simplify CardBrowser's selectAllDecks"}, {"oid": "e599145b41d85b148286e920edd7a77cfd5c64f0", "committedDate": "2021-11-10 07:29:11 -0500", "message": "refactor: remove FunctionalInterfaces.Consumer"}, {"oid": "d4c34c2e1735a0cb4354b6a1cdc0703e61904416", "committedDate": "2021-11-13 07:33:34 -0500", "message": "NF: change signature of `TagsDialogListener#onSelectedTags`"}, {"oid": "90fef130faea1471c87e864b8f8104813efd3e37", "committedDate": "2021-11-13 07:33:34 -0500", "message": "NF: refactor listener to do multiple actions"}, {"oid": "b9108e61d81ba0fc3f32857fb14c525814347563", "committedDate": "2021-11-13 07:33:34 -0500", "message": "feat: add \"Edit Tags\" in CardBrowser"}, {"oid": "18595046d4a869d3f88f3f8773c770e17c577e29", "committedDate": "2022-03-03 11:45:06 -0500", "message": "NF: replace tab by spaces"}, {"oid": "f21d95c75b1e366a9424adeb263729601b4c022e", "committedDate": "2022-04-05 17:17:32 -0500", "message": "Use DeckSelectionDialog on changeDeckDialog"}, {"oid": "5da9561a290122b52047c5c24648f078dc02dca7", "committedDate": "2022-04-07 10:27:03 -0500", "message": "refactor: typos & related KotlinCleanup"}, {"oid": "0fd0f558c49c728f0eca73a7f5059125cb0a638c", "committedDate": "2022-04-13 17:16:47 -0500", "message": "refactor: Rename CardBrowser.java to .kt"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0Mzc1OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435543759", "body": "Further performance: `Tags.join` should be static ", "bodyText": "Further performance: Tags.join should be static", "bodyHTML": "<p dir=\"auto\">Further performance: <code>Tags.join</code> should be static</p>", "author": "david-allison-1", "createdAt": "2020-06-04T20:56:01Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1531,6 +1534,13 @@ public static void updateSearchItemQA(Context context, Map<String, String> item,\n         item.put(NOTE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n+        String tags = note.stringTags();", "originalCommit": "3b638b1e5356ea1642c12d14b517aec3b13c5c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2MTkzMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435561933", "bodyText": "I don't understand this remark", "author": "Arthur-Milchior", "createdAt": "2020-06-04T21:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0Mzc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2MzQ5Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435563493", "bodyText": "note.stringTags is implemented as:\n        return mCol.getTags().join(mCol.getTags().canonify(mTags));\nThis can be simplified to\n        return Tags.join(mCol.getTags().canonify(mTags));\nas Tags.join refers to no instance variables.", "author": "david-allison-1", "createdAt": "2020-06-04T21:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0Mzc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2Mzk3Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435563976", "bodyText": "Actually... might be worth doing in a separate PR, as there's a few unrelated usages", "author": "david-allison-1", "createdAt": "2020-06-04T21:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0Mzc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NjY4MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435576680", "bodyText": "I don't think I've ever seen this one to be a bottle neck, but I'd certainly would be okay with such a change.", "author": "Arthur-Milchior", "createdAt": "2020-06-04T22:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0Mzc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NzU4Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435577586", "bodyText": "It's a micro-optimisation that'll make the code easier to reason about, win-win :)", "author": "david-allison-1", "createdAt": "2020-06-04T22:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0Mzc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzMDk5OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435630999", "bodyText": "Let's leave this as TODO", "author": "david-allison-1", "createdAt": "2020-06-05T00:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0Mzc1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "783609ad81e5b933cd8b93bdc4a5d8ed0596029e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 55a90b1d1..a0a1ba715 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1534,13 +1531,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(NOTE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n-        String tags = note.stringTags();\n-        item.put(TAGS, tags);\n-        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n-        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n-        item.put(DECK, col.getDecks().name(c.getDid()));\n-        item.put(SFLD, note.getSFld());\n+        item.put(MARKED, (item.get(TAGS).matches(\".*[Mm]arked.*\"))?\"marked\": null);\n     }\n \n     @CheckResult\n", "next_change": {"commit": "4570aeb1e44bd78877deee85d0b82019f355d1fb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex a0a1ba715..5dd41cca0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1531,7 +1532,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(NOTE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n-        item.put(MARKED, (item.get(TAGS).matches(\".*[Mm]arked.*\"))?\"marked\": null);\n+        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n     }\n \n     @CheckResult\n", "next_change": {"commit": "f884e785d57513c684fa992df32dcd234078a385", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 5dd41cca0..c120b2c3c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1533,6 +1533,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n+        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n     }\n \n     @CheckResult\n", "next_change": {"commit": "ba3088dca4876c86e1feb0f0335ce8b218bbafac", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex c120b2c3c..82938885d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1532,6 +1533,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(NOTE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n+        String tags = note.stringTags();\n+        item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n         item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n     }\n", "next_change": {"commit": "654b5f00e2da527c2dea394210524cdce275a9ce", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 82938885d..3fcc2e2ec 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1537,6 +1537,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n         item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n+        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n     }\n \n     @CheckResult\n", "next_change": {"commit": "d02c4af7f391992ac9ec3c7ed2d5e8113ad28f13", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 3fcc2e2ec..e21e7c3ae 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1538,6 +1538,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n         item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n+        item.put(DECK, col.getDecks().name(c.getDid()));\n     }\n \n     @CheckResult\n", "next_change": {"commit": "db867c9006c24de3f8ad5ea0e6f68e35fe13e66c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex e21e7c3ae..e64b9d4bd 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1539,6 +1539,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n+        item.put(SFLD, note.getSFld());\n     }\n \n     @CheckResult\n", "next_change": {"commit": "7fccc05cde4e26216a73054bd61bd5278c507f6d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex e64b9d4bd..057645b49 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1482,66 +1469,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n-        // render question and answer\n-        Map<String, String> qa = c._getQA(true, true);\n-        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-            HashMap<String, String> qaFull = c._getQA(true, false);\n-            if (\"\".equals(qa.get(\"q\"))) {\n-                qa.put(\"q\", qaFull.get(\"q\"));\n-            }\n-            if (\"\".equals(qa.get(\"a\"))) {\n-                qa.put(\"a\", qaFull.get(\"a\"));\n-            }\n-        }\n-        // update the original hash map to include rendered question & answer\n-        String q = qa.get(\"q\");\n-        String a = qa.get(\"a\");\n-        // remove the question from the start of the answer if it exists\n-        if (a.startsWith(q)) {\n-            a = a.replaceFirst(Pattern.quote(q), \"\");\n-        }\n-        // put all of the fields in except for those that have already been pulled out straight from the\n-        // database\n-        item.put(ANSWER, formatQA(a, context));\n-        item.put(CARD, c.template().optString(\"name\"));\n-        item.put(DUE, c.getDueString());\n-        if (c.getType() == Consts.CARD_TYPE_NEW) {\n-            item.put(EASE, context.getString(R.string.card_browser_ease_new_card));\n-        } else {\n-            item.put(EASE, (c.getFactor()/10)+\"%\");\n-        }\n-\n-        Note note = c.note();\n-        item.put(CHANGED, LanguageUtil.getShortDateFormatFromS(c.getMod()));\n-        item.put(CREATED, LanguageUtil.getShortDateFormatFromMs(note.getId()));\n-        item.put(EDITED, LanguageUtil.getShortDateFormatFromS(note.getMod()));\n-        // interval\n-        switch (c.getType()) {\n-            case Consts.CARD_TYPE_NEW:\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_new_card));\n-                break;\n-            case Consts.CARD_TYPE_LRN :\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_learning_card));\n-                break;\n-            default:\n-                item.put(INTERVAL, Utils.roundedTimeSpanUnformatted(context, c.getIvl()*86400));\n-                break;\n-        }\n-        item.put(LAPSES, Integer.toString(c.getLapses()));\n-        item.put(NOTE, c.model().optString(\"name\"));\n-        item.put(QUESTION, formatQA(q, context));\n-        item.put(REVIEWS, Integer.toString(c.getReps()));\n-        String tags = note.stringTags();\n-        item.put(TAGS, tags);\n-        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n-        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n-        item.put(DECK, col.getDecks().name(c.getDid()));\n-        item.put(SFLD, note.getSFld());\n-    }\n-\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": {"commit": "2114aeedad26a5384d6d6a46289f72e405f8c9e9", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 057645b49..826edafd6 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1469,6 +1482,66 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n+    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n+        // render question and answer\n+        Map<String, String> qa = c._getQA(true, true);\n+        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n+        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n+            HashMap<String, String> qaFull = c._getQA(true, false);\n+            if (\"\".equals(qa.get(\"q\"))) {\n+                qa.put(\"q\", qaFull.get(\"q\"));\n+            }\n+            if (\"\".equals(qa.get(\"a\"))) {\n+                qa.put(\"a\", qaFull.get(\"a\"));\n+            }\n+        }\n+        // update the original hash map to include rendered question & answer\n+        String q = qa.get(\"q\");\n+        String a = qa.get(\"a\");\n+        // remove the question from the start of the answer if it exists\n+        if (a.startsWith(q)) {\n+            a = a.replaceFirst(Pattern.quote(q), \"\");\n+        }\n+        // put all of the fields in except for those that have already been pulled out straight from the\n+        // database\n+        item.put(ANSWER, formatQA(a, context));\n+        item.put(CARD, c.template().optString(\"name\"));\n+        item.put(DUE, c.getDueString());\n+        if (c.getType() == Consts.CARD_TYPE_NEW) {\n+            item.put(EASE, context.getString(R.string.card_browser_ease_new_card));\n+        } else {\n+            item.put(EASE, (c.getFactor()/10)+\"%\");\n+        }\n+\n+        Note note = c.note();\n+        item.put(CHANGED, LanguageUtil.getShortDateFormatFromS(c.getMod()));\n+        item.put(CREATED, LanguageUtil.getShortDateFormatFromMs(note.getId()));\n+        item.put(EDITED, LanguageUtil.getShortDateFormatFromS(note.getMod()));\n+        // interval\n+        switch (c.getType()) {\n+            case Consts.CARD_TYPE_NEW:\n+                item.put(INTERVAL, context.getString(R.string.card_browser_interval_new_card));\n+                break;\n+            case Consts.CARD_TYPE_LRN :\n+                item.put(INTERVAL, context.getString(R.string.card_browser_interval_learning_card));\n+                break;\n+            default:\n+                item.put(INTERVAL, Utils.roundedTimeSpanUnformatted(context, c.getIvl()*86400));\n+                break;\n+        }\n+        item.put(LAPSES, Integer.toString(c.getLapses()));\n+        item.put(NOTE, c.model().optString(\"name\"));\n+        item.put(QUESTION, formatQA(q, context));\n+        item.put(REVIEWS, Integer.toString(c.getReps()));\n+        String tags = note.stringTags();\n+        item.put(TAGS, tags);\n+        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n+        item.put(FLAGS, (Integer.toString(c.getUserFlag())));\n+        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n+        item.put(DECK, col.getDecks().name(c.getDid()));\n+        item.put(SFLD, note.getSFld());\n+    }\n+\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 55a90b1d1..9f719f63b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1537,7 +1528,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n+        item.put(FLAGS, (Integer.toString(c.getUserFlag())));\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n", "next_change": {"commit": "0dba81bdef77c234dd4d9a90e1ee89e6c0dc827f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 9f719f63b..7eab66e5e 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1522,13 +1520,13 @@ public class CardBrowser extends NavigationDrawerActivity implements\n                 break;\n         }\n         item.put(LAPSES, Integer.toString(c.getLapses()));\n-        item.put(NOTE, c.model().optString(\"name\"));\n+        item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (Integer.toString(c.getUserFlag())));\n+        item.put(FLAGS, (Integer.toString(c.userFlag())));\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n", "next_change": {"commit": "40af31415bc356b207b0eb07921d62fc3c57eda3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 7eab66e5e..c19f4e6da 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1526,7 +1528,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (Integer.toString(c.userFlag())));\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n", "next_change": {"commit": "5f63aeea4bb6e6f1958f78c0fea980a942f33ad6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex c19f4e6da..34ec806f9 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1528,7 +1527,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n     }\n", "next_change": {"commit": "2d9bb9a08928843e01b7adb39df61f67b0eefeb5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 34ec806f9..1089c2d46 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1526,7 +1525,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n-        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n     }\n", "next_change": {"commit": "0a4218fe7c17fee8a4cf38a0cdb3fc45cf8d770f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 1089c2d46..b0d3c313c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1526,7 +1521,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(DECK, col.getDecks().name(c.getDid()));\n-        item.put(SFLD, note.getSFld());\n     }\n \n     @CheckResult\n", "next_change": {"commit": "7d454e131c800ea1bfb826b3acffc74f1a9a324d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex b0d3c313c..7050438a8 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1520,7 +1515,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n-        item.put(DECK, col.getDecks().name(c.getDid()));\n     }\n \n     @CheckResult\n", "next_change": {"commit": "2ede85b0dda0d29139e6266b787e580cd5530a94", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 7050438a8..33f27a4f9 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1513,8 +1509,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n-        String tags = note.stringTags();\n-        item.put(TAGS, tags);\n     }\n \n     @CheckResult\n", "next_change": {"commit": "fe98ebdcbc1e1ff0b9999dc3d574ff64c43e28dc", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 33f27a4f9..d853cba2b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,30 +1480,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         // put all of the fields in except for those that have already been pulled out straight from the\n         // database\n         item.put(ANSWER, formatQA(a, context));\n-        item.put(CARD, c.template().optString(\"name\"));\n-        item.put(DUE, c.getDueString());\n-        if (c.getType() == Consts.CARD_TYPE_NEW) {\n-            item.put(EASE, context.getString(R.string.card_browser_ease_new_card));\n-        } else {\n-            item.put(EASE, (c.getFactor()/10)+\"%\");\n-        }\n \n-        Note note = c.note();\n-        item.put(CHANGED, LanguageUtil.getShortDateFormatFromS(c.getMod()));\n-        item.put(CREATED, LanguageUtil.getShortDateFormatFromMs(note.getId()));\n-        item.put(EDITED, LanguageUtil.getShortDateFormatFromS(note.getMod()));\n-        // interval\n-        switch (c.getType()) {\n-            case Consts.CARD_TYPE_NEW:\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_new_card));\n-                break;\n-            case Consts.CARD_TYPE_LRN :\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_learning_card));\n-                break;\n-            default:\n-                item.put(INTERVAL, Utils.roundedTimeSpanUnformatted(context, c.getIvl()*86400));\n-                break;\n-        }\n         item.put(LAPSES, Integer.toString(c.getLapses()));\n         item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n", "next_change": {"commit": "17d9b916e4cfc4e6c3cc552f04dc72038450e8e1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex d853cba2b..087a58df6 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,7 +1481,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         // database\n         item.put(ANSWER, formatQA(a, context));\n \n-        item.put(LAPSES, Integer.toString(c.getLapses()));\n         item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n", "next_change": {"commit": "b696126cdfb39e7e967088855a64f98995742d29", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 087a58df6..17b0cafce 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1480,8 +1480,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         // put all of the fields in except for those that have already been pulled out straight from the\n         // database\n         item.put(ANSWER, formatQA(a, context));\n-\n-        item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n     }\n", "next_change": {"commit": "cffe326a64e97452f9d0ad296e00b56636dd3807", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 17b0cafce..94743e4f0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,7 +1481,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         // database\n         item.put(ANSWER, formatQA(a, context));\n         item.put(QUESTION, formatQA(q, context));\n-        item.put(REVIEWS, Integer.toString(c.getReps()));\n     }\n \n     @CheckResult\n", "next_change": {"commit": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 94743e4f0..33f2d76d3 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1470,15 +1470,12 @@ public class CardBrowser extends NavigationDrawerActivity implements\n                 qa.put(\"a\", qaFull.get(\"a\"));\n             }\n         }\n-        // update the original hash map to include rendered question & answer\n         String q = qa.get(\"q\");\n         String a = qa.get(\"a\");\n         // remove the question from the start of the answer if it exists\n         if (a.startsWith(q)) {\n             a = a.replaceFirst(Pattern.quote(q), \"\");\n         }\n-        // put all of the fields in except for those that have already been pulled out straight from the\n-        // database\n         item.put(ANSWER, formatQA(a, context));\n         item.put(QUESTION, formatQA(q, context));\n     }\n", "next_change": {"commit": "474450d513e379802bca25b64e9d2dccfa7dc105", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 33f2d76d3..de54a7132 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1457,29 +1457,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, CardCache item, Card c) {\n-        // render question and answer\n-        Map<String, String> qa = c._getQA(true, true);\n-        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-            HashMap<String, String> qaFull = c._getQA(true, false);\n-            if (\"\".equals(qa.get(\"q\"))) {\n-                qa.put(\"q\", qaFull.get(\"q\"));\n-            }\n-            if (\"\".equals(qa.get(\"a\"))) {\n-                qa.put(\"a\", qaFull.get(\"a\"));\n-            }\n-        }\n-        String q = qa.get(\"q\");\n-        String a = qa.get(\"a\");\n-        // remove the question from the start of the answer if it exists\n-        if (a.startsWith(q)) {\n-            a = a.replaceFirst(Pattern.quote(q), \"\");\n-        }\n-        item.put(ANSWER, formatQA(a, context));\n-        item.put(QUESTION, formatQA(q, context));\n-    }\n-\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": {"commit": "7383c6809f93d6fd931a8f3bec4b43c9c488b19f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex de54a7132..a773d50b5 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1404,56 +1436,71 @@ public class CardBrowser extends NavigationDrawerActivity implements\n      * @param updatedCardTags Mapping note id -> updated tags\n      */\n     private void updateCardsInList(List<Card> cards, Map<Long, String> updatedCardTags) {\n-        Map<Long, Integer> idToPos = getPositionMap(getCards());\n+        List<CardCache> cardList = getCards();\n+        Map<Long, Integer> idToPos = getPositionMap(cardList);\n         for (Card c : cards) {\n             // get position in the mCards search results HashMap\n-            int pos = idToPos.containsKey(c.getId()) ? idToPos.get(c.getId()) : -1;\n-            if (pos < 0 || pos >= getCardCount()) {\n+            Integer pos = idToPos.get(c.getId());\n+            if (pos == null || pos >= getCardCount()) {\n                 continue;\n             }\n-            CardCache card = getCards().get(pos);\n             // update Q & A etc\n-            card.load(true);\n+            cardList.get(pos).load(true, mColumn1Index, mColumn2Index);\n         }\n \n         updateList();\n     }\n \n-    private TaskListener mUpdateCardHandler = new ListenerWithProgressBarCloseOnFalse(\"Card Browser - mUpdateCardHandler.onPostExecute()\"){\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+\n+    private static class UpdateCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public UpdateCardHandler(CardBrowser browser) {\n+            super(\"Card Browser - UpdateCardHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n+        }\n+\n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            updateCardInList(value.getCard(), value.getString());\n+        public void actualOnProgressUpdate(@NonNull CardBrowser browser, TaskData value) {\n+            browser.updateCardInList(value.getCard(), value.getString());\n         }\n \n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n+        protected void actualOnValidPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n         }\n     };\n \n-    private TaskListener mChangeDeckHandler = new ListenerWithProgressBarCloseOnFalse(\"Card Browser - mChangeDeckHandler.onPostExecute()\") {\n+    private ChangeDeckHandler changeDeckHandler() {\n+        return new ChangeDeckHandler(this);\n+    }\n+    private static class ChangeDeckHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public ChangeDeckHandler(CardBrowser browser) {\n+            super(\"Card Browser - changeDeckHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n+        protected void actualOnValidPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n \n-            searchCards();\n-            endMultiSelectMode();\n-            mCardsAdapter.notifyDataSetChanged();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.searchCards();\n+            browser.endMultiSelectMode();\n+            browser.mCardsAdapter.notifyDataSetChanged();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n \n             if (!result.getBoolean()) {\n-                Timber.i(\"mChangeDeckHandler failed, not offering undo\");\n-                displayCouldNotChangeDeck();\n+                Timber.i(\"changeDeckHandler failed, not offering undo\");\n+                browser.displayCouldNotChangeDeck();\n                 return;\n             }\n             // snackbar to offer undo\n-            String deckName = getCol().getDecks().name(mNewDid);\n-            mUndoSnackbar = UIUtils.showSnackbar(CardBrowser.this, String.format(getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n+            String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n                 @Override\n                 public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, mUndoHandler);\n+                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);\n                 }\n-            }, mCardsListView, null);\n+            }, browser.mCardsListView, null);\n         }\n     };\n \n", "next_change": {"commit": "715357c31701ffe4d1f87d8278be7c622fd25f60", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex a773d50b5..5f2682430 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1502,7 +1523,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n                 }\n             }, browser.mCardsListView, null);\n         }\n-    };\n+    }\n+\n \n     @CheckResult\n     private static String formatQA(String text, Context context) {\n", "next_change": {"commit": "c0595464b0b205d704b293f64543e5f54e4b2612", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 5f2682430..e015758c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1516,12 +1578,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n-                @Override\n-                public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);\n-                }\n-            }, browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex e015758c7..7ea57886b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1578,7 +1726,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> TaskManager.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 7ea57886b..ed1747b0a 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1726,7 +1716,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> TaskManager.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION,\n+                                                         R.string.undo, v -> TaskManager.launchCollectionTask(new CollectionTask.Undo(), browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "bd8f85f29633812b249152b8e4dac986d89ae49f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex ed1747b0a..9da7f8009 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1709,15 +1759,20 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             browser.mCardsAdapter.notifyDataSetChanged();\n             browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n \n-            if (!result.getBoolean()) {\n+            if (!result.succeeded()) {\n                 Timber.i(\"changeDeckHandler failed, not offering undo\");\n                 browser.displayCouldNotChangeDeck();\n                 return;\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION,\n-                                                         R.string.undo, v -> TaskManager.launchCollectionTask(new CollectionTask.Undo(), browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(\n+                    browser,\n+                    String.format(browser.getString(R.string.changed_deck_message), deckName),\n+                    SNACKBAR_DURATION,\n+                    R.string.undo,\n+                    v -> TaskManager.launchCollectionTask(new UndoService.Undo().toDelegate(), browser.mUndoHandler),\n+                    browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "0fd0f558c49c728f0eca73a7f5059125cb0a638c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\ndeleted file mode 100644\nindex 9da7f8009..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ /dev/null\n", "chunk": "@@ -1,2973 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *\n- * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-\n-package com.ichi2.anki;\n-\n-import android.app.AlertDialog;\n-import android.content.BroadcastReceiver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.IntentFilter;\n-import android.content.SharedPreferences;\n-import android.graphics.Typeface;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.SystemClock;\n-\n-import androidx.activity.result.ActivityResultLauncher;\n-import androidx.activity.result.contract.ActivityResultContracts;\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import com.google.android.material.snackbar.Snackbar;\n-\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.widget.SearchView;\n-import android.text.TextUtils;\n-import android.util.Pair;\n-import android.util.TypedValue;\n-import android.view.KeyEvent;\n-import android.view.LayoutInflater;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.view.WindowManager;\n-import android.widget.AbsListView;\n-import android.widget.AdapterView;\n-import android.widget.AdapterView.OnItemSelectedListener;\n-import android.widget.ArrayAdapter;\n-import android.widget.BaseAdapter;\n-import android.widget.CheckBox;\n-import android.widget.ListView;\n-import android.widget.Spinner;\n-import android.widget.TextView;\n-\n-import com.afollestad.materialdialogs.MaterialDialog;\n-import com.ichi2.anki.dialogs.CardBrowserMySearchesDialog;\n-import com.ichi2.anki.dialogs.CardBrowserOrderDialog;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.dialogs.DeckSelectionDialog;\n-import com.ichi2.anki.dialogs.IntegerDialog;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.dialogs.SimpleMessageDialog;\n-import com.ichi2.anki.dialogs.tags.TagsDialog;\n-import com.ichi2.anki.dialogs.tags.TagsDialogFactory;\n-import com.ichi2.anki.dialogs.tags.TagsDialogListener;\n-import com.ichi2.anki.receiver.SdCardReceiver;\n-import com.ichi2.anki.servicelayer.SchedulerService;\n-import com.ichi2.anki.servicelayer.UndoService;\n-import com.ichi2.anki.widgets.DeckDropDownAdapter;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.async.TaskListenerWithContext;\n-import com.ichi2.async.TaskManager;\n-import com.ichi2.compat.Compat;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.Deck;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.ui.CardBrowserSearchView;\n-import com.ichi2.upgrade.Upgrade;\n-import com.ichi2.utils.FunctionalInterfaces;\n-import com.ichi2.utils.HashUtil;\n-import com.ichi2.utils.LanguageUtil;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import com.ichi2.utils.JSONException;\n-import com.ichi2.utils.JSONObject;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.CardBrowser.Column.*;\n-import static com.ichi2.libanki.stats.Stats.SECONDS_PER_DAY;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-import static com.ichi2.utils.LanguageUtil.getLocaleCompat;\n-\n-public class CardBrowser extends NavigationDrawerActivity implements\n-        DeckDropDownAdapter.SubtitleListener,\n-        DeckSelectionDialog.DeckSelectionListener,\n-        TagsDialogListener {\n-\n-    @Override\n-    public void onDeckSelected(@Nullable DeckSelectionDialog.SelectableDeck deck) {\n-        if (deck == null) {\n-            return;\n-        }\n-        long deckId = deck.getDeckId();\n-        mDeckSpinnerSelection.initializeActionBarDeckSpinner(this.getSupportActionBar());\n-        mDeckSpinnerSelection.selectDeckById(deckId, true);\n-        selectDeckAndSave(deckId);\n-    }\n-\n-\n-    enum Column {\n-        QUESTION,\n-        ANSWER,\n-        FLAGS,\n-        SUSPENDED,\n-        MARKED,\n-        SFLD,\n-        DECK,\n-        TAGS,\n-        ID,\n-        CARD,\n-        DUE,\n-        EASE,\n-        CHANGED,\n-        CREATED,\n-        EDITED,\n-        INTERVAL,\n-        LAPSES,\n-        NOTE_TYPE,\n-        REVIEWS\n-    }\n-\n-    /** List of cards in the browser.\n-    * When the list is changed, the position member of its elements should get changed.*/\n-    @NonNull\n-    private final CardCollection<CardCache> mCards = new CardCollection<>();\n-    public DeckSpinnerSelection mDeckSpinnerSelection;\n-    @VisibleForTesting\n-    public ListView mCardsListView;\n-    private CardBrowserSearchView mSearchView;\n-    private MultiColumnListAdapter mCardsAdapter;\n-    private String mSearchTerms;\n-    private String mRestrictOnDeck;\n-    private int mCurrentFlag;\n-\n-    private TagsDialogFactory mTagsDialogFactory;\n-\n-    private MenuItem mSearchItem;\n-    private MenuItem mSaveSearchItem;\n-    private MenuItem mMySearchesItem;\n-    private MenuItem mPreviewItem;\n-\n-    private Snackbar mUndoSnackbar;\n-\n-    public static Card sCardBrowserCard;\n-\n-    // card that was clicked (not marked)\n-    private long mCurrentCardId;\n-\n-    private int mOrder;\n-    private boolean mOrderAsc;\n-    private int mColumn1Index;\n-    private int mColumn2Index;\n-\n-    //DEFECT: Doesn't need to be a local\n-    /** The next deck for the \"Change Deck\" operation */\n-    private long mNewDid;\n-\n-    /** The query which is currently in the search box, potentially null. Only set when search box was open */\n-    private String mTempSearchQuery;\n-\n-    ActivityResultLauncher<Intent> mOnEditCardActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onEditCardActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        if (result.getResultCode() != RESULT_CANCELED) {\n-            Timber.i(\"CardBrowser:: CardBrowser: Saving card...\");\n-            TaskManager.launchCollectionTask(new CollectionTask.UpdateNote(sCardBrowserCard, false, false),\n-                    updateCardHandler());\n-        }\n-        Intent data = result.getData();\n-        if (data != null &&\n-                (data.getBooleanExtra(\"reloadRequired\", false) || data.getBooleanExtra(\"noteChanged\", false))) {\n-            // if reloadRequired or noteChanged flag was sent from note editor then reload card list\n-            searchCards();\n-            mShouldRestoreScroll = true;\n-            // in use by reviewer?\n-            if (getReviewerCardId() == mCurrentCardId) {\n-                mReloadRequired = true;\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    ActivityResultLauncher<Intent> mOnAddNoteActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onAddNoteActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        if (result.getResultCode() == RESULT_OK) {\n-            if (mSearchView != null) {\n-                mSearchTerms = mSearchView.getQuery().toString();\n-                searchCards();\n-            } else {\n-                Timber.w(\"Note was added from browser and on return mSearchView == null\");\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    ActivityResultLauncher<Intent> mOnPreviewCardsActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onPreviewCardsActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        // Previewing can now perform an \"edit\", so it can pass on a reloadRequired\n-        Intent data = result.getData();\n-        if (data != null &&\n-                (data.getBooleanExtra(\"reloadRequired\", false) || data.getBooleanExtra(\"noteChanged\", false))) {\n-            searchCards();\n-            if (getReviewerCardId() == mCurrentCardId) {\n-                mReloadRequired = true;\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    private static final int DEFAULT_FONT_SIZE_RATIO = 100;\n-    // Should match order of R.array.card_browser_order_labels\n-    public static final int CARD_ORDER_NONE = 0;\n-    private static final String[] fSortTypes = new String[] {\n-        \"\",\n-        \"noteFld\",\n-        \"noteCrt\",\n-        \"noteMod\",\n-        \"cardMod\",\n-        \"cardDue\",\n-        \"cardIvl\",\n-        \"cardEase\",\n-        \"cardReps\",\n-        \"cardLapses\"};\n-    private static final Column[] COLUMN1_KEYS = {QUESTION, SFLD};\n-\n-    // list of available keys in mCards corresponding to the column names in R.array.browser_column2_headings.\n-    // Note: the last 6 are currently hidden\n-    private static final Column[] COLUMN2_KEYS = {ANSWER,\n-        CARD,\n-        DECK,\n-        NOTE_TYPE,\n-        QUESTION,\n-        TAGS,\n-        LAPSES,\n-        REVIEWS,\n-        INTERVAL,\n-        EASE,\n-        DUE,\n-        CHANGED,\n-        CREATED,\n-        EDITED,\n-    };\n-    private long mLastRenderStart = 0;\n-    private TextView mActionBarTitle;\n-    private boolean mReloadRequired = false;\n-    private boolean mInMultiSelectMode = false;\n-    private final @NonNull Set<CardCache> mCheckedCards = Collections.synchronizedSet(new LinkedHashSet<>());\n-    private int mLastSelectedPosition;\n-    @Nullable\n-    private Menu mActionBarMenu;\n-\n-    private static final int SNACKBAR_DURATION = 8000;\n-\n-\n-    // Values related to persistent state data\n-    private static final long ALL_DECKS_ID = 0L;\n-    private static final String PERSISTENT_STATE_FILE = \"DeckPickerState\";\n-    private static final String LAST_DECK_ID_KEY = \"lastDeckId\";\n-\n-    public static final int CARD_NOT_AVAILABLE = -1;\n-    private long mOldCardId = 0;\n-    private int mOldCardTopOffset = 0;\n-    private boolean mShouldRestoreScroll = false;\n-    private boolean mPostAutoScroll = false;\n-\n-    private final Onboarding.CardBrowser mOnboarding = new Onboarding.CardBrowser(this);\n-\n-    /**\n-     * Broadcast that informs us when the sd card is about to be unmounted\n-     */\n-    private BroadcastReceiver mUnmountReceiver = null;\n-\n-    private final MaterialDialog.ListCallbackSingleChoice mOrderDialogListener =\n-            (materialDialog, view, which, charSequence) -> {\n-                changeCardOrder(which);\n-                return true;\n-            };\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)\n-    protected void changeCardOrder(int which) {\n-        if (which != mOrder) {\n-            mOrder = which;\n-            mOrderAsc = false;\n-            if (mOrder == 0) {\n-                // if the sort value in the card browser was changed, then perform a new search\n-                getCol().set_config(\"sortType\", fSortTypes[1]);\n-                AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()\n-                        .putBoolean(\"cardBrowserNoSorting\", true)\n-                        .apply();\n-            } else {\n-                getCol().set_config(\"sortType\", fSortTypes[mOrder]);\n-                AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()\n-                        .putBoolean(\"cardBrowserNoSorting\", false)\n-                        .apply();\n-            }\n-            getCol().set_config(\"sortBackwards\", mOrderAsc);\n-            searchCards();\n-        } else if (which != CARD_ORDER_NONE) {\n-            // if the same element is selected again, reverse the order\n-            mOrderAsc = !mOrderAsc;\n-            getCol().set_config(\"sortBackwards\", mOrderAsc);\n-            mCards.reverse();\n-            updateList();\n-        }\n-        // To update the collection\n-        getCol().getDb().setMod(true);\n-    }\n-\n-\n-    private RepositionCardHandler repositionCardHandler() {\n-        return new RepositionCardHandler(this);\n-    }\n-\n-    private static class RepositionCardHandler extends TaskListenerWithContext<CardBrowser, Object, Computation<? extends Card[]>> {\n-        public RepositionCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::RepositionCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::RepositionCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reposition_card_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private ResetProgressCardHandler resetProgressCardHandler() {\n-        return new ResetProgressCardHandler(this);\n-    }\n-    private static class ResetProgressCardHandler extends TaskListenerWithContext<CardBrowser, Object, Computation<? extends Card[]>>{\n-        public ResetProgressCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::ResetProgressCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::ResetProgressCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reset_cards_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private RescheduleCardHandler rescheduleCardHandler() {\n-        return new RescheduleCardHandler(this);\n-    }\n-    private static class RescheduleCardHandler extends TaskListenerWithContext<CardBrowser, Card, Computation<? extends Card[]>>{\n-        public RescheduleCardHandler (CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::RescheduleCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::RescheduleCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reschedule_cards_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private final CardBrowserMySearchesDialog.MySearchesDialogListener mMySearchesDialogListener =\n-            new CardBrowserMySearchesDialog.MySearchesDialogListener() {\n-        @Override\n-        public void onSelection(String searchName) {\n-            Timber.d(\"OnSelection using search named: %s\", searchName);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            Timber.d(\"SavedFilters are %s\", savedFiltersObj == null ? null : savedFiltersObj.toString());\n-            if (savedFiltersObj != null) {\n-                mSearchTerms = savedFiltersObj.optString(searchName);\n-                Timber.d(\"OnSelection using search terms: %s\", mSearchTerms);\n-                mSearchView.setQuery(mSearchTerms, false);\n-                mSearchItem.expandActionView();\n-                searchCards();\n-            }\n-        }\n-\n-        @Override\n-        public void onRemoveSearch(String searchName) {\n-            Timber.d(\"OnRemoveSelection using search named: %s\", searchName);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            if (savedFiltersObj != null && savedFiltersObj.has(searchName)) {\n-                savedFiltersObj.remove(searchName);\n-                getCol().set_config(\"savedFilters\", savedFiltersObj);\n-                getCol().flush();\n-                if (savedFiltersObj.length() == 0) {\n-                    mMySearchesItem.setVisible(false);\n-                }\n-            }\n-\n-        }\n-\n-        @Override\n-        public void onSaveSearch(String searchName, String searchTerms) {\n-            if (TextUtils.isEmpty(searchName)) {\n-                UIUtils.showThemedToast(CardBrowser.this,\n-                        getString(R.string.card_browser_list_my_searches_new_search_error_empty_name), true);\n-                return;\n-            }\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            boolean should_save = false;\n-            if (savedFiltersObj == null) {\n-                savedFiltersObj = new JSONObject();\n-                savedFiltersObj.put(searchName, searchTerms);\n-                should_save = true;\n-            } else if (!savedFiltersObj.has(searchName)) {\n-                savedFiltersObj.put(searchName, searchTerms);\n-                should_save = true;\n-            } else {\n-                UIUtils.showThemedToast(CardBrowser.this,\n-                                        getString(R.string.card_browser_list_my_searches_new_search_error_dup), true);\n-            }\n-            if (should_save) {\n-                getCol().set_config(\"savedFilters\", savedFiltersObj);\n-                getCol().flush();\n-                mSearchView.setQuery(\"\", false);\n-                mMySearchesItem.setVisible(true);\n-            }\n-        }\n-    };\n-\n-\n-    private void onSearch() {\n-        mSearchTerms = mSearchView.getQuery().toString();\n-        if (mSearchTerms.length() == 0) {\n-            mSearchView.setQueryHint(getResources().getString(R.string.deck_conf_cram_search));\n-        }\n-        searchCards();\n-    }\n-\n-    private List<Long> getSelectedCardIds() {\n-        List<Long> ids = new ArrayList<>(mCheckedCards.size());\n-        for (CardCache cardPosition : mCheckedCards) {\n-            ids.add(cardPosition.getId());\n-        }\n-        return ids;\n-    }\n-\n-    private boolean canPerformCardInfo() {\n-        return checkedCardCount() == 1;\n-    }\n-\n-    private boolean canPerformMultiSelectEditNote() {\n-        //The noteId is not currently available. Only allow if a single card is selected for now.\n-        return checkedCardCount() == 1;\n-    }\n-\n-\n-    /**\n-     * Change Deck\n-     * @param deckPosition NOT the did. The index in the DISPLAYED Deck list to change the decks to.\n-     * grep: changeDeck\n-     */\n-    @VisibleForTesting\n-    void moveSelectedCardsToDeck(int deckPosition) {\n-        List<Long> ids = getSelectedCardIds();\n-\n-        Deck selectedDeck = getValidDecksForChangeDeck().get(deckPosition);\n-\n-        try {\n-            //#5932 - can't be dynamic\n-            if (Decks.isDynamic(selectedDeck)) {\n-                Timber.w(\"Attempted to change cards to dynamic deck. Cancelling operation.\");\n-                displayCouldNotChangeDeck();\n-                return;\n-            }\n-        } catch (Exception e) {\n-            displayCouldNotChangeDeck();\n-            Timber.e(e);\n-            return;\n-        }\n-\n-        mNewDid = selectedDeck.getLong(\"id\");\n-\n-        Timber.i(\"Changing selected cards to deck: %d\", mNewDid);\n-\n-        if (ids.isEmpty()) {\n-            endMultiSelectMode();\n-            mCardsAdapter.notifyDataSetChanged();\n-            return;\n-        }\n-\n-        if (ids.contains(getReviewerCardId())) {\n-            mReloadRequired = true;\n-        }\n-\n-        executeChangeCollectionTask(ids, mNewDid);\n-    }\n-\n-\n-    private void displayCouldNotChangeDeck() {\n-        UIUtils.showThemedToast(this, getString(R.string.card_browser_deck_change_error), true);\n-    }\n-\n-\n-    @VisibleForTesting\n-    Long getLastDeckId() {\n-        SharedPreferences state = getSharedPreferences(PERSISTENT_STATE_FILE,0);\n-        if (!state.contains(LAST_DECK_ID_KEY)) {\n-            return null;\n-        }\n-        return state.getLong(LAST_DECK_ID_KEY, -1);\n-    }\n-\n-    public static void clearLastDeckId() {\n-        Context context = AnkiDroidApp.getInstance();\n-        context.getSharedPreferences(PERSISTENT_STATE_FILE,0).edit().remove(LAST_DECK_ID_KEY).apply();\n-    }\n-\n-    private void saveLastDeckId(Long id) {\n-        if (id == null) {\n-            clearLastDeckId();\n-            return;\n-        }\n-        getSharedPreferences(PERSISTENT_STATE_FILE, 0).edit().putLong(LAST_DECK_ID_KEY, id).apply();\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        mTagsDialogFactory = new TagsDialogFactory(this).attachToActivity(this);\n-        super.onCreate(savedInstanceState);\n-        Timber.d(\"onCreate()\");\n-        if (wasLoadedFromExternalTextActionItem() && !Permissions.hasStorageAccessPermission(this)) {\n-            Timber.w(\"'Card Browser' Action item pressed before storage permissions granted.\");\n-            UIUtils.showThemedToast(this, getString(R.string.intent_handler_failed_no_storage_permission), false);\n-            displayDeckPickerForPermissionsDialog();\n-            return;\n-        }\n-        setContentView(R.layout.card_browser);\n-        initNavigationDrawer(findViewById(android.R.id.content));\n-        startLoadingCollection();\n-\n-        // for intent coming from search query js api\n-        if (getIntent().getStringExtra(\"search_query\") != null) {\n-            mSearchTerms = getIntent().getStringExtra(\"search_query\");\n-            searchCards();\n-        }\n-\n-        mOnboarding.onCreate();\n-    }\n-\n-    // Finish initializing the activity after the collection has been correctly loaded\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        Timber.d(\"onCollectionLoaded()\");\n-        registerExternalStorageListener();\n-\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-\n-        // Load reference to action bar title\n-        mActionBarTitle = findViewById(R.id.toolbar_title);\n-\n-        mOrder = CARD_ORDER_NONE;\n-        String colOrder = getCol().get_config_string(\"sortType\");\n-        for (int c = 0; c < fSortTypes.length; ++c) {\n-            if (fSortTypes[c].equals(colOrder)) {\n-                mOrder = c;\n-                break;\n-            }\n-        }\n-        if (mOrder == 1 && preferences.getBoolean(\"cardBrowserNoSorting\", false)) {\n-            mOrder = 0;\n-        }\n-        //This upgrade should already have been done during\n-        //setConf. However older version of AnkiDroid didn't call\n-        //upgradeJSONIfNecessary during setConf, which means the\n-        //conf saved may still have this bug.\n-        mOrderAsc = Upgrade.upgradeJSONIfNecessary(getCol(), \"sortBackwards\", false);\n-\n-        mCards.reset();\n-        mCardsListView = findViewById(R.id.card_browser_list);\n-        // Create a spinner for column1\n-        Spinner cardsColumn1Spinner = findViewById(R.id.browser_column1_spinner);\n-        ArrayAdapter<CharSequence> column1Adapter = ArrayAdapter.createFromResource(this,\n-                R.array.browser_column1_headings, android.R.layout.simple_spinner_item);\n-        column1Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n-        cardsColumn1Spinner.setAdapter(column1Adapter);\n-        mColumn1Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt(\"cardBrowserColumn1\", 0);\n-        cardsColumn1Spinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n-            @Override\n-            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {\n-                // If a new column was selected then change the key used to map from mCards to the column TextView\n-                if (pos != mColumn1Index) {\n-                    mColumn1Index = pos;\n-                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()\n-                            .putInt(\"cardBrowserColumn1\", mColumn1Index).apply();\n-                    Column[] fromMap = mCardsAdapter.getFromMapping();\n-                    fromMap[0] = COLUMN1_KEYS[mColumn1Index];\n-                    mCardsAdapter.setFromMapping(fromMap);\n-                }\n-            }\n-\n-            @Override\n-            public void onNothingSelected(AdapterView<?> parent) {\n-                // Do Nothing\n-            }\n-        });\n-        // Load default value for column2 selection\n-        mColumn2Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt(\"cardBrowserColumn2\", 0);\n-        // Setup the column 2 heading as a spinner so that users can easily change the column type\n-        Spinner cardsColumn2Spinner = findViewById(R.id.browser_column2_spinner);\n-        ArrayAdapter<CharSequence> column2Adapter = ArrayAdapter.createFromResource(this,\n-                R.array.browser_column2_headings, android.R.layout.simple_spinner_item);\n-        column2Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n-        cardsColumn2Spinner.setAdapter(column2Adapter);\n-        // Create a new list adapter with updated column map any time the user changes the column\n-        cardsColumn2Spinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n-            @Override\n-            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {\n-                // If a new column was selected then change the key used to map from mCards to the column TextView\n-                if (pos != mColumn2Index) {\n-                    mColumn2Index = pos;\n-                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()\n-                            .putInt(\"cardBrowserColumn2\", mColumn2Index).apply();\n-                    Column[] fromMap = mCardsAdapter.getFromMapping();\n-                    fromMap[1] = COLUMN2_KEYS[mColumn2Index];\n-                    mCardsAdapter.setFromMapping(fromMap);\n-                }\n-            }\n-\n-            @Override\n-            public void onNothingSelected(AdapterView<?> parent) {\n-                // Do Nothing\n-            }\n-        });\n-        // get the font and font size from the preferences\n-        int sflRelativeFontSize = preferences.getInt(\"relativeCardBrowserFontSize\", DEFAULT_FONT_SIZE_RATIO);\n-        String sflCustomFont = preferences.getString(\"browserEditorFont\", \"\");\n-        Column[] columnsContent = {COLUMN1_KEYS[mColumn1Index], COLUMN2_KEYS[mColumn2Index]};\n-        // make a new list adapter mapping the data in mCards to column1 and column2 of R.layout.card_item_browser\n-        mCardsAdapter = new MultiColumnListAdapter(\n-                this,\n-                R.layout.card_item_browser,\n-                columnsContent,\n-                new int[] {R.id.card_sfld, R.id.card_column2},\n-                sflRelativeFontSize,\n-                sflCustomFont);\n-        // link the adapter to the main mCardsListView\n-        mCardsListView.setAdapter(mCardsAdapter);\n-        // make the items (e.g. question & answer) render dynamically when scrolling\n-        mCardsListView.setOnScrollListener(new RenderOnScroll());\n-        // set the spinner index\n-        cardsColumn1Spinner.setSelection(mColumn1Index);\n-        cardsColumn2Spinner.setSelection(mColumn2Index);\n-\n-\n-        mCardsListView.setOnItemClickListener((parent, view, position, id) -> {\n-            if (mInMultiSelectMode) {\n-                // click on whole cell triggers select\n-                CheckBox cb = view.findViewById(R.id.card_checkbox);\n-                cb.toggle();\n-                onCheck(position, view);\n-            } else {\n-                // load up the card selected on the list\n-                long clickedCardId = getCards().get(position).getId();\n-                saveScrollingState(position);\n-                openNoteEditorForCard(clickedCardId);\n-            }\n-        });\n-\n-        mCardsListView.setOnItemLongClickListener((adapterView, view, position, id) -> {\n-            if (mInMultiSelectMode) {\n-                boolean hasChanged = false;\n-                for (int i = Math.min(mLastSelectedPosition, position); i <= Math.max(mLastSelectedPosition, position); i++) {\n-                    CardCache card = (CardCache) mCardsListView.getItemAtPosition(i);\n-\n-                    // Add to the set of checked cards\n-                    hasChanged |= mCheckedCards.add(card);\n-                }\n-                if (hasChanged) {\n-                    onSelectionChanged();\n-                }\n-            } else {\n-                mLastSelectedPosition = position;\n-                saveScrollingState(position);\n-                loadMultiSelectMode();\n-\n-                // click on whole cell triggers select\n-                CheckBox cb = view.findViewById(R.id.card_checkbox);\n-                cb.toggle();\n-                onCheck(position, view);\n-                recenterListView(view);\n-                mCardsAdapter.notifyDataSetChanged();\n-            }\n-            return true;\n-        });\n-\n-        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n-\n-        long deckId = getCol().getDecks().selected();\n-        mDeckSpinnerSelection = new DeckSpinnerSelection(this, col, this.findViewById(R.id.toolbar_spinner));\n-        mDeckSpinnerSelection.setShowAllDecks(true);\n-        mDeckSpinnerSelection.initializeActionBarDeckSpinner(this.getSupportActionBar());\n-        selectDeckAndSave(deckId);\n-\n-        // If a valid value for last deck exists then use it, otherwise use libanki selected deck\n-        if (getLastDeckId() != null && getLastDeckId() == ALL_DECKS_ID) {\n-            selectAllDecks();\n-        } else  if (getLastDeckId() != null && getCol().getDecks().get(getLastDeckId(), false) != null) {\n-            mDeckSpinnerSelection.selectDeckById(getLastDeckId(), false);\n-        } else {\n-            mDeckSpinnerSelection.selectDeckById(getCol().getDecks().selected(), false);\n-        }\n-    }\n-\n-    public void selectDeckAndSave(long deckId) {\n-        mDeckSpinnerSelection.selectDeckById(deckId, true);\n-        if (deckId == ALL_DECKS_ID) {\n-            mRestrictOnDeck = \"\";\n-        } else {\n-            String deckName = getCol().getDecks().name(deckId);\n-            mRestrictOnDeck = \"deck:\\\"\" + deckName + \"\\\" \";\n-        }\n-        saveLastDeckId(deckId);\n-        searchCards();\n-    }\n-\n-\n-\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        // NOTE: These are all active when typing in the search - doesn't matter as all need CTRL\n-\n-        switch (keyCode) {\n-            /* Ctrl+A - Select All */\n-            case KeyEvent.KEYCODE_A: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+A - Select All\");\n-                    onSelectAll();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_E: {\n-                // Ctrl+Shift+E: Export (TODO)\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+E: Add Note\");\n-                    addNoteFromCardBrowser();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_D: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+D: Change Deck\");\n-                    showChangeDeckDialog();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_K: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+K: Toggle Mark\");\n-                    toggleMark();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_R: {\n-                if (event.isCtrlPressed() && event.isAltPressed()) {\n-                    Timber.i(\"Ctrl+Alt+R - Reschedule\");\n-                    rescheduleSelectedCards();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_FORWARD_DEL: {\n-                Timber.i(\"Delete pressed - Delete Selected Note\");\n-                deleteSelectedNote();\n-                return true;\n-            }\n-        }\n-        return super.onKeyDown(keyCode, event);\n-    }\n-\n-    /** All the notes of the selected cards will be marked\n-     * If one or more card is unmarked, all will be marked,\n-     * otherwise, they will be unmarked */\n-    private void toggleMark() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Not marking cards - nothing selected\");\n-            return;\n-        }\n-\n-        TaskManager.launchCollectionTask(new CollectionTask.MarkNoteMulti(getSelectedCardIds()),\n-                markCardHandler());\n-    }\n-\n-\n-    @VisibleForTesting\n-    void selectAllDecks() {\n-        mDeckSpinnerSelection.selectDropDownItem(0);\n-        mRestrictOnDeck = \"\";\n-        saveLastDeckId(ALL_DECKS_ID);\n-        searchCards();\n-    }\n-\n-\n-    /** Opens the note editor for a card.\n-     * We use the Card ID to specify the preview target */\n-    public void openNoteEditorForCard(long cardId) {\n-        mCurrentCardId = cardId;\n-        sCardBrowserCard = getCol().getCard(mCurrentCardId);\n-        // start note editor using the card we just loaded\n-        Intent editCard = new Intent(this, NoteEditor.class)\n-                .putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_EDIT)\n-                .putExtra(NoteEditor.EXTRA_CARD_ID, sCardBrowserCard.getId());\n-        this.launchActivityForResultWithAnimation(editCard, mOnEditCardActivityResult, START);\n-        //#6432 - FIXME - onCreateOptionsMenu crashes if receiving an activity result from edit card when in multiselect\n-        endMultiSelectMode();\n-    }\n-\n-    private void openNoteEditorForCurrentlySelectedNote() {\n-        try {\n-            //Just select the first one. It doesn't particularly matter if there's a multiselect occurring.\n-            openNoteEditorForCard(getSelectedCardIds().get(0));\n-        } catch (Exception e) {\n-            Timber.w(e, \"Error Opening Note Editor\");\n-            UIUtils.showThemedToast(this, getString(R.string.multimedia_editor_something_wrong), false);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected void onStop() {\n-        Timber.d(\"onStop()\");\n-        // cancel rendering the question and answer, which has shared access to mCards\n-        super.onStop();\n-        if (!isFinishing()) {\n-            WidgetStatus.update(this);\n-            UIUtils.saveCollectionInBackground();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected void onDestroy() {\n-        Timber.d(\"onDestroy()\");\n-        invalidate();\n-        super.onDestroy();\n-        if (mUnmountReceiver != null) {\n-            unregisterReceiver(mUnmountReceiver);\n-        }\n-    }\n-\n-\n-    @Override\n-    public void onBackPressed() {\n-        if (isDrawerOpen()) {\n-            super.onBackPressed();\n-        } else if (mInMultiSelectMode) {\n-            endMultiSelectMode();\n-        } else {\n-            Timber.i(\"Back key pressed\");\n-            Intent data = new Intent();\n-            if (mReloadRequired) {\n-                // Add reload flag to result intent so that schedule reset when returning to note editor\n-                data.putExtra(\"reloadRequired\", true);\n-            }\n-            closeCardBrowser(RESULT_OK, data);\n-        }\n-    }\n-\n-    @Override\n-    protected void onPause() {\n-        super.onPause();\n-        // If the user entered something into the search, but didn't press \"search\", clear this.\n-        // It's confusing if the bar is shown with a query that does not relate to the data on the screen\n-        mTempSearchQuery = null;\n-        if (mPostAutoScroll) {\n-            mPostAutoScroll = false;\n-        }\n-    }\n-\n-    @Override\n-    protected void onResume() {\n-        Timber.d(\"onResume()\");\n-        super.onResume();\n-        selectNavigationItem(R.id.nav_browser);\n-    }\n-\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(final Menu menu) {\n-        Timber.d(\"onCreateOptionsMenu()\");\n-        mActionBarMenu = menu;\n-        if (!mInMultiSelectMode) {\n-            // restore drawer click listener and icon\n-            restoreDrawerIcon();\n-            getMenuInflater().inflate(R.menu.card_browser, menu);\n-            mSaveSearchItem = menu.findItem(R.id.action_save_search);\n-            mSaveSearchItem.setVisible(false); //the searchview's query always starts empty.\n-            mMySearchesItem = menu.findItem(R.id.action_list_my_searches);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            mMySearchesItem.setVisible(savedFiltersObj != null && savedFiltersObj.length() > 0);\n-            mSearchItem = menu.findItem(R.id.action_search);\n-            mSearchItem.setOnActionExpandListener(new MenuItem.OnActionExpandListener() {\n-                @Override\n-                public boolean onMenuItemActionExpand(MenuItem item) {\n-                    return true;\n-                }\n-\n-                @Override\n-                public boolean onMenuItemActionCollapse(MenuItem item) {\n-                    // SearchView doesn't support empty queries so we always reset the search when collapsing\n-                    mSearchTerms = \"\";\n-                    mSearchView.setQuery(mSearchTerms, false);\n-                    searchCards();\n-                    // invalidate options menu so that disappeared icons would appear again\n-                    supportInvalidateOptionsMenu();\n-                    mTempSearchQuery = null;\n-                    return true;\n-                }\n-            });\n-            mSearchView = (CardBrowserSearchView) mSearchItem.getActionView();\n-            mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n-                @Override\n-                public boolean onQueryTextChange(String newText) {\n-                    if (mSearchView.shouldIgnoreValueChange()) {\n-                        return true;\n-                    }\n-                    mSaveSearchItem.setVisible(!TextUtils.isEmpty(newText));\n-                    mTempSearchQuery = newText;\n-                    return true;\n-                }\n-\n-                @Override\n-                public boolean onQueryTextSubmit(String query) {\n-                    onSearch();\n-                    mSearchView.clearFocus();\n-                    return true;\n-                }\n-            });\n-            // Fixes #6500 - keep the search consistent if coming back from note editor\n-            // Fixes #9010 - consistent search after drawer change calls supportInvalidateOptionsMenu (mTempSearchQuery)\n-            if (!TextUtils.isEmpty(mTempSearchQuery) || !TextUtils.isEmpty(mSearchTerms)) {\n-                mSearchItem.expandActionView(); // This calls mSearchView.setOnSearchClickListener\n-                String toUse = !TextUtils.isEmpty(mTempSearchQuery) ? mTempSearchQuery : mSearchTerms;\n-                mSearchView.setQuery(toUse, false);\n-            }\n-            mSearchView.setOnSearchClickListener(v -> {\n-                // Provide SearchView with the previous search terms\n-                mSearchView.setQuery(mSearchTerms, false);\n-            });\n-        } else {\n-            // multi-select mode\n-            getMenuInflater().inflate(R.menu.card_browser_multiselect, menu);\n-            showBackIcon();\n-        }\n-\n-        if (mActionBarMenu != null && mActionBarMenu.findItem(R.id.action_undo) != null) {\n-            MenuItem undo =  mActionBarMenu.findItem(R.id.action_undo);\n-            undo.setVisible(getCol().undoAvailable());\n-            undo.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        // Maybe we were called from ACTION_PROCESS_TEXT.\n-        // In that case we already fill in the search.\n-        Intent intent = getIntent();\n-        Compat compat = CompatHelper.getCompat();\n-        if (compat.ACTION_PROCESS_TEXT.equals(intent.getAction())) {\n-            CharSequence search = intent.getCharSequenceExtra(compat.EXTRA_PROCESS_TEXT);\n-            if (search != null && search.length() != 0) {\n-                Timber.i(\"CardBrowser :: Called with search intent: %s\", search.toString());\n-                mSearchView.setQuery(search, true);\n-                intent.setAction(Intent.ACTION_DEFAULT);\n-            }\n-        }\n-\n-        mPreviewItem = menu.findItem(R.id.action_preview);\n-        onSelectionChanged();\n-        updatePreviewMenuItem();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-    @Override\n-    protected void onNavigationPressed() {\n-        if (mInMultiSelectMode) {\n-            endMultiSelectMode();\n-        } else {\n-            super.onNavigationPressed();\n-        }\n-    }\n-\n-\n-    private void displayDeckPickerForPermissionsDialog() {\n-        //TODO: Combine this with class: IntentHandler after both are well-tested\n-        Intent deckPicker = new Intent(this, DeckPicker.class);\n-        deckPicker.setAction(Intent.ACTION_MAIN);\n-        deckPicker.addCategory(Intent.CATEGORY_LAUNCHER);\n-        deckPicker.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-        startActivityWithAnimation(deckPicker, FADE);\n-        AnkiActivity.finishActivityWithFade(this);\n-        finishActivityWithFade(this);\n-        this.setResult(RESULT_CANCELED);\n-    }\n-\n-\n-    private boolean wasLoadedFromExternalTextActionItem() {\n-        Intent intent = this.getIntent();\n-        if (intent == null) {\n-            return false;\n-        }\n-        //API 23: Replace with Intent.ACTION_PROCESS_TEXT\n-        return \"android.intent.action.PROCESS_TEXT\".equalsIgnoreCase(intent.getAction());\n-    }\n-\n-    private void updatePreviewMenuItem() {\n-        if (mPreviewItem == null) {\n-            return;\n-        }\n-        mPreviewItem.setVisible(getCardCount() > 0);\n-    }\n-\n-    /** Returns the number of cards that are visible on the screen */\n-    public int getCardCount() {\n-        return getCards().size();\n-    }\n-\n-\n-    private void updateMultiselectMenu() {\n-        Timber.d(\"updateMultiselectMenu()\");\n-        if (mActionBarMenu == null || mActionBarMenu.findItem(R.id.action_suspend_card) == null) {\n-            return;\n-        }\n-\n-        if (!mCheckedCards.isEmpty()) {\n-            TaskManager.cancelAllTasks(CollectionTask.CheckCardSelection.class);\n-            TaskManager.launchCollectionTask(new CollectionTask.CheckCardSelection(mCheckedCards),\n-                    mCheckSelectedCardsHandler);\n-        }\n-\n-        mActionBarMenu.findItem(R.id.action_select_all).setVisible(!hasSelectedAllCards());\n-        //Note: Theoretically should not happen, as this should kick us back to the menu\n-        mActionBarMenu.findItem(R.id.action_select_none).setVisible(hasSelectedCards());\n-        mActionBarMenu.findItem(R.id.action_edit_note).setVisible(canPerformMultiSelectEditNote());\n-        mActionBarMenu.findItem(R.id.action_view_card_info).setVisible(canPerformCardInfo());\n-    }\n-\n-\n-    private boolean hasSelectedCards() {\n-        return !mCheckedCards.isEmpty();\n-    }\n-\n-    private boolean hasSelectedAllCards() {\n-        return checkedCardCount() >= getCardCount(); //must handle 0.\n-    }\n-\n-\n-    @VisibleForTesting\n-    public void flagTask (int flag) {\n-        TaskManager.launchCollectionTask(\n-                new CollectionTask.Flag(getSelectedCardIds(), flag),\n-                flagCardHandler());\n-    }\n-\n-    /** Updates flag icon color and cards shown with given color */\n-    private void selectionWithFlagTask(int flag) {\n-        mCurrentFlag = flag;\n-        filterByFlag();\n-    }\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-\n-        // dismiss undo-snackbar if shown to avoid race condition\n-        // (when another operation will be performed on the model, it will undo the latest operation)\n-        if (mUndoSnackbar != null && mUndoSnackbar.isShown())\n-            mUndoSnackbar.dismiss();\n-\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            endMultiSelectMode();\n-            return true;\n-        } else if (itemId == R.id.action_add_note_from_card_browser) {\n-            addNoteFromCardBrowser();\n-            return true;\n-        } else if (itemId == R.id.action_save_search) {\n-            String searchTerms = mSearchView.getQuery().toString();\n-            showDialogFragment(CardBrowserMySearchesDialog.newInstance(null, mMySearchesDialogListener,\n-                    searchTerms, CardBrowserMySearchesDialog.CARD_BROWSER_MY_SEARCHES_TYPE_SAVE));\n-            return true;\n-        } else if (itemId == R.id.action_list_my_searches) {\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            HashMap<String, String> savedFilters;\n-            if (savedFiltersObj != null) {\n-                savedFilters = HashUtil.HashMapInit(savedFiltersObj.length());\n-                for (String searchName : savedFiltersObj) {\n-                    savedFilters.put(searchName, savedFiltersObj.optString(searchName));\n-                }\n-            } else {\n-                savedFilters = HashUtil.HashMapInit(0);\n-            }\n-            showDialogFragment(CardBrowserMySearchesDialog.newInstance(savedFilters, mMySearchesDialogListener,\n-                    \"\", CardBrowserMySearchesDialog.CARD_BROWSER_MY_SEARCHES_TYPE_LIST));\n-            return true;\n-        } else if (itemId == R.id.action_sort_by_size) {\n-            showDialogFragment(CardBrowserOrderDialog\n-                    .newInstance(mOrder, mOrderAsc, mOrderDialogListener));\n-            return true;\n-        } else if (itemId == R.id.action_show_marked) {\n-            mSearchTerms = \"tag:marked\";\n-            mSearchView.setQuery(\"\", false);\n-            mSearchView.setQueryHint(getResources().getString(R.string.card_browser_show_marked));\n-            searchCards();\n-            return true;\n-        } else if (itemId == R.id.action_show_suspended) {\n-            mSearchTerms = \"is:suspended\";\n-            mSearchView.setQuery(\"\", false);\n-            mSearchView.setQueryHint(getResources().getString(R.string.card_browser_show_suspended));\n-            searchCards();\n-            return true;\n-        } else if (itemId == R.id.action_search_by_tag) {\n-            showTagsDialog();\n-            return true;\n-        } else if (itemId == R.id.action_flag_zero) {\n-            flagTask(0);\n-            return true;\n-        } else if (itemId == R.id.action_flag_one) {\n-            flagTask(1);\n-            return true;\n-        } else if (itemId == R.id.action_flag_two) {\n-            flagTask(2);\n-            return true;\n-        } else if (itemId == R.id.action_flag_three) {\n-            flagTask(3);\n-            return true;\n-        } else if (itemId == R.id.action_flag_four) {\n-            flagTask(4);\n-            return true;\n-        } else if (itemId == R.id.action_flag_five) {\n-            flagTask(5);\n-            return true;\n-        } else if (itemId == R.id.action_flag_six) {\n-            flagTask(6);\n-            return true;\n-        } else if (itemId == R.id.action_flag_seven) {\n-            flagTask(7);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_zero) {\n-            selectionWithFlagTask(0);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_one) {\n-            selectionWithFlagTask(1);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_two) {\n-            selectionWithFlagTask(2);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_three) {\n-            selectionWithFlagTask(3);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_four) {\n-            selectionWithFlagTask(4);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_five) {\n-            selectionWithFlagTask(5);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_six) {\n-            selectionWithFlagTask(6);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_seven) {\n-            selectionWithFlagTask(7);\n-            return true;\n-        } else if (itemId == R.id.action_delete_card) {\n-            deleteSelectedNote();\n-            return true;\n-        } else if (itemId == R.id.action_mark_card) {\n-            toggleMark();\n-\n-            return true;\n-        } else if (itemId == R.id.action_suspend_card) {\n-            TaskManager.launchCollectionTask(new CollectionTask.SuspendCardMulti(getSelectedCardIds()),\n-                    suspendCardHandler());\n-\n-            return true;\n-        } else if (itemId == R.id.action_change_deck) {\n-            showChangeDeckDialog();\n-            return true;\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.w(\"CardBrowser:: Undo pressed\");\n-            onUndo();\n-            return true;\n-        } else if (itemId == R.id.action_select_none) {\n-            onSelectNone();\n-            return true;\n-        } else if (itemId == R.id.action_select_all) {\n-            onSelectAll();\n-            return true;\n-        } else if (itemId == R.id.action_preview) {\n-            onPreview();\n-            return true;\n-        } else if (itemId == R.id.action_reset_cards_progress) {\n-            Timber.i(\"NoteEditor:: Reset progress button pressed\");\n-            onResetProgress();\n-            return true;\n-        } else if (itemId == R.id.action_reschedule_cards) {\n-            Timber.i(\"CardBrowser:: Reschedule button pressed\");\n-            rescheduleSelectedCards();\n-            return true;\n-        } else if (itemId == R.id.action_reposition_cards) {\n-            Timber.i(\"CardBrowser:: Reposition button pressed\");\n-\n-            // Only new cards may be repositioned\n-            List<Long> cardIds = getSelectedCardIds();\n-            for (long cardId : cardIds) {\n-                if (getCol().getCard(cardId).getQueue() != Consts.QUEUE_TYPE_NEW) {\n-                    SimpleMessageDialog dialog = SimpleMessageDialog.newInstance(\n-                            getString(R.string.vague_error),\n-                            getString(R.string.reposition_card_not_new_error),\n-                            false);\n-                    showDialogFragment(dialog);\n-                    return false;\n-                }\n-            }\n-\n-            IntegerDialog repositionDialog = new IntegerDialog();\n-            repositionDialog.setArgs(\n-                    getString(R.string.reposition_card_dialog_title),\n-                    getString(R.string.reposition_card_dialog_message),\n-                    5);\n-            repositionDialog.setCallbackRunnable(position -> repositionCardsNoValidation(cardIds, position));\n-            showDialogFragment(repositionDialog);\n-            return true;\n-        } else if (itemId == R.id.action_edit_note) {\n-            openNoteEditorForCurrentlySelectedNote();\n-\n-\n-            return super.onOptionsItemSelected(item);\n-        } else if (itemId == R.id.action_view_card_info) {\n-            List<Long> selectedCardIds = getSelectedCardIds();\n-            if (!selectedCardIds.isEmpty()) {\n-                Intent intent = new Intent(this, CardInfo.class);\n-                intent.putExtra(\"cardId\", selectedCardIds.get(0));\n-                startActivityWithAnimation(intent, FADE);\n-            }\n-            return true;\n-        }\n-        return super.onOptionsItemSelected(item);\n-    }\n-\n-\n-    protected void deleteSelectedNote() {\n-        if (!mInMultiSelectMode) {\n-            return;\n-        }\n-        TaskManager.launchCollectionTask(new CollectionTask.DeleteNoteMulti(getSelectedCardIds()),\n-                                            mDeleteNoteHandler);\n-\n-        mCheckedCards.clear();\n-        endMultiSelectMode();\n-        mCardsAdapter.notifyDataSetChanged();\n-    }\n-\n-\n-    @VisibleForTesting\n-    void onUndo() {\n-        if (getCol().undoAvailable()) {\n-            new UndoService.Undo().runWithHandler(mUndoHandler);\n-        }\n-    }\n-\n-\n-    protected void onResetProgress() {\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getString(R.string.reset_card_dialog_title);\n-        String message = getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"CardBrowser:: ResetProgress button pressed\");\n-            resetProgressNoConfirm(getSelectedCardIds());\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    @VisibleForTesting\n-    void resetProgressNoConfirm(List<Long> cardIds) {\n-        TaskManager.launchCollectionTask(new SchedulerService.ResetCards(cardIds).toDelegate(), resetProgressCardHandler());\n-    }\n-\n-\n-    @VisibleForTesting\n-    void repositionCardsNoValidation(List<Long> cardIds, Integer position) {\n-        TaskManager.launchCollectionTask(new SchedulerService.RepositionCards(cardIds, position).toDelegate(),\n-                                            repositionCardHandler());\n-    }\n-\n-\n-    protected void onPreview() {\n-        Intent previewer = getPreviewIntent();\n-        this.launchActivityForResultWithoutAnimation(previewer, mOnPreviewCardsActivityResult);\n-    }\n-\n-\n-    @NonNull\n-    @VisibleForTesting\n-    Intent getPreviewIntent() {\n-        if (mInMultiSelectMode && checkedCardCount() > 1) {\n-            // Multiple cards have been explicitly selected, so preview only those cards\n-            int index = 0;\n-            return getPreviewIntent(index, Utils.toPrimitive(getSelectedCardIds()));\n-        } else {\n-            // Preview all cards, starting from the one that is currently selected\n-            int startIndex = mCheckedCards.isEmpty() ? 0 : mCheckedCards.iterator().next().getPosition();\n-            return getPreviewIntent(startIndex, getAllCardIds());\n-        }\n-    }\n-\n-\n-    @NonNull\n-    private Intent getPreviewIntent(int index, long[] selectedCardIds) {\n-        return Previewer.getPreviewIntent(CardBrowser.this, index, selectedCardIds);\n-    }\n-\n-\n-    private void rescheduleSelectedCards() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Attempted reschedule - no cards selected\");\n-            return;\n-        }\n-\n-        List<Long> selectedCardIds = getSelectedCardIds();\n-        FunctionalInterfaces.Consumer<Integer> consumer = newDays -> rescheduleWithoutValidation(selectedCardIds, newDays);\n-        RescheduleDialog rescheduleDialog;\n-        if (selectedCardIds.size() == 1) {\n-            long cardId = selectedCardIds.get(0);\n-            Card selected = getCol().getCard(cardId);\n-            rescheduleDialog = RescheduleDialog.rescheduleSingleCard(getResources(), selected, consumer);\n-        } else {\n-            rescheduleDialog = RescheduleDialog.rescheduleMultipleCards(getResources(),\n-                    consumer,\n-                    selectedCardIds.size());\n-        }\n-        showDialogFragment(rescheduleDialog);\n-    }\n-\n-\n-    @VisibleForTesting\n-    void rescheduleWithoutValidation(List<Long> selectedCardIds, Integer newDays) {\n-        TaskManager.launchCollectionTask(new SchedulerService.RescheduleCards(selectedCardIds, newDays).toDelegate(),\n-            rescheduleCardHandler());\n-    }\n-\n-\n-    private void showChangeDeckDialog() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Not showing Change Deck - No Cards\");\n-            return;\n-        }\n-\n-        AlertDialog.Builder builderSingle = new AlertDialog.Builder(this);\n-        builderSingle.setTitle(getString(R.string.move_all_to_deck));\n-\n-        //WARNING: changeDeck depends on this index, so any changes should be reflected there.\n-        final ArrayAdapter<String> arrayAdapter = new ArrayAdapter<>(this, R.layout.dropdown_deck_item);\n-        for (Deck deck : getValidDecksForChangeDeck()) {\n-            try {\n-                arrayAdapter.add(deck.getString(\"name\"));\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-            }\n-        }\n-\n-        builderSingle.setNegativeButton(getString(R.string.dialog_cancel), (dialog, which) -> dialog.dismiss());\n-        builderSingle.setAdapter(arrayAdapter, (dialog, which) -> moveSelectedCardsToDeck(which));\n-        builderSingle.show();\n-    }\n-\n-\n-    @VisibleForTesting\n-    Intent getAddNoteIntent() {\n-        Intent intent = new Intent(CardBrowser.this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_ADD);\n-        Long did = getLastDeckId();\n-        if (did != null && did > 0) {\n-            intent.putExtra(NoteEditor.EXTRA_DID, (long) did);\n-        }\n-        intent.putExtra(NoteEditor.EXTRA_TEXT_FROM_SEARCH_VIEW, mSearchTerms);\n-        return intent;\n-    }\n-\n-    private void addNoteFromCardBrowser() {\n-        this.launchActivityForResultWithAnimation(getAddNoteIntent(), mOnAddNoteActivityResult, START);\n-    }\n-\n-\n-    // We spawn CollectionTasks that may create memory pressure, this transmits it so polling isCancelled sees the pressure\n-    @Override\n-    public void onTrimMemory(int pressureLevel) {\n-        super.onTrimMemory(pressureLevel);\n-        TaskManager.cancelCurrentlyExecutingTask();\n-    }\n-\n-    private long getReviewerCardId() {\n-        if (getIntent().hasExtra(\"currentCard\")) {\n-            return getIntent().getExtras().getLong(\"currentCard\");\n-        } else {\n-            return -1;\n-        }\n-    }\n-\n-    private void showTagsDialog() {\n-        TagsDialog dialog = mTagsDialogFactory.newTagsDialog().withArguments(\n-                TagsDialog.DialogType.FILTER_BY_TAG, new ArrayList<>(0), new ArrayList<>(getCol().getTags().all()));\n-        showDialogFragment(dialog);\n-    }\n-\n-    @Override\n-    public void onSaveInstanceState(@NonNull Bundle savedInstanceState) {\n-        // Save current search terms\n-        savedInstanceState.putString(\"mSearchTerms\", mSearchTerms);\n-        savedInstanceState.putLong(\"mOldCardId\", mOldCardId);\n-        savedInstanceState.putInt(\"mOldCardTopOffset\", mOldCardTopOffset);\n-        savedInstanceState.putBoolean(\"mShouldRestoreScroll\", mShouldRestoreScroll);\n-        savedInstanceState.putBoolean(\"mPostAutoScroll\", mPostAutoScroll);\n-        savedInstanceState.putInt(\"mLastSelectedPosition\", mLastSelectedPosition);\n-        savedInstanceState.putBoolean(\"mInMultiSelectMode\", mInMultiSelectMode);\n-        super.onSaveInstanceState(savedInstanceState);\n-    }\n-\n-    @Override\n-    public void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {\n-        super.onRestoreInstanceState(savedInstanceState);\n-        mSearchTerms = savedInstanceState.getString(\"mSearchTerms\");\n-        mOldCardId = savedInstanceState.getLong(\"mOldCardId\");\n-        mOldCardTopOffset = savedInstanceState.getInt(\"mOldCardTopOffset\");\n-        mShouldRestoreScroll = savedInstanceState.getBoolean(\"mShouldRestoreScroll\");\n-        mPostAutoScroll = savedInstanceState.getBoolean(\"mPostAutoScroll\");\n-        mLastSelectedPosition = savedInstanceState.getInt(\"mLastSelectedPosition\");\n-        mInMultiSelectMode = savedInstanceState.getBoolean(\"mInMultiSelectMode\");\n-        searchCards();\n-    }\n-\n-    private void invalidate() {\n-        TaskManager.cancelAllTasks(CollectionTask.SearchCards.class);\n-        TaskManager.cancelAllTasks(CollectionTask.RenderBrowserQA.class);\n-        TaskManager.cancelAllTasks(CollectionTask.CheckCardSelection.class);\n-        mCards.clear();\n-        mCheckedCards.clear();\n-    }\n-\n-    /** Currently unused - to be used in #7676 */\n-    private void forceRefreshSearch() {\n-        searchCards();\n-    }\n-\n-\n-    private void searchCards() {\n-        // cancel the previous search & render tasks if still running\n-        invalidate();\n-        String searchText;\n-        if (mSearchTerms == null) {\n-            mSearchTerms = \"\";\n-        }\n-        if (!\"\".equals(mSearchTerms) && (mSearchView != null)) {\n-            mSearchView.setQuery(mSearchTerms, false);\n-            mSearchItem.expandActionView();\n-        }\n-        if (mSearchTerms.contains(\"deck:\")) {\n-            searchText = \"(\" + mSearchTerms + \")\";\n-        } else {\n-            if (!\"\".equals(mSearchTerms))\n-                searchText = mRestrictOnDeck + \"(\" + mSearchTerms + \")\";\n-            else\n-                searchText = mRestrictOnDeck;\n-        }\n-        if (colIsOpen() && mCardsAdapter!= null) {\n-            // clear the existing card list\n-            mCards.reset();\n-            mCardsAdapter.notifyDataSetChanged();\n-            //  estimate maximum number of cards that could be visible (assuming worst-case minimum row height of 20dp)\n-            // Perform database query to get all card ids\n-            TaskManager.launchCollectionTask(new CollectionTask.SearchCards(searchText,\n-                            (mOrder != CARD_ORDER_NONE),\n-                            numCardsToRender(),\n-                            mColumn1Index,\n-                            mColumn2Index),\n-                    mSearchCardsHandler\n-            );\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    protected int numCardsToRender() {\n-        return (int) Math.ceil(mCardsListView.getHeight() /\n-                TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, getResources().getDisplayMetrics())) + 5;\n-    }\n-\n-    private void updateList() {\n-        if (colIsOpen() && mCardsAdapter!= null) {\n-            mCardsAdapter.notifyDataSetChanged();\n-            mDeckSpinnerSelection.notifyDataSetChanged();\n-            onSelectionChanged();\n-            updatePreviewMenuItem();\n-        }\n-    }\n-\n-    /**\n-     * @return text to be used in the subtitle of the drop-down deck selector\n-     */\n-    public String getSubtitleText() {\n-        int count = getCardCount();\n-        return getResources().getQuantityString(R.plurals.card_browser_subtitle, count, count);\n-    }\n-\n-\n-    private static Map<Long, Integer> getPositionMap(CardCollection<CardCache> list) {\n-        Map<Long, Integer> positions = HashUtil.HashMapInit(list.size());\n-        for (int i = 0; i < list.size(); i++) {\n-            positions.put(list.get(i).getId(), i);\n-        }\n-        return positions;\n-    }\n-\n-    // convenience method for updateCardsInList(...)\n-    private void updateCardInList(Card card) {\n-        List<Card> cards = new ArrayList<>(1);\n-        cards.add(card);\n-        updateCardsInList(cards);\n-    }\n-\n-    /** Returns the decks which are valid targets for \"Change Deck\" */\n-    @VisibleForTesting\n-    List<Deck> getValidDecksForChangeDeck() {\n-        List<Deck> nonDynamicDecks = new ArrayList<>(mDeckSpinnerSelection.getDropDownDecks().size());\n-        for (Deck d : mDeckSpinnerSelection.getDropDownDecks()) {\n-            if (Decks.isDynamic(d)) {\n-                continue;\n-            }\n-            nonDynamicDecks.add(d);\n-        }\n-        return nonDynamicDecks;\n-    }\n-\n-\n-    @Override\n-    public void onSelectedTags(List<String> selectedTags, int option) {\n-        //TODO: Duplication between here and CustomStudyDialog:onSelectedTags\n-        mSearchView.setQuery(\"\", false);\n-        String tags = selectedTags.toString();\n-        mSearchView.setQueryHint(getResources().getString(R.string.CardEditorTags,\n-                tags.substring(1, tags.length() - 1)));\n-        StringBuilder sb = new StringBuilder();\n-        switch (option) {\n-            case 1:\n-                sb.append(\"is:new \");\n-                break;\n-            case 2:\n-                sb.append(\"is:due \");\n-                break;\n-            default:\n-                // Logging here might be appropriate : )\n-                break;\n-        }\n-        int i = 0;\n-        for (String tag : selectedTags) {\n-            if (i != 0) {\n-                sb.append(\"or \");\n-            } else {\n-                sb.append(\"(\"); // Only if we really have selected tags\n-            }\n-            // 7070: quote tags so brackets are properly escaped\n-            sb.append(\"tag:\").append(\"'\").append(tag).append(\"'\").append(\" \");\n-            i++;\n-        }\n-        if (i > 0) {\n-            sb.append(\")\"); // Only if we added anything to the tag list\n-        }\n-        mSearchTerms = sb.toString();\n-        searchCards();\n-    }\n-\n-\n-    /** Updates search terms to only show cards with selected flag. */\n-    private void filterByFlag() {\n-        mSearchView.setQuery(\"\", false);\n-        String flagSearchTerm = \"flag:\" + mCurrentFlag;\n-        if (mSearchTerms.contains(\"flag:\")) {\n-            mSearchTerms = mSearchTerms.replaceFirst(\"flag:.\", flagSearchTerm);\n-        }\n-        else if (!mSearchTerms.isEmpty()) {\n-            mSearchTerms = flagSearchTerm + \" \" + mSearchTerms;\n-        } else {\n-            mSearchTerms = flagSearchTerm;\n-        }\n-        searchCards();\n-    }\n-\n-\n-    private static abstract class ListenerWithProgressBar<Progress, Result> extends TaskListenerWithContext<CardBrowser, Progress, Result>{\n-        public ListenerWithProgressBar(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            browser.showProgressBar();\n-        }\n-    }\n-\n-    /** Does not leak Card Browser. */\n-    private static abstract class ListenerWithProgressBarCloseOnFalse<Progress, Result extends Computation<?>> extends ListenerWithProgressBar<Progress, Result> {\n-        private final String mTimber;\n-        public ListenerWithProgressBarCloseOnFalse(String timber, CardBrowser browser) {\n-            super(browser);\n-            mTimber = timber;\n-        }\n-\n-        public ListenerWithProgressBarCloseOnFalse(CardBrowser browser) {\n-            this(null, browser);\n-\t\t}\n-\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Result result) {\n-            if (mTimber != null) {\n-                Timber.d(mTimber);\n-            }\n-            if (result.succeeded()) {\n-                actualOnValidPostExecute(browser, result);\n-            } else {\n-                browser.closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-            }\n-        }\n-\n-        protected abstract void actualOnValidPostExecute(CardBrowser browser, Result result);\n-    }\n-\n-    /**\n-     * @param cards Cards that were changed\n-     */\n-    private void updateCardsInList(List<Card> cards) {\n-        CardCollection<CardCache> cardList = getCards();\n-        Map<Long, Integer> idToPos = getPositionMap(cardList);\n-        for (Card c : cards) {\n-            // get position in the mCards search results HashMap\n-            Integer pos = idToPos.get(c.getId());\n-            if (pos == null || pos >= getCardCount()) {\n-                continue;\n-            }\n-            // update Q & A etc\n-            cardList.get(pos).load(true, mColumn1Index, mColumn2Index);\n-        }\n-\n-        updateList();\n-    }\n-\n-    private UpdateCardHandler updateCardHandler() {\n-        return new UpdateCardHandler(this);\n-    }\n-\n-    private static class UpdateCardHandler extends ListenerWithProgressBarCloseOnFalse<Card, Computation<?>> {\n-        public UpdateCardHandler(CardBrowser browser) {\n-            super(\"Card Browser - UpdateCardHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Card value) {\n-            browser.updateCardInList(value);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-    private static class ChangeDeckHandler extends ListenerWithProgressBarCloseOnFalse<Object, Computation<? extends Card[]>> {\n-        public ChangeDeckHandler(CardBrowser browser) {\n-            super(\"Card Browser - changeDeckHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n-        }\n-\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> result) {\n-            browser.hideProgressBar();\n-\n-            browser.searchCards();\n-            browser.endMultiSelectMode();\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-\n-            if (!result.succeeded()) {\n-                Timber.i(\"changeDeckHandler failed, not offering undo\");\n-                browser.displayCouldNotChangeDeck();\n-                return;\n-            }\n-            // snackbar to offer undo\n-            String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(\n-                    browser,\n-                    String.format(browser.getString(R.string.changed_deck_message), deckName),\n-                    SNACKBAR_DURATION,\n-                    R.string.undo,\n-                    v -> TaskManager.launchCollectionTask(new UndoService.Undo().toDelegate(), browser.mUndoHandler),\n-                    browser.mCardsListView, null);\n-        }\n-    }\n-\n-\n-    @CheckResult\n-    private static String formatQA(String text, Context context) {\n-        boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n-        return formatQAInternal(text, showFilenames);\n-    }\n-\n-\n-    /**\n-     * @param txt The text to strip HTML, comments, tags and media from\n-     * @param showFileNames Whether [sound:foo.mp3] should be rendered as \" foo.mp3 \" or  \" \"\n-     * @return The formatted string\n-     */\n-    @VisibleForTesting\n-    @CheckResult\n-    static String formatQAInternal(String txt, boolean showFileNames) {\n-        /* Strips all formatting from the string txt for use in displaying question/answer in browser */\n-        String s = txt;\n-        s = s.replaceAll(\"<!--.*?-->\", \"\");\n-        s = s.replace(\"<br>\", \" \");\n-        s = s.replace(\"<br />\", \" \");\n-        s = s.replace(\"<div>\", \" \");\n-        s = s.replace(\"\\n\", \" \");\n-        s = showFileNames ? Utils.stripSoundMedia(s) : Utils.stripSoundMedia(s, \" \");\n-        s = s.replaceAll(\"\\\\[\\\\[type:[^]]+]]\", \"\");\n-        s = showFileNames ? Utils.stripHTMLMedia(s) : Utils.stripHTMLMedia(s, \" \");\n-        s = s.trim();\n-        return s;\n-    }\n-\n-    /**\n-     * Removes cards from view. Doesn't delete them in model (database).\n-     */\n-    @SuppressWarnings(\"SameParameterValue\")\n-    private void removeNotesView(Card[] cards, boolean reorderCards) {\n-        List<Long> cardIds = new ArrayList<>(cards.length);\n-        for (Card c : cards) {\n-            cardIds.add(c.getId());\n-        }\n-        removeNotesView(cardIds, reorderCards);\n-    }\n-\n-    /**\n-     * Removes cards from view. Doesn't delete them in model (database).\n-     * @param reorderCards Whether to rearrange the positions of checked items (DEFECT: Currently deselects all)\n-     */\n-    private void removeNotesView(java.util.Collection<Long> cardsIds, boolean reorderCards) {\n-        long reviewerCardId = getReviewerCardId();\n-        CardCollection<CardCache> oldMCards = getCards();\n-        Map<Long, Integer> idToPos = getPositionMap(oldMCards);\n-        Set<Long> idToRemove = new HashSet<>();\n-        for (Long cardId : cardsIds) {\n-            if (cardId == reviewerCardId) {\n-                mReloadRequired = true;\n-            }\n-            if (idToPos.containsKey(cardId)) {\n-                idToRemove.add(cardId);\n-            }\n-        }\n-\n-        List<CardCache> newMCards = new ArrayList<>(oldMCards.size());\n-        int pos = 0;\n-        for (CardCache card: oldMCards) {\n-            if (!idToRemove.contains(card.getId())) {\n-                newMCards.add(new CardCache(card, pos++));\n-            }\n-        }\n-        mCards.replaceWith(newMCards);\n-\n-        if (reorderCards) {\n-            //Suboptimal from a UX perspective, we should reorder\n-            //but this is only hit on a rare sad path and we'd need to rejig the data structures to allow an efficient\n-            //search\n-            Timber.w(\"Removing current selection due to unexpected removal of cards\");\n-            onSelectNone();\n-        }\n-\n-        updateList();\n-    }\n-\n-    private SuspendCardHandler suspendCardHandler() {\n-        return new SuspendCardHandler(this);\n-    }\n-\n-    private static class SuspendCardHandler extends ListenerWithProgressBarCloseOnFalse<Void, Computation<? extends Card[]>> {\n-        public SuspendCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> cards) {\n-            browser.updateCardsInList(Arrays.asList(cards.getValue()));\n-            browser.hideProgressBar();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-    private FlagCardHandler flagCardHandler(){\n-        return new FlagCardHandler(this);\n-    }\n-    private static class FlagCardHandler extends SuspendCardHandler {\n-        public FlagCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-    }\n-\n-\n-    private MarkCardHandler markCardHandler() {\n-        return new MarkCardHandler(this);\n-    }\n-    private static class MarkCardHandler extends ListenerWithProgressBarCloseOnFalse<Void, Computation<? extends Card[]>> {\n-        public MarkCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> cards) {\n-            browser.updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards.getValue()))));\n-            browser.hideProgressBar();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-\n-    private final DeleteNoteHandler mDeleteNoteHandler = new DeleteNoteHandler(this);\n-    private static class DeleteNoteHandler extends ListenerWithProgressBarCloseOnFalse<Card[], Computation<?>> {\n-        public DeleteNoteHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        private int mCardsDeleted = -1;\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            super.actualOnPreExecute(browser);\n-            browser.invalidate();\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Card[] cards) {\n-            //we don't need to reorder cards here as we've already deselected all notes,\n-            browser.removeNotesView(cards, false);\n-            mCardsDeleted = cards.length;\n-        }\n-\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            browser.hideProgressBar();\n-            browser.mActionBarTitle.setText(String.format(getLocaleCompat(browser.getResources()), \"%d\", browser.checkedCardCount()));\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-            // snackbar to offer undo\n-            String deletedMessage = browser.getResources().getQuantityString(R.plurals.card_browser_cards_deleted, mCardsDeleted, mCardsDeleted);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, deletedMessage, SNACKBAR_DURATION,\n-                    R.string.undo, v -> new UndoService.Undo().runWithHandler(browser.mUndoHandler),\n-                    browser.mCardsListView, null);\n-            browser.searchCards();\n-        }\n-    }\n-\n-\n-\n-    private final UndoHandler mUndoHandler = new UndoHandler(this);\n-    private static class UndoHandler extends ListenerWithProgressBarCloseOnFalse<Card, Computation<?>> {\n-        public UndoHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            Timber.d(\"Card Browser - mUndoHandler.actualOnPostExecute(CardBrowser browser)\");\n-            browser.hideProgressBar();\n-            // reload whole view\n-            browser.forceRefreshSearch();\n-            browser.endMultiSelectMode();\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-            browser.updatePreviewMenuItem();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-\n-    private final SearchCardsHandler mSearchCardsHandler = new SearchCardsHandler(this);\n-    @VisibleForTesting\n-    class SearchCardsHandler extends ListenerWithProgressBar<List<CardCache>, List<CardCache>> {\n-        public SearchCardsHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, List<CardCache> cards) {\n-            // Need to copy the list into a new list, because the original list is modified, and\n-            // ListAdapter crash\n-            mCards.replaceWith(new ArrayList<>(cards));\n-            updateList();\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, List<CardCache> result) {\n-            if (result != null) {\n-                mCards.replaceWith(result);\n-                updateList();\n-                handleSearchResult();\n-            }\n-            if (mShouldRestoreScroll) {\n-                mShouldRestoreScroll = false;\n-                int newPosition = getNewPositionOfSelectedCard();\n-                boolean isRestorePossible = (newPosition != CARD_NOT_AVAILABLE);\n-                if (isRestorePossible) {\n-                    autoScrollTo(newPosition);\n-                }\n-            }\n-            updatePreviewMenuItem();\n-            hideProgressBar();\n-        }\n-\n-\n-        private void handleSearchResult() {\n-            Timber.i(\"CardBrowser:: Completed doInBackgroundSearchCards Successfully\");\n-            updateList();\n-            \n-            if ((mSearchView == null) || mSearchView.isIconified()) {\n-                return;\n-            }\n-\n-            if (hasSelectedAllDecks()) {\n-                UIUtils.showSimpleSnackbar(CardBrowser.this, getSubtitleText(), true);\n-                return;\n-            }\n-\n-            //If we haven't selected all decks, allow the user the option to search all decks.\n-            String displayText;\n-            if (getCardCount() == 0) {\n-                displayText = getString(R.string.card_browser_no_cards_in_deck, getSelectedDeckNameForUi());\n-            } else {\n-                displayText = getSubtitleText();\n-            }\n-            View root = CardBrowser.this.findViewById(R.id.root_layout);\n-            UIUtils.showSnackbar(CardBrowser.this,\n-                    displayText,\n-                    SNACKBAR_DURATION,\n-                    R.string.card_browser_search_all_decks,\n-                    (v) -> searchAllDecks(),\n-                    root,\n-                    null);\n-\n-        }\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            super.actualOnCancelled(browser);\n-            hideProgressBar();\n-        }\n-    }\n-\n-\n-    private void saveScrollingState(int position) {\n-        mOldCardId = getCards().get(position).getId();\n-        mOldCardTopOffset = calculateTopOffset(position);\n-    }\n-\n-    private void autoScrollTo(int newPosition) {\n-        mCardsListView.setSelectionFromTop(newPosition, mOldCardTopOffset);\n-        mPostAutoScroll = true;\n-    }\n-\n-    private int calculateTopOffset(int cardPosition) {\n-        int firstVisiblePosition = mCardsListView.getFirstVisiblePosition();\n-        View v = mCardsListView.getChildAt(cardPosition - firstVisiblePosition);\n-        return (v == null) ? 0 : v.getTop();\n-    }\n-\n-    private int getNewPositionOfSelectedCard() {\n-        if (mCards.size() == 0) {\n-            return CARD_NOT_AVAILABLE;\n-        }\n-        for (CardCache card : mCards) {\n-            if (card.getId() == mOldCardId) {\n-                return card.mPosition;\n-            }\n-        }\n-        return CARD_NOT_AVAILABLE;\n-    }\n-\n-    public boolean hasSelectedAllDecks() {\n-        Long lastDeckId = getLastDeckId();\n-        return lastDeckId != null && lastDeckId == ALL_DECKS_ID;\n-    }\n-\n-\n-    public void searchAllDecks() {\n-        //all we need to do is select all decks\n-        selectAllDecks();\n-    }\n-\n-    /**\n-     * Returns the current deck name, \"All Decks\" if all decks are selected, or \"Unknown\"\n-     * Do not use this for any business logic, as this will return inconsistent data\n-     * with the collection.\n-     */\n-    public String getSelectedDeckNameForUi() {\n-        try {\n-            Long lastDeckId = getLastDeckId();\n-            if (lastDeckId == null) {\n-                return getString(R.string.card_browser_unknown_deck_name);\n-            }\n-            if (lastDeckId == ALL_DECKS_ID) {\n-                return getString(R.string.card_browser_all_decks);\n-            }\n-            return getCol().getDecks().name(lastDeckId);\n-        } catch (Exception e) {\n-            Timber.w(e, \"Unable to get selected deck name\");\n-            return getString(R.string.card_browser_unknown_deck_name);\n-        }\n-    }\n-\n-    private final RenderQAHandler mRenderQAHandler = new RenderQAHandler(this);\n-    private static class RenderQAHandler extends TaskListenerWithContext<CardBrowser, Integer, Pair<CardCollection<CardBrowser.CardCache>, List<Long>>>{\n-        public RenderQAHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Integer value) {\n-            // Note: This is called every time a card is rendered.\n-            // It blocks the long-click callback while the task is running, so usage of the task should be minimized\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-        }\n-\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"Starting Q&A background rendering\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Pair<CardCollection<CardBrowser.CardCache>, List<Long>> value) {\n-            List<Long> cardsIdsToHide = value.second;\n-            if (cardsIdsToHide != null) {\n-                    try {\n-                        if (!cardsIdsToHide.isEmpty()) {\n-                            Timber.i(\"Removing %d invalid cards from view\", cardsIdsToHide.size());\n-                            browser.removeNotesView(cardsIdsToHide, true);\n-                        }\n-                    } catch (Exception e) {\n-                        Timber.e(e, \"failed to hide cards\");\n-                    }\n-                browser.hideProgressBar();\n-                browser.mCardsAdapter.notifyDataSetChanged();\n-                Timber.d(\"Completed doInBackgroundRenderBrowserQA Successfuly\");\n-            } else {\n-                // Might want to do something more proactive here like show a message box?\n-                Timber.e(\"doInBackgroundRenderBrowserQA was not successful... continuing anyway\");\n-            }\n-        }\n-\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-\n-    private final CheckSelectedCardsHandler mCheckSelectedCardsHandler = new CheckSelectedCardsHandler(this);\n-    private static class CheckSelectedCardsHandler extends ListenerWithProgressBar<Void, Pair<Boolean, Boolean>> {\n-        public CheckSelectedCardsHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Pair<Boolean, Boolean> result) {\n-            if (result == null) {\n-                return;\n-            }\n-            browser.hideProgressBar();\n-\n-            if (browser.mActionBarMenu != null) {\n-                boolean hasUnsuspended = result.first;\n-                boolean hasUnmarked = result.second;\n-\n-                setMenuIcons(browser, hasUnsuspended, hasUnmarked, browser.mActionBarMenu);\n-            }\n-        }\n-\n-\n-        protected void setMenuIcons(@NonNull Context browser, boolean hasUnsuspended, boolean hasUnmarked, @NonNull Menu actionBarMenu) {\n-            int title;\n-            int icon;\n-            if (hasUnsuspended) {\n-                title = R.string.card_browser_suspend_card;\n-                icon = R.drawable.ic_pause_circle_outline;\n-            } else {\n-                title = R.string.card_browser_unsuspend_card;\n-                icon = R.drawable.ic_pause_circle_filled;\n-            }\n-            MenuItem suspend_item = actionBarMenu.findItem(R.id.action_suspend_card);\n-            suspend_item.setTitle(browser.getString(title));\n-            suspend_item.setIcon(icon);\n-\n-            if (hasUnmarked) {\n-                title = R.string.card_browser_mark_card;\n-                icon = R.drawable.ic_star_border_white;\n-            } else {\n-                title = R.string.card_browser_unmark_card;\n-                icon = R.drawable.ic_star_white;\n-            }\n-            MenuItem mark_item = actionBarMenu.findItem(R.id.action_mark_card);\n-            mark_item.setTitle(browser.getString(title));\n-            mark_item.setIcon(icon);\n-        }\n-\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            super.actualOnCancelled(browser);\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-    @SuppressWarnings(\"SameParameterValue\")\n-    private void closeCardBrowser(int result) {\n-        closeCardBrowser(result, null);\n-    }\n-\n-    private void closeCardBrowser(int result, Intent data) {\n-        // Set result and finish\n-        setResult(result, data);\n-        finishWithAnimation(END);\n-    }\n-\n-    /**\n-     * Render the second column whenever the user stops scrolling\n-     */\n-    @VisibleForTesting\n-    public final class RenderOnScroll implements AbsListView.OnScrollListener {\n-        @Override\n-        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n-            // Show the progress bar if scrolling to given position requires rendering of the question / answer\n-            int lastVisibleItem = firstVisibleItem + visibleItemCount - 1;\n-            CardCollection<CardCache> cards = getCards();\n-            // List is never cleared, only reset to a new list. So it's safe here.\n-            int size = cards.size();\n-            if (size > 0 && visibleItemCount <= 0) {\n-                // According to Mike, there used to be 5 to 10 report by hour on the beta version. All with\n-                // > com.ichi2.anki.exception.ManuallyReportedException: Useless onScroll call, with size 0 firstVisibleItem 0,\n-                // > lastVisibleItem 0 and visibleItemCount 0.\n-\n-                // This change ensure that we log more specifically case where #8821 could have occured. That is, there are cards but we\n-                // are asked to display nothing.\n-\n-                // Note that this is not a bug. The fact that `visibleItemCount` is equal to 0 is actually authorized by the method we\n-                // override and mentionned in the javadoc. It perfectly makes sens to get this order, since it can be used to know that we\n-                // can delete some elements from the cache for example, since nothing is displayed.\n-\n-                // It would be interesting to know how often it occurs, but it is not a bug.\n-                AnkiDroidApp.sendExceptionReport(\"CardBrowser Scroll Issue 8821\", \"In a search result of \" + size + \" cards, with totalItemCount = \" + totalItemCount + \", somehow we got \" + visibleItemCount + \" elements to display.\");\n-            }\n-            // In all of those cases, there is nothing to do:\n-            if (size <= 0 ||\n-                    firstVisibleItem >= size ||\n-                    lastVisibleItem >= size ||\n-                    visibleItemCount <= 0\n-            ) {\n-                return;\n-            }\n-            boolean firstLoaded = cards.get(firstVisibleItem).isLoaded();\n-            // Note: max value of lastVisibleItem is totalItemCount, so need to subtract 1\n-            boolean lastLoaded = cards.get(lastVisibleItem).isLoaded();\n-            if (!firstLoaded || !lastLoaded) {\n-                if (!mPostAutoScroll) {\n-                    showProgressBar();\n-                }\n-                // Also start rendering the items on the screen every 300ms while scrolling\n-                long currentTime = SystemClock.elapsedRealtime();\n-                if ((currentTime - mLastRenderStart > 300 || lastVisibleItem + 1 >= totalItemCount)) {\n-                    mLastRenderStart = currentTime;\n-                    TaskManager.cancelAllTasks(CollectionTask.RenderBrowserQA.class);\n-                    TaskManager.launchCollectionTask(renderBrowserQAParams(firstVisibleItem, visibleItemCount, cards), mRenderQAHandler);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void onScrollStateChanged(AbsListView listView, int scrollState) {\n-            // TODO: Try change to RecyclerView as currently gets stuck a lot when using scrollbar on right of ListView\n-            // Start rendering the question & answer every time the user stops scrolling\n-            if (mPostAutoScroll) {\n-                mPostAutoScroll = false;\n-            }\n-            if (scrollState == SCROLL_STATE_IDLE) {\n-                int startIdx = listView.getFirstVisiblePosition();\n-                int numVisible = listView.getLastVisiblePosition() - startIdx;\n-                TaskManager.launchCollectionTask(renderBrowserQAParams(startIdx - 5, 2 * numVisible + 5, getCards()), mRenderQAHandler);\n-            }\n-        }\n-    }\n-\n-\n-    @NonNull\n-    protected CollectionTask.RenderBrowserQA renderBrowserQAParams(int firstVisibleItem, int visibleItemCount, CardCollection<CardCache> cards) {\n-        return new CollectionTask.RenderBrowserQA(cards, firstVisibleItem, visibleItemCount, mColumn1Index, mColumn2Index);\n-    }\n-\n-\n-    private final class MultiColumnListAdapter extends BaseAdapter {\n-        private final int mResource;\n-        private Column[] mFromKeys;\n-        private final int[] mToIds;\n-        private float mOriginalTextSize = -1.0f;\n-        private final int mFontSizeScalePcent;\n-        private Typeface mCustomTypeface = null;\n-        private final LayoutInflater mInflater;\n-\n-        public MultiColumnListAdapter(Context context, int resource, Column[] from, int[] to,\n-                                      int fontSizeScalePcent, String customFont) {\n-            mResource = resource;\n-            mFromKeys = from;\n-            mToIds = to;\n-            mFontSizeScalePcent = fontSizeScalePcent;\n-            if (!\"\".equals(customFont)) {\n-                mCustomTypeface = AnkiFont.getTypeface(context, customFont);\n-            }\n-            mInflater = LayoutInflater.from(context);\n-        }\n-\n-\n-        public View getView(int position, View convertView, ViewGroup parent) {\n-            // Get the main container view if it doesn't already exist, and call bindView\n-            View v;\n-            if (convertView == null) {\n-                v = mInflater.inflate(mResource, parent, false);\n-                final int count = mToIds.length;\n-                final View[] columns = new View[count];\n-                for (int i = 0; i < count; i++) {\n-                    columns[i] = v.findViewById(mToIds[i]);\n-                }\n-                v.setTag(columns);\n-            } else {\n-                v = convertView;\n-            }\n-            bindView(position, v);\n-            return v;\n-        }\n-\n-\n-        private void bindView(final int position, final View v) {\n-            // Draw the content in the columns\n-            View[] columns = (View[]) v.getTag();\n-            final CardCache card = getCards().get(position);\n-            for (int i = 0; i < mToIds.length; i++) {\n-                TextView col = (TextView) columns[i];\n-                // set font for column\n-                setFont(col);\n-                // set text for column\n-                col.setText(card.getColumnHeaderText(mFromKeys[i]));\n-            }\n-            // set card's background color\n-            final int backgroundColor = Themes.getColorFromAttr(CardBrowser.this, card.getColor());\n-            v.setBackgroundColor(backgroundColor);\n-            // setup checkbox to change color in multi-select mode\n-            final CheckBox checkBox = v.findViewById(R.id.card_checkbox);\n-            // if in multi-select mode, be sure to show the checkboxes\n-            if(mInMultiSelectMode) {\n-                checkBox.setVisibility(View.VISIBLE);\n-                checkBox.setChecked(mCheckedCards.contains(card));\n-                // this prevents checkboxes from showing an animation from selected -> unselected when\n-                // checkbox was selected, then selection mode was ended and now restarted\n-                checkBox.jumpDrawablesToCurrentState();\n-            } else {\n-                checkBox.setChecked(false);\n-                checkBox.setVisibility(View.GONE);\n-            }\n-            // change bg color on check changed\n-            checkBox.setOnClickListener(view -> onCheck(position, v));\n-        }\n-\n-        private void setFont(TextView v) {\n-            // Set the font and font size for a TextView v\n-            float currentSize = v.getTextSize();\n-            if (mOriginalTextSize < 0) {\n-                mOriginalTextSize = v.getTextSize();\n-            }\n-            // do nothing when pref is 100% and apply scaling only once\n-            if (mFontSizeScalePcent != 100 && Math.abs(mOriginalTextSize - currentSize) < 0.1) {\n-                // getTextSize returns value in absolute PX so use that in the setter\n-                v.setTextSize(TypedValue.COMPLEX_UNIT_PX, mOriginalTextSize * (mFontSizeScalePcent / 100.0f));\n-            }\n-\n-            if (mCustomTypeface != null) {\n-                v.setTypeface(mCustomTypeface);\n-            }\n-        }\n-\n-        public void setFromMapping(Column[] from) {\n-            mFromKeys = from;\n-            notifyDataSetChanged();\n-        }\n-\n-\n-        public Column[] getFromMapping() {\n-            return mFromKeys;\n-        }\n-\n-\n-        @Override\n-        public int getCount() {\n-            return getCardCount();\n-        }\n-\n-\n-        @Override\n-        public CardCache getItem(int position) {\n-            return getCards().get(position);\n-        }\n-\n-\n-        @Override\n-        public long getItemId(int position) {\n-            return position;\n-        }\n-\n-    }\n-\n-\n-    private void onCheck(int position, View cell) {\n-        CheckBox checkBox = cell.findViewById(R.id.card_checkbox);\n-        CardCache card = getCards().get(position);\n-\n-        if (checkBox.isChecked()) {\n-            mCheckedCards.add(card);\n-        } else {\n-            mCheckedCards.remove(card);\n-        }\n-\n-       onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting\n-    void onSelectAll() {\n-        mCheckedCards.addAll(mCards.unsafeGetWrapped());\n-        onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting\n-    void onSelectNone() {\n-        mCheckedCards.clear();\n-        onSelectionChanged();\n-    }\n-\n-    private void onSelectionChanged() {\n-        Timber.d(\"onSelectionChanged()\");\n-        try {\n-            if (!mInMultiSelectMode && !mCheckedCards.isEmpty()) {\n-                //If we have selected cards, load multiselect\n-                loadMultiSelectMode();\n-            } else if (mInMultiSelectMode && mCheckedCards.isEmpty()) {\n-                //If we don't have cards, unload multiselect\n-                endMultiSelectMode();\n-            }\n-\n-            //If we're not in mutliselect, we can select cards if there are cards to select\n-            if (!mInMultiSelectMode && this.mActionBarMenu != null) {\n-                MenuItem selectAll = mActionBarMenu.findItem(R.id.action_select_all);\n-                selectAll.setVisible(mCards != null && cardCount() != 0);\n-            }\n-\n-            if (!mInMultiSelectMode) {\n-                return;\n-            }\n-\n-            updateMultiselectMenu();\n-            mActionBarTitle.setText(String.format(getLocaleCompat(getResources()), \"%d\", checkedCardCount()));\n-        } finally {\n-            if (colIsOpen() && mCardsAdapter != null) {\n-                mCardsAdapter.notifyDataSetChanged();\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Reloads the data of the cards, taking on their current values from the database.\n-     */\n-    protected void reloadCards(Card[] cards) {\n-        if (cards == null || cards.length == 0) {\n-            return;\n-        }\n-\n-        Set<Long> cardIds = new HashSet<>();\n-        for (Card c : cards) {\n-            cardIds.add(c.getId());\n-        }\n-\n-        for (CardCache props : mCards) {\n-            if (cardIds.contains(props.getId())) {\n-                props.reload();\n-            }\n-        }\n-        mCardsAdapter.notifyDataSetChanged();\n-    }\n-\n-    @VisibleForTesting\n-    CardCollection<CardCache> getCards() {\n-        mCards.ensureValidValue();\n-        return mCards;\n-    }\n-\n-    private long[] getAllCardIds() {\n-        long[] l = new long[mCards.size()];\n-        for (int i = 0; i < mCards.size(); i++) {\n-            l[i] = mCards.get(i).getId();\n-        }\n-        return l;\n-    }\n-\n-    // This could be better: use a wrapper class PositionAware<T> to store the position so it's\n-    // no longer a responsibility of CardCache and we can guarantee it's consistent just by using this collection\n-    /** A position-aware collection to ensure consistency between the position of items and the collection */\n-    public static class CardCollection<T extends PositionAware> implements Iterable<T> {\n-        private List<T> mWrapped = new ArrayList<>(0);\n-\n-        public int size() {\n-            return mWrapped.size();\n-        }\n-\n-        public T get(int index) {\n-            return mWrapped.get(index);\n-        }\n-\n-\n-        public void reset() {\n-            mWrapped = new ArrayList<>(0);\n-        }\n-\n-\n-        public void replaceWith(List<T> value) {\n-            mWrapped = value;\n-        }\n-\n-        public void reverse() {\n-            Collections.reverse(mWrapped);\n-            int position = 0;\n-            for (int i = 0; i < mWrapped.size(); i++) {\n-                mWrapped.get(i).setPosition(position++);\n-            }\n-        }\n-\n-\n-        @NonNull\n-        @Override\n-        public Iterator<T> iterator() {\n-            return mWrapped.iterator();\n-        }\n-\n-        public java.util.Collection<T> unsafeGetWrapped() {\n-            return mWrapped;\n-        }\n-\n-\n-        public void ensureValidValue() {\n-            if (mWrapped == null) {\n-                reset();\n-            }\n-        }\n-\n-\n-        public void clear() {\n-            mWrapped.clear();\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    interface PositionAware {\n-        int getPosition();\n-        void setPosition(int value);\n-    }\n-\n-    public static class CardCache extends Card.Cache implements PositionAware {\n-        private boolean mLoaded = false;\n-        private Pair<String, String> mQa = null;\n-        private int mPosition;\n-\n-        public CardCache(long id, Collection col, int position) {\n-            super(col, id);\n-            mPosition = position;\n-        }\n-\n-        protected CardCache(CardCache cache, int position) {\n-            super(cache);\n-            mLoaded = cache.mLoaded;\n-            mQa = cache.mQa;\n-            mPosition = position;\n-        }\n-\n-        public int getPosition() {\n-            return mPosition;\n-        }\n-\n-\n-        @Override\n-        public void setPosition(int value) {\n-            mPosition = value;\n-        }\n-\n-\n-        /** clear all values except ID.*/\n-        public void reload() {\n-            super.reload();\n-            mLoaded = false;\n-            mQa = null;\n-        }\n-\n-        /**\n-         * Get the background color of items in the card list based on the Card\n-         * @return index into TypedArray specifying the background color\n-         */\n-        private int getColor() {\n-            int flag = getCard().userFlag();\n-            switch (flag) {\n-                case 1:\n-                    return R.attr.flagRed;\n-                case 2:\n-                    return R.attr.flagOrange;\n-                case 3:\n-                    return R.attr.flagGreen;\n-                case 4:\n-                    return R.attr.flagBlue;\n-                case 5:\n-                    return R.attr.flagPink;\n-                case 6:\n-                    return R.attr.flagTurquoise;\n-                case 7:\n-                    return R.attr.flagPurple;\n-                default:\n-                    if (getCard().note().hasTag(\"marked\")) {\n-                        return R.attr.markedColor;\n-                    } else {\n-                        if (getCard().getQueue() == Consts.QUEUE_TYPE_SUSPENDED) {\n-                            return R.attr.suspendedColor;\n-                        } else {\n-                            return android.R.attr.colorBackground;\n-                        }\n-                    }\n-            }\n-        }\n-\n-        public String getColumnHeaderText(Column key) {\n-            switch (key) {\n-            case FLAGS:\n-                return (Integer.valueOf(getCard().userFlag())).toString();\n-            case SUSPENDED:\n-                return getCard().getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\";\n-            case MARKED:\n-                return getCard().note().hasTag(\"marked\") ? \"marked\" : null;\n-            case SFLD:\n-                return getCard().note().getSFld();\n-            case DECK:\n-                return getCol().getDecks().name(getCard().getDid());\n-            case TAGS:\n-                return getCard().note().stringTags();\n-            case CARD:\n-                return getCard().template().optString(\"name\");\n-            case DUE:\n-                return getCard().getDueString();\n-            case EASE:\n-                if (getCard().getType() == Consts.CARD_TYPE_NEW) {\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_new_card);\n-                } else {\n-                    return (getCard().getFactor()/10)+\"%\";\n-                }\n-            case CHANGED:\n-                return LanguageUtil.getShortDateFormatFromS(getCard().getMod());\n-            case CREATED:\n-                return LanguageUtil.getShortDateFormatFromMs(getCard().note().getId());\n-            case EDITED:\n-                return LanguageUtil.getShortDateFormatFromS(getCard().note().getMod());\n-            case INTERVAL:\n-                switch (getCard().getType()) {\n-                case Consts.CARD_TYPE_NEW:\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_new_card);\n-                case Consts.CARD_TYPE_LRN :\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_learning_card);\n-                default:\n-                    return Utils.roundedTimeSpanUnformatted(AnkiDroidApp.getInstance(), getCard().getIvl()*SECONDS_PER_DAY);\n-                }\n-            case LAPSES:\n-                return Integer.toString(getCard().getLapses());\n-            case NOTE_TYPE:\n-                return getCard().model().optString(\"name\");\n-            case REVIEWS:\n-                return Integer.toString(getCard().getReps());\n-            case QUESTION:\n-                updateSearchItemQA();\n-                return mQa.first;\n-            case ANSWER:\n-                updateSearchItemQA();\n-                return mQa.second;\n-            default:\n-                return null;\n-            }\n-        }\n-\n-        /** pre compute the note and question/answer.  It can safely\n-            be called twice without doing extra work. */\n-        public void load(boolean reload, int column1Index, int column2Index) {\n-            if (reload) {\n-                reload();\n-            }\n-            getCard().note();\n-            if (\n-                COLUMN1_KEYS[column1Index] == QUESTION ||\n-                COLUMN2_KEYS[column2Index] == QUESTION ||\n-                COLUMN2_KEYS[column2Index] == ANSWER\n-                // First column can not be the answer. If it were to\n-                // change, this code should also be changed.\n-                ) {\n-                updateSearchItemQA();\n-            }\n-            mLoaded = true;\n-        }\n-\n-        public boolean isLoaded() {\n-            return mLoaded;\n-        }\n-\n-        /**\n-           Reload question and answer. Use browser format. If it's empty\n-           uses non-browser format. If answer starts by question, remove\n-           question.\n-        */\n-        public void updateSearchItemQA() {\n-            if (mQa != null) {\n-                return;\n-            }\n-            // render question and answer\n-            Map<String, String> qa = getCard()._getQA(true, true);\n-            // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-            if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-                HashMap<String, String> qaFull = getCard()._getQA(true, false);\n-                if (\"\".equals(qa.get(\"q\"))) {\n-                    qa.put(\"q\", qaFull.get(\"q\"));\n-                }\n-                if (\"\".equals(qa.get(\"a\"))) {\n-                    qa.put(\"a\", qaFull.get(\"a\"));\n-                }\n-            }\n-            // update the original hash map to include rendered question & answer\n-            String q = qa.get(\"q\");\n-            String a = qa.get(\"a\");\n-            // remove the question from the start of the answer if it exists\n-            if (a.startsWith(q)) {\n-                a = a.substring(q.length());\n-            }\n-            a = formatQA(a, AnkiDroidApp.getInstance());\n-            q = formatQA(q, AnkiDroidApp.getInstance());\n-            mQa = new Pair<>(q, a);\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n-            }\n-            if (obj == null) {\n-                return false;\n-            }\n-            if (getClass() != obj.getClass()) {\n-                return false;\n-            }\n-            return getId() == ((CardCache) obj).getId();\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Long.valueOf(getId()).hashCode();\n-        }\n-    }\n-\n-    /**\n-     * Show/dismiss dialog when sd card is ejected/remounted (collection is saved by SdCardReceiver)\n-     */\n-    private void registerExternalStorageListener() {\n-        if (mUnmountReceiver == null) {\n-            mUnmountReceiver = new BroadcastReceiver() {\n-                @Override\n-                public void onReceive(Context context, Intent intent) {\n-                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {\n-                        finishWithoutAnimation();\n-                    }\n-                }\n-            };\n-            IntentFilter iFilter = new IntentFilter();\n-            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);\n-            registerReceiver(mUnmountReceiver, iFilter);\n-        }\n-    }\n-\n-    /**\n-     * The views expand / contract when switching between multi-select mode so we manually\n-     * adjust so that the vertical position of the given view is maintained\n-     */\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    private void recenterListView(@NonNull View view) {\n-        final int position = mCardsListView.getPositionForView(view);\n-        // Get the current vertical position of the top of the selected view\n-        final int top = view.getTop();\n-        final Handler handler = new Handler();\n-        // Post to event queue with some delay to give time for the UI to update the layout\n-        handler.postDelayed(() -> {\n-            // Scroll to the same vertical position before the layout was changed\n-            mCardsListView.setSelectionFromTop(position, top);\n-        }, 10);\n-    }\n-\n-    /**\n-     * Turn on Multi-Select Mode so that the user can select multiple cards at once.\n-     */\n-    private void loadMultiSelectMode() {\n-        if (mInMultiSelectMode) {\n-            return;\n-        }\n-        Timber.d(\"loadMultiSelectMode()\");\n-        // set in multi-select mode\n-        mInMultiSelectMode = true;\n-        // show title and hide spinner\n-        mActionBarTitle.setVisibility(View.VISIBLE);\n-        mActionBarTitle.setText(String.valueOf(checkedCardCount()));\n-        mDeckSpinnerSelection.setSpinnerVisibility(View.GONE);\n-        // reload the actionbar using the multi-select mode actionbar\n-        supportInvalidateOptionsMenu();\n-    }\n-\n-    /**\n-     * Turn off Multi-Select Mode and return to normal state\n-     */\n-    private void endMultiSelectMode() {\n-        Timber.d(\"endMultiSelectMode()\");\n-        mCheckedCards.clear();\n-        mInMultiSelectMode = false;\n-        // If view which was originally selected when entering multi-select is visible then maintain its position\n-        View view = mCardsListView.getChildAt(mLastSelectedPosition - mCardsListView.getFirstVisiblePosition());\n-        if (view != null) {\n-            recenterListView(view);\n-        }\n-        // update adapter to remove check boxes\n-        mCardsAdapter.notifyDataSetChanged();\n-        // update action bar\n-        supportInvalidateOptionsMenu();\n-        mDeckSpinnerSelection.setSpinnerVisibility(View.VISIBLE);\n-        mActionBarTitle.setVisibility(View.GONE);\n-    }\n-\n-    @VisibleForTesting\n-    public int checkedCardCount() {\n-        return mCheckedCards.size();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean isInMultiSelectMode() {\n-        return mInMultiSelectMode;\n-    }\n-\n-    @VisibleForTesting()\n-    long cardCount() {\n-        return mCards.size();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-     boolean isShowingSelectAll() {\n-        return mActionBarMenu != null && mActionBarMenu.findItem(R.id.action_select_all).isVisible();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean isShowingSelectNone() {\n-        return mActionBarMenu != null &&\n-                mActionBarMenu.findItem(R.id.action_select_none) != null && //\n-                mActionBarMenu.findItem(R.id.action_select_none).isVisible();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void clearCardData(int position) {\n-        mCards.get(position).reload();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void rerenderAllCards() {\n-        TaskManager.launchCollectionTask(renderBrowserQAParams(0, mCards.size()-1, getCards()), mRenderQAHandler);\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    long[] getCardIds() {\n-        CardCache[] cardsCopy = mCards.unsafeGetWrapped().toArray(new CardCache[0]);\n-        long[] ret = new long[cardsCopy.length];\n-        for (int i = 0; i < cardsCopy.length; i++) {\n-            ret[i] = cardsCopy[i].getId();\n-        }\n-        return ret;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void checkCardsAtPositions(int... positions) {\n-        for (int position : positions) {\n-            if (position >= mCards.size()) {\n-                throw new IllegalStateException(\n-                        String.format(Locale.US, \"Attempted to check card at index %d. %d cards available\",\n-                                position, mCards.size()));\n-            }\n-            mCheckedCards.add(getCards().get(position));\n-        }\n-        onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean hasCheckedCardAtPosition(int i) {\n-        return mCheckedCards.contains(getCards().get(i));\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public int getChangeDeckPositionFromId(long deckId) {\n-        List<Deck> decks = getValidDecksForChangeDeck();\n-        for (int i = 0; i < decks.size(); i++) {\n-            Deck deck = decks.get(i);\n-            if (deck.getLong(\"id\") == deckId) {\n-                return i;\n-            }\n-        }\n-        throw new IllegalStateException(String.format(Locale.US, \"Deck %d not found\", deckId));\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public List<Long> getCheckedCardIds() {\n-        List<Long> cardIds = new ArrayList<>(mCheckedCards.size());\n-        for (CardCache card : mCheckedCards) {\n-            long id = card.getId();\n-            cardIds.add(id);\n-        }\n-        return cardIds;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE) //should only be called from changeDeck()\n-    void executeChangeCollectionTask(List<Long> ids, long newDid) {\n-        mNewDid = newDid; //line required for unit tests, not necessary, but a noop in regular call.\n-        TaskManager.launchCollectionTask(\n-                new CollectionTask.ChangeDeckMulti(ids, newDid),\n-                new ChangeDeckHandler(this));\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public CardCache getPropertiesForCardId(long cardId) {\n-        for (CardCache props : mCards) {\n-            long id = props.getId();\n-            if (id == cardId) {\n-                return props;\n-            }\n-        }\n-        throw new IllegalStateException(String.format(Locale.US, \"Card '%d' not found\", cardId));\n-    }\n-\n-\n-    @VisibleForTesting\n-    void filterByTag(String... tags) {\n-        onSelectedTags(Arrays.asList(tags), 0);\n-    }\n-\n-    @VisibleForTesting\n-    @SuppressWarnings(\"SameParameterValue\")\n-    void filterByFlag(int flag) {\n-        mCurrentFlag = flag;\n-        filterByFlag();\n-    }\n-\n-    @VisibleForTesting\n-    void replaceSelectionWith(int[] positions) {\n-        mCheckedCards.clear();\n-        checkCardsAtPositions(positions);\n-    }\n-\n-    @VisibleForTesting\n-    @SuppressWarnings(\"SameParameterValue\")\n-    void searchCards(String searchQuery) {\n-        mSearchTerms = searchQuery;\n-        searchCards();\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "message": "Merge commit", "committedDate": null}, {"oid": "775aa05336a8b02a44434facc0eca6db09d21ae1", "committedDate": "2020-06-08 08:23:17 -0500", "message": "hasSelectedSingleNoteId: Handle concurrency issue"}, {"oid": "6e0f09f950205347663b058830806de64c6e87c7", "committedDate": "2020-06-08 08:23:17 -0500", "message": "hasSelectedSingleNoteId: concurrency fix"}, {"oid": "24056efa63638e8e8ac252f5d9399f2231b996f1", "committedDate": "2020-06-11 11:25:18 -0500", "message": "Remove buggy implementation: hasSelectedSingleNoteId"}, {"oid": "238d935bbcb41e198a9f512d81abc06f40901b30", "committedDate": "2020-06-11 11:25:18 -0500", "message": "Browser: Allow user to change note type if editing"}, {"oid": "5bb384a3aff953bed4d7ce1243bd74e5febfa45e", "committedDate": "2020-06-11 11:25:18 -0500", "message": "NF: Rename NOTE to NOTE_TYPE"}, {"oid": "b1135ff3cbd8d536a0175e7b9b156fdb88585e1b", "committedDate": "2020-06-12 23:28:18 -0500", "message": "Remove unused parameter in saveCollectionInBackground"}, {"oid": "de280d8fa079636e232fe1b8ffe703aabc0ab054", "committedDate": "2020-06-20 20:14:33 -0500", "message": "Keep displaying search terms after editing card"}, {"oid": "8236599b1db98f774a45c4f84de308e16affd0c3", "committedDate": "2020-06-20 20:14:33 -0500", "message": "CardBrowser: Hide Progress Bar if tasks cancelled"}, {"oid": "cf720e0c56ff05a63590a5f86697444c01f02515", "committedDate": "2020-06-29 15:25:38 -0500", "message": "Reload CardBrowser but not reviewer when note edited"}, {"oid": "b91a511d46b57a88b2a000ca2f6a2375dfbe3bdd", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Task type becomes an enum"}, {"oid": "017cb41d04e55b284f5e11410c50f63d2b368d38", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Remove TASK_TYPE from enum name"}, {"oid": "6a7f8d895eaaa08df21998a02c09a7c754ddeb97", "committedDate": "2020-07-05 08:46:49 -0500", "message": "cancelTask(type) cancel all tasks of given type"}, {"oid": "c18a421db5329cf3f2b86e62a819e5a116265f60", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: cancelTask to cancelCurrentlyExecutingTask"}, {"oid": "0dba81bdef77c234dd4d9a90e1ee89e6c0dc827f", "committedDate": "2020-07-20 19:51:47 -0500", "message": "getUserFlag->userFlag"}, {"oid": "c126ac42a5eac08fba6d54d531c0821df0193c68", "committedDate": "2020-07-21 15:50:01 -0500", "message": "NF: Deck type"}, {"oid": "03aa2f4cd0aea7032cc93d27d8676be51154db3c", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: import static com.ichi2.async.CollectionTask.TaskData;"}, {"oid": "1df6f2510ed5c6d410b98c8955a0c230e1ffb309", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: TaskData in a separate file"}, {"oid": "6d8d7d4abdc604c7edc5ed97da47b57cb9b076a1", "committedDate": "2020-07-25 15:14:56 -0500", "message": "NF: listener's onProgressUpdate take a single element"}, {"oid": "2f0af8ff7c5cc18d850aa1fc8c1bdd2c39a6bb1c", "committedDate": "2020-08-08 09:05:50 -0500", "message": "NF: Listener as separate file"}, {"oid": "d4267b868d9b4e584d186f667de2f48636b333be", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: create type cardCache"}, {"oid": "e00b4f587d88ef102e20dadc03689f22976b75b2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: replace ID by \"id\"."}, {"oid": "b6e9594f93f40946d6f0b934fbac71aa0a85acf4", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: reload in CardCache"}, {"oid": "3d5b1f8c596931244f79f8a4e0916c345e39903d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: reload CardCache in updateCardsInList"}, {"oid": "f6b4230e354e2965089317b68124bf15bfa54b84", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: id in CardCache"}, {"oid": "0ed0b26615da7a6bca6313471ceda4e1162656b0", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardClass has card accessor"}, {"oid": "cf059ad47c4889a7d01586d4800c7bf080136fed", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: move getFlagOrDefault in CardClass"}, {"oid": "ad60a300fb9dff4d0b957dec653c8b0576652005", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: getColor, get variable when needed"}, {"oid": "0a9fead54f040d70b39bb83596c51ca2f02f54f9", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify flag"}, {"oid": "59df407e8574d70e86a010c5e5edad0976cede1d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify getFlagOrDefault to use card"}, {"oid": "397cc318f49494a4bfb6c14b13bbe5da4f64c187", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove getFlagOrDefault"}, {"oid": "ca5cde170d69b80e198b1534808c1db0a9eff192", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: getColor in CardClass"}, {"oid": "cd8ae0d2b27e452af7e4c4d8cde4bbcabbfb63e9", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses card feature in color"}, {"oid": "0b65cb3645f6f1ec21c054616b6f12b4c565b278", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: cardProperties renamed to card"}, {"oid": "f9b4463d1fccb380b92b7c6c0b10597fd3bace09", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: introduce variable text_for_column in bindView"}, {"oid": "cee32b600bae5bdaf33c5fb2c84db8414ce4dff2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses content instead than setText"}, {"oid": "4a0d565455507e4b0a9123f13a6d23c539788df7", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache deal with loading"}, {"oid": "40af31415bc356b207b0eb07921d62fc3c57eda3", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: FLAGS in content"}, {"oid": "5f63aeea4bb6e6f1958f78c0fea980a942f33ad6", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: SUSPENDED in content"}, {"oid": "2d9bb9a08928843e01b7adb39df61f67b0eefeb5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: MARKED in Content"}, {"oid": "d5f109e6cada59c76b7167b50aae2002e556dfe6", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused sMarkedPattern"}, {"oid": "0a4218fe7c17fee8a4cf38a0cdb3fc45cf8d770f", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: SFLD in content"}, {"oid": "7d454e131c800ea1bfb826b3acffc74f1a9a324d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: DECK in content"}, {"oid": "2ede85b0dda0d29139e6266b787e580cd5530a94", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: TAGS in content"}, {"oid": "3beace334a38147d9160673983aaa7c06e7d6253", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CARD in content"}, {"oid": "d8e0e3bf68ec037a563a0efb62c5d94fffec0693", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: DUE in content"}, {"oid": "3e56bcaaaff8361dca7a2788057808cace6f518a", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: EASE in content"}, {"oid": "e66a43034b0aae17d9d1bbbad84f98f52b348953", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CHANGED in content"}, {"oid": "548170633037c3968947f28ff008b35f622112d5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CREATED in content"}, {"oid": "b3551b17d8d763824e886fefbc080c4565193399", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: EDITED in content"}, {"oid": "fe98ebdcbc1e1ff0b9999dc3d574ff64c43e28dc", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: INTERVAL in Content"}, {"oid": "17d9b916e4cfc4e6c3cc552f04dc72038450e8e1", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: LAPSES in content"}, {"oid": "b696126cdfb39e7e967088855a64f98995742d29", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: NOTE_TYPE in content"}, {"oid": "cffe326a64e97452f9d0ad296e00b56636dd3807", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: REVIEWS in content"}, {"oid": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused paramater, varilable and comment"}, {"oid": "25668235083fa2e4c0716fb177f0ed756d5f18f1", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: context is got directly in updateSearchItemQA"}, {"oid": "216580a8bfebb2e94d3ee973e9c16dea5b45f6a2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: updateSearchItemQA don't take card, but get it from CardCache"}, {"oid": "474450d513e379802bca25b64e9d2dccfa7dc105", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: Question/Answer in Content"}, {"oid": "0d83a8a8070a1f750aded8e2f35e4f90689da7ce", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: To get card browser value, uses only .content"}, {"oid": "cebb0704f32af078181a041bd3f5d2378e5705ad", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify slightly code"}, {"oid": "f4981c1a84187ffaf956e9bc0d3e995e083019ed", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache does not inherits HashMap"}, {"oid": "ab32f45cbef06a9f3f964512c0536eabfb54c290", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: use enum for column"}, {"oid": "23d64c43221e83f1ca9b1dd0987e47a570a1f33c", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: don't compute question/answer if it's not used"}, {"oid": "5f21fa7f1b58effc22372ae7bbbbd22f398a2d3d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache have hash and equals"}, {"oid": "23caa8ecb5b24de130671b569ab6fc649480e4b5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: cardCache constructor takes position"}, {"oid": "607f9dc344b11f2a770f5b119878da67c8d2e4e0", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: throw exception before adding to set"}, {"oid": "2ea7d9a79284cbf6464e6be6a5286a2965859475", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: mCheckedCardPositions becomes a list of CardCache"}, {"oid": "89a9718449d95b6f59d17c0109e2f711f5c46b5b", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses checkedCardCount when possible"}, {"oid": "58b46cca4aebc46f1f2467e331ae2526130adc13", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: use empty instead of size"}, {"oid": "8f3628f0fda73538b3a8e8739411d34b07239716", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove an always false condition"}, {"oid": "f51427dc57c0249f225dafd7c5d776c5a9172767", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: updateCardsInList more clear"}, {"oid": "ac2d979c2e394e61bcba9a6efe36d755ea7472ca", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: indicates that getPositionMap is static"}, {"oid": "3be7f0e1c8e7bc5bc9102d3bfe93f4e9219110a2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: ensure updateCardsInList iterate on a single list of card"}, {"oid": "84448a30d968bdca49b143b560cc2ee928296e17", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: RepositionCardHandler with context"}, {"oid": "9130f8046b512b111966c0a029b47f24a53d7106", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: ResetCardHandler with context"}, {"oid": "0da8d61fd274449fd11bdc5a6a8d3f7e531b389b", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: RescheduleCardHandler with context"}, {"oid": "964cc28b2a74cabe9473c0f96b4b84874dd9240e", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: factorize mCheckSelectedCardsHandler"}, {"oid": "6d828ea8e9001ed918a561daa6c60aa864927ad0", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: Factorize selected card handler"}, {"oid": "7383c6809f93d6fd931a8f3bec4b43c9c488b19f", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: ListenerWithProgressBar with context"}, {"oid": "eabd3b8eff2df7a51e9a44fd8919092781080f31", "committedDate": "2020-08-19 14:19:18 -0500", "message": "onTrimMemory call super"}, {"oid": "31439eed2dcd6b4442c9a381d8650035b5bf27ff", "committedDate": "2020-08-21 11:29:10 -0500", "message": "NF: replace 86400 by SECONDS_PER_DAY"}, {"oid": "e2cf422fb9c2f6b42afb09fe812daa38534068aa", "committedDate": "2020-08-22 22:33:15 +0200", "message": "NF: copy a list to ensure it does not change."}, {"oid": "1fe7e7d8bfe176e941fad8480da164ada7932319", "committedDate": "2020-08-28 16:00:39 -0500", "message": "NF: correct creation of card cache"}, {"oid": "d22c2b2ff1e3e7e38c4a6e83f3da9bb4a9362249", "committedDate": "2020-08-29 22:34:54 -0500", "message": "Second column of browser repaired"}, {"oid": "1562a65403d5ded875451f01b46fe77bead42764", "committedDate": "2020-08-30 09:45:59 -0500", "message": "NF: invalidate browser"}, {"oid": "566d0864718738a781190304cda800fa7ce5e0c9", "committedDate": "2020-08-30 09:45:59 -0500", "message": "Delete a card invalidate the brwosre"}, {"oid": "c11da9873ff0934f6f3f28d1c9a23f76af951581", "committedDate": "2020-09-06 18:36:55 -0500", "message": "Added \"Edit Note\" to Previewer"}, {"oid": "392eff78a581986b8afc1d751eebc931d1767036", "committedDate": "2020-09-06 18:40:40 -0500", "message": "Cards are displayed in card browser after return from background"}, {"oid": "32a4e06304dcafc47d7048586c482bbbd209a84d", "committedDate": "2020-09-06 18:40:40 -0500", "message": "NF: alow to cancel Task_type_Check_Card_selection"}, {"oid": "ff5156f8f524b62be48b222eb206b68d0cc4bd26", "committedDate": "2020-09-12 14:38:16 -0500", "message": "Allow searches on tags containing brackets"}, {"oid": "890ef6c5835e1acde92edc6af8a36a64dcc90601", "committedDate": "2020-09-19 03:48:07 +0200", "message": "Fix NullPointerException on invalidate()"}, {"oid": "715357c31701ffe4d1f87d8278be7c622fd25f60", "committedDate": "2020-09-20 23:27:15 -0500", "message": "NF: remove useless semicolons"}, {"oid": "a833d04dedf1185d5e4934dc6d037802014f686d", "committedDate": "2020-09-21 07:18:25 -0500", "message": "NF: remove unboxing warning"}, {"oid": "48c102f1d45d48c930606e08267fe4a5d42a06b5", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+A: \"Select All\""}, {"oid": "287dc8c963e3779db7585ee65c98ab2223c85d24", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+E: \"Add Note\""}, {"oid": "79f580c7f6786a5d3b49a5c2ab34ab12cccff2b5", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+D: \"Change Deck\""}, {"oid": "943d30d9caa109a5545c934e269769225b727ff1", "committedDate": "2020-09-21 08:58:08 -0500", "message": "NF: Refactor showChangeDeckDialog"}, {"oid": "54982f3c6abcab9d4eaf61e6c0569db21f3203ca", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+K: \"Toggle Mark\""}, {"oid": "1d77e154b49d300831a6c1888e01f799a9d30a95", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+Alt+R: \"Reschedule\""}, {"oid": "9bfbb028cc6e2e069859d2833ab20aeec5d4e571", "committedDate": "2020-09-21 08:58:08 -0500", "message": "DOCS: CardBrowsert onKeyDown: Add warning"}, {"oid": "41daedf82d490a1dc74d1afa2130cf79de26fe67", "committedDate": "2020-09-21 10:23:05 -0500", "message": "NF: remove warning DefaultAnnotationParam"}, {"oid": "a4d1643b4723b8d4bd43ff375e0e061baa2a2a5a", "committedDate": "2020-09-21 12:21:31 -0500", "message": "NF: Remove warning about useless int instead of advanced loop"}, {"oid": "c0595464b0b205d704b293f64543e5f54e4b2612", "committedDate": "2020-09-22 09:09:16 -0500", "message": "NF: remove warning Convert2Lambda"}, {"oid": "cef2394efe6d7347643cd796cd5ed8105c692b9a", "committedDate": "2020-09-22 09:12:07 -0500", "message": "NF: uses Equals() for string"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "6359569144205e2d8338fcdc6571ead7fc19bcea", "committedDate": "2020-09-23 16:55:49 -0500", "message": "NF: remove wraning of values that are clearly not null"}, {"oid": "975a902915821a23623b20e8daeff9fc681b92cd", "committedDate": "2020-09-24 09:30:56 -0500", "message": "NF: Remove warning about useless type in generic class constructors"}, {"oid": "42b92180120040299e590634f5b03d6f352c0a4f", "committedDate": "2020-09-24 11:41:08 -0500", "message": "NF: remove useless casts"}, {"oid": "a079a61fc0e7dc06437c851026b29266868aef9b", "committedDate": "2020-09-28 08:29:08 -0500", "message": "NF: suppress warning of redundant escape when it does not seems redundant"}, {"oid": "1d4ec27fc2e0e64f5ba599369d2a633d49686f68", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: Extract class CardCollection"}, {"oid": "c5e92a4c315932cbbdb392f146fe7de28a029d99", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: CardBrowser - Extract methods"}, {"oid": "68ee9e1ebd348a728754632b5c8741c2a45d1f41", "committedDate": "2020-09-28 11:24:51 -0500", "message": "Regression Test: Browser - Preview after sorting"}, {"oid": "7bfa728086d70278433ae76a1655ee573de8b835", "committedDate": "2020-09-28 11:24:51 -0500", "message": "[BugFix] Preview reverse cards correctly"}, {"oid": "fe6a93e79014acd6ae7ae04ca34447f4cb3bc0a3", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: CardBrowser - Improve comments"}, {"oid": "0b23ca26293d5834775f39ede7dbd55c627fc3f6", "committedDate": "2020-09-30 10:51:24 -0500", "message": "NF: use enum for direction"}, {"oid": "8fd630afcaf2a114d32e76ecb6982d995c1a73d2", "committedDate": "2020-10-04 13:53:44 -0500", "message": "Display cards deleted when deleting notes"}, {"oid": "517b5a15ea15761fc0a816cb35daa53ec3910438", "committedDate": "2020-10-04 16:25:33 -0500", "message": "Lint: Use valueOf instead of new"}, {"oid": "ada67bc3d304193eab15d42badaafe9863d340cf", "committedDate": "2020-10-14 06:06:10 -0500", "message": "Adjust resoure reference usage to handle future non-final state"}, {"oid": "99ab89ed6fb3bb0c568db544a76ae9928ce79db7", "committedDate": "2020-10-14 13:58:41 -0500", "message": "Add Filter by flag icon to card browser"}, {"oid": "456daa33af9c099a52d05ecba69b47ed9a4d1944", "committedDate": "2020-10-14 16:20:04 -0500", "message": "Remember scroll position in CardBrowser"}, {"oid": "7bfc313ea25f3ba79f99662795387abed64dfd78", "committedDate": "2020-10-18 11:46:46 -0500", "message": "NF: replace string cancel by dialog_cancel"}, {"oid": "a0120f327d806aea5b08f231bc21f6f0f0cdb782", "committedDate": "2020-10-19 18:16:06 -0500", "message": "NF: Refactor changeDeck naming and variables"}, {"oid": "dd57f7cec478de2fff2c9b437dc9946317bd509c", "committedDate": "2020-10-19 18:16:06 -0500", "message": "NF: Add tests for \"add note\" target deck"}, {"oid": "97c5739ae4bd8b73a56c7bbf29759c278209b775", "committedDate": "2020-10-19 18:16:06 -0500", "message": "Use Browser's Selected Deck when adding note"}, {"oid": "8e2ea03689701afc5a6a629f298ed4b8ee668a61", "committedDate": "2020-10-21 06:32:30 -0500", "message": "NF: remove duplicate \"Tags: %1$s\""}, {"oid": "68ca357ebfc5adbdf40c72e18cd574a1e8d5e94f", "committedDate": "2020-10-23 13:33:05 -0500", "message": "Add \"Card Info\" screen"}, {"oid": "7c882bbb8a848c0bb2a6bb897a3767151e91f76d", "committedDate": "2020-10-25 22:26:29 +0000", "message": "NF: remove duplicate \"(new)\""}, {"oid": "34167abea29fd4d8419a7478022be4e31e5fa01e", "committedDate": "2020-10-26 01:51:44 +0000", "message": "NF: remove duplicate search"}, {"oid": "23f9d804f22cb87af322c279db7804b943f8d503", "committedDate": "2020-10-28 22:37:47 -0500", "message": "NF: save current search to avoid doing it twice"}, {"oid": "81237e0f7122659cd50767949d6e921183d26ddd", "committedDate": "2020-11-03 20:09:18 +0000", "message": "NF: uses for-loop if possible"}, {"oid": "5524e7a6442efad0b8f5440e4c8c0b8cd7c718cd", "committedDate": "2020-11-05 05:30:10 +0000", "message": "NF. remove an unused paramater"}, {"oid": "9c8182dde2ed45a0c0de69214097ac10c85bd14a", "committedDate": "2020-11-09 13:08:37 -0500", "message": "Handle App.onCreate not executing after restore"}, {"oid": "eb84e4ed4bda37fa8f59c8e3b655beb2c79b1b2e", "committedDate": "2020-11-13 09:17:40 -0500", "message": "NF: Remove Specific Error String"}, {"oid": "3dd23578b50498b9fbd1c3b9ad07c5f352944d96", "committedDate": "2020-11-14 08:32:02 -0500", "message": "Revert: \"NF: save current search to avoid doing it twice\""}, {"oid": "383aa2493ef332cdebf42bf6bebe415ddefa6307", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Rename checkedCardsAtPositions"}, {"oid": "78beef4bc78a9bbea9cf51e30f24a9a42e577c19", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: extract repositionCardsNoValidation"}, {"oid": "97757073161bf5982bde6ee23874bf9798609224", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract rescheduleWithoutValidation"}, {"oid": "e5cdc91a9b424c98d84bd738bb291f5cfe6538b5", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract onResetProgress"}, {"oid": "c153719c40ae2f706d866d935827d835fd82235f", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract resetProgressNoConfirm"}, {"oid": "057be86c6b6cd0e99df65b40f78e3558328bd865", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: checkCardsAtPositions - accept varargs"}, {"oid": "0389d60b51827c189cff119eececd94cec89256e", "committedDate": "2020-11-15 07:36:02 -0500", "message": "Refresh Card Browser data on reposition"}, {"oid": "43b06bc7856e19263153ff95f64a0ae8ecec7efe", "committedDate": "2020-11-15 07:36:02 -0500", "message": "Show undo menu on reset, reposition and resched"}, {"oid": "ebba0a01b1f2a8b0e6996539f1d0daac0470c201", "committedDate": "2020-11-15 07:36:02 -0500", "message": "BugFix: Undo - Ensure data in grid is updated"}, {"oid": "dbaf6549ec268333b20d160a0c40962d3135ba0d", "committedDate": "2020-11-20 07:54:40 -0500", "message": "Show partial result in browser before showing all"}, {"oid": "4f2e7f6226246f7626c15234f5d947a6a02c7a74", "committedDate": "2020-11-22 17:41:07 -0500", "message": "NF: Extract setMenuIcons"}, {"oid": "831b8f1be882ff5d43b30ed77f637dadbc3cafc6", "committedDate": "2020-11-22 17:41:07 -0500", "message": "Fix crash if mActionBarMenu is null"}, {"oid": "3e17cca53b9feec8032bc07d6be9f2690dabb1de", "committedDate": "2020-12-02 08:40:06 -0500", "message": "Browser shortcuts: Fix switch fall-through"}, {"oid": "94b3919547fab325239d52d1a9f07d15ddeeb738", "committedDate": "2020-12-02 08:40:06 -0500", "message": "NF: Extract deleteSelectedNote"}, {"oid": "bdef0a8f063d0343c6d747759b0acbd2bb8a4d55", "committedDate": "2020-12-02 08:40:06 -0500", "message": "Card Browser: Add \"Delete\" Shortcut"}, {"oid": "2d1e8714db8cc6e066341d27ad638a5818b0c65a", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: Remove a unused map"}, {"oid": "b0a841366a02673f7ec35e5d197ad7633d247f16", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: remove duplicate if"}, {"oid": "4d37cf273c758b9d873f4a54ba6454f1e143a94a", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: Remove useless parameter"}, {"oid": "fb56df4c0be4d3b333a75beccb9c3568328ba190", "committedDate": "2020-12-08 09:27:51 -0500", "message": "NF: Extract method: getPreviewIntent"}, {"oid": "cce056d89cb1cc4176faf3a4b4be5f9bd8c31283", "committedDate": "2020-12-08 09:27:51 -0500", "message": "BugFix - Previewer: Display same card after edit"}, {"oid": "5128cc2c756ce1434367eb58807650581f26c661", "committedDate": "2020-12-09 11:27:39 -0500", "message": "NF: init capacity of list, map and set"}, {"oid": "ec80d4eb9fb57fd538bccdc8c7e52b8545c4af3e", "committedDate": "2020-12-09 11:44:05 -0500", "message": "NF: Dismiss_multi first argument is List<Long>"}, {"oid": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "committedDate": "2020-12-09 12:17:48 -0500", "message": "NF: Move static part of CollectionTask to other class"}, {"oid": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: Add Type Task, type CollectionTask and TaskListener"}, {"oid": "930bd70272c2acda40e3da35e1ed454b91176a1b", "committedDate": "2020-12-12 14:14:20 +0100", "message": "NF: correct typing of tasks"}, {"oid": "67d636de3f071d2ca87fb4a80447ffd8a03a7d35", "committedDate": "2020-12-13 08:25:34 -0500", "message": "NF: remove redundant if warning"}, {"oid": "ba6051f93e29a4ed3ebb58fe591ddcaef532d2db", "committedDate": "2021-01-23 14:59:29 -0500", "message": "Fix some deprecations"}, {"oid": "0c858ce63b151e82a81866d7e7e652c850d6b621", "committedDate": "2021-03-20 13:05:08 +0100", "message": "Select many option in Card browser"}, {"oid": "6bb12e744843ba3a4d7f1a30e39f735dd8389a5c", "committedDate": "2021-03-20 13:05:08 +0100", "message": "Removed the lastselectedposition from itemclicklistener"}, {"oid": "33f9b63573ede5b40f1c31f74aaa0c6bb30c65e1", "committedDate": "2021-03-24 13:00:21 -0500", "message": "Save/restore card browser multi-select state during Activity lifecycle (#8306)"}, {"oid": "3de33abda7a436ef8c71bcf03c78fda497d78ce2", "committedDate": "2021-03-25 15:43:52 +0000", "message": "NF: use enum for TagsDialog type instead of ints"}, {"oid": "007ad994758eb9525a533512a486f617d6450f82", "committedDate": "2021-03-26 09:42:38 -0500", "message": "NF: refactor TagsDialog to listener interface (#8341)"}, {"oid": "db9260c03143d3770ede4b39db9e15727a69b4cf", "committedDate": "2021-03-27 09:32:18 -0500", "message": "Use browser search text as first field when adding new note  (#8345)"}, {"oid": "34c9f25038d24e3bf9f338fa307b1bcb3610b5ba", "committedDate": "2021-04-03 08:29:29 -0500", "message": "Prevent OR CardBrowser query from bypassing RestrictOnDeck (#8414)"}, {"oid": "5fa8827e0503f775d81704868cbd20d64fe554b0", "committedDate": "2021-04-07 22:39:02 -0500", "message": "Reverse Activity transition for RTL language (#8470)"}, {"oid": "5542ad6ea5f212c04ae8dd93e19626832c25b11d", "committedDate": "2021-04-08 10:08:22 -0500", "message": "chore: Fix usage of Throwable.printStackTrace"}, {"oid": "1d0ad0613b6961d290f0a83832a16dd7fdd62ca3", "committedDate": "2021-04-10 19:45:03 +0100", "message": "NF: MultiColumnListAdapter's getCard return `CardCache`"}, {"oid": "246fba3811d60dd3f302e50210393da3c8a39016", "committedDate": "2021-04-14 07:49:34 -0500", "message": "Display Order of cards in Card Browser corrected"}, {"oid": "9c2e7788262006017c7939fa514072e915efeded", "committedDate": "2021-04-14 07:49:34 -0500", "message": "Unit Test to check display order is persistant on restart"}, {"oid": "00abc059f60fd18ddc9e77d2425436a3cad044ed", "committedDate": "2021-04-14 13:00:45 -0500", "message": "NF: Convert Deck methods to return List"}, {"oid": "d63f8ebaa7ba1693f220d0115cbbb30481f5cbbb", "committedDate": "2021-04-16 10:43:24 -0500", "message": "refactor: Open Previewer from CardBrowser using new Activity APIs"}, {"oid": "b58dd95ff8649dea7e71f103ec2a8dec01bdb0d0", "committedDate": "2021-04-24 06:07:18 +0200", "message": "Fix: Prevent crash on long pressing at end of card browser (#8665)"}, {"oid": "d9dcbb987004d86b4af464d957d6fe1b1dca7267", "committedDate": "2021-04-24 22:31:29 -0500", "message": "refactor: Use androidx Activity APIs in CardBrowser"}, {"oid": "a5dbe4bd129b7760aa8fdcab4fd5e322c59e648b", "committedDate": "2021-04-24 22:31:29 -0500", "message": "fix: Restore no animation settings to start Previewer from CardBrowser"}, {"oid": "0c544371db268cb520e1f89dbc7aa2f499153452", "committedDate": "2021-04-25 12:25:39 -0500", "message": "Convert google material design icons"}, {"oid": "1aa3041789b3a8d29cb48b3204d74ea72ec16b60", "committedDate": "2021-04-29 19:46:40 -0500", "message": "NF: Move TagsDialog to its own package"}, {"oid": "a10214b2ec7061bc46863467ed32a73b81b1f355", "committedDate": "2021-04-30 14:53:54 -0500", "message": "Ensure that CheckCardSelection gets only checked cards"}, {"oid": "72d6b996514a3a547b8ef823fa441ba7297d9f4d", "committedDate": "2021-05-01 09:12:17 -0500", "message": "NF: refactor TagsDialog to use factory"}, {"oid": "8954b35fd0535b65355f398a9938260c11ec21a0", "committedDate": "2021-05-01 09:12:17 -0500", "message": "NF: move TagsDialogListener to a new file"}, {"oid": "aa1c65121804bc9440dd2a0ccd7f9d34af9f4abe", "committedDate": "2021-05-04 12:50:02 -0500", "message": "Card Browser, NoteEditor And Statistics : Improve \"Search Deck\" UX  (#8644)"}, {"oid": "5a9f8fac1f968379c46757c944fbb397412baf4a", "committedDate": "2021-05-04 15:56:52 -0500", "message": "Speed up card browser"}, {"oid": "123d1451ed953a55e7724bf114fe885b42b13b9c", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: reverse condition. Quick return instead of imbrication"}, {"oid": "300b396c2cffd8e08e794729d0afe56422d2a020", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: reverse condition. Quick return instead of imbrication"}, {"oid": "7dd2b7895807c12b1f730894e13fd9512ffdcf38", "committedDate": "2021-05-14 17:38:33 -0500", "message": "Consider scrolling with 0 cards."}, {"oid": "a1ef99fa872362e58b9f9c8deb8fbf1d3c50bc4a", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: send exception report if on scroll was cancelled"}, {"oid": "6b31d01de6752f9d36648a9f56093c58970e841b", "committedDate": "2021-05-16 13:29:52 -0500", "message": "NF: More specific exception for useless scroll call (#8844)"}, {"oid": "3c9783d0b65e6272d861750214776d0ab7a55617", "committedDate": "2021-05-22 17:13:17 -0500", "message": "lint: de-lint CardBrowser"}, {"oid": "80a2ef5172039f0c0d64ab251a409cd294b2fb3e", "committedDate": "2021-05-22 17:13:17 -0500", "message": "fix(CardBrowser): protect mCardsAdapter uses w/colOpen + null check"}, {"oid": "6d96bbebd62346f049666e2d4c12af3fdf58def3", "committedDate": "2021-05-23 10:24:30 -0500", "message": "Uses correct locale"}, {"oid": "30ad7fc0321bc95189980f979875087c43af8a46", "committedDate": "2021-06-01 22:54:41 -0500", "message": "NF: duplicate call to mSearchView.setQuery"}, {"oid": "a5363a2082c16261910bab0847941c4aa5ee07c2", "committedDate": "2021-06-01 22:54:41 -0500", "message": "fix: don't clear text when opening nav bar"}, {"oid": "1bdd80e9b17c2c3954bda1b3b0235870a5ad53c3", "committedDate": "2021-06-01 23:02:34 -0500", "message": "Fix for empty search results and wrong card count (#8998)"}, {"oid": "7d02438912756a3bfdbf34ddaf5cc6540e9d5f09", "committedDate": "2021-06-02 13:20:50 -0500", "message": "Test for card browser changing color when card flag changes (#8800)"}, {"oid": "532c25266e299ba7d55313d23ffe60a0d8b16e49", "committedDate": "2021-06-04 10:56:14 -0500", "message": "NF: CardBrowser create numCardsToRender"}, {"oid": "034ec28daa1ba4ac922cc77d1ff274c3d739edde", "committedDate": "2021-06-19 23:54:44 -0500", "message": "NF: remove usage of CardGetter/PairWithCard"}, {"oid": "becea6decc0023dedf3fd20c7c82f2592bb17cdb", "committedDate": "2021-06-19 23:54:44 -0500", "message": "NF: delete unused classes CardGetter/PairWithCard"}, {"oid": "34ed57bde71765358351e61803d373a90c7d30cb", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: remove BooleanGetter"}, {"oid": "f692b10de3bbc75e37075b4cc42b04cbada3bef6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename `other` to `value`"}, {"oid": "d3bbcfc9ec280c7e45a64ab5ab54550b697b04b6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename getBoolean to Success"}, {"oid": "22e0854ccc348a1ac395e1b9a73245a34621545f", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename PairWithBoolean to Computation"}, {"oid": "8f423418a4b5aa3c754d94fdcf04017ea602894c", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: use getVlaue instead of mValue"}, {"oid": "c84cf4b151cfe460fd820d4cdf90c5daec4f43e1", "committedDate": "2021-07-16 09:37:14 -0500", "message": "Fix CardBrowser shows wrong deck"}, {"oid": "341e453ae469ca14405ba54fdd79fc77b1eeef76", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on handlers"}, {"oid": "79981a009745916ce9fffeed9cee9bb74f4ee3e3", "committedDate": "2021-07-31 09:15:04 -0500", "message": "fix lint: WrongConstant"}, {"oid": "37b924539e93597a65e7750bc260428b4837dced", "committedDate": "2021-08-04 20:45:34 -0500", "message": "feat: pink, turquoise & purple flags"}, {"oid": "12f24b93a16d1ad2313a79d14b47d290ce7d486c", "committedDate": "2021-08-05 15:27:23 -0500", "message": "js api to search card"}, {"oid": "d08acb24174f60f3f380b909beb1c0ae83d12411", "committedDate": "2021-08-11 23:06:21 +0200", "message": "Implement onboarding for CardBrowser"}, {"oid": "263c09b2e25ad37faec52da110084102c6a9e0b5", "committedDate": "2021-08-22 16:45:21 -0500", "message": "nf: DeckSpinnerSelection: extract collection deps"}, {"oid": "2529e8ccd4c4cfa33e116b27f515363152626793", "committedDate": "2021-08-22 16:45:21 -0500", "message": "nf: DeckSpinnerSelection: extract spinner"}, {"oid": "485934feb600efaa936bf6e40c1e729802691b53", "committedDate": "2021-08-22 16:45:21 -0500", "message": "fix: Display Note Editor title"}, {"oid": "60301a3db2a78990a49e0f71309a8798039d72c3", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: add set_config & remove_config"}, {"oid": "060357b99f0cc510f319d3aa6f242c9783e3bffa", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf using strongly typed get_config"}, {"oid": "d44f6196ef3f10e3f5ccfc952ec846a36e2449fd", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf objects using get_config"}, {"oid": "1ff3ff7570944e5f80d0a2f6caea13a3dcb44fd7", "committedDate": "2021-08-22 17:53:20 -0500", "message": "nf: fix nullability bug"}, {"oid": "e546c9ac7bfc2d33afee48da4e3e77666a438149", "committedDate": "2021-08-27 08:19:38 -0500", "message": "nf: Use isEmpty in place of checking size to be zero when possible"}, {"oid": "27dbaeed881d3a1ef7b775311dabdf0780d3fc7f", "committedDate": "2021-09-04 09:47:41 -0500", "message": "NF: uses hash set/map which take size as init istead of capacity (#8339)"}, {"oid": "562cfac72209132f9f22ff707276d0a46c3ecfbc", "committedDate": "2021-10-18 12:10:56 -0500", "message": "Computation: add \"out\" constraint"}, {"oid": "c88bc2e14bf2691c597b8702f701801c99632e2a", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert ScheduleCollectionTask async style"}, {"oid": "cb57ff16f3d8131cfd797b2e2f4a2771419adb9b", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert RescheduleRepositionReset async style"}, {"oid": "bd8f85f29633812b249152b8e4dac986d89ae49f", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert Undo async style"}, {"oid": "a316393d837034884fd4ceacef44572111f93ea5", "committedDate": "2021-10-18 12:10:56 -0500", "message": "sched: Extract Next Card functionality to pair"}, {"oid": "a757225878819325cb40dc832428dba7fe6128f4", "committedDate": "2021-10-18 12:33:34 -0500", "message": "fix(card-browser): Don't always show default deck"}, {"oid": "81d1d134863b8ab2c0560f9f11148b6a91996c0d", "committedDate": "2021-10-22 08:59:35 -0500", "message": "fix(handler): deprecation"}, {"oid": "1c0fa70b13d270cd2f230c0fb87d9e9347e75320", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract NoteService.isMarked"}, {"oid": "28736a6345e42d67a54991df3260f352d5459229", "committedDate": "2021-10-31 11:16:39 -0500", "message": "nf(eco-compat): rename _getQA to render_output"}, {"oid": "9bfceb3ac837201461d9a4d349a756d747bdbdb2", "committedDate": "2021-10-31 11:16:39 -0500", "message": "feat(eco-compat): render_output returns class"}, {"oid": "b0cb2174c467f769393d063944344fd5b927679a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: Introduce SortOrder class"}, {"oid": "442d57cead6c340f42437241c068da2270d92cb9", "committedDate": "2021-10-31 13:32:07 -0500", "message": "fix(search): V16 compat with bracketed tag search"}, {"oid": "019c32c32827080d1de8259c0212b9057d46c3bc", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: extract SearchCardsResult"}, {"oid": "1b3c687bfc7a4da0df1a1a90ebbc680f65650b6a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "feat(v16): implement findCards in backend"}, {"oid": "2b0b7c47ac79615a79e777987f13c94c187ee71f", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: move mShowAllDecks to final, add it in constructor"}, {"oid": "0b74559ff47c09f863d3ad9bc025581782e1c442", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: alwaysShowDefault is final. Move it to constructor"}, {"oid": "447d1ea5e049330a445f731ea64cd483c9e4f705", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: simplify CardBrowser's selectAllDecks"}, {"oid": "e599145b41d85b148286e920edd7a77cfd5c64f0", "committedDate": "2021-11-10 07:29:11 -0500", "message": "refactor: remove FunctionalInterfaces.Consumer"}, {"oid": "d4c34c2e1735a0cb4354b6a1cdc0703e61904416", "committedDate": "2021-11-13 07:33:34 -0500", "message": "NF: change signature of `TagsDialogListener#onSelectedTags`"}, {"oid": "90fef130faea1471c87e864b8f8104813efd3e37", "committedDate": "2021-11-13 07:33:34 -0500", "message": "NF: refactor listener to do multiple actions"}, {"oid": "b9108e61d81ba0fc3f32857fb14c525814347563", "committedDate": "2021-11-13 07:33:34 -0500", "message": "feat: add \"Edit Tags\" in CardBrowser"}, {"oid": "18595046d4a869d3f88f3f8773c770e17c577e29", "committedDate": "2022-03-03 11:45:06 -0500", "message": "NF: replace tab by spaces"}, {"oid": "f21d95c75b1e366a9424adeb263729601b4c022e", "committedDate": "2022-04-05 17:17:32 -0500", "message": "Use DeckSelectionDialog on changeDeckDialog"}, {"oid": "5da9561a290122b52047c5c24648f078dc02dca7", "committedDate": "2022-04-07 10:27:03 -0500", "message": "refactor: typos & related KotlinCleanup"}, {"oid": "0fd0f558c49c728f0eca73a7f5059125cb0a638c", "committedDate": "2022-04-13 17:16:47 -0500", "message": "refactor: Rename CardBrowser.java to .kt"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NDM4Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435544382", "body": "I don't get `new Integer().toString()` - is this validation as it'll throw otherwise?", "bodyText": "I don't get new Integer().toString() - is this validation as it'll throw otherwise?", "bodyHTML": "<p dir=\"auto\">I don't get <code>new Integer().toString()</code> - is this validation as it'll throw otherwise?</p>", "author": "david-allison-1", "createdAt": "2020-06-04T20:57:08Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1531,6 +1534,13 @@ public static void updateSearchItemQA(Context context, Map<String, String> item,\n         item.put(NOTE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n+        String tags = note.stringTags();\n+        item.put(TAGS, tags);\n+        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n+        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());", "originalCommit": "3b638b1e5356ea1642c12d14b517aec3b13c5c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2MzQ0MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435563441", "bodyText": "I honestly have no clue. I just copy-pasted the line\ncard.put(CardBrowser.FLAGS, (new Integer(Card.intToFlag(cur.getInt(5)))).toString());\n\nwhich already have the same strange line", "author": "Arthur-Milchior", "createdAt": "2020-06-04T21:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NDM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MjEyMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435572122", "bodyText": "Oh, it's because it's creating an Integer out of an int, and then transforming it into a string. It's not transforming a int from a string and then back to string", "author": "Arthur-Milchior", "createdAt": "2020-06-04T21:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NDM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzMDMwMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435630300", "bodyText": "card.put(FLAGS, Integer.toString(c.getUserFlag())) ?", "author": "david-allison-1", "createdAt": "2020-06-05T00:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NDM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk2NDYwNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435964606", "bodyText": "It is now deleted anyway", "author": "Arthur-Milchior", "createdAt": "2020-06-05T14:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NDM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3NDAxNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435974015", "bodyText": "Rebased to follow your advice", "author": "Arthur-Milchior", "createdAt": "2020-06-05T14:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NDM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "783609ad81e5b933cd8b93bdc4a5d8ed0596029e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 55a90b1d1..a0a1ba715 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1534,13 +1531,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(NOTE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n-        String tags = note.stringTags();\n-        item.put(TAGS, tags);\n-        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n-        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n-        item.put(DECK, col.getDecks().name(c.getDid()));\n-        item.put(SFLD, note.getSFld());\n+        item.put(MARKED, (item.get(TAGS).matches(\".*[Mm]arked.*\"))?\"marked\": null);\n     }\n \n     @CheckResult\n", "next_change": {"commit": "4570aeb1e44bd78877deee85d0b82019f355d1fb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex a0a1ba715..5dd41cca0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1531,7 +1532,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(NOTE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n-        item.put(MARKED, (item.get(TAGS).matches(\".*[Mm]arked.*\"))?\"marked\": null);\n+        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n     }\n \n     @CheckResult\n", "next_change": {"commit": "f884e785d57513c684fa992df32dcd234078a385", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 5dd41cca0..c120b2c3c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1533,6 +1533,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n+        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n     }\n \n     @CheckResult\n", "next_change": {"commit": "ba3088dca4876c86e1feb0f0335ce8b218bbafac", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex c120b2c3c..82938885d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1532,6 +1533,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(NOTE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n+        String tags = note.stringTags();\n+        item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n         item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n     }\n", "next_change": {"commit": "654b5f00e2da527c2dea394210524cdce275a9ce", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 82938885d..3fcc2e2ec 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1537,6 +1537,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n         item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n+        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n     }\n \n     @CheckResult\n", "next_change": {"commit": "d02c4af7f391992ac9ec3c7ed2d5e8113ad28f13", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 3fcc2e2ec..e21e7c3ae 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1538,6 +1538,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n         item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n+        item.put(DECK, col.getDecks().name(c.getDid()));\n     }\n \n     @CheckResult\n", "next_change": {"commit": "db867c9006c24de3f8ad5ea0e6f68e35fe13e66c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex e21e7c3ae..e64b9d4bd 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1539,6 +1539,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n+        item.put(SFLD, note.getSFld());\n     }\n \n     @CheckResult\n", "next_change": {"commit": "7fccc05cde4e26216a73054bd61bd5278c507f6d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex e64b9d4bd..057645b49 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1482,66 +1469,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n-        // render question and answer\n-        Map<String, String> qa = c._getQA(true, true);\n-        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-            HashMap<String, String> qaFull = c._getQA(true, false);\n-            if (\"\".equals(qa.get(\"q\"))) {\n-                qa.put(\"q\", qaFull.get(\"q\"));\n-            }\n-            if (\"\".equals(qa.get(\"a\"))) {\n-                qa.put(\"a\", qaFull.get(\"a\"));\n-            }\n-        }\n-        // update the original hash map to include rendered question & answer\n-        String q = qa.get(\"q\");\n-        String a = qa.get(\"a\");\n-        // remove the question from the start of the answer if it exists\n-        if (a.startsWith(q)) {\n-            a = a.replaceFirst(Pattern.quote(q), \"\");\n-        }\n-        // put all of the fields in except for those that have already been pulled out straight from the\n-        // database\n-        item.put(ANSWER, formatQA(a, context));\n-        item.put(CARD, c.template().optString(\"name\"));\n-        item.put(DUE, c.getDueString());\n-        if (c.getType() == Consts.CARD_TYPE_NEW) {\n-            item.put(EASE, context.getString(R.string.card_browser_ease_new_card));\n-        } else {\n-            item.put(EASE, (c.getFactor()/10)+\"%\");\n-        }\n-\n-        Note note = c.note();\n-        item.put(CHANGED, LanguageUtil.getShortDateFormatFromS(c.getMod()));\n-        item.put(CREATED, LanguageUtil.getShortDateFormatFromMs(note.getId()));\n-        item.put(EDITED, LanguageUtil.getShortDateFormatFromS(note.getMod()));\n-        // interval\n-        switch (c.getType()) {\n-            case Consts.CARD_TYPE_NEW:\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_new_card));\n-                break;\n-            case Consts.CARD_TYPE_LRN :\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_learning_card));\n-                break;\n-            default:\n-                item.put(INTERVAL, Utils.roundedTimeSpanUnformatted(context, c.getIvl()*86400));\n-                break;\n-        }\n-        item.put(LAPSES, Integer.toString(c.getLapses()));\n-        item.put(NOTE, c.model().optString(\"name\"));\n-        item.put(QUESTION, formatQA(q, context));\n-        item.put(REVIEWS, Integer.toString(c.getReps()));\n-        String tags = note.stringTags();\n-        item.put(TAGS, tags);\n-        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n-        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n-        item.put(DECK, col.getDecks().name(c.getDid()));\n-        item.put(SFLD, note.getSFld());\n-    }\n-\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": {"commit": "2114aeedad26a5384d6d6a46289f72e405f8c9e9", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 057645b49..826edafd6 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1469,6 +1482,66 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n+    public static void updateSearchItemQA(Context context, Map<String, String> item, Card c, Collection col) {\n+        // render question and answer\n+        Map<String, String> qa = c._getQA(true, true);\n+        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n+        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n+            HashMap<String, String> qaFull = c._getQA(true, false);\n+            if (\"\".equals(qa.get(\"q\"))) {\n+                qa.put(\"q\", qaFull.get(\"q\"));\n+            }\n+            if (\"\".equals(qa.get(\"a\"))) {\n+                qa.put(\"a\", qaFull.get(\"a\"));\n+            }\n+        }\n+        // update the original hash map to include rendered question & answer\n+        String q = qa.get(\"q\");\n+        String a = qa.get(\"a\");\n+        // remove the question from the start of the answer if it exists\n+        if (a.startsWith(q)) {\n+            a = a.replaceFirst(Pattern.quote(q), \"\");\n+        }\n+        // put all of the fields in except for those that have already been pulled out straight from the\n+        // database\n+        item.put(ANSWER, formatQA(a, context));\n+        item.put(CARD, c.template().optString(\"name\"));\n+        item.put(DUE, c.getDueString());\n+        if (c.getType() == Consts.CARD_TYPE_NEW) {\n+            item.put(EASE, context.getString(R.string.card_browser_ease_new_card));\n+        } else {\n+            item.put(EASE, (c.getFactor()/10)+\"%\");\n+        }\n+\n+        Note note = c.note();\n+        item.put(CHANGED, LanguageUtil.getShortDateFormatFromS(c.getMod()));\n+        item.put(CREATED, LanguageUtil.getShortDateFormatFromMs(note.getId()));\n+        item.put(EDITED, LanguageUtil.getShortDateFormatFromS(note.getMod()));\n+        // interval\n+        switch (c.getType()) {\n+            case Consts.CARD_TYPE_NEW:\n+                item.put(INTERVAL, context.getString(R.string.card_browser_interval_new_card));\n+                break;\n+            case Consts.CARD_TYPE_LRN :\n+                item.put(INTERVAL, context.getString(R.string.card_browser_interval_learning_card));\n+                break;\n+            default:\n+                item.put(INTERVAL, Utils.roundedTimeSpanUnformatted(context, c.getIvl()*86400));\n+                break;\n+        }\n+        item.put(LAPSES, Integer.toString(c.getLapses()));\n+        item.put(NOTE, c.model().optString(\"name\"));\n+        item.put(QUESTION, formatQA(q, context));\n+        item.put(REVIEWS, Integer.toString(c.getReps()));\n+        String tags = note.stringTags();\n+        item.put(TAGS, tags);\n+        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n+        item.put(FLAGS, (Integer.toString(c.getUserFlag())));\n+        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n+        item.put(DECK, col.getDecks().name(c.getDid()));\n+        item.put(SFLD, note.getSFld());\n+    }\n+\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 55a90b1d1..9f719f63b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1537,7 +1528,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (new Integer(c.getUserFlag())).toString());\n+        item.put(FLAGS, (Integer.toString(c.getUserFlag())));\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n", "next_change": {"commit": "0dba81bdef77c234dd4d9a90e1ee89e6c0dc827f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 9f719f63b..7eab66e5e 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1522,13 +1520,13 @@ public class CardBrowser extends NavigationDrawerActivity implements\n                 break;\n         }\n         item.put(LAPSES, Integer.toString(c.getLapses()));\n-        item.put(NOTE, c.model().optString(\"name\"));\n+        item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (Integer.toString(c.getUserFlag())));\n+        item.put(FLAGS, (Integer.toString(c.userFlag())));\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n", "next_change": {"commit": "40af31415bc356b207b0eb07921d62fc3c57eda3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 7eab66e5e..c19f4e6da 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1526,7 +1528,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(FLAGS, (Integer.toString(c.userFlag())));\n         item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n", "next_change": {"commit": "5f63aeea4bb6e6f1958f78c0fea980a942f33ad6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex c19f4e6da..34ec806f9 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1528,7 +1527,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n-        item.put(SUSPENDED, c.getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\");\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n     }\n", "next_change": {"commit": "2d9bb9a08928843e01b7adb39df61f67b0eefeb5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 34ec806f9..1089c2d46 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1526,7 +1525,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n-        item.put(MARKED, (sMarkedPattern.matcher(item.get(TAGS)).matches())?\"marked\": null);\n         item.put(DECK, col.getDecks().name(c.getDid()));\n         item.put(SFLD, note.getSFld());\n     }\n", "next_change": {"commit": "0a4218fe7c17fee8a4cf38a0cdb3fc45cf8d770f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 1089c2d46..b0d3c313c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1526,7 +1521,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n         item.put(DECK, col.getDecks().name(c.getDid()));\n-        item.put(SFLD, note.getSFld());\n     }\n \n     @CheckResult\n", "next_change": {"commit": "7d454e131c800ea1bfb826b3acffc74f1a9a324d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex b0d3c313c..7050438a8 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1520,7 +1515,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n         String tags = note.stringTags();\n         item.put(TAGS, tags);\n-        item.put(DECK, col.getDecks().name(c.getDid()));\n     }\n \n     @CheckResult\n", "next_change": {"commit": "2ede85b0dda0d29139e6266b787e580cd5530a94", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 7050438a8..33f27a4f9 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1513,8 +1509,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n-        String tags = note.stringTags();\n-        item.put(TAGS, tags);\n     }\n \n     @CheckResult\n", "next_change": {"commit": "fe98ebdcbc1e1ff0b9999dc3d574ff64c43e28dc", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 33f27a4f9..d853cba2b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,30 +1480,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         // put all of the fields in except for those that have already been pulled out straight from the\n         // database\n         item.put(ANSWER, formatQA(a, context));\n-        item.put(CARD, c.template().optString(\"name\"));\n-        item.put(DUE, c.getDueString());\n-        if (c.getType() == Consts.CARD_TYPE_NEW) {\n-            item.put(EASE, context.getString(R.string.card_browser_ease_new_card));\n-        } else {\n-            item.put(EASE, (c.getFactor()/10)+\"%\");\n-        }\n \n-        Note note = c.note();\n-        item.put(CHANGED, LanguageUtil.getShortDateFormatFromS(c.getMod()));\n-        item.put(CREATED, LanguageUtil.getShortDateFormatFromMs(note.getId()));\n-        item.put(EDITED, LanguageUtil.getShortDateFormatFromS(note.getMod()));\n-        // interval\n-        switch (c.getType()) {\n-            case Consts.CARD_TYPE_NEW:\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_new_card));\n-                break;\n-            case Consts.CARD_TYPE_LRN :\n-                item.put(INTERVAL, context.getString(R.string.card_browser_interval_learning_card));\n-                break;\n-            default:\n-                item.put(INTERVAL, Utils.roundedTimeSpanUnformatted(context, c.getIvl()*86400));\n-                break;\n-        }\n         item.put(LAPSES, Integer.toString(c.getLapses()));\n         item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n", "next_change": {"commit": "17d9b916e4cfc4e6c3cc552f04dc72038450e8e1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex d853cba2b..087a58df6 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,7 +1481,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         // database\n         item.put(ANSWER, formatQA(a, context));\n \n-        item.put(LAPSES, Integer.toString(c.getLapses()));\n         item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n", "next_change": {"commit": "b696126cdfb39e7e967088855a64f98995742d29", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 087a58df6..17b0cafce 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1480,8 +1480,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         // put all of the fields in except for those that have already been pulled out straight from the\n         // database\n         item.put(ANSWER, formatQA(a, context));\n-\n-        item.put(NOTE_TYPE, c.model().optString(\"name\"));\n         item.put(QUESTION, formatQA(q, context));\n         item.put(REVIEWS, Integer.toString(c.getReps()));\n     }\n", "next_change": {"commit": "cffe326a64e97452f9d0ad296e00b56636dd3807", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 17b0cafce..94743e4f0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1481,7 +1481,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         // database\n         item.put(ANSWER, formatQA(a, context));\n         item.put(QUESTION, formatQA(q, context));\n-        item.put(REVIEWS, Integer.toString(c.getReps()));\n     }\n \n     @CheckResult\n", "next_change": {"commit": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 94743e4f0..33f2d76d3 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1470,15 +1470,12 @@ public class CardBrowser extends NavigationDrawerActivity implements\n                 qa.put(\"a\", qaFull.get(\"a\"));\n             }\n         }\n-        // update the original hash map to include rendered question & answer\n         String q = qa.get(\"q\");\n         String a = qa.get(\"a\");\n         // remove the question from the start of the answer if it exists\n         if (a.startsWith(q)) {\n             a = a.replaceFirst(Pattern.quote(q), \"\");\n         }\n-        // put all of the fields in except for those that have already been pulled out straight from the\n-        // database\n         item.put(ANSWER, formatQA(a, context));\n         item.put(QUESTION, formatQA(q, context));\n     }\n", "next_change": {"commit": "474450d513e379802bca25b64e9d2dccfa7dc105", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 33f2d76d3..de54a7132 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1457,29 +1457,6 @@ public class CardBrowser extends NavigationDrawerActivity implements\n         }\n     };\n \n-    public static void updateSearchItemQA(Context context, CardCache item, Card c) {\n-        // render question and answer\n-        Map<String, String> qa = c._getQA(true, true);\n-        // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-        if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-            HashMap<String, String> qaFull = c._getQA(true, false);\n-            if (\"\".equals(qa.get(\"q\"))) {\n-                qa.put(\"q\", qaFull.get(\"q\"));\n-            }\n-            if (\"\".equals(qa.get(\"a\"))) {\n-                qa.put(\"a\", qaFull.get(\"a\"));\n-            }\n-        }\n-        String q = qa.get(\"q\");\n-        String a = qa.get(\"a\");\n-        // remove the question from the start of the answer if it exists\n-        if (a.startsWith(q)) {\n-            a = a.replaceFirst(Pattern.quote(q), \"\");\n-        }\n-        item.put(ANSWER, formatQA(a, context));\n-        item.put(QUESTION, formatQA(q, context));\n-    }\n-\n     @CheckResult\n     private static String formatQA(String text, Context context) {\n         boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n", "next_change": {"commit": "7383c6809f93d6fd931a8f3bec4b43c9c488b19f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex de54a7132..a773d50b5 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1404,56 +1436,71 @@ public class CardBrowser extends NavigationDrawerActivity implements\n      * @param updatedCardTags Mapping note id -> updated tags\n      */\n     private void updateCardsInList(List<Card> cards, Map<Long, String> updatedCardTags) {\n-        Map<Long, Integer> idToPos = getPositionMap(getCards());\n+        List<CardCache> cardList = getCards();\n+        Map<Long, Integer> idToPos = getPositionMap(cardList);\n         for (Card c : cards) {\n             // get position in the mCards search results HashMap\n-            int pos = idToPos.containsKey(c.getId()) ? idToPos.get(c.getId()) : -1;\n-            if (pos < 0 || pos >= getCardCount()) {\n+            Integer pos = idToPos.get(c.getId());\n+            if (pos == null || pos >= getCardCount()) {\n                 continue;\n             }\n-            CardCache card = getCards().get(pos);\n             // update Q & A etc\n-            card.load(true);\n+            cardList.get(pos).load(true, mColumn1Index, mColumn2Index);\n         }\n \n         updateList();\n     }\n \n-    private TaskListener mUpdateCardHandler = new ListenerWithProgressBarCloseOnFalse(\"Card Browser - mUpdateCardHandler.onPostExecute()\"){\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+\n+    private static class UpdateCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public UpdateCardHandler(CardBrowser browser) {\n+            super(\"Card Browser - UpdateCardHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n+        }\n+\n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            updateCardInList(value.getCard(), value.getString());\n+        public void actualOnProgressUpdate(@NonNull CardBrowser browser, TaskData value) {\n+            browser.updateCardInList(value.getCard(), value.getString());\n         }\n \n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n+        protected void actualOnValidPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n         }\n     };\n \n-    private TaskListener mChangeDeckHandler = new ListenerWithProgressBarCloseOnFalse(\"Card Browser - mChangeDeckHandler.onPostExecute()\") {\n+    private ChangeDeckHandler changeDeckHandler() {\n+        return new ChangeDeckHandler(this);\n+    }\n+    private static class ChangeDeckHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public ChangeDeckHandler(CardBrowser browser) {\n+            super(\"Card Browser - changeDeckHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n+        protected void actualOnValidPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n \n-            searchCards();\n-            endMultiSelectMode();\n-            mCardsAdapter.notifyDataSetChanged();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.searchCards();\n+            browser.endMultiSelectMode();\n+            browser.mCardsAdapter.notifyDataSetChanged();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n \n             if (!result.getBoolean()) {\n-                Timber.i(\"mChangeDeckHandler failed, not offering undo\");\n-                displayCouldNotChangeDeck();\n+                Timber.i(\"changeDeckHandler failed, not offering undo\");\n+                browser.displayCouldNotChangeDeck();\n                 return;\n             }\n             // snackbar to offer undo\n-            String deckName = getCol().getDecks().name(mNewDid);\n-            mUndoSnackbar = UIUtils.showSnackbar(CardBrowser.this, String.format(getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n+            String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n                 @Override\n                 public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, mUndoHandler);\n+                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);\n                 }\n-            }, mCardsListView, null);\n+            }, browser.mCardsListView, null);\n         }\n     };\n \n", "next_change": {"commit": "715357c31701ffe4d1f87d8278be7c622fd25f60", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex a773d50b5..5f2682430 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1502,7 +1523,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n                 }\n             }, browser.mCardsListView, null);\n         }\n-    };\n+    }\n+\n \n     @CheckResult\n     private static String formatQA(String text, Context context) {\n", "next_change": {"commit": "c0595464b0b205d704b293f64543e5f54e4b2612", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 5f2682430..e015758c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1516,12 +1578,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n-                @Override\n-                public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);\n-                }\n-            }, browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex e015758c7..7ea57886b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1578,7 +1726,7 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> TaskManager.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex 7ea57886b..ed1747b0a 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1726,7 +1716,8 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION, R.string.undo, v -> TaskManager.launchCollectionTask(UNDO, browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION,\n+                                                         R.string.undo, v -> TaskManager.launchCollectionTask(new CollectionTask.Undo(), browser.mUndoHandler), browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "bd8f85f29633812b249152b8e4dac986d89ae49f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\nindex ed1747b0a..9da7f8009 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n", "chunk": "@@ -1709,15 +1759,20 @@ public class CardBrowser extends NavigationDrawerActivity implements\n             browser.mCardsAdapter.notifyDataSetChanged();\n             browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n \n-            if (!result.getBoolean()) {\n+            if (!result.succeeded()) {\n                 Timber.i(\"changeDeckHandler failed, not offering undo\");\n                 browser.displayCouldNotChangeDeck();\n                 return;\n             }\n             // snackbar to offer undo\n             String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, String.format(browser.getString(R.string.changed_deck_message), deckName), SNACKBAR_DURATION,\n-                                                         R.string.undo, v -> TaskManager.launchCollectionTask(new CollectionTask.Undo(), browser.mUndoHandler), browser.mCardsListView, null);\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(\n+                    browser,\n+                    String.format(browser.getString(R.string.changed_deck_message), deckName),\n+                    SNACKBAR_DURATION,\n+                    R.string.undo,\n+                    v -> TaskManager.launchCollectionTask(new UndoService.Undo().toDelegate(), browser.mUndoHandler),\n+                    browser.mCardsListView, null);\n         }\n     }\n \n", "next_change": {"commit": "0fd0f558c49c728f0eca73a7f5059125cb0a638c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java b/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\ndeleted file mode 100644\nindex 9da7f8009..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java\n+++ /dev/null\n", "chunk": "@@ -1,2973 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *\n- * Copyright (c) 2012 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Timothy Rae <perceptualchaos2@gmail.com>                          *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-\n-package com.ichi2.anki;\n-\n-import android.app.AlertDialog;\n-import android.content.BroadcastReceiver;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.IntentFilter;\n-import android.content.SharedPreferences;\n-import android.graphics.Typeface;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.SystemClock;\n-\n-import androidx.activity.result.ActivityResultLauncher;\n-import androidx.activity.result.contract.ActivityResultContracts;\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import com.google.android.material.snackbar.Snackbar;\n-\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.widget.SearchView;\n-import android.text.TextUtils;\n-import android.util.Pair;\n-import android.util.TypedValue;\n-import android.view.KeyEvent;\n-import android.view.LayoutInflater;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.view.WindowManager;\n-import android.widget.AbsListView;\n-import android.widget.AdapterView;\n-import android.widget.AdapterView.OnItemSelectedListener;\n-import android.widget.ArrayAdapter;\n-import android.widget.BaseAdapter;\n-import android.widget.CheckBox;\n-import android.widget.ListView;\n-import android.widget.Spinner;\n-import android.widget.TextView;\n-\n-import com.afollestad.materialdialogs.MaterialDialog;\n-import com.ichi2.anki.dialogs.CardBrowserMySearchesDialog;\n-import com.ichi2.anki.dialogs.CardBrowserOrderDialog;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.dialogs.DeckSelectionDialog;\n-import com.ichi2.anki.dialogs.IntegerDialog;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.dialogs.SimpleMessageDialog;\n-import com.ichi2.anki.dialogs.tags.TagsDialog;\n-import com.ichi2.anki.dialogs.tags.TagsDialogFactory;\n-import com.ichi2.anki.dialogs.tags.TagsDialogListener;\n-import com.ichi2.anki.receiver.SdCardReceiver;\n-import com.ichi2.anki.servicelayer.SchedulerService;\n-import com.ichi2.anki.servicelayer.UndoService;\n-import com.ichi2.anki.widgets.DeckDropDownAdapter;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.async.TaskListenerWithContext;\n-import com.ichi2.async.TaskManager;\n-import com.ichi2.compat.Compat;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.Deck;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.ui.CardBrowserSearchView;\n-import com.ichi2.upgrade.Upgrade;\n-import com.ichi2.utils.FunctionalInterfaces;\n-import com.ichi2.utils.HashUtil;\n-import com.ichi2.utils.LanguageUtil;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import com.ichi2.utils.JSONException;\n-import com.ichi2.utils.JSONObject;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.CardBrowser.Column.*;\n-import static com.ichi2.libanki.stats.Stats.SECONDS_PER_DAY;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-import static com.ichi2.utils.LanguageUtil.getLocaleCompat;\n-\n-public class CardBrowser extends NavigationDrawerActivity implements\n-        DeckDropDownAdapter.SubtitleListener,\n-        DeckSelectionDialog.DeckSelectionListener,\n-        TagsDialogListener {\n-\n-    @Override\n-    public void onDeckSelected(@Nullable DeckSelectionDialog.SelectableDeck deck) {\n-        if (deck == null) {\n-            return;\n-        }\n-        long deckId = deck.getDeckId();\n-        mDeckSpinnerSelection.initializeActionBarDeckSpinner(this.getSupportActionBar());\n-        mDeckSpinnerSelection.selectDeckById(deckId, true);\n-        selectDeckAndSave(deckId);\n-    }\n-\n-\n-    enum Column {\n-        QUESTION,\n-        ANSWER,\n-        FLAGS,\n-        SUSPENDED,\n-        MARKED,\n-        SFLD,\n-        DECK,\n-        TAGS,\n-        ID,\n-        CARD,\n-        DUE,\n-        EASE,\n-        CHANGED,\n-        CREATED,\n-        EDITED,\n-        INTERVAL,\n-        LAPSES,\n-        NOTE_TYPE,\n-        REVIEWS\n-    }\n-\n-    /** List of cards in the browser.\n-    * When the list is changed, the position member of its elements should get changed.*/\n-    @NonNull\n-    private final CardCollection<CardCache> mCards = new CardCollection<>();\n-    public DeckSpinnerSelection mDeckSpinnerSelection;\n-    @VisibleForTesting\n-    public ListView mCardsListView;\n-    private CardBrowserSearchView mSearchView;\n-    private MultiColumnListAdapter mCardsAdapter;\n-    private String mSearchTerms;\n-    private String mRestrictOnDeck;\n-    private int mCurrentFlag;\n-\n-    private TagsDialogFactory mTagsDialogFactory;\n-\n-    private MenuItem mSearchItem;\n-    private MenuItem mSaveSearchItem;\n-    private MenuItem mMySearchesItem;\n-    private MenuItem mPreviewItem;\n-\n-    private Snackbar mUndoSnackbar;\n-\n-    public static Card sCardBrowserCard;\n-\n-    // card that was clicked (not marked)\n-    private long mCurrentCardId;\n-\n-    private int mOrder;\n-    private boolean mOrderAsc;\n-    private int mColumn1Index;\n-    private int mColumn2Index;\n-\n-    //DEFECT: Doesn't need to be a local\n-    /** The next deck for the \"Change Deck\" operation */\n-    private long mNewDid;\n-\n-    /** The query which is currently in the search box, potentially null. Only set when search box was open */\n-    private String mTempSearchQuery;\n-\n-    ActivityResultLauncher<Intent> mOnEditCardActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onEditCardActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        if (result.getResultCode() != RESULT_CANCELED) {\n-            Timber.i(\"CardBrowser:: CardBrowser: Saving card...\");\n-            TaskManager.launchCollectionTask(new CollectionTask.UpdateNote(sCardBrowserCard, false, false),\n-                    updateCardHandler());\n-        }\n-        Intent data = result.getData();\n-        if (data != null &&\n-                (data.getBooleanExtra(\"reloadRequired\", false) || data.getBooleanExtra(\"noteChanged\", false))) {\n-            // if reloadRequired or noteChanged flag was sent from note editor then reload card list\n-            searchCards();\n-            mShouldRestoreScroll = true;\n-            // in use by reviewer?\n-            if (getReviewerCardId() == mCurrentCardId) {\n-                mReloadRequired = true;\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    ActivityResultLauncher<Intent> mOnAddNoteActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onAddNoteActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        if (result.getResultCode() == RESULT_OK) {\n-            if (mSearchView != null) {\n-                mSearchTerms = mSearchView.getQuery().toString();\n-                searchCards();\n-            } else {\n-                Timber.w(\"Note was added from browser and on return mSearchView == null\");\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    ActivityResultLauncher<Intent> mOnPreviewCardsActivityResult = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {\n-        Timber.d(\"onPreviewCardsActivityResult: resultCode=%d\", result.getResultCode());\n-        if (result.getResultCode() == DeckPicker.RESULT_DB_ERROR) {\n-            closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-        }\n-        // Previewing can now perform an \"edit\", so it can pass on a reloadRequired\n-        Intent data = result.getData();\n-        if (data != null &&\n-                (data.getBooleanExtra(\"reloadRequired\", false) || data.getBooleanExtra(\"noteChanged\", false))) {\n-            searchCards();\n-            if (getReviewerCardId() == mCurrentCardId) {\n-                mReloadRequired = true;\n-            }\n-        }\n-        invalidateOptionsMenu();    // maybe the availability of undo changed\n-    });\n-\n-    private static final int DEFAULT_FONT_SIZE_RATIO = 100;\n-    // Should match order of R.array.card_browser_order_labels\n-    public static final int CARD_ORDER_NONE = 0;\n-    private static final String[] fSortTypes = new String[] {\n-        \"\",\n-        \"noteFld\",\n-        \"noteCrt\",\n-        \"noteMod\",\n-        \"cardMod\",\n-        \"cardDue\",\n-        \"cardIvl\",\n-        \"cardEase\",\n-        \"cardReps\",\n-        \"cardLapses\"};\n-    private static final Column[] COLUMN1_KEYS = {QUESTION, SFLD};\n-\n-    // list of available keys in mCards corresponding to the column names in R.array.browser_column2_headings.\n-    // Note: the last 6 are currently hidden\n-    private static final Column[] COLUMN2_KEYS = {ANSWER,\n-        CARD,\n-        DECK,\n-        NOTE_TYPE,\n-        QUESTION,\n-        TAGS,\n-        LAPSES,\n-        REVIEWS,\n-        INTERVAL,\n-        EASE,\n-        DUE,\n-        CHANGED,\n-        CREATED,\n-        EDITED,\n-    };\n-    private long mLastRenderStart = 0;\n-    private TextView mActionBarTitle;\n-    private boolean mReloadRequired = false;\n-    private boolean mInMultiSelectMode = false;\n-    private final @NonNull Set<CardCache> mCheckedCards = Collections.synchronizedSet(new LinkedHashSet<>());\n-    private int mLastSelectedPosition;\n-    @Nullable\n-    private Menu mActionBarMenu;\n-\n-    private static final int SNACKBAR_DURATION = 8000;\n-\n-\n-    // Values related to persistent state data\n-    private static final long ALL_DECKS_ID = 0L;\n-    private static final String PERSISTENT_STATE_FILE = \"DeckPickerState\";\n-    private static final String LAST_DECK_ID_KEY = \"lastDeckId\";\n-\n-    public static final int CARD_NOT_AVAILABLE = -1;\n-    private long mOldCardId = 0;\n-    private int mOldCardTopOffset = 0;\n-    private boolean mShouldRestoreScroll = false;\n-    private boolean mPostAutoScroll = false;\n-\n-    private final Onboarding.CardBrowser mOnboarding = new Onboarding.CardBrowser(this);\n-\n-    /**\n-     * Broadcast that informs us when the sd card is about to be unmounted\n-     */\n-    private BroadcastReceiver mUnmountReceiver = null;\n-\n-    private final MaterialDialog.ListCallbackSingleChoice mOrderDialogListener =\n-            (materialDialog, view, which, charSequence) -> {\n-                changeCardOrder(which);\n-                return true;\n-            };\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.PROTECTED)\n-    protected void changeCardOrder(int which) {\n-        if (which != mOrder) {\n-            mOrder = which;\n-            mOrderAsc = false;\n-            if (mOrder == 0) {\n-                // if the sort value in the card browser was changed, then perform a new search\n-                getCol().set_config(\"sortType\", fSortTypes[1]);\n-                AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()\n-                        .putBoolean(\"cardBrowserNoSorting\", true)\n-                        .apply();\n-            } else {\n-                getCol().set_config(\"sortType\", fSortTypes[mOrder]);\n-                AnkiDroidApp.getSharedPrefs(getBaseContext()).edit()\n-                        .putBoolean(\"cardBrowserNoSorting\", false)\n-                        .apply();\n-            }\n-            getCol().set_config(\"sortBackwards\", mOrderAsc);\n-            searchCards();\n-        } else if (which != CARD_ORDER_NONE) {\n-            // if the same element is selected again, reverse the order\n-            mOrderAsc = !mOrderAsc;\n-            getCol().set_config(\"sortBackwards\", mOrderAsc);\n-            mCards.reverse();\n-            updateList();\n-        }\n-        // To update the collection\n-        getCol().getDb().setMod(true);\n-    }\n-\n-\n-    private RepositionCardHandler repositionCardHandler() {\n-        return new RepositionCardHandler(this);\n-    }\n-\n-    private static class RepositionCardHandler extends TaskListenerWithContext<CardBrowser, Object, Computation<? extends Card[]>> {\n-        public RepositionCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::RepositionCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::RepositionCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reposition_card_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private ResetProgressCardHandler resetProgressCardHandler() {\n-        return new ResetProgressCardHandler(this);\n-    }\n-    private static class ResetProgressCardHandler extends TaskListenerWithContext<CardBrowser, Object, Computation<? extends Card[]>>{\n-        public ResetProgressCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::ResetProgressCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::ResetProgressCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reset_cards_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private RescheduleCardHandler rescheduleCardHandler() {\n-        return new RescheduleCardHandler(this);\n-    }\n-    private static class RescheduleCardHandler extends TaskListenerWithContext<CardBrowser, Card, Computation<? extends Card[]>>{\n-        public RescheduleCardHandler (CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"CardBrowser::RescheduleCardHandler() onPreExecute\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Computation<? extends Card[]> cards) {\n-            Timber.d(\"CardBrowser::RescheduleCardHandler() onPostExecute\");\n-            browser.mReloadRequired = true;\n-            int cardCount = cards.getValue().length;\n-            UIUtils.showThemedToast(browser,\n-                    browser.getResources().getQuantityString(R.plurals.reschedule_cards_dialog_acknowledge, cardCount, cardCount), true);\n-            browser.reloadCards(cards.getValue());\n-            browser.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-    private final CardBrowserMySearchesDialog.MySearchesDialogListener mMySearchesDialogListener =\n-            new CardBrowserMySearchesDialog.MySearchesDialogListener() {\n-        @Override\n-        public void onSelection(String searchName) {\n-            Timber.d(\"OnSelection using search named: %s\", searchName);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            Timber.d(\"SavedFilters are %s\", savedFiltersObj == null ? null : savedFiltersObj.toString());\n-            if (savedFiltersObj != null) {\n-                mSearchTerms = savedFiltersObj.optString(searchName);\n-                Timber.d(\"OnSelection using search terms: %s\", mSearchTerms);\n-                mSearchView.setQuery(mSearchTerms, false);\n-                mSearchItem.expandActionView();\n-                searchCards();\n-            }\n-        }\n-\n-        @Override\n-        public void onRemoveSearch(String searchName) {\n-            Timber.d(\"OnRemoveSelection using search named: %s\", searchName);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            if (savedFiltersObj != null && savedFiltersObj.has(searchName)) {\n-                savedFiltersObj.remove(searchName);\n-                getCol().set_config(\"savedFilters\", savedFiltersObj);\n-                getCol().flush();\n-                if (savedFiltersObj.length() == 0) {\n-                    mMySearchesItem.setVisible(false);\n-                }\n-            }\n-\n-        }\n-\n-        @Override\n-        public void onSaveSearch(String searchName, String searchTerms) {\n-            if (TextUtils.isEmpty(searchName)) {\n-                UIUtils.showThemedToast(CardBrowser.this,\n-                        getString(R.string.card_browser_list_my_searches_new_search_error_empty_name), true);\n-                return;\n-            }\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            boolean should_save = false;\n-            if (savedFiltersObj == null) {\n-                savedFiltersObj = new JSONObject();\n-                savedFiltersObj.put(searchName, searchTerms);\n-                should_save = true;\n-            } else if (!savedFiltersObj.has(searchName)) {\n-                savedFiltersObj.put(searchName, searchTerms);\n-                should_save = true;\n-            } else {\n-                UIUtils.showThemedToast(CardBrowser.this,\n-                                        getString(R.string.card_browser_list_my_searches_new_search_error_dup), true);\n-            }\n-            if (should_save) {\n-                getCol().set_config(\"savedFilters\", savedFiltersObj);\n-                getCol().flush();\n-                mSearchView.setQuery(\"\", false);\n-                mMySearchesItem.setVisible(true);\n-            }\n-        }\n-    };\n-\n-\n-    private void onSearch() {\n-        mSearchTerms = mSearchView.getQuery().toString();\n-        if (mSearchTerms.length() == 0) {\n-            mSearchView.setQueryHint(getResources().getString(R.string.deck_conf_cram_search));\n-        }\n-        searchCards();\n-    }\n-\n-    private List<Long> getSelectedCardIds() {\n-        List<Long> ids = new ArrayList<>(mCheckedCards.size());\n-        for (CardCache cardPosition : mCheckedCards) {\n-            ids.add(cardPosition.getId());\n-        }\n-        return ids;\n-    }\n-\n-    private boolean canPerformCardInfo() {\n-        return checkedCardCount() == 1;\n-    }\n-\n-    private boolean canPerformMultiSelectEditNote() {\n-        //The noteId is not currently available. Only allow if a single card is selected for now.\n-        return checkedCardCount() == 1;\n-    }\n-\n-\n-    /**\n-     * Change Deck\n-     * @param deckPosition NOT the did. The index in the DISPLAYED Deck list to change the decks to.\n-     * grep: changeDeck\n-     */\n-    @VisibleForTesting\n-    void moveSelectedCardsToDeck(int deckPosition) {\n-        List<Long> ids = getSelectedCardIds();\n-\n-        Deck selectedDeck = getValidDecksForChangeDeck().get(deckPosition);\n-\n-        try {\n-            //#5932 - can't be dynamic\n-            if (Decks.isDynamic(selectedDeck)) {\n-                Timber.w(\"Attempted to change cards to dynamic deck. Cancelling operation.\");\n-                displayCouldNotChangeDeck();\n-                return;\n-            }\n-        } catch (Exception e) {\n-            displayCouldNotChangeDeck();\n-            Timber.e(e);\n-            return;\n-        }\n-\n-        mNewDid = selectedDeck.getLong(\"id\");\n-\n-        Timber.i(\"Changing selected cards to deck: %d\", mNewDid);\n-\n-        if (ids.isEmpty()) {\n-            endMultiSelectMode();\n-            mCardsAdapter.notifyDataSetChanged();\n-            return;\n-        }\n-\n-        if (ids.contains(getReviewerCardId())) {\n-            mReloadRequired = true;\n-        }\n-\n-        executeChangeCollectionTask(ids, mNewDid);\n-    }\n-\n-\n-    private void displayCouldNotChangeDeck() {\n-        UIUtils.showThemedToast(this, getString(R.string.card_browser_deck_change_error), true);\n-    }\n-\n-\n-    @VisibleForTesting\n-    Long getLastDeckId() {\n-        SharedPreferences state = getSharedPreferences(PERSISTENT_STATE_FILE,0);\n-        if (!state.contains(LAST_DECK_ID_KEY)) {\n-            return null;\n-        }\n-        return state.getLong(LAST_DECK_ID_KEY, -1);\n-    }\n-\n-    public static void clearLastDeckId() {\n-        Context context = AnkiDroidApp.getInstance();\n-        context.getSharedPreferences(PERSISTENT_STATE_FILE,0).edit().remove(LAST_DECK_ID_KEY).apply();\n-    }\n-\n-    private void saveLastDeckId(Long id) {\n-        if (id == null) {\n-            clearLastDeckId();\n-            return;\n-        }\n-        getSharedPreferences(PERSISTENT_STATE_FILE, 0).edit().putLong(LAST_DECK_ID_KEY, id).apply();\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        mTagsDialogFactory = new TagsDialogFactory(this).attachToActivity(this);\n-        super.onCreate(savedInstanceState);\n-        Timber.d(\"onCreate()\");\n-        if (wasLoadedFromExternalTextActionItem() && !Permissions.hasStorageAccessPermission(this)) {\n-            Timber.w(\"'Card Browser' Action item pressed before storage permissions granted.\");\n-            UIUtils.showThemedToast(this, getString(R.string.intent_handler_failed_no_storage_permission), false);\n-            displayDeckPickerForPermissionsDialog();\n-            return;\n-        }\n-        setContentView(R.layout.card_browser);\n-        initNavigationDrawer(findViewById(android.R.id.content));\n-        startLoadingCollection();\n-\n-        // for intent coming from search query js api\n-        if (getIntent().getStringExtra(\"search_query\") != null) {\n-            mSearchTerms = getIntent().getStringExtra(\"search_query\");\n-            searchCards();\n-        }\n-\n-        mOnboarding.onCreate();\n-    }\n-\n-    // Finish initializing the activity after the collection has been correctly loaded\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        Timber.d(\"onCollectionLoaded()\");\n-        registerExternalStorageListener();\n-\n-        SharedPreferences preferences = AnkiDroidApp.getSharedPrefs(getBaseContext());\n-\n-        // Load reference to action bar title\n-        mActionBarTitle = findViewById(R.id.toolbar_title);\n-\n-        mOrder = CARD_ORDER_NONE;\n-        String colOrder = getCol().get_config_string(\"sortType\");\n-        for (int c = 0; c < fSortTypes.length; ++c) {\n-            if (fSortTypes[c].equals(colOrder)) {\n-                mOrder = c;\n-                break;\n-            }\n-        }\n-        if (mOrder == 1 && preferences.getBoolean(\"cardBrowserNoSorting\", false)) {\n-            mOrder = 0;\n-        }\n-        //This upgrade should already have been done during\n-        //setConf. However older version of AnkiDroid didn't call\n-        //upgradeJSONIfNecessary during setConf, which means the\n-        //conf saved may still have this bug.\n-        mOrderAsc = Upgrade.upgradeJSONIfNecessary(getCol(), \"sortBackwards\", false);\n-\n-        mCards.reset();\n-        mCardsListView = findViewById(R.id.card_browser_list);\n-        // Create a spinner for column1\n-        Spinner cardsColumn1Spinner = findViewById(R.id.browser_column1_spinner);\n-        ArrayAdapter<CharSequence> column1Adapter = ArrayAdapter.createFromResource(this,\n-                R.array.browser_column1_headings, android.R.layout.simple_spinner_item);\n-        column1Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n-        cardsColumn1Spinner.setAdapter(column1Adapter);\n-        mColumn1Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt(\"cardBrowserColumn1\", 0);\n-        cardsColumn1Spinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n-            @Override\n-            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {\n-                // If a new column was selected then change the key used to map from mCards to the column TextView\n-                if (pos != mColumn1Index) {\n-                    mColumn1Index = pos;\n-                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()\n-                            .putInt(\"cardBrowserColumn1\", mColumn1Index).apply();\n-                    Column[] fromMap = mCardsAdapter.getFromMapping();\n-                    fromMap[0] = COLUMN1_KEYS[mColumn1Index];\n-                    mCardsAdapter.setFromMapping(fromMap);\n-                }\n-            }\n-\n-            @Override\n-            public void onNothingSelected(AdapterView<?> parent) {\n-                // Do Nothing\n-            }\n-        });\n-        // Load default value for column2 selection\n-        mColumn2Index = AnkiDroidApp.getSharedPrefs(getBaseContext()).getInt(\"cardBrowserColumn2\", 0);\n-        // Setup the column 2 heading as a spinner so that users can easily change the column type\n-        Spinner cardsColumn2Spinner = findViewById(R.id.browser_column2_spinner);\n-        ArrayAdapter<CharSequence> column2Adapter = ArrayAdapter.createFromResource(this,\n-                R.array.browser_column2_headings, android.R.layout.simple_spinner_item);\n-        column2Adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n-        cardsColumn2Spinner.setAdapter(column2Adapter);\n-        // Create a new list adapter with updated column map any time the user changes the column\n-        cardsColumn2Spinner.setOnItemSelectedListener(new OnItemSelectedListener() {\n-            @Override\n-            public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {\n-                // If a new column was selected then change the key used to map from mCards to the column TextView\n-                if (pos != mColumn2Index) {\n-                    mColumn2Index = pos;\n-                    AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit()\n-                            .putInt(\"cardBrowserColumn2\", mColumn2Index).apply();\n-                    Column[] fromMap = mCardsAdapter.getFromMapping();\n-                    fromMap[1] = COLUMN2_KEYS[mColumn2Index];\n-                    mCardsAdapter.setFromMapping(fromMap);\n-                }\n-            }\n-\n-            @Override\n-            public void onNothingSelected(AdapterView<?> parent) {\n-                // Do Nothing\n-            }\n-        });\n-        // get the font and font size from the preferences\n-        int sflRelativeFontSize = preferences.getInt(\"relativeCardBrowserFontSize\", DEFAULT_FONT_SIZE_RATIO);\n-        String sflCustomFont = preferences.getString(\"browserEditorFont\", \"\");\n-        Column[] columnsContent = {COLUMN1_KEYS[mColumn1Index], COLUMN2_KEYS[mColumn2Index]};\n-        // make a new list adapter mapping the data in mCards to column1 and column2 of R.layout.card_item_browser\n-        mCardsAdapter = new MultiColumnListAdapter(\n-                this,\n-                R.layout.card_item_browser,\n-                columnsContent,\n-                new int[] {R.id.card_sfld, R.id.card_column2},\n-                sflRelativeFontSize,\n-                sflCustomFont);\n-        // link the adapter to the main mCardsListView\n-        mCardsListView.setAdapter(mCardsAdapter);\n-        // make the items (e.g. question & answer) render dynamically when scrolling\n-        mCardsListView.setOnScrollListener(new RenderOnScroll());\n-        // set the spinner index\n-        cardsColumn1Spinner.setSelection(mColumn1Index);\n-        cardsColumn2Spinner.setSelection(mColumn2Index);\n-\n-\n-        mCardsListView.setOnItemClickListener((parent, view, position, id) -> {\n-            if (mInMultiSelectMode) {\n-                // click on whole cell triggers select\n-                CheckBox cb = view.findViewById(R.id.card_checkbox);\n-                cb.toggle();\n-                onCheck(position, view);\n-            } else {\n-                // load up the card selected on the list\n-                long clickedCardId = getCards().get(position).getId();\n-                saveScrollingState(position);\n-                openNoteEditorForCard(clickedCardId);\n-            }\n-        });\n-\n-        mCardsListView.setOnItemLongClickListener((adapterView, view, position, id) -> {\n-            if (mInMultiSelectMode) {\n-                boolean hasChanged = false;\n-                for (int i = Math.min(mLastSelectedPosition, position); i <= Math.max(mLastSelectedPosition, position); i++) {\n-                    CardCache card = (CardCache) mCardsListView.getItemAtPosition(i);\n-\n-                    // Add to the set of checked cards\n-                    hasChanged |= mCheckedCards.add(card);\n-                }\n-                if (hasChanged) {\n-                    onSelectionChanged();\n-                }\n-            } else {\n-                mLastSelectedPosition = position;\n-                saveScrollingState(position);\n-                loadMultiSelectMode();\n-\n-                // click on whole cell triggers select\n-                CheckBox cb = view.findViewById(R.id.card_checkbox);\n-                cb.toggle();\n-                onCheck(position, view);\n-                recenterListView(view);\n-                mCardsAdapter.notifyDataSetChanged();\n-            }\n-            return true;\n-        });\n-\n-        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);\n-\n-        long deckId = getCol().getDecks().selected();\n-        mDeckSpinnerSelection = new DeckSpinnerSelection(this, col, this.findViewById(R.id.toolbar_spinner));\n-        mDeckSpinnerSelection.setShowAllDecks(true);\n-        mDeckSpinnerSelection.initializeActionBarDeckSpinner(this.getSupportActionBar());\n-        selectDeckAndSave(deckId);\n-\n-        // If a valid value for last deck exists then use it, otherwise use libanki selected deck\n-        if (getLastDeckId() != null && getLastDeckId() == ALL_DECKS_ID) {\n-            selectAllDecks();\n-        } else  if (getLastDeckId() != null && getCol().getDecks().get(getLastDeckId(), false) != null) {\n-            mDeckSpinnerSelection.selectDeckById(getLastDeckId(), false);\n-        } else {\n-            mDeckSpinnerSelection.selectDeckById(getCol().getDecks().selected(), false);\n-        }\n-    }\n-\n-    public void selectDeckAndSave(long deckId) {\n-        mDeckSpinnerSelection.selectDeckById(deckId, true);\n-        if (deckId == ALL_DECKS_ID) {\n-            mRestrictOnDeck = \"\";\n-        } else {\n-            String deckName = getCol().getDecks().name(deckId);\n-            mRestrictOnDeck = \"deck:\\\"\" + deckName + \"\\\" \";\n-        }\n-        saveLastDeckId(deckId);\n-        searchCards();\n-    }\n-\n-\n-\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        // NOTE: These are all active when typing in the search - doesn't matter as all need CTRL\n-\n-        switch (keyCode) {\n-            /* Ctrl+A - Select All */\n-            case KeyEvent.KEYCODE_A: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+A - Select All\");\n-                    onSelectAll();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_E: {\n-                // Ctrl+Shift+E: Export (TODO)\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+E: Add Note\");\n-                    addNoteFromCardBrowser();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_D: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+D: Change Deck\");\n-                    showChangeDeckDialog();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_K: {\n-                if (event.isCtrlPressed()) {\n-                    Timber.i(\"Ctrl+K: Toggle Mark\");\n-                    toggleMark();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_R: {\n-                if (event.isCtrlPressed() && event.isAltPressed()) {\n-                    Timber.i(\"Ctrl+Alt+R - Reschedule\");\n-                    rescheduleSelectedCards();\n-                    return true;\n-                }\n-                break;\n-            }\n-            case KeyEvent.KEYCODE_FORWARD_DEL: {\n-                Timber.i(\"Delete pressed - Delete Selected Note\");\n-                deleteSelectedNote();\n-                return true;\n-            }\n-        }\n-        return super.onKeyDown(keyCode, event);\n-    }\n-\n-    /** All the notes of the selected cards will be marked\n-     * If one or more card is unmarked, all will be marked,\n-     * otherwise, they will be unmarked */\n-    private void toggleMark() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Not marking cards - nothing selected\");\n-            return;\n-        }\n-\n-        TaskManager.launchCollectionTask(new CollectionTask.MarkNoteMulti(getSelectedCardIds()),\n-                markCardHandler());\n-    }\n-\n-\n-    @VisibleForTesting\n-    void selectAllDecks() {\n-        mDeckSpinnerSelection.selectDropDownItem(0);\n-        mRestrictOnDeck = \"\";\n-        saveLastDeckId(ALL_DECKS_ID);\n-        searchCards();\n-    }\n-\n-\n-    /** Opens the note editor for a card.\n-     * We use the Card ID to specify the preview target */\n-    public void openNoteEditorForCard(long cardId) {\n-        mCurrentCardId = cardId;\n-        sCardBrowserCard = getCol().getCard(mCurrentCardId);\n-        // start note editor using the card we just loaded\n-        Intent editCard = new Intent(this, NoteEditor.class)\n-                .putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_EDIT)\n-                .putExtra(NoteEditor.EXTRA_CARD_ID, sCardBrowserCard.getId());\n-        this.launchActivityForResultWithAnimation(editCard, mOnEditCardActivityResult, START);\n-        //#6432 - FIXME - onCreateOptionsMenu crashes if receiving an activity result from edit card when in multiselect\n-        endMultiSelectMode();\n-    }\n-\n-    private void openNoteEditorForCurrentlySelectedNote() {\n-        try {\n-            //Just select the first one. It doesn't particularly matter if there's a multiselect occurring.\n-            openNoteEditorForCard(getSelectedCardIds().get(0));\n-        } catch (Exception e) {\n-            Timber.w(e, \"Error Opening Note Editor\");\n-            UIUtils.showThemedToast(this, getString(R.string.multimedia_editor_something_wrong), false);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected void onStop() {\n-        Timber.d(\"onStop()\");\n-        // cancel rendering the question and answer, which has shared access to mCards\n-        super.onStop();\n-        if (!isFinishing()) {\n-            WidgetStatus.update(this);\n-            UIUtils.saveCollectionInBackground();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected void onDestroy() {\n-        Timber.d(\"onDestroy()\");\n-        invalidate();\n-        super.onDestroy();\n-        if (mUnmountReceiver != null) {\n-            unregisterReceiver(mUnmountReceiver);\n-        }\n-    }\n-\n-\n-    @Override\n-    public void onBackPressed() {\n-        if (isDrawerOpen()) {\n-            super.onBackPressed();\n-        } else if (mInMultiSelectMode) {\n-            endMultiSelectMode();\n-        } else {\n-            Timber.i(\"Back key pressed\");\n-            Intent data = new Intent();\n-            if (mReloadRequired) {\n-                // Add reload flag to result intent so that schedule reset when returning to note editor\n-                data.putExtra(\"reloadRequired\", true);\n-            }\n-            closeCardBrowser(RESULT_OK, data);\n-        }\n-    }\n-\n-    @Override\n-    protected void onPause() {\n-        super.onPause();\n-        // If the user entered something into the search, but didn't press \"search\", clear this.\n-        // It's confusing if the bar is shown with a query that does not relate to the data on the screen\n-        mTempSearchQuery = null;\n-        if (mPostAutoScroll) {\n-            mPostAutoScroll = false;\n-        }\n-    }\n-\n-    @Override\n-    protected void onResume() {\n-        Timber.d(\"onResume()\");\n-        super.onResume();\n-        selectNavigationItem(R.id.nav_browser);\n-    }\n-\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(final Menu menu) {\n-        Timber.d(\"onCreateOptionsMenu()\");\n-        mActionBarMenu = menu;\n-        if (!mInMultiSelectMode) {\n-            // restore drawer click listener and icon\n-            restoreDrawerIcon();\n-            getMenuInflater().inflate(R.menu.card_browser, menu);\n-            mSaveSearchItem = menu.findItem(R.id.action_save_search);\n-            mSaveSearchItem.setVisible(false); //the searchview's query always starts empty.\n-            mMySearchesItem = menu.findItem(R.id.action_list_my_searches);\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            mMySearchesItem.setVisible(savedFiltersObj != null && savedFiltersObj.length() > 0);\n-            mSearchItem = menu.findItem(R.id.action_search);\n-            mSearchItem.setOnActionExpandListener(new MenuItem.OnActionExpandListener() {\n-                @Override\n-                public boolean onMenuItemActionExpand(MenuItem item) {\n-                    return true;\n-                }\n-\n-                @Override\n-                public boolean onMenuItemActionCollapse(MenuItem item) {\n-                    // SearchView doesn't support empty queries so we always reset the search when collapsing\n-                    mSearchTerms = \"\";\n-                    mSearchView.setQuery(mSearchTerms, false);\n-                    searchCards();\n-                    // invalidate options menu so that disappeared icons would appear again\n-                    supportInvalidateOptionsMenu();\n-                    mTempSearchQuery = null;\n-                    return true;\n-                }\n-            });\n-            mSearchView = (CardBrowserSearchView) mSearchItem.getActionView();\n-            mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n-                @Override\n-                public boolean onQueryTextChange(String newText) {\n-                    if (mSearchView.shouldIgnoreValueChange()) {\n-                        return true;\n-                    }\n-                    mSaveSearchItem.setVisible(!TextUtils.isEmpty(newText));\n-                    mTempSearchQuery = newText;\n-                    return true;\n-                }\n-\n-                @Override\n-                public boolean onQueryTextSubmit(String query) {\n-                    onSearch();\n-                    mSearchView.clearFocus();\n-                    return true;\n-                }\n-            });\n-            // Fixes #6500 - keep the search consistent if coming back from note editor\n-            // Fixes #9010 - consistent search after drawer change calls supportInvalidateOptionsMenu (mTempSearchQuery)\n-            if (!TextUtils.isEmpty(mTempSearchQuery) || !TextUtils.isEmpty(mSearchTerms)) {\n-                mSearchItem.expandActionView(); // This calls mSearchView.setOnSearchClickListener\n-                String toUse = !TextUtils.isEmpty(mTempSearchQuery) ? mTempSearchQuery : mSearchTerms;\n-                mSearchView.setQuery(toUse, false);\n-            }\n-            mSearchView.setOnSearchClickListener(v -> {\n-                // Provide SearchView with the previous search terms\n-                mSearchView.setQuery(mSearchTerms, false);\n-            });\n-        } else {\n-            // multi-select mode\n-            getMenuInflater().inflate(R.menu.card_browser_multiselect, menu);\n-            showBackIcon();\n-        }\n-\n-        if (mActionBarMenu != null && mActionBarMenu.findItem(R.id.action_undo) != null) {\n-            MenuItem undo =  mActionBarMenu.findItem(R.id.action_undo);\n-            undo.setVisible(getCol().undoAvailable());\n-            undo.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        // Maybe we were called from ACTION_PROCESS_TEXT.\n-        // In that case we already fill in the search.\n-        Intent intent = getIntent();\n-        Compat compat = CompatHelper.getCompat();\n-        if (compat.ACTION_PROCESS_TEXT.equals(intent.getAction())) {\n-            CharSequence search = intent.getCharSequenceExtra(compat.EXTRA_PROCESS_TEXT);\n-            if (search != null && search.length() != 0) {\n-                Timber.i(\"CardBrowser :: Called with search intent: %s\", search.toString());\n-                mSearchView.setQuery(search, true);\n-                intent.setAction(Intent.ACTION_DEFAULT);\n-            }\n-        }\n-\n-        mPreviewItem = menu.findItem(R.id.action_preview);\n-        onSelectionChanged();\n-        updatePreviewMenuItem();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-    @Override\n-    protected void onNavigationPressed() {\n-        if (mInMultiSelectMode) {\n-            endMultiSelectMode();\n-        } else {\n-            super.onNavigationPressed();\n-        }\n-    }\n-\n-\n-    private void displayDeckPickerForPermissionsDialog() {\n-        //TODO: Combine this with class: IntentHandler after both are well-tested\n-        Intent deckPicker = new Intent(this, DeckPicker.class);\n-        deckPicker.setAction(Intent.ACTION_MAIN);\n-        deckPicker.addCategory(Intent.CATEGORY_LAUNCHER);\n-        deckPicker.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\n-        startActivityWithAnimation(deckPicker, FADE);\n-        AnkiActivity.finishActivityWithFade(this);\n-        finishActivityWithFade(this);\n-        this.setResult(RESULT_CANCELED);\n-    }\n-\n-\n-    private boolean wasLoadedFromExternalTextActionItem() {\n-        Intent intent = this.getIntent();\n-        if (intent == null) {\n-            return false;\n-        }\n-        //API 23: Replace with Intent.ACTION_PROCESS_TEXT\n-        return \"android.intent.action.PROCESS_TEXT\".equalsIgnoreCase(intent.getAction());\n-    }\n-\n-    private void updatePreviewMenuItem() {\n-        if (mPreviewItem == null) {\n-            return;\n-        }\n-        mPreviewItem.setVisible(getCardCount() > 0);\n-    }\n-\n-    /** Returns the number of cards that are visible on the screen */\n-    public int getCardCount() {\n-        return getCards().size();\n-    }\n-\n-\n-    private void updateMultiselectMenu() {\n-        Timber.d(\"updateMultiselectMenu()\");\n-        if (mActionBarMenu == null || mActionBarMenu.findItem(R.id.action_suspend_card) == null) {\n-            return;\n-        }\n-\n-        if (!mCheckedCards.isEmpty()) {\n-            TaskManager.cancelAllTasks(CollectionTask.CheckCardSelection.class);\n-            TaskManager.launchCollectionTask(new CollectionTask.CheckCardSelection(mCheckedCards),\n-                    mCheckSelectedCardsHandler);\n-        }\n-\n-        mActionBarMenu.findItem(R.id.action_select_all).setVisible(!hasSelectedAllCards());\n-        //Note: Theoretically should not happen, as this should kick us back to the menu\n-        mActionBarMenu.findItem(R.id.action_select_none).setVisible(hasSelectedCards());\n-        mActionBarMenu.findItem(R.id.action_edit_note).setVisible(canPerformMultiSelectEditNote());\n-        mActionBarMenu.findItem(R.id.action_view_card_info).setVisible(canPerformCardInfo());\n-    }\n-\n-\n-    private boolean hasSelectedCards() {\n-        return !mCheckedCards.isEmpty();\n-    }\n-\n-    private boolean hasSelectedAllCards() {\n-        return checkedCardCount() >= getCardCount(); //must handle 0.\n-    }\n-\n-\n-    @VisibleForTesting\n-    public void flagTask (int flag) {\n-        TaskManager.launchCollectionTask(\n-                new CollectionTask.Flag(getSelectedCardIds(), flag),\n-                flagCardHandler());\n-    }\n-\n-    /** Updates flag icon color and cards shown with given color */\n-    private void selectionWithFlagTask(int flag) {\n-        mCurrentFlag = flag;\n-        filterByFlag();\n-    }\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-\n-        // dismiss undo-snackbar if shown to avoid race condition\n-        // (when another operation will be performed on the model, it will undo the latest operation)\n-        if (mUndoSnackbar != null && mUndoSnackbar.isShown())\n-            mUndoSnackbar.dismiss();\n-\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            endMultiSelectMode();\n-            return true;\n-        } else if (itemId == R.id.action_add_note_from_card_browser) {\n-            addNoteFromCardBrowser();\n-            return true;\n-        } else if (itemId == R.id.action_save_search) {\n-            String searchTerms = mSearchView.getQuery().toString();\n-            showDialogFragment(CardBrowserMySearchesDialog.newInstance(null, mMySearchesDialogListener,\n-                    searchTerms, CardBrowserMySearchesDialog.CARD_BROWSER_MY_SEARCHES_TYPE_SAVE));\n-            return true;\n-        } else if (itemId == R.id.action_list_my_searches) {\n-            JSONObject savedFiltersObj = getCol().get_config(\"savedFilters\", (JSONObject) null);\n-            HashMap<String, String> savedFilters;\n-            if (savedFiltersObj != null) {\n-                savedFilters = HashUtil.HashMapInit(savedFiltersObj.length());\n-                for (String searchName : savedFiltersObj) {\n-                    savedFilters.put(searchName, savedFiltersObj.optString(searchName));\n-                }\n-            } else {\n-                savedFilters = HashUtil.HashMapInit(0);\n-            }\n-            showDialogFragment(CardBrowserMySearchesDialog.newInstance(savedFilters, mMySearchesDialogListener,\n-                    \"\", CardBrowserMySearchesDialog.CARD_BROWSER_MY_SEARCHES_TYPE_LIST));\n-            return true;\n-        } else if (itemId == R.id.action_sort_by_size) {\n-            showDialogFragment(CardBrowserOrderDialog\n-                    .newInstance(mOrder, mOrderAsc, mOrderDialogListener));\n-            return true;\n-        } else if (itemId == R.id.action_show_marked) {\n-            mSearchTerms = \"tag:marked\";\n-            mSearchView.setQuery(\"\", false);\n-            mSearchView.setQueryHint(getResources().getString(R.string.card_browser_show_marked));\n-            searchCards();\n-            return true;\n-        } else if (itemId == R.id.action_show_suspended) {\n-            mSearchTerms = \"is:suspended\";\n-            mSearchView.setQuery(\"\", false);\n-            mSearchView.setQueryHint(getResources().getString(R.string.card_browser_show_suspended));\n-            searchCards();\n-            return true;\n-        } else if (itemId == R.id.action_search_by_tag) {\n-            showTagsDialog();\n-            return true;\n-        } else if (itemId == R.id.action_flag_zero) {\n-            flagTask(0);\n-            return true;\n-        } else if (itemId == R.id.action_flag_one) {\n-            flagTask(1);\n-            return true;\n-        } else if (itemId == R.id.action_flag_two) {\n-            flagTask(2);\n-            return true;\n-        } else if (itemId == R.id.action_flag_three) {\n-            flagTask(3);\n-            return true;\n-        } else if (itemId == R.id.action_flag_four) {\n-            flagTask(4);\n-            return true;\n-        } else if (itemId == R.id.action_flag_five) {\n-            flagTask(5);\n-            return true;\n-        } else if (itemId == R.id.action_flag_six) {\n-            flagTask(6);\n-            return true;\n-        } else if (itemId == R.id.action_flag_seven) {\n-            flagTask(7);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_zero) {\n-            selectionWithFlagTask(0);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_one) {\n-            selectionWithFlagTask(1);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_two) {\n-            selectionWithFlagTask(2);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_three) {\n-            selectionWithFlagTask(3);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_four) {\n-            selectionWithFlagTask(4);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_five) {\n-            selectionWithFlagTask(5);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_six) {\n-            selectionWithFlagTask(6);\n-            return true;\n-        } else if (itemId == R.id.action_select_flag_seven) {\n-            selectionWithFlagTask(7);\n-            return true;\n-        } else if (itemId == R.id.action_delete_card) {\n-            deleteSelectedNote();\n-            return true;\n-        } else if (itemId == R.id.action_mark_card) {\n-            toggleMark();\n-\n-            return true;\n-        } else if (itemId == R.id.action_suspend_card) {\n-            TaskManager.launchCollectionTask(new CollectionTask.SuspendCardMulti(getSelectedCardIds()),\n-                    suspendCardHandler());\n-\n-            return true;\n-        } else if (itemId == R.id.action_change_deck) {\n-            showChangeDeckDialog();\n-            return true;\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.w(\"CardBrowser:: Undo pressed\");\n-            onUndo();\n-            return true;\n-        } else if (itemId == R.id.action_select_none) {\n-            onSelectNone();\n-            return true;\n-        } else if (itemId == R.id.action_select_all) {\n-            onSelectAll();\n-            return true;\n-        } else if (itemId == R.id.action_preview) {\n-            onPreview();\n-            return true;\n-        } else if (itemId == R.id.action_reset_cards_progress) {\n-            Timber.i(\"NoteEditor:: Reset progress button pressed\");\n-            onResetProgress();\n-            return true;\n-        } else if (itemId == R.id.action_reschedule_cards) {\n-            Timber.i(\"CardBrowser:: Reschedule button pressed\");\n-            rescheduleSelectedCards();\n-            return true;\n-        } else if (itemId == R.id.action_reposition_cards) {\n-            Timber.i(\"CardBrowser:: Reposition button pressed\");\n-\n-            // Only new cards may be repositioned\n-            List<Long> cardIds = getSelectedCardIds();\n-            for (long cardId : cardIds) {\n-                if (getCol().getCard(cardId).getQueue() != Consts.QUEUE_TYPE_NEW) {\n-                    SimpleMessageDialog dialog = SimpleMessageDialog.newInstance(\n-                            getString(R.string.vague_error),\n-                            getString(R.string.reposition_card_not_new_error),\n-                            false);\n-                    showDialogFragment(dialog);\n-                    return false;\n-                }\n-            }\n-\n-            IntegerDialog repositionDialog = new IntegerDialog();\n-            repositionDialog.setArgs(\n-                    getString(R.string.reposition_card_dialog_title),\n-                    getString(R.string.reposition_card_dialog_message),\n-                    5);\n-            repositionDialog.setCallbackRunnable(position -> repositionCardsNoValidation(cardIds, position));\n-            showDialogFragment(repositionDialog);\n-            return true;\n-        } else if (itemId == R.id.action_edit_note) {\n-            openNoteEditorForCurrentlySelectedNote();\n-\n-\n-            return super.onOptionsItemSelected(item);\n-        } else if (itemId == R.id.action_view_card_info) {\n-            List<Long> selectedCardIds = getSelectedCardIds();\n-            if (!selectedCardIds.isEmpty()) {\n-                Intent intent = new Intent(this, CardInfo.class);\n-                intent.putExtra(\"cardId\", selectedCardIds.get(0));\n-                startActivityWithAnimation(intent, FADE);\n-            }\n-            return true;\n-        }\n-        return super.onOptionsItemSelected(item);\n-    }\n-\n-\n-    protected void deleteSelectedNote() {\n-        if (!mInMultiSelectMode) {\n-            return;\n-        }\n-        TaskManager.launchCollectionTask(new CollectionTask.DeleteNoteMulti(getSelectedCardIds()),\n-                                            mDeleteNoteHandler);\n-\n-        mCheckedCards.clear();\n-        endMultiSelectMode();\n-        mCardsAdapter.notifyDataSetChanged();\n-    }\n-\n-\n-    @VisibleForTesting\n-    void onUndo() {\n-        if (getCol().undoAvailable()) {\n-            new UndoService.Undo().runWithHandler(mUndoHandler);\n-        }\n-    }\n-\n-\n-    protected void onResetProgress() {\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getString(R.string.reset_card_dialog_title);\n-        String message = getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"CardBrowser:: ResetProgress button pressed\");\n-            resetProgressNoConfirm(getSelectedCardIds());\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    @VisibleForTesting\n-    void resetProgressNoConfirm(List<Long> cardIds) {\n-        TaskManager.launchCollectionTask(new SchedulerService.ResetCards(cardIds).toDelegate(), resetProgressCardHandler());\n-    }\n-\n-\n-    @VisibleForTesting\n-    void repositionCardsNoValidation(List<Long> cardIds, Integer position) {\n-        TaskManager.launchCollectionTask(new SchedulerService.RepositionCards(cardIds, position).toDelegate(),\n-                                            repositionCardHandler());\n-    }\n-\n-\n-    protected void onPreview() {\n-        Intent previewer = getPreviewIntent();\n-        this.launchActivityForResultWithoutAnimation(previewer, mOnPreviewCardsActivityResult);\n-    }\n-\n-\n-    @NonNull\n-    @VisibleForTesting\n-    Intent getPreviewIntent() {\n-        if (mInMultiSelectMode && checkedCardCount() > 1) {\n-            // Multiple cards have been explicitly selected, so preview only those cards\n-            int index = 0;\n-            return getPreviewIntent(index, Utils.toPrimitive(getSelectedCardIds()));\n-        } else {\n-            // Preview all cards, starting from the one that is currently selected\n-            int startIndex = mCheckedCards.isEmpty() ? 0 : mCheckedCards.iterator().next().getPosition();\n-            return getPreviewIntent(startIndex, getAllCardIds());\n-        }\n-    }\n-\n-\n-    @NonNull\n-    private Intent getPreviewIntent(int index, long[] selectedCardIds) {\n-        return Previewer.getPreviewIntent(CardBrowser.this, index, selectedCardIds);\n-    }\n-\n-\n-    private void rescheduleSelectedCards() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Attempted reschedule - no cards selected\");\n-            return;\n-        }\n-\n-        List<Long> selectedCardIds = getSelectedCardIds();\n-        FunctionalInterfaces.Consumer<Integer> consumer = newDays -> rescheduleWithoutValidation(selectedCardIds, newDays);\n-        RescheduleDialog rescheduleDialog;\n-        if (selectedCardIds.size() == 1) {\n-            long cardId = selectedCardIds.get(0);\n-            Card selected = getCol().getCard(cardId);\n-            rescheduleDialog = RescheduleDialog.rescheduleSingleCard(getResources(), selected, consumer);\n-        } else {\n-            rescheduleDialog = RescheduleDialog.rescheduleMultipleCards(getResources(),\n-                    consumer,\n-                    selectedCardIds.size());\n-        }\n-        showDialogFragment(rescheduleDialog);\n-    }\n-\n-\n-    @VisibleForTesting\n-    void rescheduleWithoutValidation(List<Long> selectedCardIds, Integer newDays) {\n-        TaskManager.launchCollectionTask(new SchedulerService.RescheduleCards(selectedCardIds, newDays).toDelegate(),\n-            rescheduleCardHandler());\n-    }\n-\n-\n-    private void showChangeDeckDialog() {\n-        if (!hasSelectedCards()) {\n-            Timber.i(\"Not showing Change Deck - No Cards\");\n-            return;\n-        }\n-\n-        AlertDialog.Builder builderSingle = new AlertDialog.Builder(this);\n-        builderSingle.setTitle(getString(R.string.move_all_to_deck));\n-\n-        //WARNING: changeDeck depends on this index, so any changes should be reflected there.\n-        final ArrayAdapter<String> arrayAdapter = new ArrayAdapter<>(this, R.layout.dropdown_deck_item);\n-        for (Deck deck : getValidDecksForChangeDeck()) {\n-            try {\n-                arrayAdapter.add(deck.getString(\"name\"));\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-            }\n-        }\n-\n-        builderSingle.setNegativeButton(getString(R.string.dialog_cancel), (dialog, which) -> dialog.dismiss());\n-        builderSingle.setAdapter(arrayAdapter, (dialog, which) -> moveSelectedCardsToDeck(which));\n-        builderSingle.show();\n-    }\n-\n-\n-    @VisibleForTesting\n-    Intent getAddNoteIntent() {\n-        Intent intent = new Intent(CardBrowser.this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_CARDBROWSER_ADD);\n-        Long did = getLastDeckId();\n-        if (did != null && did > 0) {\n-            intent.putExtra(NoteEditor.EXTRA_DID, (long) did);\n-        }\n-        intent.putExtra(NoteEditor.EXTRA_TEXT_FROM_SEARCH_VIEW, mSearchTerms);\n-        return intent;\n-    }\n-\n-    private void addNoteFromCardBrowser() {\n-        this.launchActivityForResultWithAnimation(getAddNoteIntent(), mOnAddNoteActivityResult, START);\n-    }\n-\n-\n-    // We spawn CollectionTasks that may create memory pressure, this transmits it so polling isCancelled sees the pressure\n-    @Override\n-    public void onTrimMemory(int pressureLevel) {\n-        super.onTrimMemory(pressureLevel);\n-        TaskManager.cancelCurrentlyExecutingTask();\n-    }\n-\n-    private long getReviewerCardId() {\n-        if (getIntent().hasExtra(\"currentCard\")) {\n-            return getIntent().getExtras().getLong(\"currentCard\");\n-        } else {\n-            return -1;\n-        }\n-    }\n-\n-    private void showTagsDialog() {\n-        TagsDialog dialog = mTagsDialogFactory.newTagsDialog().withArguments(\n-                TagsDialog.DialogType.FILTER_BY_TAG, new ArrayList<>(0), new ArrayList<>(getCol().getTags().all()));\n-        showDialogFragment(dialog);\n-    }\n-\n-    @Override\n-    public void onSaveInstanceState(@NonNull Bundle savedInstanceState) {\n-        // Save current search terms\n-        savedInstanceState.putString(\"mSearchTerms\", mSearchTerms);\n-        savedInstanceState.putLong(\"mOldCardId\", mOldCardId);\n-        savedInstanceState.putInt(\"mOldCardTopOffset\", mOldCardTopOffset);\n-        savedInstanceState.putBoolean(\"mShouldRestoreScroll\", mShouldRestoreScroll);\n-        savedInstanceState.putBoolean(\"mPostAutoScroll\", mPostAutoScroll);\n-        savedInstanceState.putInt(\"mLastSelectedPosition\", mLastSelectedPosition);\n-        savedInstanceState.putBoolean(\"mInMultiSelectMode\", mInMultiSelectMode);\n-        super.onSaveInstanceState(savedInstanceState);\n-    }\n-\n-    @Override\n-    public void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {\n-        super.onRestoreInstanceState(savedInstanceState);\n-        mSearchTerms = savedInstanceState.getString(\"mSearchTerms\");\n-        mOldCardId = savedInstanceState.getLong(\"mOldCardId\");\n-        mOldCardTopOffset = savedInstanceState.getInt(\"mOldCardTopOffset\");\n-        mShouldRestoreScroll = savedInstanceState.getBoolean(\"mShouldRestoreScroll\");\n-        mPostAutoScroll = savedInstanceState.getBoolean(\"mPostAutoScroll\");\n-        mLastSelectedPosition = savedInstanceState.getInt(\"mLastSelectedPosition\");\n-        mInMultiSelectMode = savedInstanceState.getBoolean(\"mInMultiSelectMode\");\n-        searchCards();\n-    }\n-\n-    private void invalidate() {\n-        TaskManager.cancelAllTasks(CollectionTask.SearchCards.class);\n-        TaskManager.cancelAllTasks(CollectionTask.RenderBrowserQA.class);\n-        TaskManager.cancelAllTasks(CollectionTask.CheckCardSelection.class);\n-        mCards.clear();\n-        mCheckedCards.clear();\n-    }\n-\n-    /** Currently unused - to be used in #7676 */\n-    private void forceRefreshSearch() {\n-        searchCards();\n-    }\n-\n-\n-    private void searchCards() {\n-        // cancel the previous search & render tasks if still running\n-        invalidate();\n-        String searchText;\n-        if (mSearchTerms == null) {\n-            mSearchTerms = \"\";\n-        }\n-        if (!\"\".equals(mSearchTerms) && (mSearchView != null)) {\n-            mSearchView.setQuery(mSearchTerms, false);\n-            mSearchItem.expandActionView();\n-        }\n-        if (mSearchTerms.contains(\"deck:\")) {\n-            searchText = \"(\" + mSearchTerms + \")\";\n-        } else {\n-            if (!\"\".equals(mSearchTerms))\n-                searchText = mRestrictOnDeck + \"(\" + mSearchTerms + \")\";\n-            else\n-                searchText = mRestrictOnDeck;\n-        }\n-        if (colIsOpen() && mCardsAdapter!= null) {\n-            // clear the existing card list\n-            mCards.reset();\n-            mCardsAdapter.notifyDataSetChanged();\n-            //  estimate maximum number of cards that could be visible (assuming worst-case minimum row height of 20dp)\n-            // Perform database query to get all card ids\n-            TaskManager.launchCollectionTask(new CollectionTask.SearchCards(searchText,\n-                            (mOrder != CARD_ORDER_NONE),\n-                            numCardsToRender(),\n-                            mColumn1Index,\n-                            mColumn2Index),\n-                    mSearchCardsHandler\n-            );\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    protected int numCardsToRender() {\n-        return (int) Math.ceil(mCardsListView.getHeight() /\n-                TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, getResources().getDisplayMetrics())) + 5;\n-    }\n-\n-    private void updateList() {\n-        if (colIsOpen() && mCardsAdapter!= null) {\n-            mCardsAdapter.notifyDataSetChanged();\n-            mDeckSpinnerSelection.notifyDataSetChanged();\n-            onSelectionChanged();\n-            updatePreviewMenuItem();\n-        }\n-    }\n-\n-    /**\n-     * @return text to be used in the subtitle of the drop-down deck selector\n-     */\n-    public String getSubtitleText() {\n-        int count = getCardCount();\n-        return getResources().getQuantityString(R.plurals.card_browser_subtitle, count, count);\n-    }\n-\n-\n-    private static Map<Long, Integer> getPositionMap(CardCollection<CardCache> list) {\n-        Map<Long, Integer> positions = HashUtil.HashMapInit(list.size());\n-        for (int i = 0; i < list.size(); i++) {\n-            positions.put(list.get(i).getId(), i);\n-        }\n-        return positions;\n-    }\n-\n-    // convenience method for updateCardsInList(...)\n-    private void updateCardInList(Card card) {\n-        List<Card> cards = new ArrayList<>(1);\n-        cards.add(card);\n-        updateCardsInList(cards);\n-    }\n-\n-    /** Returns the decks which are valid targets for \"Change Deck\" */\n-    @VisibleForTesting\n-    List<Deck> getValidDecksForChangeDeck() {\n-        List<Deck> nonDynamicDecks = new ArrayList<>(mDeckSpinnerSelection.getDropDownDecks().size());\n-        for (Deck d : mDeckSpinnerSelection.getDropDownDecks()) {\n-            if (Decks.isDynamic(d)) {\n-                continue;\n-            }\n-            nonDynamicDecks.add(d);\n-        }\n-        return nonDynamicDecks;\n-    }\n-\n-\n-    @Override\n-    public void onSelectedTags(List<String> selectedTags, int option) {\n-        //TODO: Duplication between here and CustomStudyDialog:onSelectedTags\n-        mSearchView.setQuery(\"\", false);\n-        String tags = selectedTags.toString();\n-        mSearchView.setQueryHint(getResources().getString(R.string.CardEditorTags,\n-                tags.substring(1, tags.length() - 1)));\n-        StringBuilder sb = new StringBuilder();\n-        switch (option) {\n-            case 1:\n-                sb.append(\"is:new \");\n-                break;\n-            case 2:\n-                sb.append(\"is:due \");\n-                break;\n-            default:\n-                // Logging here might be appropriate : )\n-                break;\n-        }\n-        int i = 0;\n-        for (String tag : selectedTags) {\n-            if (i != 0) {\n-                sb.append(\"or \");\n-            } else {\n-                sb.append(\"(\"); // Only if we really have selected tags\n-            }\n-            // 7070: quote tags so brackets are properly escaped\n-            sb.append(\"tag:\").append(\"'\").append(tag).append(\"'\").append(\" \");\n-            i++;\n-        }\n-        if (i > 0) {\n-            sb.append(\")\"); // Only if we added anything to the tag list\n-        }\n-        mSearchTerms = sb.toString();\n-        searchCards();\n-    }\n-\n-\n-    /** Updates search terms to only show cards with selected flag. */\n-    private void filterByFlag() {\n-        mSearchView.setQuery(\"\", false);\n-        String flagSearchTerm = \"flag:\" + mCurrentFlag;\n-        if (mSearchTerms.contains(\"flag:\")) {\n-            mSearchTerms = mSearchTerms.replaceFirst(\"flag:.\", flagSearchTerm);\n-        }\n-        else if (!mSearchTerms.isEmpty()) {\n-            mSearchTerms = flagSearchTerm + \" \" + mSearchTerms;\n-        } else {\n-            mSearchTerms = flagSearchTerm;\n-        }\n-        searchCards();\n-    }\n-\n-\n-    private static abstract class ListenerWithProgressBar<Progress, Result> extends TaskListenerWithContext<CardBrowser, Progress, Result>{\n-        public ListenerWithProgressBar(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            browser.showProgressBar();\n-        }\n-    }\n-\n-    /** Does not leak Card Browser. */\n-    private static abstract class ListenerWithProgressBarCloseOnFalse<Progress, Result extends Computation<?>> extends ListenerWithProgressBar<Progress, Result> {\n-        private final String mTimber;\n-        public ListenerWithProgressBarCloseOnFalse(String timber, CardBrowser browser) {\n-            super(browser);\n-            mTimber = timber;\n-        }\n-\n-        public ListenerWithProgressBarCloseOnFalse(CardBrowser browser) {\n-            this(null, browser);\n-\t\t}\n-\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Result result) {\n-            if (mTimber != null) {\n-                Timber.d(mTimber);\n-            }\n-            if (result.succeeded()) {\n-                actualOnValidPostExecute(browser, result);\n-            } else {\n-                browser.closeCardBrowser(DeckPicker.RESULT_DB_ERROR);\n-            }\n-        }\n-\n-        protected abstract void actualOnValidPostExecute(CardBrowser browser, Result result);\n-    }\n-\n-    /**\n-     * @param cards Cards that were changed\n-     */\n-    private void updateCardsInList(List<Card> cards) {\n-        CardCollection<CardCache> cardList = getCards();\n-        Map<Long, Integer> idToPos = getPositionMap(cardList);\n-        for (Card c : cards) {\n-            // get position in the mCards search results HashMap\n-            Integer pos = idToPos.get(c.getId());\n-            if (pos == null || pos >= getCardCount()) {\n-                continue;\n-            }\n-            // update Q & A etc\n-            cardList.get(pos).load(true, mColumn1Index, mColumn2Index);\n-        }\n-\n-        updateList();\n-    }\n-\n-    private UpdateCardHandler updateCardHandler() {\n-        return new UpdateCardHandler(this);\n-    }\n-\n-    private static class UpdateCardHandler extends ListenerWithProgressBarCloseOnFalse<Card, Computation<?>> {\n-        public UpdateCardHandler(CardBrowser browser) {\n-            super(\"Card Browser - UpdateCardHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Card value) {\n-            browser.updateCardInList(value);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-    private static class ChangeDeckHandler extends ListenerWithProgressBarCloseOnFalse<Object, Computation<? extends Card[]>> {\n-        public ChangeDeckHandler(CardBrowser browser) {\n-            super(\"Card Browser - changeDeckHandler.actualOnPostExecute(CardBrowser browser)\", browser);\n-        }\n-\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> result) {\n-            browser.hideProgressBar();\n-\n-            browser.searchCards();\n-            browser.endMultiSelectMode();\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-\n-            if (!result.succeeded()) {\n-                Timber.i(\"changeDeckHandler failed, not offering undo\");\n-                browser.displayCouldNotChangeDeck();\n-                return;\n-            }\n-            // snackbar to offer undo\n-            String deckName = browser.getCol().getDecks().name(browser.mNewDid);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(\n-                    browser,\n-                    String.format(browser.getString(R.string.changed_deck_message), deckName),\n-                    SNACKBAR_DURATION,\n-                    R.string.undo,\n-                    v -> TaskManager.launchCollectionTask(new UndoService.Undo().toDelegate(), browser.mUndoHandler),\n-                    browser.mCardsListView, null);\n-        }\n-    }\n-\n-\n-    @CheckResult\n-    private static String formatQA(String text, Context context) {\n-        boolean showFilenames = AnkiDroidApp.getSharedPrefs(context).getBoolean(\"card_browser_show_media_filenames\", false);\n-        return formatQAInternal(text, showFilenames);\n-    }\n-\n-\n-    /**\n-     * @param txt The text to strip HTML, comments, tags and media from\n-     * @param showFileNames Whether [sound:foo.mp3] should be rendered as \" foo.mp3 \" or  \" \"\n-     * @return The formatted string\n-     */\n-    @VisibleForTesting\n-    @CheckResult\n-    static String formatQAInternal(String txt, boolean showFileNames) {\n-        /* Strips all formatting from the string txt for use in displaying question/answer in browser */\n-        String s = txt;\n-        s = s.replaceAll(\"<!--.*?-->\", \"\");\n-        s = s.replace(\"<br>\", \" \");\n-        s = s.replace(\"<br />\", \" \");\n-        s = s.replace(\"<div>\", \" \");\n-        s = s.replace(\"\\n\", \" \");\n-        s = showFileNames ? Utils.stripSoundMedia(s) : Utils.stripSoundMedia(s, \" \");\n-        s = s.replaceAll(\"\\\\[\\\\[type:[^]]+]]\", \"\");\n-        s = showFileNames ? Utils.stripHTMLMedia(s) : Utils.stripHTMLMedia(s, \" \");\n-        s = s.trim();\n-        return s;\n-    }\n-\n-    /**\n-     * Removes cards from view. Doesn't delete them in model (database).\n-     */\n-    @SuppressWarnings(\"SameParameterValue\")\n-    private void removeNotesView(Card[] cards, boolean reorderCards) {\n-        List<Long> cardIds = new ArrayList<>(cards.length);\n-        for (Card c : cards) {\n-            cardIds.add(c.getId());\n-        }\n-        removeNotesView(cardIds, reorderCards);\n-    }\n-\n-    /**\n-     * Removes cards from view. Doesn't delete them in model (database).\n-     * @param reorderCards Whether to rearrange the positions of checked items (DEFECT: Currently deselects all)\n-     */\n-    private void removeNotesView(java.util.Collection<Long> cardsIds, boolean reorderCards) {\n-        long reviewerCardId = getReviewerCardId();\n-        CardCollection<CardCache> oldMCards = getCards();\n-        Map<Long, Integer> idToPos = getPositionMap(oldMCards);\n-        Set<Long> idToRemove = new HashSet<>();\n-        for (Long cardId : cardsIds) {\n-            if (cardId == reviewerCardId) {\n-                mReloadRequired = true;\n-            }\n-            if (idToPos.containsKey(cardId)) {\n-                idToRemove.add(cardId);\n-            }\n-        }\n-\n-        List<CardCache> newMCards = new ArrayList<>(oldMCards.size());\n-        int pos = 0;\n-        for (CardCache card: oldMCards) {\n-            if (!idToRemove.contains(card.getId())) {\n-                newMCards.add(new CardCache(card, pos++));\n-            }\n-        }\n-        mCards.replaceWith(newMCards);\n-\n-        if (reorderCards) {\n-            //Suboptimal from a UX perspective, we should reorder\n-            //but this is only hit on a rare sad path and we'd need to rejig the data structures to allow an efficient\n-            //search\n-            Timber.w(\"Removing current selection due to unexpected removal of cards\");\n-            onSelectNone();\n-        }\n-\n-        updateList();\n-    }\n-\n-    private SuspendCardHandler suspendCardHandler() {\n-        return new SuspendCardHandler(this);\n-    }\n-\n-    private static class SuspendCardHandler extends ListenerWithProgressBarCloseOnFalse<Void, Computation<? extends Card[]>> {\n-        public SuspendCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> cards) {\n-            browser.updateCardsInList(Arrays.asList(cards.getValue()));\n-            browser.hideProgressBar();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-    private FlagCardHandler flagCardHandler(){\n-        return new FlagCardHandler(this);\n-    }\n-    private static class FlagCardHandler extends SuspendCardHandler {\n-        public FlagCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-    }\n-\n-\n-    private MarkCardHandler markCardHandler() {\n-        return new MarkCardHandler(this);\n-    }\n-    private static class MarkCardHandler extends ListenerWithProgressBarCloseOnFalse<Void, Computation<? extends Card[]>> {\n-        public MarkCardHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<? extends Card[]> cards) {\n-            browser.updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards.getValue()))));\n-            browser.hideProgressBar();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-\n-    private final DeleteNoteHandler mDeleteNoteHandler = new DeleteNoteHandler(this);\n-    private static class DeleteNoteHandler extends ListenerWithProgressBarCloseOnFalse<Card[], Computation<?>> {\n-        public DeleteNoteHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        private int mCardsDeleted = -1;\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            super.actualOnPreExecute(browser);\n-            browser.invalidate();\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Card[] cards) {\n-            //we don't need to reorder cards here as we've already deselected all notes,\n-            browser.removeNotesView(cards, false);\n-            mCardsDeleted = cards.length;\n-        }\n-\n-\n-        @Override\n-        protected void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            browser.hideProgressBar();\n-            browser.mActionBarTitle.setText(String.format(getLocaleCompat(browser.getResources()), \"%d\", browser.checkedCardCount()));\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-            // snackbar to offer undo\n-            String deletedMessage = browser.getResources().getQuantityString(R.plurals.card_browser_cards_deleted, mCardsDeleted, mCardsDeleted);\n-            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, deletedMessage, SNACKBAR_DURATION,\n-                    R.string.undo, v -> new UndoService.Undo().runWithHandler(browser.mUndoHandler),\n-                    browser.mCardsListView, null);\n-            browser.searchCards();\n-        }\n-    }\n-\n-\n-\n-    private final UndoHandler mUndoHandler = new UndoHandler(this);\n-    private static class UndoHandler extends ListenerWithProgressBarCloseOnFalse<Card, Computation<?>> {\n-        public UndoHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnValidPostExecute(CardBrowser browser, Computation<?> result) {\n-            Timber.d(\"Card Browser - mUndoHandler.actualOnPostExecute(CardBrowser browser)\");\n-            browser.hideProgressBar();\n-            // reload whole view\n-            browser.forceRefreshSearch();\n-            browser.endMultiSelectMode();\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-            browser.updatePreviewMenuItem();\n-            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n-        }\n-    }\n-\n-\n-\n-    private final SearchCardsHandler mSearchCardsHandler = new SearchCardsHandler(this);\n-    @VisibleForTesting\n-    class SearchCardsHandler extends ListenerWithProgressBar<List<CardCache>, List<CardCache>> {\n-        public SearchCardsHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, List<CardCache> cards) {\n-            // Need to copy the list into a new list, because the original list is modified, and\n-            // ListAdapter crash\n-            mCards.replaceWith(new ArrayList<>(cards));\n-            updateList();\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, List<CardCache> result) {\n-            if (result != null) {\n-                mCards.replaceWith(result);\n-                updateList();\n-                handleSearchResult();\n-            }\n-            if (mShouldRestoreScroll) {\n-                mShouldRestoreScroll = false;\n-                int newPosition = getNewPositionOfSelectedCard();\n-                boolean isRestorePossible = (newPosition != CARD_NOT_AVAILABLE);\n-                if (isRestorePossible) {\n-                    autoScrollTo(newPosition);\n-                }\n-            }\n-            updatePreviewMenuItem();\n-            hideProgressBar();\n-        }\n-\n-\n-        private void handleSearchResult() {\n-            Timber.i(\"CardBrowser:: Completed doInBackgroundSearchCards Successfully\");\n-            updateList();\n-            \n-            if ((mSearchView == null) || mSearchView.isIconified()) {\n-                return;\n-            }\n-\n-            if (hasSelectedAllDecks()) {\n-                UIUtils.showSimpleSnackbar(CardBrowser.this, getSubtitleText(), true);\n-                return;\n-            }\n-\n-            //If we haven't selected all decks, allow the user the option to search all decks.\n-            String displayText;\n-            if (getCardCount() == 0) {\n-                displayText = getString(R.string.card_browser_no_cards_in_deck, getSelectedDeckNameForUi());\n-            } else {\n-                displayText = getSubtitleText();\n-            }\n-            View root = CardBrowser.this.findViewById(R.id.root_layout);\n-            UIUtils.showSnackbar(CardBrowser.this,\n-                    displayText,\n-                    SNACKBAR_DURATION,\n-                    R.string.card_browser_search_all_decks,\n-                    (v) -> searchAllDecks(),\n-                    root,\n-                    null);\n-\n-        }\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            super.actualOnCancelled(browser);\n-            hideProgressBar();\n-        }\n-    }\n-\n-\n-    private void saveScrollingState(int position) {\n-        mOldCardId = getCards().get(position).getId();\n-        mOldCardTopOffset = calculateTopOffset(position);\n-    }\n-\n-    private void autoScrollTo(int newPosition) {\n-        mCardsListView.setSelectionFromTop(newPosition, mOldCardTopOffset);\n-        mPostAutoScroll = true;\n-    }\n-\n-    private int calculateTopOffset(int cardPosition) {\n-        int firstVisiblePosition = mCardsListView.getFirstVisiblePosition();\n-        View v = mCardsListView.getChildAt(cardPosition - firstVisiblePosition);\n-        return (v == null) ? 0 : v.getTop();\n-    }\n-\n-    private int getNewPositionOfSelectedCard() {\n-        if (mCards.size() == 0) {\n-            return CARD_NOT_AVAILABLE;\n-        }\n-        for (CardCache card : mCards) {\n-            if (card.getId() == mOldCardId) {\n-                return card.mPosition;\n-            }\n-        }\n-        return CARD_NOT_AVAILABLE;\n-    }\n-\n-    public boolean hasSelectedAllDecks() {\n-        Long lastDeckId = getLastDeckId();\n-        return lastDeckId != null && lastDeckId == ALL_DECKS_ID;\n-    }\n-\n-\n-    public void searchAllDecks() {\n-        //all we need to do is select all decks\n-        selectAllDecks();\n-    }\n-\n-    /**\n-     * Returns the current deck name, \"All Decks\" if all decks are selected, or \"Unknown\"\n-     * Do not use this for any business logic, as this will return inconsistent data\n-     * with the collection.\n-     */\n-    public String getSelectedDeckNameForUi() {\n-        try {\n-            Long lastDeckId = getLastDeckId();\n-            if (lastDeckId == null) {\n-                return getString(R.string.card_browser_unknown_deck_name);\n-            }\n-            if (lastDeckId == ALL_DECKS_ID) {\n-                return getString(R.string.card_browser_all_decks);\n-            }\n-            return getCol().getDecks().name(lastDeckId);\n-        } catch (Exception e) {\n-            Timber.w(e, \"Unable to get selected deck name\");\n-            return getString(R.string.card_browser_unknown_deck_name);\n-        }\n-    }\n-\n-    private final RenderQAHandler mRenderQAHandler = new RenderQAHandler(this);\n-    private static class RenderQAHandler extends TaskListenerWithContext<CardBrowser, Integer, Pair<CardCollection<CardBrowser.CardCache>, List<Long>>>{\n-        public RenderQAHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnProgressUpdate(@NonNull CardBrowser browser, Integer value) {\n-            // Note: This is called every time a card is rendered.\n-            // It blocks the long-click callback while the task is running, so usage of the task should be minimized\n-            browser.mCardsAdapter.notifyDataSetChanged();\n-        }\n-\n-\n-        @Override\n-        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n-            Timber.d(\"Starting Q&A background rendering\");\n-        }\n-\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Pair<CardCollection<CardBrowser.CardCache>, List<Long>> value) {\n-            List<Long> cardsIdsToHide = value.second;\n-            if (cardsIdsToHide != null) {\n-                    try {\n-                        if (!cardsIdsToHide.isEmpty()) {\n-                            Timber.i(\"Removing %d invalid cards from view\", cardsIdsToHide.size());\n-                            browser.removeNotesView(cardsIdsToHide, true);\n-                        }\n-                    } catch (Exception e) {\n-                        Timber.e(e, \"failed to hide cards\");\n-                    }\n-                browser.hideProgressBar();\n-                browser.mCardsAdapter.notifyDataSetChanged();\n-                Timber.d(\"Completed doInBackgroundRenderBrowserQA Successfuly\");\n-            } else {\n-                // Might want to do something more proactive here like show a message box?\n-                Timber.e(\"doInBackgroundRenderBrowserQA was not successful... continuing anyway\");\n-            }\n-        }\n-\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-\n-    private final CheckSelectedCardsHandler mCheckSelectedCardsHandler = new CheckSelectedCardsHandler(this);\n-    private static class CheckSelectedCardsHandler extends ListenerWithProgressBar<Void, Pair<Boolean, Boolean>> {\n-        public CheckSelectedCardsHandler(CardBrowser browser) {\n-            super(browser);\n-        }\n-\n-        @Override\n-        public void actualOnPostExecute(@NonNull CardBrowser browser, Pair<Boolean, Boolean> result) {\n-            if (result == null) {\n-                return;\n-            }\n-            browser.hideProgressBar();\n-\n-            if (browser.mActionBarMenu != null) {\n-                boolean hasUnsuspended = result.first;\n-                boolean hasUnmarked = result.second;\n-\n-                setMenuIcons(browser, hasUnsuspended, hasUnmarked, browser.mActionBarMenu);\n-            }\n-        }\n-\n-\n-        protected void setMenuIcons(@NonNull Context browser, boolean hasUnsuspended, boolean hasUnmarked, @NonNull Menu actionBarMenu) {\n-            int title;\n-            int icon;\n-            if (hasUnsuspended) {\n-                title = R.string.card_browser_suspend_card;\n-                icon = R.drawable.ic_pause_circle_outline;\n-            } else {\n-                title = R.string.card_browser_unsuspend_card;\n-                icon = R.drawable.ic_pause_circle_filled;\n-            }\n-            MenuItem suspend_item = actionBarMenu.findItem(R.id.action_suspend_card);\n-            suspend_item.setTitle(browser.getString(title));\n-            suspend_item.setIcon(icon);\n-\n-            if (hasUnmarked) {\n-                title = R.string.card_browser_mark_card;\n-                icon = R.drawable.ic_star_border_white;\n-            } else {\n-                title = R.string.card_browser_unmark_card;\n-                icon = R.drawable.ic_star_white;\n-            }\n-            MenuItem mark_item = actionBarMenu.findItem(R.id.action_mark_card);\n-            mark_item.setTitle(browser.getString(title));\n-            mark_item.setIcon(icon);\n-        }\n-\n-\n-        @Override\n-        public void actualOnCancelled(@NonNull CardBrowser browser) {\n-            super.actualOnCancelled(browser);\n-            browser.hideProgressBar();\n-        }\n-    }\n-\n-\n-    @SuppressWarnings(\"SameParameterValue\")\n-    private void closeCardBrowser(int result) {\n-        closeCardBrowser(result, null);\n-    }\n-\n-    private void closeCardBrowser(int result, Intent data) {\n-        // Set result and finish\n-        setResult(result, data);\n-        finishWithAnimation(END);\n-    }\n-\n-    /**\n-     * Render the second column whenever the user stops scrolling\n-     */\n-    @VisibleForTesting\n-    public final class RenderOnScroll implements AbsListView.OnScrollListener {\n-        @Override\n-        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n-            // Show the progress bar if scrolling to given position requires rendering of the question / answer\n-            int lastVisibleItem = firstVisibleItem + visibleItemCount - 1;\n-            CardCollection<CardCache> cards = getCards();\n-            // List is never cleared, only reset to a new list. So it's safe here.\n-            int size = cards.size();\n-            if (size > 0 && visibleItemCount <= 0) {\n-                // According to Mike, there used to be 5 to 10 report by hour on the beta version. All with\n-                // > com.ichi2.anki.exception.ManuallyReportedException: Useless onScroll call, with size 0 firstVisibleItem 0,\n-                // > lastVisibleItem 0 and visibleItemCount 0.\n-\n-                // This change ensure that we log more specifically case where #8821 could have occured. That is, there are cards but we\n-                // are asked to display nothing.\n-\n-                // Note that this is not a bug. The fact that `visibleItemCount` is equal to 0 is actually authorized by the method we\n-                // override and mentionned in the javadoc. It perfectly makes sens to get this order, since it can be used to know that we\n-                // can delete some elements from the cache for example, since nothing is displayed.\n-\n-                // It would be interesting to know how often it occurs, but it is not a bug.\n-                AnkiDroidApp.sendExceptionReport(\"CardBrowser Scroll Issue 8821\", \"In a search result of \" + size + \" cards, with totalItemCount = \" + totalItemCount + \", somehow we got \" + visibleItemCount + \" elements to display.\");\n-            }\n-            // In all of those cases, there is nothing to do:\n-            if (size <= 0 ||\n-                    firstVisibleItem >= size ||\n-                    lastVisibleItem >= size ||\n-                    visibleItemCount <= 0\n-            ) {\n-                return;\n-            }\n-            boolean firstLoaded = cards.get(firstVisibleItem).isLoaded();\n-            // Note: max value of lastVisibleItem is totalItemCount, so need to subtract 1\n-            boolean lastLoaded = cards.get(lastVisibleItem).isLoaded();\n-            if (!firstLoaded || !lastLoaded) {\n-                if (!mPostAutoScroll) {\n-                    showProgressBar();\n-                }\n-                // Also start rendering the items on the screen every 300ms while scrolling\n-                long currentTime = SystemClock.elapsedRealtime();\n-                if ((currentTime - mLastRenderStart > 300 || lastVisibleItem + 1 >= totalItemCount)) {\n-                    mLastRenderStart = currentTime;\n-                    TaskManager.cancelAllTasks(CollectionTask.RenderBrowserQA.class);\n-                    TaskManager.launchCollectionTask(renderBrowserQAParams(firstVisibleItem, visibleItemCount, cards), mRenderQAHandler);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void onScrollStateChanged(AbsListView listView, int scrollState) {\n-            // TODO: Try change to RecyclerView as currently gets stuck a lot when using scrollbar on right of ListView\n-            // Start rendering the question & answer every time the user stops scrolling\n-            if (mPostAutoScroll) {\n-                mPostAutoScroll = false;\n-            }\n-            if (scrollState == SCROLL_STATE_IDLE) {\n-                int startIdx = listView.getFirstVisiblePosition();\n-                int numVisible = listView.getLastVisiblePosition() - startIdx;\n-                TaskManager.launchCollectionTask(renderBrowserQAParams(startIdx - 5, 2 * numVisible + 5, getCards()), mRenderQAHandler);\n-            }\n-        }\n-    }\n-\n-\n-    @NonNull\n-    protected CollectionTask.RenderBrowserQA renderBrowserQAParams(int firstVisibleItem, int visibleItemCount, CardCollection<CardCache> cards) {\n-        return new CollectionTask.RenderBrowserQA(cards, firstVisibleItem, visibleItemCount, mColumn1Index, mColumn2Index);\n-    }\n-\n-\n-    private final class MultiColumnListAdapter extends BaseAdapter {\n-        private final int mResource;\n-        private Column[] mFromKeys;\n-        private final int[] mToIds;\n-        private float mOriginalTextSize = -1.0f;\n-        private final int mFontSizeScalePcent;\n-        private Typeface mCustomTypeface = null;\n-        private final LayoutInflater mInflater;\n-\n-        public MultiColumnListAdapter(Context context, int resource, Column[] from, int[] to,\n-                                      int fontSizeScalePcent, String customFont) {\n-            mResource = resource;\n-            mFromKeys = from;\n-            mToIds = to;\n-            mFontSizeScalePcent = fontSizeScalePcent;\n-            if (!\"\".equals(customFont)) {\n-                mCustomTypeface = AnkiFont.getTypeface(context, customFont);\n-            }\n-            mInflater = LayoutInflater.from(context);\n-        }\n-\n-\n-        public View getView(int position, View convertView, ViewGroup parent) {\n-            // Get the main container view if it doesn't already exist, and call bindView\n-            View v;\n-            if (convertView == null) {\n-                v = mInflater.inflate(mResource, parent, false);\n-                final int count = mToIds.length;\n-                final View[] columns = new View[count];\n-                for (int i = 0; i < count; i++) {\n-                    columns[i] = v.findViewById(mToIds[i]);\n-                }\n-                v.setTag(columns);\n-            } else {\n-                v = convertView;\n-            }\n-            bindView(position, v);\n-            return v;\n-        }\n-\n-\n-        private void bindView(final int position, final View v) {\n-            // Draw the content in the columns\n-            View[] columns = (View[]) v.getTag();\n-            final CardCache card = getCards().get(position);\n-            for (int i = 0; i < mToIds.length; i++) {\n-                TextView col = (TextView) columns[i];\n-                // set font for column\n-                setFont(col);\n-                // set text for column\n-                col.setText(card.getColumnHeaderText(mFromKeys[i]));\n-            }\n-            // set card's background color\n-            final int backgroundColor = Themes.getColorFromAttr(CardBrowser.this, card.getColor());\n-            v.setBackgroundColor(backgroundColor);\n-            // setup checkbox to change color in multi-select mode\n-            final CheckBox checkBox = v.findViewById(R.id.card_checkbox);\n-            // if in multi-select mode, be sure to show the checkboxes\n-            if(mInMultiSelectMode) {\n-                checkBox.setVisibility(View.VISIBLE);\n-                checkBox.setChecked(mCheckedCards.contains(card));\n-                // this prevents checkboxes from showing an animation from selected -> unselected when\n-                // checkbox was selected, then selection mode was ended and now restarted\n-                checkBox.jumpDrawablesToCurrentState();\n-            } else {\n-                checkBox.setChecked(false);\n-                checkBox.setVisibility(View.GONE);\n-            }\n-            // change bg color on check changed\n-            checkBox.setOnClickListener(view -> onCheck(position, v));\n-        }\n-\n-        private void setFont(TextView v) {\n-            // Set the font and font size for a TextView v\n-            float currentSize = v.getTextSize();\n-            if (mOriginalTextSize < 0) {\n-                mOriginalTextSize = v.getTextSize();\n-            }\n-            // do nothing when pref is 100% and apply scaling only once\n-            if (mFontSizeScalePcent != 100 && Math.abs(mOriginalTextSize - currentSize) < 0.1) {\n-                // getTextSize returns value in absolute PX so use that in the setter\n-                v.setTextSize(TypedValue.COMPLEX_UNIT_PX, mOriginalTextSize * (mFontSizeScalePcent / 100.0f));\n-            }\n-\n-            if (mCustomTypeface != null) {\n-                v.setTypeface(mCustomTypeface);\n-            }\n-        }\n-\n-        public void setFromMapping(Column[] from) {\n-            mFromKeys = from;\n-            notifyDataSetChanged();\n-        }\n-\n-\n-        public Column[] getFromMapping() {\n-            return mFromKeys;\n-        }\n-\n-\n-        @Override\n-        public int getCount() {\n-            return getCardCount();\n-        }\n-\n-\n-        @Override\n-        public CardCache getItem(int position) {\n-            return getCards().get(position);\n-        }\n-\n-\n-        @Override\n-        public long getItemId(int position) {\n-            return position;\n-        }\n-\n-    }\n-\n-\n-    private void onCheck(int position, View cell) {\n-        CheckBox checkBox = cell.findViewById(R.id.card_checkbox);\n-        CardCache card = getCards().get(position);\n-\n-        if (checkBox.isChecked()) {\n-            mCheckedCards.add(card);\n-        } else {\n-            mCheckedCards.remove(card);\n-        }\n-\n-       onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting\n-    void onSelectAll() {\n-        mCheckedCards.addAll(mCards.unsafeGetWrapped());\n-        onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting\n-    void onSelectNone() {\n-        mCheckedCards.clear();\n-        onSelectionChanged();\n-    }\n-\n-    private void onSelectionChanged() {\n-        Timber.d(\"onSelectionChanged()\");\n-        try {\n-            if (!mInMultiSelectMode && !mCheckedCards.isEmpty()) {\n-                //If we have selected cards, load multiselect\n-                loadMultiSelectMode();\n-            } else if (mInMultiSelectMode && mCheckedCards.isEmpty()) {\n-                //If we don't have cards, unload multiselect\n-                endMultiSelectMode();\n-            }\n-\n-            //If we're not in mutliselect, we can select cards if there are cards to select\n-            if (!mInMultiSelectMode && this.mActionBarMenu != null) {\n-                MenuItem selectAll = mActionBarMenu.findItem(R.id.action_select_all);\n-                selectAll.setVisible(mCards != null && cardCount() != 0);\n-            }\n-\n-            if (!mInMultiSelectMode) {\n-                return;\n-            }\n-\n-            updateMultiselectMenu();\n-            mActionBarTitle.setText(String.format(getLocaleCompat(getResources()), \"%d\", checkedCardCount()));\n-        } finally {\n-            if (colIsOpen() && mCardsAdapter != null) {\n-                mCardsAdapter.notifyDataSetChanged();\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * Reloads the data of the cards, taking on their current values from the database.\n-     */\n-    protected void reloadCards(Card[] cards) {\n-        if (cards == null || cards.length == 0) {\n-            return;\n-        }\n-\n-        Set<Long> cardIds = new HashSet<>();\n-        for (Card c : cards) {\n-            cardIds.add(c.getId());\n-        }\n-\n-        for (CardCache props : mCards) {\n-            if (cardIds.contains(props.getId())) {\n-                props.reload();\n-            }\n-        }\n-        mCardsAdapter.notifyDataSetChanged();\n-    }\n-\n-    @VisibleForTesting\n-    CardCollection<CardCache> getCards() {\n-        mCards.ensureValidValue();\n-        return mCards;\n-    }\n-\n-    private long[] getAllCardIds() {\n-        long[] l = new long[mCards.size()];\n-        for (int i = 0; i < mCards.size(); i++) {\n-            l[i] = mCards.get(i).getId();\n-        }\n-        return l;\n-    }\n-\n-    // This could be better: use a wrapper class PositionAware<T> to store the position so it's\n-    // no longer a responsibility of CardCache and we can guarantee it's consistent just by using this collection\n-    /** A position-aware collection to ensure consistency between the position of items and the collection */\n-    public static class CardCollection<T extends PositionAware> implements Iterable<T> {\n-        private List<T> mWrapped = new ArrayList<>(0);\n-\n-        public int size() {\n-            return mWrapped.size();\n-        }\n-\n-        public T get(int index) {\n-            return mWrapped.get(index);\n-        }\n-\n-\n-        public void reset() {\n-            mWrapped = new ArrayList<>(0);\n-        }\n-\n-\n-        public void replaceWith(List<T> value) {\n-            mWrapped = value;\n-        }\n-\n-        public void reverse() {\n-            Collections.reverse(mWrapped);\n-            int position = 0;\n-            for (int i = 0; i < mWrapped.size(); i++) {\n-                mWrapped.get(i).setPosition(position++);\n-            }\n-        }\n-\n-\n-        @NonNull\n-        @Override\n-        public Iterator<T> iterator() {\n-            return mWrapped.iterator();\n-        }\n-\n-        public java.util.Collection<T> unsafeGetWrapped() {\n-            return mWrapped;\n-        }\n-\n-\n-        public void ensureValidValue() {\n-            if (mWrapped == null) {\n-                reset();\n-            }\n-        }\n-\n-\n-        public void clear() {\n-            mWrapped.clear();\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    interface PositionAware {\n-        int getPosition();\n-        void setPosition(int value);\n-    }\n-\n-    public static class CardCache extends Card.Cache implements PositionAware {\n-        private boolean mLoaded = false;\n-        private Pair<String, String> mQa = null;\n-        private int mPosition;\n-\n-        public CardCache(long id, Collection col, int position) {\n-            super(col, id);\n-            mPosition = position;\n-        }\n-\n-        protected CardCache(CardCache cache, int position) {\n-            super(cache);\n-            mLoaded = cache.mLoaded;\n-            mQa = cache.mQa;\n-            mPosition = position;\n-        }\n-\n-        public int getPosition() {\n-            return mPosition;\n-        }\n-\n-\n-        @Override\n-        public void setPosition(int value) {\n-            mPosition = value;\n-        }\n-\n-\n-        /** clear all values except ID.*/\n-        public void reload() {\n-            super.reload();\n-            mLoaded = false;\n-            mQa = null;\n-        }\n-\n-        /**\n-         * Get the background color of items in the card list based on the Card\n-         * @return index into TypedArray specifying the background color\n-         */\n-        private int getColor() {\n-            int flag = getCard().userFlag();\n-            switch (flag) {\n-                case 1:\n-                    return R.attr.flagRed;\n-                case 2:\n-                    return R.attr.flagOrange;\n-                case 3:\n-                    return R.attr.flagGreen;\n-                case 4:\n-                    return R.attr.flagBlue;\n-                case 5:\n-                    return R.attr.flagPink;\n-                case 6:\n-                    return R.attr.flagTurquoise;\n-                case 7:\n-                    return R.attr.flagPurple;\n-                default:\n-                    if (getCard().note().hasTag(\"marked\")) {\n-                        return R.attr.markedColor;\n-                    } else {\n-                        if (getCard().getQueue() == Consts.QUEUE_TYPE_SUSPENDED) {\n-                            return R.attr.suspendedColor;\n-                        } else {\n-                            return android.R.attr.colorBackground;\n-                        }\n-                    }\n-            }\n-        }\n-\n-        public String getColumnHeaderText(Column key) {\n-            switch (key) {\n-            case FLAGS:\n-                return (Integer.valueOf(getCard().userFlag())).toString();\n-            case SUSPENDED:\n-                return getCard().getQueue() == Consts.QUEUE_TYPE_SUSPENDED ? \"True\": \"False\";\n-            case MARKED:\n-                return getCard().note().hasTag(\"marked\") ? \"marked\" : null;\n-            case SFLD:\n-                return getCard().note().getSFld();\n-            case DECK:\n-                return getCol().getDecks().name(getCard().getDid());\n-            case TAGS:\n-                return getCard().note().stringTags();\n-            case CARD:\n-                return getCard().template().optString(\"name\");\n-            case DUE:\n-                return getCard().getDueString();\n-            case EASE:\n-                if (getCard().getType() == Consts.CARD_TYPE_NEW) {\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_new_card);\n-                } else {\n-                    return (getCard().getFactor()/10)+\"%\";\n-                }\n-            case CHANGED:\n-                return LanguageUtil.getShortDateFormatFromS(getCard().getMod());\n-            case CREATED:\n-                return LanguageUtil.getShortDateFormatFromMs(getCard().note().getId());\n-            case EDITED:\n-                return LanguageUtil.getShortDateFormatFromS(getCard().note().getMod());\n-            case INTERVAL:\n-                switch (getCard().getType()) {\n-                case Consts.CARD_TYPE_NEW:\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_new_card);\n-                case Consts.CARD_TYPE_LRN :\n-                    return AnkiDroidApp.getInstance().getString(R.string.card_browser_interval_learning_card);\n-                default:\n-                    return Utils.roundedTimeSpanUnformatted(AnkiDroidApp.getInstance(), getCard().getIvl()*SECONDS_PER_DAY);\n-                }\n-            case LAPSES:\n-                return Integer.toString(getCard().getLapses());\n-            case NOTE_TYPE:\n-                return getCard().model().optString(\"name\");\n-            case REVIEWS:\n-                return Integer.toString(getCard().getReps());\n-            case QUESTION:\n-                updateSearchItemQA();\n-                return mQa.first;\n-            case ANSWER:\n-                updateSearchItemQA();\n-                return mQa.second;\n-            default:\n-                return null;\n-            }\n-        }\n-\n-        /** pre compute the note and question/answer.  It can safely\n-            be called twice without doing extra work. */\n-        public void load(boolean reload, int column1Index, int column2Index) {\n-            if (reload) {\n-                reload();\n-            }\n-            getCard().note();\n-            if (\n-                COLUMN1_KEYS[column1Index] == QUESTION ||\n-                COLUMN2_KEYS[column2Index] == QUESTION ||\n-                COLUMN2_KEYS[column2Index] == ANSWER\n-                // First column can not be the answer. If it were to\n-                // change, this code should also be changed.\n-                ) {\n-                updateSearchItemQA();\n-            }\n-            mLoaded = true;\n-        }\n-\n-        public boolean isLoaded() {\n-            return mLoaded;\n-        }\n-\n-        /**\n-           Reload question and answer. Use browser format. If it's empty\n-           uses non-browser format. If answer starts by question, remove\n-           question.\n-        */\n-        public void updateSearchItemQA() {\n-            if (mQa != null) {\n-                return;\n-            }\n-            // render question and answer\n-            Map<String, String> qa = getCard()._getQA(true, true);\n-            // Render full question / answer if the bafmt (i.e. \"browser appearance\") setting forced blank result\n-            if (\"\".equals(qa.get(\"q\")) || \"\".equals(qa.get(\"a\"))) {\n-                HashMap<String, String> qaFull = getCard()._getQA(true, false);\n-                if (\"\".equals(qa.get(\"q\"))) {\n-                    qa.put(\"q\", qaFull.get(\"q\"));\n-                }\n-                if (\"\".equals(qa.get(\"a\"))) {\n-                    qa.put(\"a\", qaFull.get(\"a\"));\n-                }\n-            }\n-            // update the original hash map to include rendered question & answer\n-            String q = qa.get(\"q\");\n-            String a = qa.get(\"a\");\n-            // remove the question from the start of the answer if it exists\n-            if (a.startsWith(q)) {\n-                a = a.substring(q.length());\n-            }\n-            a = formatQA(a, AnkiDroidApp.getInstance());\n-            q = formatQA(q, AnkiDroidApp.getInstance());\n-            mQa = new Pair<>(q, a);\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n-            }\n-            if (obj == null) {\n-                return false;\n-            }\n-            if (getClass() != obj.getClass()) {\n-                return false;\n-            }\n-            return getId() == ((CardCache) obj).getId();\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Long.valueOf(getId()).hashCode();\n-        }\n-    }\n-\n-    /**\n-     * Show/dismiss dialog when sd card is ejected/remounted (collection is saved by SdCardReceiver)\n-     */\n-    private void registerExternalStorageListener() {\n-        if (mUnmountReceiver == null) {\n-            mUnmountReceiver = new BroadcastReceiver() {\n-                @Override\n-                public void onReceive(Context context, Intent intent) {\n-                    if (intent.getAction().equals(SdCardReceiver.MEDIA_EJECT)) {\n-                        finishWithoutAnimation();\n-                    }\n-                }\n-            };\n-            IntentFilter iFilter = new IntentFilter();\n-            iFilter.addAction(SdCardReceiver.MEDIA_EJECT);\n-            registerReceiver(mUnmountReceiver, iFilter);\n-        }\n-    }\n-\n-    /**\n-     * The views expand / contract when switching between multi-select mode so we manually\n-     * adjust so that the vertical position of the given view is maintained\n-     */\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    private void recenterListView(@NonNull View view) {\n-        final int position = mCardsListView.getPositionForView(view);\n-        // Get the current vertical position of the top of the selected view\n-        final int top = view.getTop();\n-        final Handler handler = new Handler();\n-        // Post to event queue with some delay to give time for the UI to update the layout\n-        handler.postDelayed(() -> {\n-            // Scroll to the same vertical position before the layout was changed\n-            mCardsListView.setSelectionFromTop(position, top);\n-        }, 10);\n-    }\n-\n-    /**\n-     * Turn on Multi-Select Mode so that the user can select multiple cards at once.\n-     */\n-    private void loadMultiSelectMode() {\n-        if (mInMultiSelectMode) {\n-            return;\n-        }\n-        Timber.d(\"loadMultiSelectMode()\");\n-        // set in multi-select mode\n-        mInMultiSelectMode = true;\n-        // show title and hide spinner\n-        mActionBarTitle.setVisibility(View.VISIBLE);\n-        mActionBarTitle.setText(String.valueOf(checkedCardCount()));\n-        mDeckSpinnerSelection.setSpinnerVisibility(View.GONE);\n-        // reload the actionbar using the multi-select mode actionbar\n-        supportInvalidateOptionsMenu();\n-    }\n-\n-    /**\n-     * Turn off Multi-Select Mode and return to normal state\n-     */\n-    private void endMultiSelectMode() {\n-        Timber.d(\"endMultiSelectMode()\");\n-        mCheckedCards.clear();\n-        mInMultiSelectMode = false;\n-        // If view which was originally selected when entering multi-select is visible then maintain its position\n-        View view = mCardsListView.getChildAt(mLastSelectedPosition - mCardsListView.getFirstVisiblePosition());\n-        if (view != null) {\n-            recenterListView(view);\n-        }\n-        // update adapter to remove check boxes\n-        mCardsAdapter.notifyDataSetChanged();\n-        // update action bar\n-        supportInvalidateOptionsMenu();\n-        mDeckSpinnerSelection.setSpinnerVisibility(View.VISIBLE);\n-        mActionBarTitle.setVisibility(View.GONE);\n-    }\n-\n-    @VisibleForTesting\n-    public int checkedCardCount() {\n-        return mCheckedCards.size();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean isInMultiSelectMode() {\n-        return mInMultiSelectMode;\n-    }\n-\n-    @VisibleForTesting()\n-    long cardCount() {\n-        return mCards.size();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-     boolean isShowingSelectAll() {\n-        return mActionBarMenu != null && mActionBarMenu.findItem(R.id.action_select_all).isVisible();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean isShowingSelectNone() {\n-        return mActionBarMenu != null &&\n-                mActionBarMenu.findItem(R.id.action_select_none) != null && //\n-                mActionBarMenu.findItem(R.id.action_select_none).isVisible();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void clearCardData(int position) {\n-        mCards.get(position).reload();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void rerenderAllCards() {\n-        TaskManager.launchCollectionTask(renderBrowserQAParams(0, mCards.size()-1, getCards()), mRenderQAHandler);\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    long[] getCardIds() {\n-        CardCache[] cardsCopy = mCards.unsafeGetWrapped().toArray(new CardCache[0]);\n-        long[] ret = new long[cardsCopy.length];\n-        for (int i = 0; i < cardsCopy.length; i++) {\n-            ret[i] = cardsCopy[i].getId();\n-        }\n-        return ret;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    void checkCardsAtPositions(int... positions) {\n-        for (int position : positions) {\n-            if (position >= mCards.size()) {\n-                throw new IllegalStateException(\n-                        String.format(Locale.US, \"Attempted to check card at index %d. %d cards available\",\n-                                position, mCards.size()));\n-            }\n-            mCheckedCards.add(getCards().get(position));\n-        }\n-        onSelectionChanged();\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    boolean hasCheckedCardAtPosition(int i) {\n-        return mCheckedCards.contains(getCards().get(i));\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public int getChangeDeckPositionFromId(long deckId) {\n-        List<Deck> decks = getValidDecksForChangeDeck();\n-        for (int i = 0; i < decks.size(); i++) {\n-            Deck deck = decks.get(i);\n-            if (deck.getLong(\"id\") == deckId) {\n-                return i;\n-            }\n-        }\n-        throw new IllegalStateException(String.format(Locale.US, \"Deck %d not found\", deckId));\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public List<Long> getCheckedCardIds() {\n-        List<Long> cardIds = new ArrayList<>(mCheckedCards.size());\n-        for (CardCache card : mCheckedCards) {\n-            long id = card.getId();\n-            cardIds.add(id);\n-        }\n-        return cardIds;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE) //should only be called from changeDeck()\n-    void executeChangeCollectionTask(List<Long> ids, long newDid) {\n-        mNewDid = newDid; //line required for unit tests, not necessary, but a noop in regular call.\n-        TaskManager.launchCollectionTask(\n-                new CollectionTask.ChangeDeckMulti(ids, newDid),\n-                new ChangeDeckHandler(this));\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public CardCache getPropertiesForCardId(long cardId) {\n-        for (CardCache props : mCards) {\n-            long id = props.getId();\n-            if (id == cardId) {\n-                return props;\n-            }\n-        }\n-        throw new IllegalStateException(String.format(Locale.US, \"Card '%d' not found\", cardId));\n-    }\n-\n-\n-    @VisibleForTesting\n-    void filterByTag(String... tags) {\n-        onSelectedTags(Arrays.asList(tags), 0);\n-    }\n-\n-    @VisibleForTesting\n-    @SuppressWarnings(\"SameParameterValue\")\n-    void filterByFlag(int flag) {\n-        mCurrentFlag = flag;\n-        filterByFlag();\n-    }\n-\n-    @VisibleForTesting\n-    void replaceSelectionWith(int[] positions) {\n-        mCheckedCards.clear();\n-        checkCardsAtPositions(positions);\n-    }\n-\n-    @VisibleForTesting\n-    @SuppressWarnings(\"SameParameterValue\")\n-    void searchCards(String searchQuery) {\n-        mSearchTerms = searchQuery;\n-        searchCards();\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "message": "Merge commit", "committedDate": null}, {"oid": "775aa05336a8b02a44434facc0eca6db09d21ae1", "committedDate": "2020-06-08 08:23:17 -0500", "message": "hasSelectedSingleNoteId: Handle concurrency issue"}, {"oid": "6e0f09f950205347663b058830806de64c6e87c7", "committedDate": "2020-06-08 08:23:17 -0500", "message": "hasSelectedSingleNoteId: concurrency fix"}, {"oid": "24056efa63638e8e8ac252f5d9399f2231b996f1", "committedDate": "2020-06-11 11:25:18 -0500", "message": "Remove buggy implementation: hasSelectedSingleNoteId"}, {"oid": "238d935bbcb41e198a9f512d81abc06f40901b30", "committedDate": "2020-06-11 11:25:18 -0500", "message": "Browser: Allow user to change note type if editing"}, {"oid": "5bb384a3aff953bed4d7ce1243bd74e5febfa45e", "committedDate": "2020-06-11 11:25:18 -0500", "message": "NF: Rename NOTE to NOTE_TYPE"}, {"oid": "b1135ff3cbd8d536a0175e7b9b156fdb88585e1b", "committedDate": "2020-06-12 23:28:18 -0500", "message": "Remove unused parameter in saveCollectionInBackground"}, {"oid": "de280d8fa079636e232fe1b8ffe703aabc0ab054", "committedDate": "2020-06-20 20:14:33 -0500", "message": "Keep displaying search terms after editing card"}, {"oid": "8236599b1db98f774a45c4f84de308e16affd0c3", "committedDate": "2020-06-20 20:14:33 -0500", "message": "CardBrowser: Hide Progress Bar if tasks cancelled"}, {"oid": "cf720e0c56ff05a63590a5f86697444c01f02515", "committedDate": "2020-06-29 15:25:38 -0500", "message": "Reload CardBrowser but not reviewer when note edited"}, {"oid": "b91a511d46b57a88b2a000ca2f6a2375dfbe3bdd", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Task type becomes an enum"}, {"oid": "017cb41d04e55b284f5e11410c50f63d2b368d38", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Remove TASK_TYPE from enum name"}, {"oid": "6a7f8d895eaaa08df21998a02c09a7c754ddeb97", "committedDate": "2020-07-05 08:46:49 -0500", "message": "cancelTask(type) cancel all tasks of given type"}, {"oid": "c18a421db5329cf3f2b86e62a819e5a116265f60", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: cancelTask to cancelCurrentlyExecutingTask"}, {"oid": "0dba81bdef77c234dd4d9a90e1ee89e6c0dc827f", "committedDate": "2020-07-20 19:51:47 -0500", "message": "getUserFlag->userFlag"}, {"oid": "c126ac42a5eac08fba6d54d531c0821df0193c68", "committedDate": "2020-07-21 15:50:01 -0500", "message": "NF: Deck type"}, {"oid": "03aa2f4cd0aea7032cc93d27d8676be51154db3c", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: import static com.ichi2.async.CollectionTask.TaskData;"}, {"oid": "1df6f2510ed5c6d410b98c8955a0c230e1ffb309", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: TaskData in a separate file"}, {"oid": "6d8d7d4abdc604c7edc5ed97da47b57cb9b076a1", "committedDate": "2020-07-25 15:14:56 -0500", "message": "NF: listener's onProgressUpdate take a single element"}, {"oid": "2f0af8ff7c5cc18d850aa1fc8c1bdd2c39a6bb1c", "committedDate": "2020-08-08 09:05:50 -0500", "message": "NF: Listener as separate file"}, {"oid": "d4267b868d9b4e584d186f667de2f48636b333be", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: create type cardCache"}, {"oid": "e00b4f587d88ef102e20dadc03689f22976b75b2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: replace ID by \"id\"."}, {"oid": "b6e9594f93f40946d6f0b934fbac71aa0a85acf4", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: reload in CardCache"}, {"oid": "3d5b1f8c596931244f79f8a4e0916c345e39903d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: reload CardCache in updateCardsInList"}, {"oid": "f6b4230e354e2965089317b68124bf15bfa54b84", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: id in CardCache"}, {"oid": "0ed0b26615da7a6bca6313471ceda4e1162656b0", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardClass has card accessor"}, {"oid": "cf059ad47c4889a7d01586d4800c7bf080136fed", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: move getFlagOrDefault in CardClass"}, {"oid": "ad60a300fb9dff4d0b957dec653c8b0576652005", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: getColor, get variable when needed"}, {"oid": "0a9fead54f040d70b39bb83596c51ca2f02f54f9", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify flag"}, {"oid": "59df407e8574d70e86a010c5e5edad0976cede1d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify getFlagOrDefault to use card"}, {"oid": "397cc318f49494a4bfb6c14b13bbe5da4f64c187", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove getFlagOrDefault"}, {"oid": "ca5cde170d69b80e198b1534808c1db0a9eff192", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: getColor in CardClass"}, {"oid": "cd8ae0d2b27e452af7e4c4d8cde4bbcabbfb63e9", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses card feature in color"}, {"oid": "0b65cb3645f6f1ec21c054616b6f12b4c565b278", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: cardProperties renamed to card"}, {"oid": "f9b4463d1fccb380b92b7c6c0b10597fd3bace09", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: introduce variable text_for_column in bindView"}, {"oid": "cee32b600bae5bdaf33c5fb2c84db8414ce4dff2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses content instead than setText"}, {"oid": "4a0d565455507e4b0a9123f13a6d23c539788df7", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache deal with loading"}, {"oid": "40af31415bc356b207b0eb07921d62fc3c57eda3", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: FLAGS in content"}, {"oid": "5f63aeea4bb6e6f1958f78c0fea980a942f33ad6", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: SUSPENDED in content"}, {"oid": "2d9bb9a08928843e01b7adb39df61f67b0eefeb5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: MARKED in Content"}, {"oid": "d5f109e6cada59c76b7167b50aae2002e556dfe6", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused sMarkedPattern"}, {"oid": "0a4218fe7c17fee8a4cf38a0cdb3fc45cf8d770f", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: SFLD in content"}, {"oid": "7d454e131c800ea1bfb826b3acffc74f1a9a324d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: DECK in content"}, {"oid": "2ede85b0dda0d29139e6266b787e580cd5530a94", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: TAGS in content"}, {"oid": "3beace334a38147d9160673983aaa7c06e7d6253", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CARD in content"}, {"oid": "d8e0e3bf68ec037a563a0efb62c5d94fffec0693", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: DUE in content"}, {"oid": "3e56bcaaaff8361dca7a2788057808cace6f518a", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: EASE in content"}, {"oid": "e66a43034b0aae17d9d1bbbad84f98f52b348953", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CHANGED in content"}, {"oid": "548170633037c3968947f28ff008b35f622112d5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CREATED in content"}, {"oid": "b3551b17d8d763824e886fefbc080c4565193399", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: EDITED in content"}, {"oid": "fe98ebdcbc1e1ff0b9999dc3d574ff64c43e28dc", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: INTERVAL in Content"}, {"oid": "17d9b916e4cfc4e6c3cc552f04dc72038450e8e1", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: LAPSES in content"}, {"oid": "b696126cdfb39e7e967088855a64f98995742d29", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: NOTE_TYPE in content"}, {"oid": "cffe326a64e97452f9d0ad296e00b56636dd3807", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: REVIEWS in content"}, {"oid": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused paramater, varilable and comment"}, {"oid": "25668235083fa2e4c0716fb177f0ed756d5f18f1", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: context is got directly in updateSearchItemQA"}, {"oid": "216580a8bfebb2e94d3ee973e9c16dea5b45f6a2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: updateSearchItemQA don't take card, but get it from CardCache"}, {"oid": "474450d513e379802bca25b64e9d2dccfa7dc105", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: Question/Answer in Content"}, {"oid": "0d83a8a8070a1f750aded8e2f35e4f90689da7ce", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: To get card browser value, uses only .content"}, {"oid": "cebb0704f32af078181a041bd3f5d2378e5705ad", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: simplify slightly code"}, {"oid": "f4981c1a84187ffaf956e9bc0d3e995e083019ed", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache does not inherits HashMap"}, {"oid": "ab32f45cbef06a9f3f964512c0536eabfb54c290", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: use enum for column"}, {"oid": "23d64c43221e83f1ca9b1dd0987e47a570a1f33c", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: don't compute question/answer if it's not used"}, {"oid": "5f21fa7f1b58effc22372ae7bbbbd22f398a2d3d", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache have hash and equals"}, {"oid": "23caa8ecb5b24de130671b569ab6fc649480e4b5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: cardCache constructor takes position"}, {"oid": "607f9dc344b11f2a770f5b119878da67c8d2e4e0", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: throw exception before adding to set"}, {"oid": "2ea7d9a79284cbf6464e6be6a5286a2965859475", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: mCheckedCardPositions becomes a list of CardCache"}, {"oid": "89a9718449d95b6f59d17c0109e2f711f5c46b5b", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: uses checkedCardCount when possible"}, {"oid": "58b46cca4aebc46f1f2467e331ae2526130adc13", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: use empty instead of size"}, {"oid": "8f3628f0fda73538b3a8e8739411d34b07239716", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove an always false condition"}, {"oid": "f51427dc57c0249f225dafd7c5d776c5a9172767", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: updateCardsInList more clear"}, {"oid": "ac2d979c2e394e61bcba9a6efe36d755ea7472ca", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: indicates that getPositionMap is static"}, {"oid": "3be7f0e1c8e7bc5bc9102d3bfe93f4e9219110a2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: ensure updateCardsInList iterate on a single list of card"}, {"oid": "84448a30d968bdca49b143b560cc2ee928296e17", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: RepositionCardHandler with context"}, {"oid": "9130f8046b512b111966c0a029b47f24a53d7106", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: ResetCardHandler with context"}, {"oid": "0da8d61fd274449fd11bdc5a6a8d3f7e531b389b", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: RescheduleCardHandler with context"}, {"oid": "964cc28b2a74cabe9473c0f96b4b84874dd9240e", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: factorize mCheckSelectedCardsHandler"}, {"oid": "6d828ea8e9001ed918a561daa6c60aa864927ad0", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: Factorize selected card handler"}, {"oid": "7383c6809f93d6fd931a8f3bec4b43c9c488b19f", "committedDate": "2020-08-18 10:21:00 -0500", "message": "NF: ListenerWithProgressBar with context"}, {"oid": "eabd3b8eff2df7a51e9a44fd8919092781080f31", "committedDate": "2020-08-19 14:19:18 -0500", "message": "onTrimMemory call super"}, {"oid": "31439eed2dcd6b4442c9a381d8650035b5bf27ff", "committedDate": "2020-08-21 11:29:10 -0500", "message": "NF: replace 86400 by SECONDS_PER_DAY"}, {"oid": "e2cf422fb9c2f6b42afb09fe812daa38534068aa", "committedDate": "2020-08-22 22:33:15 +0200", "message": "NF: copy a list to ensure it does not change."}, {"oid": "1fe7e7d8bfe176e941fad8480da164ada7932319", "committedDate": "2020-08-28 16:00:39 -0500", "message": "NF: correct creation of card cache"}, {"oid": "d22c2b2ff1e3e7e38c4a6e83f3da9bb4a9362249", "committedDate": "2020-08-29 22:34:54 -0500", "message": "Second column of browser repaired"}, {"oid": "1562a65403d5ded875451f01b46fe77bead42764", "committedDate": "2020-08-30 09:45:59 -0500", "message": "NF: invalidate browser"}, {"oid": "566d0864718738a781190304cda800fa7ce5e0c9", "committedDate": "2020-08-30 09:45:59 -0500", "message": "Delete a card invalidate the brwosre"}, {"oid": "c11da9873ff0934f6f3f28d1c9a23f76af951581", "committedDate": "2020-09-06 18:36:55 -0500", "message": "Added \"Edit Note\" to Previewer"}, {"oid": "392eff78a581986b8afc1d751eebc931d1767036", "committedDate": "2020-09-06 18:40:40 -0500", "message": "Cards are displayed in card browser after return from background"}, {"oid": "32a4e06304dcafc47d7048586c482bbbd209a84d", "committedDate": "2020-09-06 18:40:40 -0500", "message": "NF: alow to cancel Task_type_Check_Card_selection"}, {"oid": "ff5156f8f524b62be48b222eb206b68d0cc4bd26", "committedDate": "2020-09-12 14:38:16 -0500", "message": "Allow searches on tags containing brackets"}, {"oid": "890ef6c5835e1acde92edc6af8a36a64dcc90601", "committedDate": "2020-09-19 03:48:07 +0200", "message": "Fix NullPointerException on invalidate()"}, {"oid": "715357c31701ffe4d1f87d8278be7c622fd25f60", "committedDate": "2020-09-20 23:27:15 -0500", "message": "NF: remove useless semicolons"}, {"oid": "a833d04dedf1185d5e4934dc6d037802014f686d", "committedDate": "2020-09-21 07:18:25 -0500", "message": "NF: remove unboxing warning"}, {"oid": "48c102f1d45d48c930606e08267fe4a5d42a06b5", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+A: \"Select All\""}, {"oid": "287dc8c963e3779db7585ee65c98ab2223c85d24", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+E: \"Add Note\""}, {"oid": "79f580c7f6786a5d3b49a5c2ab34ab12cccff2b5", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+D: \"Change Deck\""}, {"oid": "943d30d9caa109a5545c934e269769225b727ff1", "committedDate": "2020-09-21 08:58:08 -0500", "message": "NF: Refactor showChangeDeckDialog"}, {"oid": "54982f3c6abcab9d4eaf61e6c0569db21f3203ca", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+K: \"Toggle Mark\""}, {"oid": "1d77e154b49d300831a6c1888e01f799a9d30a95", "committedDate": "2020-09-21 08:58:08 -0500", "message": "CardBrowser: Ctrl+Alt+R: \"Reschedule\""}, {"oid": "9bfbb028cc6e2e069859d2833ab20aeec5d4e571", "committedDate": "2020-09-21 08:58:08 -0500", "message": "DOCS: CardBrowsert onKeyDown: Add warning"}, {"oid": "41daedf82d490a1dc74d1afa2130cf79de26fe67", "committedDate": "2020-09-21 10:23:05 -0500", "message": "NF: remove warning DefaultAnnotationParam"}, {"oid": "a4d1643b4723b8d4bd43ff375e0e061baa2a2a5a", "committedDate": "2020-09-21 12:21:31 -0500", "message": "NF: Remove warning about useless int instead of advanced loop"}, {"oid": "c0595464b0b205d704b293f64543e5f54e4b2612", "committedDate": "2020-09-22 09:09:16 -0500", "message": "NF: remove warning Convert2Lambda"}, {"oid": "cef2394efe6d7347643cd796cd5ed8105c692b9a", "committedDate": "2020-09-22 09:12:07 -0500", "message": "NF: uses Equals() for string"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "6359569144205e2d8338fcdc6571ead7fc19bcea", "committedDate": "2020-09-23 16:55:49 -0500", "message": "NF: remove wraning of values that are clearly not null"}, {"oid": "975a902915821a23623b20e8daeff9fc681b92cd", "committedDate": "2020-09-24 09:30:56 -0500", "message": "NF: Remove warning about useless type in generic class constructors"}, {"oid": "42b92180120040299e590634f5b03d6f352c0a4f", "committedDate": "2020-09-24 11:41:08 -0500", "message": "NF: remove useless casts"}, {"oid": "a079a61fc0e7dc06437c851026b29266868aef9b", "committedDate": "2020-09-28 08:29:08 -0500", "message": "NF: suppress warning of redundant escape when it does not seems redundant"}, {"oid": "1d4ec27fc2e0e64f5ba599369d2a633d49686f68", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: Extract class CardCollection"}, {"oid": "c5e92a4c315932cbbdb392f146fe7de28a029d99", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: CardBrowser - Extract methods"}, {"oid": "68ee9e1ebd348a728754632b5c8741c2a45d1f41", "committedDate": "2020-09-28 11:24:51 -0500", "message": "Regression Test: Browser - Preview after sorting"}, {"oid": "7bfa728086d70278433ae76a1655ee573de8b835", "committedDate": "2020-09-28 11:24:51 -0500", "message": "[BugFix] Preview reverse cards correctly"}, {"oid": "fe6a93e79014acd6ae7ae04ca34447f4cb3bc0a3", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: CardBrowser - Improve comments"}, {"oid": "0b23ca26293d5834775f39ede7dbd55c627fc3f6", "committedDate": "2020-09-30 10:51:24 -0500", "message": "NF: use enum for direction"}, {"oid": "8fd630afcaf2a114d32e76ecb6982d995c1a73d2", "committedDate": "2020-10-04 13:53:44 -0500", "message": "Display cards deleted when deleting notes"}, {"oid": "517b5a15ea15761fc0a816cb35daa53ec3910438", "committedDate": "2020-10-04 16:25:33 -0500", "message": "Lint: Use valueOf instead of new"}, {"oid": "ada67bc3d304193eab15d42badaafe9863d340cf", "committedDate": "2020-10-14 06:06:10 -0500", "message": "Adjust resoure reference usage to handle future non-final state"}, {"oid": "99ab89ed6fb3bb0c568db544a76ae9928ce79db7", "committedDate": "2020-10-14 13:58:41 -0500", "message": "Add Filter by flag icon to card browser"}, {"oid": "456daa33af9c099a52d05ecba69b47ed9a4d1944", "committedDate": "2020-10-14 16:20:04 -0500", "message": "Remember scroll position in CardBrowser"}, {"oid": "7bfc313ea25f3ba79f99662795387abed64dfd78", "committedDate": "2020-10-18 11:46:46 -0500", "message": "NF: replace string cancel by dialog_cancel"}, {"oid": "a0120f327d806aea5b08f231bc21f6f0f0cdb782", "committedDate": "2020-10-19 18:16:06 -0500", "message": "NF: Refactor changeDeck naming and variables"}, {"oid": "dd57f7cec478de2fff2c9b437dc9946317bd509c", "committedDate": "2020-10-19 18:16:06 -0500", "message": "NF: Add tests for \"add note\" target deck"}, {"oid": "97c5739ae4bd8b73a56c7bbf29759c278209b775", "committedDate": "2020-10-19 18:16:06 -0500", "message": "Use Browser's Selected Deck when adding note"}, {"oid": "8e2ea03689701afc5a6a629f298ed4b8ee668a61", "committedDate": "2020-10-21 06:32:30 -0500", "message": "NF: remove duplicate \"Tags: %1$s\""}, {"oid": "68ca357ebfc5adbdf40c72e18cd574a1e8d5e94f", "committedDate": "2020-10-23 13:33:05 -0500", "message": "Add \"Card Info\" screen"}, {"oid": "7c882bbb8a848c0bb2a6bb897a3767151e91f76d", "committedDate": "2020-10-25 22:26:29 +0000", "message": "NF: remove duplicate \"(new)\""}, {"oid": "34167abea29fd4d8419a7478022be4e31e5fa01e", "committedDate": "2020-10-26 01:51:44 +0000", "message": "NF: remove duplicate search"}, {"oid": "23f9d804f22cb87af322c279db7804b943f8d503", "committedDate": "2020-10-28 22:37:47 -0500", "message": "NF: save current search to avoid doing it twice"}, {"oid": "81237e0f7122659cd50767949d6e921183d26ddd", "committedDate": "2020-11-03 20:09:18 +0000", "message": "NF: uses for-loop if possible"}, {"oid": "5524e7a6442efad0b8f5440e4c8c0b8cd7c718cd", "committedDate": "2020-11-05 05:30:10 +0000", "message": "NF. remove an unused paramater"}, {"oid": "9c8182dde2ed45a0c0de69214097ac10c85bd14a", "committedDate": "2020-11-09 13:08:37 -0500", "message": "Handle App.onCreate not executing after restore"}, {"oid": "eb84e4ed4bda37fa8f59c8e3b655beb2c79b1b2e", "committedDate": "2020-11-13 09:17:40 -0500", "message": "NF: Remove Specific Error String"}, {"oid": "3dd23578b50498b9fbd1c3b9ad07c5f352944d96", "committedDate": "2020-11-14 08:32:02 -0500", "message": "Revert: \"NF: save current search to avoid doing it twice\""}, {"oid": "383aa2493ef332cdebf42bf6bebe415ddefa6307", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Rename checkedCardsAtPositions"}, {"oid": "78beef4bc78a9bbea9cf51e30f24a9a42e577c19", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: extract repositionCardsNoValidation"}, {"oid": "97757073161bf5982bde6ee23874bf9798609224", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract rescheduleWithoutValidation"}, {"oid": "e5cdc91a9b424c98d84bd738bb291f5cfe6538b5", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract onResetProgress"}, {"oid": "c153719c40ae2f706d866d935827d835fd82235f", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: Extract resetProgressNoConfirm"}, {"oid": "057be86c6b6cd0e99df65b40f78e3558328bd865", "committedDate": "2020-11-15 07:36:02 -0500", "message": "NF: checkCardsAtPositions - accept varargs"}, {"oid": "0389d60b51827c189cff119eececd94cec89256e", "committedDate": "2020-11-15 07:36:02 -0500", "message": "Refresh Card Browser data on reposition"}, {"oid": "43b06bc7856e19263153ff95f64a0ae8ecec7efe", "committedDate": "2020-11-15 07:36:02 -0500", "message": "Show undo menu on reset, reposition and resched"}, {"oid": "ebba0a01b1f2a8b0e6996539f1d0daac0470c201", "committedDate": "2020-11-15 07:36:02 -0500", "message": "BugFix: Undo - Ensure data in grid is updated"}, {"oid": "dbaf6549ec268333b20d160a0c40962d3135ba0d", "committedDate": "2020-11-20 07:54:40 -0500", "message": "Show partial result in browser before showing all"}, {"oid": "4f2e7f6226246f7626c15234f5d947a6a02c7a74", "committedDate": "2020-11-22 17:41:07 -0500", "message": "NF: Extract setMenuIcons"}, {"oid": "831b8f1be882ff5d43b30ed77f637dadbc3cafc6", "committedDate": "2020-11-22 17:41:07 -0500", "message": "Fix crash if mActionBarMenu is null"}, {"oid": "3e17cca53b9feec8032bc07d6be9f2690dabb1de", "committedDate": "2020-12-02 08:40:06 -0500", "message": "Browser shortcuts: Fix switch fall-through"}, {"oid": "94b3919547fab325239d52d1a9f07d15ddeeb738", "committedDate": "2020-12-02 08:40:06 -0500", "message": "NF: Extract deleteSelectedNote"}, {"oid": "bdef0a8f063d0343c6d747759b0acbd2bb8a4d55", "committedDate": "2020-12-02 08:40:06 -0500", "message": "Card Browser: Add \"Delete\" Shortcut"}, {"oid": "2d1e8714db8cc6e066341d27ad638a5818b0c65a", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: Remove a unused map"}, {"oid": "b0a841366a02673f7ec35e5d197ad7633d247f16", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: remove duplicate if"}, {"oid": "4d37cf273c758b9d873f4a54ba6454f1e143a94a", "committedDate": "2020-12-03 23:20:03 +0000", "message": "NF: Remove useless parameter"}, {"oid": "fb56df4c0be4d3b333a75beccb9c3568328ba190", "committedDate": "2020-12-08 09:27:51 -0500", "message": "NF: Extract method: getPreviewIntent"}, {"oid": "cce056d89cb1cc4176faf3a4b4be5f9bd8c31283", "committedDate": "2020-12-08 09:27:51 -0500", "message": "BugFix - Previewer: Display same card after edit"}, {"oid": "5128cc2c756ce1434367eb58807650581f26c661", "committedDate": "2020-12-09 11:27:39 -0500", "message": "NF: init capacity of list, map and set"}, {"oid": "ec80d4eb9fb57fd538bccdc8c7e52b8545c4af3e", "committedDate": "2020-12-09 11:44:05 -0500", "message": "NF: Dismiss_multi first argument is List<Long>"}, {"oid": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "committedDate": "2020-12-09 12:17:48 -0500", "message": "NF: Move static part of CollectionTask to other class"}, {"oid": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: Add Type Task, type CollectionTask and TaskListener"}, {"oid": "930bd70272c2acda40e3da35e1ed454b91176a1b", "committedDate": "2020-12-12 14:14:20 +0100", "message": "NF: correct typing of tasks"}, {"oid": "67d636de3f071d2ca87fb4a80447ffd8a03a7d35", "committedDate": "2020-12-13 08:25:34 -0500", "message": "NF: remove redundant if warning"}, {"oid": "ba6051f93e29a4ed3ebb58fe591ddcaef532d2db", "committedDate": "2021-01-23 14:59:29 -0500", "message": "Fix some deprecations"}, {"oid": "0c858ce63b151e82a81866d7e7e652c850d6b621", "committedDate": "2021-03-20 13:05:08 +0100", "message": "Select many option in Card browser"}, {"oid": "6bb12e744843ba3a4d7f1a30e39f735dd8389a5c", "committedDate": "2021-03-20 13:05:08 +0100", "message": "Removed the lastselectedposition from itemclicklistener"}, {"oid": "33f9b63573ede5b40f1c31f74aaa0c6bb30c65e1", "committedDate": "2021-03-24 13:00:21 -0500", "message": "Save/restore card browser multi-select state during Activity lifecycle (#8306)"}, {"oid": "3de33abda7a436ef8c71bcf03c78fda497d78ce2", "committedDate": "2021-03-25 15:43:52 +0000", "message": "NF: use enum for TagsDialog type instead of ints"}, {"oid": "007ad994758eb9525a533512a486f617d6450f82", "committedDate": "2021-03-26 09:42:38 -0500", "message": "NF: refactor TagsDialog to listener interface (#8341)"}, {"oid": "db9260c03143d3770ede4b39db9e15727a69b4cf", "committedDate": "2021-03-27 09:32:18 -0500", "message": "Use browser search text as first field when adding new note  (#8345)"}, {"oid": "34c9f25038d24e3bf9f338fa307b1bcb3610b5ba", "committedDate": "2021-04-03 08:29:29 -0500", "message": "Prevent OR CardBrowser query from bypassing RestrictOnDeck (#8414)"}, {"oid": "5fa8827e0503f775d81704868cbd20d64fe554b0", "committedDate": "2021-04-07 22:39:02 -0500", "message": "Reverse Activity transition for RTL language (#8470)"}, {"oid": "5542ad6ea5f212c04ae8dd93e19626832c25b11d", "committedDate": "2021-04-08 10:08:22 -0500", "message": "chore: Fix usage of Throwable.printStackTrace"}, {"oid": "1d0ad0613b6961d290f0a83832a16dd7fdd62ca3", "committedDate": "2021-04-10 19:45:03 +0100", "message": "NF: MultiColumnListAdapter's getCard return `CardCache`"}, {"oid": "246fba3811d60dd3f302e50210393da3c8a39016", "committedDate": "2021-04-14 07:49:34 -0500", "message": "Display Order of cards in Card Browser corrected"}, {"oid": "9c2e7788262006017c7939fa514072e915efeded", "committedDate": "2021-04-14 07:49:34 -0500", "message": "Unit Test to check display order is persistant on restart"}, {"oid": "00abc059f60fd18ddc9e77d2425436a3cad044ed", "committedDate": "2021-04-14 13:00:45 -0500", "message": "NF: Convert Deck methods to return List"}, {"oid": "d63f8ebaa7ba1693f220d0115cbbb30481f5cbbb", "committedDate": "2021-04-16 10:43:24 -0500", "message": "refactor: Open Previewer from CardBrowser using new Activity APIs"}, {"oid": "b58dd95ff8649dea7e71f103ec2a8dec01bdb0d0", "committedDate": "2021-04-24 06:07:18 +0200", "message": "Fix: Prevent crash on long pressing at end of card browser (#8665)"}, {"oid": "d9dcbb987004d86b4af464d957d6fe1b1dca7267", "committedDate": "2021-04-24 22:31:29 -0500", "message": "refactor: Use androidx Activity APIs in CardBrowser"}, {"oid": "a5dbe4bd129b7760aa8fdcab4fd5e322c59e648b", "committedDate": "2021-04-24 22:31:29 -0500", "message": "fix: Restore no animation settings to start Previewer from CardBrowser"}, {"oid": "0c544371db268cb520e1f89dbc7aa2f499153452", "committedDate": "2021-04-25 12:25:39 -0500", "message": "Convert google material design icons"}, {"oid": "1aa3041789b3a8d29cb48b3204d74ea72ec16b60", "committedDate": "2021-04-29 19:46:40 -0500", "message": "NF: Move TagsDialog to its own package"}, {"oid": "a10214b2ec7061bc46863467ed32a73b81b1f355", "committedDate": "2021-04-30 14:53:54 -0500", "message": "Ensure that CheckCardSelection gets only checked cards"}, {"oid": "72d6b996514a3a547b8ef823fa441ba7297d9f4d", "committedDate": "2021-05-01 09:12:17 -0500", "message": "NF: refactor TagsDialog to use factory"}, {"oid": "8954b35fd0535b65355f398a9938260c11ec21a0", "committedDate": "2021-05-01 09:12:17 -0500", "message": "NF: move TagsDialogListener to a new file"}, {"oid": "aa1c65121804bc9440dd2a0ccd7f9d34af9f4abe", "committedDate": "2021-05-04 12:50:02 -0500", "message": "Card Browser, NoteEditor And Statistics : Improve \"Search Deck\" UX  (#8644)"}, {"oid": "5a9f8fac1f968379c46757c944fbb397412baf4a", "committedDate": "2021-05-04 15:56:52 -0500", "message": "Speed up card browser"}, {"oid": "123d1451ed953a55e7724bf114fe885b42b13b9c", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: reverse condition. Quick return instead of imbrication"}, {"oid": "300b396c2cffd8e08e794729d0afe56422d2a020", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: reverse condition. Quick return instead of imbrication"}, {"oid": "7dd2b7895807c12b1f730894e13fd9512ffdcf38", "committedDate": "2021-05-14 17:38:33 -0500", "message": "Consider scrolling with 0 cards."}, {"oid": "a1ef99fa872362e58b9f9c8deb8fbf1d3c50bc4a", "committedDate": "2021-05-14 17:38:33 -0500", "message": "NF: send exception report if on scroll was cancelled"}, {"oid": "6b31d01de6752f9d36648a9f56093c58970e841b", "committedDate": "2021-05-16 13:29:52 -0500", "message": "NF: More specific exception for useless scroll call (#8844)"}, {"oid": "3c9783d0b65e6272d861750214776d0ab7a55617", "committedDate": "2021-05-22 17:13:17 -0500", "message": "lint: de-lint CardBrowser"}, {"oid": "80a2ef5172039f0c0d64ab251a409cd294b2fb3e", "committedDate": "2021-05-22 17:13:17 -0500", "message": "fix(CardBrowser): protect mCardsAdapter uses w/colOpen + null check"}, {"oid": "6d96bbebd62346f049666e2d4c12af3fdf58def3", "committedDate": "2021-05-23 10:24:30 -0500", "message": "Uses correct locale"}, {"oid": "30ad7fc0321bc95189980f979875087c43af8a46", "committedDate": "2021-06-01 22:54:41 -0500", "message": "NF: duplicate call to mSearchView.setQuery"}, {"oid": "a5363a2082c16261910bab0847941c4aa5ee07c2", "committedDate": "2021-06-01 22:54:41 -0500", "message": "fix: don't clear text when opening nav bar"}, {"oid": "1bdd80e9b17c2c3954bda1b3b0235870a5ad53c3", "committedDate": "2021-06-01 23:02:34 -0500", "message": "Fix for empty search results and wrong card count (#8998)"}, {"oid": "7d02438912756a3bfdbf34ddaf5cc6540e9d5f09", "committedDate": "2021-06-02 13:20:50 -0500", "message": "Test for card browser changing color when card flag changes (#8800)"}, {"oid": "532c25266e299ba7d55313d23ffe60a0d8b16e49", "committedDate": "2021-06-04 10:56:14 -0500", "message": "NF: CardBrowser create numCardsToRender"}, {"oid": "034ec28daa1ba4ac922cc77d1ff274c3d739edde", "committedDate": "2021-06-19 23:54:44 -0500", "message": "NF: remove usage of CardGetter/PairWithCard"}, {"oid": "becea6decc0023dedf3fd20c7c82f2592bb17cdb", "committedDate": "2021-06-19 23:54:44 -0500", "message": "NF: delete unused classes CardGetter/PairWithCard"}, {"oid": "34ed57bde71765358351e61803d373a90c7d30cb", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: remove BooleanGetter"}, {"oid": "f692b10de3bbc75e37075b4cc42b04cbada3bef6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename `other` to `value`"}, {"oid": "d3bbcfc9ec280c7e45a64ab5ab54550b697b04b6", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename getBoolean to Success"}, {"oid": "22e0854ccc348a1ac395e1b9a73245a34621545f", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename PairWithBoolean to Computation"}, {"oid": "8f423418a4b5aa3c754d94fdcf04017ea602894c", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: use getVlaue instead of mValue"}, {"oid": "c84cf4b151cfe460fd820d4cdf90c5daec4f43e1", "committedDate": "2021-07-16 09:37:14 -0500", "message": "Fix CardBrowser shows wrong deck"}, {"oid": "341e453ae469ca14405ba54fdd79fc77b1eeef76", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on handlers"}, {"oid": "79981a009745916ce9fffeed9cee9bb74f4ee3e3", "committedDate": "2021-07-31 09:15:04 -0500", "message": "fix lint: WrongConstant"}, {"oid": "37b924539e93597a65e7750bc260428b4837dced", "committedDate": "2021-08-04 20:45:34 -0500", "message": "feat: pink, turquoise & purple flags"}, {"oid": "12f24b93a16d1ad2313a79d14b47d290ce7d486c", "committedDate": "2021-08-05 15:27:23 -0500", "message": "js api to search card"}, {"oid": "d08acb24174f60f3f380b909beb1c0ae83d12411", "committedDate": "2021-08-11 23:06:21 +0200", "message": "Implement onboarding for CardBrowser"}, {"oid": "263c09b2e25ad37faec52da110084102c6a9e0b5", "committedDate": "2021-08-22 16:45:21 -0500", "message": "nf: DeckSpinnerSelection: extract collection deps"}, {"oid": "2529e8ccd4c4cfa33e116b27f515363152626793", "committedDate": "2021-08-22 16:45:21 -0500", "message": "nf: DeckSpinnerSelection: extract spinner"}, {"oid": "485934feb600efaa936bf6e40c1e729802691b53", "committedDate": "2021-08-22 16:45:21 -0500", "message": "fix: Display Note Editor title"}, {"oid": "60301a3db2a78990a49e0f71309a8798039d72c3", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: add set_config & remove_config"}, {"oid": "060357b99f0cc510f319d3aa6f242c9783e3bffa", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf using strongly typed get_config"}, {"oid": "d44f6196ef3f10e3f5ccfc952ec846a36e2449fd", "committedDate": "2021-08-22 17:53:20 -0500", "message": "feat: obtain conf objects using get_config"}, {"oid": "1ff3ff7570944e5f80d0a2f6caea13a3dcb44fd7", "committedDate": "2021-08-22 17:53:20 -0500", "message": "nf: fix nullability bug"}, {"oid": "e546c9ac7bfc2d33afee48da4e3e77666a438149", "committedDate": "2021-08-27 08:19:38 -0500", "message": "nf: Use isEmpty in place of checking size to be zero when possible"}, {"oid": "27dbaeed881d3a1ef7b775311dabdf0780d3fc7f", "committedDate": "2021-09-04 09:47:41 -0500", "message": "NF: uses hash set/map which take size as init istead of capacity (#8339)"}, {"oid": "562cfac72209132f9f22ff707276d0a46c3ecfbc", "committedDate": "2021-10-18 12:10:56 -0500", "message": "Computation: add \"out\" constraint"}, {"oid": "c88bc2e14bf2691c597b8702f701801c99632e2a", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert ScheduleCollectionTask async style"}, {"oid": "cb57ff16f3d8131cfd797b2e2f4a2771419adb9b", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert RescheduleRepositionReset async style"}, {"oid": "bd8f85f29633812b249152b8e4dac986d89ae49f", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert Undo async style"}, {"oid": "a316393d837034884fd4ceacef44572111f93ea5", "committedDate": "2021-10-18 12:10:56 -0500", "message": "sched: Extract Next Card functionality to pair"}, {"oid": "a757225878819325cb40dc832428dba7fe6128f4", "committedDate": "2021-10-18 12:33:34 -0500", "message": "fix(card-browser): Don't always show default deck"}, {"oid": "81d1d134863b8ab2c0560f9f11148b6a91996c0d", "committedDate": "2021-10-22 08:59:35 -0500", "message": "fix(handler): deprecation"}, {"oid": "1c0fa70b13d270cd2f230c0fb87d9e9347e75320", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract NoteService.isMarked"}, {"oid": "28736a6345e42d67a54991df3260f352d5459229", "committedDate": "2021-10-31 11:16:39 -0500", "message": "nf(eco-compat): rename _getQA to render_output"}, {"oid": "9bfceb3ac837201461d9a4d349a756d747bdbdb2", "committedDate": "2021-10-31 11:16:39 -0500", "message": "feat(eco-compat): render_output returns class"}, {"oid": "b0cb2174c467f769393d063944344fd5b927679a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: Introduce SortOrder class"}, {"oid": "442d57cead6c340f42437241c068da2270d92cb9", "committedDate": "2021-10-31 13:32:07 -0500", "message": "fix(search): V16 compat with bracketed tag search"}, {"oid": "019c32c32827080d1de8259c0212b9057d46c3bc", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: extract SearchCardsResult"}, {"oid": "1b3c687bfc7a4da0df1a1a90ebbc680f65650b6a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "feat(v16): implement findCards in backend"}, {"oid": "2b0b7c47ac79615a79e777987f13c94c187ee71f", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: move mShowAllDecks to final, add it in constructor"}, {"oid": "0b74559ff47c09f863d3ad9bc025581782e1c442", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: alwaysShowDefault is final. Move it to constructor"}, {"oid": "447d1ea5e049330a445f731ea64cd483c9e4f705", "committedDate": "2021-11-02 09:43:02 -0500", "message": "NF: simplify CardBrowser's selectAllDecks"}, {"oid": "e599145b41d85b148286e920edd7a77cfd5c64f0", "committedDate": "2021-11-10 07:29:11 -0500", "message": "refactor: remove FunctionalInterfaces.Consumer"}, {"oid": "d4c34c2e1735a0cb4354b6a1cdc0703e61904416", "committedDate": "2021-11-13 07:33:34 -0500", "message": "NF: change signature of `TagsDialogListener#onSelectedTags`"}, {"oid": "90fef130faea1471c87e864b8f8104813efd3e37", "committedDate": "2021-11-13 07:33:34 -0500", "message": "NF: refactor listener to do multiple actions"}, {"oid": "b9108e61d81ba0fc3f32857fb14c525814347563", "committedDate": "2021-11-13 07:33:34 -0500", "message": "feat: add \"Edit Tags\" in CardBrowser"}, {"oid": "18595046d4a869d3f88f3f8773c770e17c577e29", "committedDate": "2022-03-03 11:45:06 -0500", "message": "NF: replace tab by spaces"}, {"oid": "f21d95c75b1e366a9424adeb263729601b4c022e", "committedDate": "2022-04-05 17:17:32 -0500", "message": "Use DeckSelectionDialog on changeDeckDialog"}, {"oid": "5da9561a290122b52047c5c24648f078dc02dca7", "committedDate": "2022-04-07 10:27:03 -0500", "message": "refactor: typos & related KotlinCleanup"}, {"oid": "0fd0f558c49c728f0eca73a7f5059125cb0a638c", "committedDate": "2022-04-13 17:16:47 -0500", "message": "refactor: Rename CardBrowser.java to .kt"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NzA2MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435547061", "body": "Would be nice to `Timber.d` the count", "bodyText": "Would be nice to Timber.d the count", "bodyHTML": "<p dir=\"auto\">Would be nice to <code>Timber.d</code> the count</p>", "author": "david-allison-1", "createdAt": "2020-06-04T21:02:32Z", "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -895,11 +895,17 @@ private TaskData doInBackgroundSearchCards(TaskData... params) {\n         String query = (String) params[0].getObjArray()[0];\n         Boolean order = (Boolean) params[0].getObjArray()[1];\n         int numCardsToRender = (int) params[0].getObjArray()[2];\n-        List<Map<String,String>> searchResult = col.findCardsForCardBrowser(query, order);\n+        List<Long> searchResult_ = col.findCards(query, order);\n+        List<Map<String,String>> searchResult = new ArrayList<>(searchResult_.size());", "originalCommit": "3b638b1e5356ea1642c12d14b517aec3b13c5c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzExNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6362#discussion_r435573117", "bodyText": "Okay", "author": "Arthur-Milchior", "createdAt": "2020-06-04T21:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NzA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "fb983f23d1bdd251c2d5c8e28e1970ef5cbc0571", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex c27d097da..cfb64083e 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -896,7 +896,9 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         Boolean order = (Boolean) params[0].getObjArray()[1];\n         int numCardsToRender = (int) params[0].getObjArray()[2];\n         List<Long> searchResult_ = col.findCards(query, order);\n-        List<Map<String,String>> searchResult = new ArrayList<>(searchResult_.size());\n+        int resultSize = searchResult_.size();\n+        Timber.d(\"The search found %d cards\", resultSize);\n+        List<Map<String,String>> searchResult = new ArrayList<>(resultSize);\n         for (Long cid: searchResult_) {\n             Map<String, String> card = new HashMap<>();\n             card.put(CardBrowser.ID, cid.toString());\n", "next_change": {"commit": "783609ad81e5b933cd8b93bdc4a5d8ed0596029e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex cfb64083e..6348a0f42 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -895,19 +895,11 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         String query = (String) params[0].getObjArray()[0];\n         Boolean order = (Boolean) params[0].getObjArray()[1];\n         int numCardsToRender = (int) params[0].getObjArray()[2];\n-        List<Long> searchResult_ = col.findCards(query, order);\n-        int resultSize = searchResult_.size();\n-        Timber.d(\"The search found %d cards\", resultSize);\n-        List<Map<String,String>> searchResult = new ArrayList<>(resultSize);\n-        for (Long cid: searchResult_) {\n-            Map<String, String> card = new HashMap<>();\n-            card.put(CardBrowser.ID, cid.toString());\n-            searchResult.add(card);\n-        }\n+        List<Map<String,String>> searchResult = col.findCardsForCardBrowser(query, order);\n         // Render the first few items\n         for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n             Card c = col.getCard(Long.parseLong(searchResult.get(i).get(\"id\")));\n-            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n+            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "e6e96b8a762942a18b24787a4ec3e91d6070479b", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 6348a0f42..18b228a03 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -899,7 +899,7 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         // Render the first few items\n         for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n             Card c = col.getCard(Long.parseLong(searchResult.get(i).get(\"id\")));\n-            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c);\n+            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "8293ad235b65d93695ed4d8eeb1b4b421d8c2d56", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 18b228a03..c27d097da 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -895,7 +895,13 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         String query = (String) params[0].getObjArray()[0];\n         Boolean order = (Boolean) params[0].getObjArray()[1];\n         int numCardsToRender = (int) params[0].getObjArray()[2];\n-        List<Map<String,String>> searchResult = col.findCardsForCardBrowser(query, order);\n+        List<Long> searchResult_ = col.findCards(query, order);\n+        List<Map<String,String>> searchResult = new ArrayList<>(searchResult_.size());\n+        for (Long cid: searchResult_) {\n+            Map<String, String> card = new HashMap<>();\n+            card.put(CardBrowser.ID, cid.toString());\n+            searchResult.add(card);\n+        }\n         // Render the first few items\n         for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n             Card c = col.getCard(Long.parseLong(searchResult.get(i).get(\"id\")));\n", "next_change": {"commit": "7fccc05cde4e26216a73054bd61bd5278c507f6d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex c27d097da..1752248de 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -896,16 +896,15 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         Boolean order = (Boolean) params[0].getObjArray()[1];\n         int numCardsToRender = (int) params[0].getObjArray()[2];\n         List<Long> searchResult_ = col.findCards(query, order);\n-        List<Map<String,String>> searchResult = new ArrayList<>(searchResult_.size());\n+        int resultSize = searchResult_.size();\n+        Timber.d(\"The search found %d cards\", resultSize);\n+        List<CardBrowser.CardCache> searchResult = new ArrayList<>(resultSize);\n         for (Long cid: searchResult_) {\n-            Map<String, String> card = new HashMap<>();\n-            card.put(CardBrowser.ID, cid.toString());\n-            searchResult.add(card);\n+            searchResult.add(new CardBrowser.CardCache(cid, col));\n         }\n         // Render the first few items\n         for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n-            Card c = col.getCard(Long.parseLong(searchResult.get(i).get(\"id\")));\n-            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n+            searchResult.get(i).load(false);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "2114aeedad26a5384d6d6a46289f72e405f8c9e9", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 1752248de..cfb64083e 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -898,13 +898,16 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         List<Long> searchResult_ = col.findCards(query, order);\n         int resultSize = searchResult_.size();\n         Timber.d(\"The search found %d cards\", resultSize);\n-        List<CardBrowser.CardCache> searchResult = new ArrayList<>(resultSize);\n+        List<Map<String,String>> searchResult = new ArrayList<>(resultSize);\n         for (Long cid: searchResult_) {\n-            searchResult.add(new CardBrowser.CardCache(cid, col));\n+            Map<String, String> card = new HashMap<>();\n+            card.put(CardBrowser.ID, cid.toString());\n+            searchResult.add(card);\n         }\n         // Render the first few items\n         for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n-            searchResult.get(i).load(false);\n+            Card c = col.getCard(Long.parseLong(searchResult.get(i).get(\"id\")));\n+            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex c27d097da..4c8416c27 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -896,7 +896,9 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         Boolean order = (Boolean) params[0].getObjArray()[1];\n         int numCardsToRender = (int) params[0].getObjArray()[2];\n         List<Long> searchResult_ = col.findCards(query, order);\n-        List<Map<String,String>> searchResult = new ArrayList<>(searchResult_.size());\n+        int resultSize = searchResult_.size();\n+        List<Map<String,String>> searchResult = new ArrayList<>(resultSize);\n+        Timber.d(\"The search found %d cards\", resultSize);\n         for (Long cid: searchResult_) {\n             Map<String, String> card = new HashMap<>();\n             card.put(CardBrowser.ID, cid.toString());\n", "next_change": {"commit": "0cb1d97ca9b5ca5ab5174629603655506f9ffad2", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 4c8416c27..c20123255 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -895,7 +959,11 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         String query = (String) params[0].getObjArray()[0];\n         Boolean order = (Boolean) params[0].getObjArray()[1];\n         int numCardsToRender = (int) params[0].getObjArray()[2];\n-        List<Long> searchResult_ = col.findCards(query, order);\n+        List<Long> searchResult_ = col.findCards(query, order, this);\n+        if (isCancelled()) {\n+            Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n+            return null;\n+        }\n         int resultSize = searchResult_.size();\n         List<Map<String,String>> searchResult = new ArrayList<>(resultSize);\n         Timber.d(\"The search found %d cards\", resultSize);\n", "next_change": {"commit": "d4267b868d9b4e584d186f667de2f48636b333be", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex c20123255..c732e4778 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -953,22 +1164,22 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n     }\n \n \n-    private TaskData doInBackgroundSearchCards(TaskData... params) {\n+    private TaskData doInBackgroundSearchCards(TaskData param) {\n         Timber.d(\"doInBackgroundSearchCards\");\n-        Collection col = CollectionHelper.getInstance().getCol(mContext);\n-        String query = (String) params[0].getObjArray()[0];\n-        Boolean order = (Boolean) params[0].getObjArray()[1];\n-        int numCardsToRender = (int) params[0].getObjArray()[2];\n+        Collection col = getCol();\n+        String query = (String) param.getObjArray()[0];\n+        Boolean order = (Boolean) param.getObjArray()[1];\n+        int numCardsToRender = (int) param.getObjArray()[2];\n         List<Long> searchResult_ = col.findCards(query, order, this);\n         if (isCancelled()) {\n             Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n             return null;\n         }\n         int resultSize = searchResult_.size();\n-        List<Map<String,String>> searchResult = new ArrayList<>(resultSize);\n+        List<CardBrowser.CardCache> searchResult = new ArrayList<>(resultSize);\n         Timber.d(\"The search found %d cards\", resultSize);\n         for (Long cid: searchResult_) {\n-            Map<String, String> card = new HashMap<>();\n+            CardBrowser.CardCache card = new CardBrowser.CardCache();\n             card.put(CardBrowser.ID, cid.toString());\n             searchResult.add(card);\n         }\n", "next_change": {"commit": "f6b4230e354e2965089317b68124bf15bfa54b84", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex c732e4778..5b63ff47f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1179,8 +1179,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n         List<CardBrowser.CardCache> searchResult = new ArrayList<>(resultSize);\n         Timber.d(\"The search found %d cards\", resultSize);\n         for (Long cid: searchResult_) {\n-            CardBrowser.CardCache card = new CardBrowser.CardCache();\n-            card.put(CardBrowser.ID, cid.toString());\n+            CardBrowser.CardCache card = new CardBrowser.CardCache(cid, col);\n             searchResult.add(card);\n         }\n         // Render the first few items\n", "next_change": {"commit": "0ed0b26615da7a6bca6313471ceda4e1162656b0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 5b63ff47f..4272ee460 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,7 +1188,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            Card c = col.getCard(searchResult.get(i).getId());\n+            Card c = searchResult.get(i).getCard();\n             CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n         // Finish off the task\n", "next_change": {"commit": "4a0d565455507e4b0a9123f13a6d23c539788df7", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 4272ee460..ba09fd15c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,7 +1188,9 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            Card c = searchResult.get(i).getCard();\n+            CardBrowser.CardCache card = searchResult.get(i);\n+            card.load(false);\n+            Card c = card.getCard();\n             CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n         // Finish off the task\n", "next_change": {"commit": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex ba09fd15c..c0ab1f715 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1191,7 +1191,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n             CardBrowser.CardCache card = searchResult.get(i);\n             card.load(false);\n             Card c = card.getCard();\n-            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n+            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "25668235083fa2e4c0716fb177f0ed756d5f18f1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex c0ab1f715..7552fda8a 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1191,7 +1191,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n             CardBrowser.CardCache card = searchResult.get(i);\n             card.load(false);\n             Card c = card.getCard();\n-            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c);\n+            CardBrowser.updateSearchItemQA(searchResult.get(i), c);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "216580a8bfebb2e94d3ee973e9c16dea5b45f6a2", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 7552fda8a..b7b8edeb1 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1190,8 +1190,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n             }\n             CardBrowser.CardCache card = searchResult.get(i);\n             card.load(false);\n-            Card c = card.getCard();\n-            CardBrowser.updateSearchItemQA(searchResult.get(i), c);\n+            CardBrowser.updateSearchItemQA(searchResult.get(i));\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "474450d513e379802bca25b64e9d2dccfa7dc105", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex b7b8edeb1..527f0c054 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,9 +1188,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            CardBrowser.CardCache card = searchResult.get(i);\n-            card.load(false);\n-            CardBrowser.updateSearchItemQA(searchResult.get(i));\n+            CardBrowser.CardCache card = searchResult.get(i).load(false);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "d90769e73040f4d591ed783b7d66a856c8bfe7e3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 527f0c054..28218624d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,7 +1188,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            CardBrowser.CardCache card = searchResult.get(i).load(false);\n+            searchResult.get(i).load(false);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "23d64c43221e83f1ca9b1dd0987e47a570a1f33c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 28218624d..19cc01d57 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,7 +1190,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            searchResult.get(i).load(false);\n+            searchResult.get(i).load(false, column1Index, column2Index);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "dbaf6549ec268333b20d160a0c40962d3135ba0d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 19cc01d57..83905c963 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1176,22 +1251,12 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n         }\n         int column1Index = (Integer) param.getObjArray()[3];\n         int column2Index = (Integer) param.getObjArray()[4];\n-        List<Long> searchResult_ = col.findCards(query, order, this);\n+        final List<CardBrowser.CardCache> searchResult = new ArrayList<>();\n+        PartialSearch partialSearch = new PartialSearch(searchResult, column1Index, column2Index, numCardsToRender);\n+        List<Long> searchResult_ = col.findCards(query, order, partialSearch);\n+        partialSearch.add(searchResult_);\n         int resultSize = searchResult_.size();\n-        List<CardBrowser.CardCache> searchResult = new ArrayList<>(resultSize);\n         Timber.d(\"The search found %d cards\", resultSize);\n-        for (Long cid: searchResult_) {\n-            CardBrowser.CardCache card = new CardBrowser.CardCache(cid, col);\n-            searchResult.add(card);\n-        }\n-        // Render the first few items\n-        for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n-            if (isCancelled()) {\n-                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-                return null;\n-            }\n-            searchResult.get(i).load(false, column1Index, column2Index);\n-        }\n         // Finish off the task\n         if (isCancelled()) {\n             Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n", "next_change": {"commit": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 83905c963..9ad6fad8d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1239,449 +1078,563 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n         }\n     }\n \n-    private TaskData doInBackgroundSearchCards(TaskData param) {\n-        Timber.d(\"doInBackgroundSearchCards\");\n-        Collection col = getCol();\n-        String query = (String) param.getObjArray()[0];\n-        Boolean order = (Boolean) param.getObjArray()[1];\n-        int numCardsToRender = (int) param.getObjArray()[2];\n-        if (isCancelled()) {\n-            Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-            return null;\n-        }\n-        int column1Index = (Integer) param.getObjArray()[3];\n-        int column2Index = (Integer) param.getObjArray()[4];\n-        final List<CardBrowser.CardCache> searchResult = new ArrayList<>();\n-        PartialSearch partialSearch = new PartialSearch(searchResult, column1Index, column2Index, numCardsToRender);\n-        List<Long> searchResult_ = col.findCards(query, order, partialSearch);\n-        partialSearch.add(searchResult_);\n-        int resultSize = searchResult_.size();\n-        Timber.d(\"The search found %d cards\", resultSize);\n-        // Finish off the task\n-        if (isCancelled()) {\n-            Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-            return null;\n-        } else {\n-            return new TaskData(searchResult);\n-        }\n-    }\n \n+    public static class SearchCards extends Task<List<CardBrowser.CardCache>, List<CardBrowser.CardCache>> {\n+        private final String query;\n+        private final boolean order;\n+        private final int numCardsToRender;\n+        private final int column1Index;\n+        private final int column2Index;\n \n-    private TaskData doInBackgroundRenderBrowserQA(TaskData param) {\n-        Timber.d(\"doInBackgroundRenderBrowserQA\");\n-        Collection col = getCol();\n-        List<CardBrowser.CardCache> cards = (List<CardBrowser.CardCache>) param.getObjArray()[0];\n-        Integer startPos = (Integer) param.getObjArray()[1];\n-        Integer n = (Integer) param.getObjArray()[2];\n-        int column1Index = (Integer) param.getObjArray()[3];\n-        int column2Index = (Integer) param.getObjArray()[4];\n \n-        List<Long> invalidCardIds = new ArrayList<>();\n-        // for each specified card in the browser list\n-        for (int i = startPos; i < startPos + n; i++) {\n-            // Stop if cancelled\n-            if (isCancelled()) {\n-                Timber.d(\"doInBackgroundRenderBrowserQA was aborted\");\n+        public SearchCards(String query, boolean order, int numCardsToRender, int column1Index, int column2Index) {\n+            this.query = query;\n+            this.order = order;\n+            this.numCardsToRender = numCardsToRender;\n+            this.column1Index = column1Index;\n+            this.column2Index = column2Index;\n+        }\n+\n+\n+        protected List<CardBrowser.CardCache> task(Collection col, ProgressSenderAndCancelListener<List<CardBrowser.CardCache>> collectionTask) {\n+            Timber.d(\"doInBackgroundSearchCards\");\n+            if (collectionTask.isCancelled()) {\n+                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            if (i < 0 || i >= cards.size()) {\n-                continue;\n-            }\n-            CardBrowser.CardCache card;\n-            try {\n-                card = cards.get(i);\n-            }\n-            catch (IndexOutOfBoundsException e) {\n-                //even though we test against card.size() above, there's still a race condition\n-                //We might be able to optimise this to return here. Logically if we're past the end of the collection,\n-                //we won't reach any more cards.\n-                continue;\n+            List<CardBrowser.CardCache> searchResult = new ArrayList<>();\n+            List<Long> searchResult_ = col.findCards(query, order, new PartialSearch(searchResult, column1Index, column2Index, numCardsToRender, collectionTask, col));\n+            Timber.d(\"The search found %d cards\", searchResult_.size());\n+            int position = 0;\n+            for (Long cid : searchResult_) {\n+                CardBrowser.CardCache card = new CardBrowser.CardCache(cid, col, position++);\n+                searchResult.add(card);\n             }\n-            if (card.isLoaded()) {\n-                //We've already rendered the answer, we don't need to do it again.\n-                continue;\n+            // Render the first few items\n+            for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n+                if (collectionTask.isCancelled()) {\n+                    Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n+                    return null;\n+                }\n+                searchResult.get(i).load(false, column1Index, column2Index);\n             }\n-            // Extract card item\n-            try {\n-                // Ensure that card still exists.\n-                card.getCard();\n-            } catch (WrongId e) {\n-                //#5891 - card can be inconsistent between the deck browser screen and the collection.\n-                //Realistically, we can skip any exception as it's a rendering task which should not kill the\n-                //process\n-                long cardId = card.getId();\n-                Timber.e(e, \"Could not process card '%d' - skipping and removing from sight\", cardId);\n-                invalidCardIds.add(cardId);\n-                continue;\n+            // Finish off the task\n+            if (collectionTask.isCancelled()) {\n+                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n+                return null;\n+            } else {\n+                return searchResult;\n             }\n-            // Update item\n-            card.load(false, column1Index, column2Index);\n-            float progress = (float) i / n * 100;\n-            publishProgress(new TaskData((int) progress));\n         }\n-        return new TaskData(new Object[] { cards, invalidCardIds });\n     }\n \n \n-    private TaskData doInBackgroundCheckDatabase() {\n+    public static class RenderBrowserQA extends Task<Integer, Pair<CardBrowser.CardCollection<CardBrowser.CardCache>, List<Long>>> {\n+        private final CardBrowser.CardCollection<CardBrowser.CardCache> cards;\n+        private final Integer startPos;\n+        private final Integer n;\n+        private final int column1Index;\n+        private final int column2Index;\n+\n+\n+        public RenderBrowserQA(CardBrowser.CardCollection<CardBrowser.CardCache> cards, Integer mStartPos, Integer n, int column1Index, int column2Index) {\n+            this.cards = cards;\n+            this.startPos = mStartPos;\n+            this.n = n;\n+            this.column1Index = column1Index;\n+            this.column2Index = column2Index;\n+        }\n+\n+\n+        protected Pair<CardBrowser.CardCollection<CardBrowser.CardCache>, List<Long>> task(Collection col, ProgressSenderAndCancelListener<Integer> collectionTask) {\n+            Timber.d(\"doInBackgroundRenderBrowserQA\");\n+\n+            List<Long> invalidCardIds = new ArrayList<>();\n+            // for each specified card in the browser list\n+            for (int i = startPos; i < startPos + n; i++) {\n+                // Stop if cancelled\n+                if (collectionTask.isCancelled()) {\n+                    Timber.d(\"doInBackgroundRenderBrowserQA was aborted\");\n+                    return null;\n+                }\n+                if (i < 0 || i >= cards.size()) {\n+                    continue;\n+                }\n+                CardBrowser.CardCache card;\n+                try {\n+                    card = cards.get(i);\n+                }\n+                catch (IndexOutOfBoundsException e) {\n+                    //even though we test against card.size() above, there's still a race condition\n+                    //We might be able to optimise this to return here. Logically if we're past the end of the collection,\n+                    //we won't reach any more cards.\n+                    continue;\n+                }\n+                if (card.isLoaded()) {\n+                    //We've already rendered the answer, we don't need to do it again.\n+                    continue;\n+                }\n+                // Extract card item\n+                try {\n+                    // Ensure that card still exists.\n+                    card.getCard();\n+                } catch (WrongId e) {\n+                    //#5891 - card can be inconsistent between the deck browser screen and the collection.\n+                    //Realistically, we can skip any exception as it's a rendering task which should not kill the\n+                    //process\n+                    long cardId = card.getId();\n+                    Timber.e(e, \"Could not process card '%d' - skipping and removing from sight\", cardId);\n+                    invalidCardIds.add(cardId);\n+                    continue;\n+                }\n+                // Update item\n+                card.load(false, column1Index, column2Index);\n+                float progress = (float) i / n * 100;\n+                collectionTask.doProgress((int) progress);\n+            }\n+            return new Pair<>(cards, invalidCardIds);\n+        }\n+    }\n+\n+    public static class CheckDatabase extends Task<String, Pair<Boolean, Collection.CheckDatabaseResult>> {\n+    protected Pair<Boolean, Collection.CheckDatabaseResult> task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n         Timber.d(\"doInBackgroundCheckDatabase\");\n-        Collection col = getCol();\n         // Don't proceed if collection closed\n         if (col == null) {\n             Timber.e(\"doInBackgroundCheckDatabase :: supplied collection was null\");\n-            return new TaskData(false);\n+            return new Pair(false, null);\n         }\n \n-        Collection.CheckDatabaseResult result = col.fixIntegrity(new ProgressCallback(this, AnkiDroidApp.getAppResources()));\n+        Collection.CheckDatabaseResult result = col.fixIntegrity(new TaskManager.ProgressCallback(collectionTask, AnkiDroidApp.getAppResources()));\n         if (result.getFailed()) {\n             //we can fail due to a locked database, which requires knowledge of the failure.\n-            return new TaskData(false, new Object[] { result });\n+            return new Pair(false, result);\n         } else {\n             // Close the collection and we restart the app to reload\n             CollectionHelper.getInstance().closeCollection(true, \"Check Database Completed\");\n-            return new TaskData(true, new Object[] { result });\n+            return new Pair(true, result);\n         }\n     }\n+    }\n \n \n-    private TaskData doInBackgroundRepairCollection() {\n-        Timber.d(\"doInBackgroundRepairCollection\");\n-        Collection col = getCol();\n-        if (col != null) {\n-            Timber.i(\"RepairCollection: Closing collection\");\n-            col.close(false);\n+    public static class RepairCollectionn extends Task<Void, Boolean> {\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundRepairCollection\");\n+            if (col != null) {\n+                Timber.i(\"RepairCollection: Closing collection\");\n+                col.close(false);\n+            }\n+            return BackupManager.repairCollection(col);\n         }\n-        return new TaskData(BackupManager.repairCollection(col));\n     }\n \n \n-    private TaskData doInBackgroundUpdateValuesFromDeck(TaskData param) {\n-        Timber.d(\"doInBackgroundUpdateValuesFromDeck\");\n-        try {\n-            Collection col = getCol();\n-            AbstractSched sched = col.getSched();\n-            Object[] obj = param.getObjArray();\n-            boolean reset = (Boolean) obj[0];\n-            if (reset) {\n-                // reset actually required because of counts, which is used in getCollectionTaskListener\n-                sched.resetCounts();\n-            }\n-            Counts counts = sched.counts();\n-            int totalNewCount = sched.totalNewForCurrentDeck();\n-            int totalCount = sched.cardCount();\n-            return new TaskData(new Object[]{counts.getNew(), counts.getLrn(), counts.getRev(), totalNewCount,\n-                    totalCount, sched.eta(counts)});\n-        } catch (RuntimeException e) {\n-            Timber.e(e, \"doInBackgroundUpdateValuesFromDeck - an error occurred\");\n-            return null;\n+    public static class UpdateValuesFromDeck extends Task<Void, int[]> {\n+        private final boolean reset;\n+\n+\n+        public UpdateValuesFromDeck(boolean reset) {\n+            this.reset = reset;\n         }\n-    }\n \n \n-    private void doInBackgroundDeleteDeck(TaskData param) {\n-        Timber.d(\"doInBackgroundDeleteDeck\");\n-        Collection col = getCol();\n-        long did = param.getLong();\n-        col.getDecks().rem(did, true);\n-        // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n-        getCol().clearUndo();\n+        public int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundUpdateValuesFromDeck\");\n+            try {\n+                AbstractSched sched = col.getSched();\n+                if (reset) {\n+                    // reset actually required because of counts, which is used in getCollectionTaskListener\n+                    sched.resetCounts();\n+                }\n+                Counts counts = sched.counts();\n+                int totalNewCount = sched.totalNewForCurrentDeck();\n+                int totalCount = sched.cardCount();\n+                return new int[] {counts.getNew(), counts.getLrn(), counts.getRev(), totalNewCount,\n+                        totalCount, sched.eta(counts)};\n+            } catch (RuntimeException e) {\n+                Timber.e(e, \"doInBackgroundUpdateValuesFromDeck - an error occurred\");\n+                return null;\n+            }\n+        }\n     }\n \n \n-    private TaskData doInBackgroundRebuildCram() {\n-        Timber.d(\"doInBackgroundRebuildCram\");\n-        Collection col = getCol();\n-        col.getSched().rebuildDyn(col.getDecks().selected());\n-        return doInBackgroundUpdateValuesFromDeck(new TaskData(new Object[]{true}));\n-    }\n+    public static class DeleteDeck extends Task<Void, int[]> {\n+        private final long did;\n \n+        public DeleteDeck(long did) {\n+            this.did = did;\n+        }\n \n-    private TaskData doInBackgroundEmptyCram() {\n-        Timber.d(\"doInBackgroundEmptyCram\");\n-        Collection col = getCol();\n-        col.getSched().emptyDyn(col.getDecks().selected());\n-        return doInBackgroundUpdateValuesFromDeck(new TaskData(new Object[]{true}));\n+        protected int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundDeleteDeck\");\n+            col.getDecks().rem(did, true);\n+            // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n+            col.clearUndo();\n+            return null;\n+        }\n     }\n \n \n-    private TaskData doInBackgroundImportAdd(TaskData param) {\n-        Timber.d(\"doInBackgroundImportAdd\");\n-        Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n-        Collection col = getCol();\n-        String path = param.getString();\n-        AnkiPackageImporter imp = new AnkiPackageImporter(col, path);\n-        imp.setProgressCallback(new ProgressCallback(this, res));\n-        try {\n-            imp.run();\n-        } catch (ImportExportException e) {\n-            return new TaskData(e.getMessage(), true);\n+    public static class RebuildCram extends Task<Void, int[]> {\n+        protected int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundRebuildCram\");\n+            col.getSched().rebuildDyn(col.getDecks().selected());\n+            return new UpdateValuesFromDeck(true).task(col, collectionTask);\n+        }\n+    }\n+\n+    public static class EmptyCram extends Task<Void, int[]> {\n+        protected int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundEmptyCram\");\n+            col.getSched().emptyDyn(col.getDecks().selected());\n+            return new UpdateValuesFromDeck(true).task(col, collectionTask);\n         }\n-        return new TaskData(new Object[] {imp});\n     }\n \n+    public static class ImportAdd extends Task<String, Triple<AnkiPackageImporter, Boolean, String>> {\n+        private final String path;\n \n-    private TaskData doInBackgroundImportReplace(TaskData param) {\n-        Timber.d(\"doInBackgroundImportReplace\");\n-        String path = param.getString();\n-        Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n \n-        // extract the deck from the zip file\n-        String colPath = CollectionHelper.getCollectionPath(mContext);\n-        File dir = new File(new File(colPath).getParentFile(), \"tmpzip\");\n-        if (dir.exists()) {\n-            BackupManager.removeDir(dir);\n+        public ImportAdd(String path) {\n+            this.path = path;\n         }\n \n-        // from anki2.py\n-        String colname = \"collection.anki21\";\n-        ZipFile zip;\n-        try {\n-            zip = new ZipFile(new File(path));\n-        } catch (IOException e) {\n-            Timber.e(e, \"doInBackgroundImportReplace - Error while unzipping\");\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace0\");\n-            return new TaskData(false);\n-        }\n-        try {\n-            // v2 scheduler?\n-            if (zip.getEntry(colname) == null) {\n-                colname = CollectionHelper.COLLECTION_FILENAME;\n+\n+        protected Triple<AnkiPackageImporter, Boolean, String> task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n+            Timber.d(\"doInBackgroundImportAdd\");\n+            Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n+            AnkiPackageImporter imp = new AnkiPackageImporter(col, path);\n+            imp.setProgressCallback(new TaskManager.ProgressCallback(collectionTask, res));\n+            try {\n+                imp.run();\n+            } catch (ImportExportException e) {\n+                return new Triple(null, true, e.getMessage());\n             }\n-            Utils.unzipFiles(zip, dir.getAbsolutePath(), new String[] { colname, \"media\" }, null);\n-        } catch (IOException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - unzip\");\n-            return new TaskData(false);\n+            return new Triple<>(imp, false, null);\n         }\n-        String colFile = new File(dir, colname).getAbsolutePath();\n-        if (!(new File(colFile)).exists()) {\n-            return new TaskData(false);\n+    }\n+\n+\n+    public static class ImportReplace extends Task<String, BooleanGetter> {\n+        private final String path;\n+\n+\n+        public ImportReplace(String path) {\n+            this.path = path;\n         }\n \n-        Collection tmpCol = null;\n-        try {\n-            tmpCol = Storage.Collection(mContext, colFile);\n-            if (!tmpCol.validCollection()) {\n-                tmpCol.close();\n-                return new TaskData(false);\n+\n+        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n+            Timber.d(\"doInBackgroundImportReplace\");\n+            Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n+            Context context = col.getContext();\n+\n+            // extract the deck from the zip file\n+            String colPath = CollectionHelper.getCollectionPath(context);\n+            File dir = new File(new File(colPath).getParentFile(), \"tmpzip\");\n+            if (dir.exists()) {\n+                BackupManager.removeDir(dir);\n             }\n-        } catch (Exception e) {\n-            Timber.e(\"Error opening new collection file... probably it's invalid\");\n+\n+            // from anki2.py\n+            String colname = \"collection.anki21\";\n+            ZipFile zip;\n             try {\n-                tmpCol.close();\n-            } catch (Exception e2) {\n-                // do nothing\n+                zip = new ZipFile(new File(path));\n+            } catch (IOException e) {\n+                Timber.e(e, \"doInBackgroundImportReplace - Error while unzipping\");\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace0\");\n+                return fromBoolean(false);\n             }\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - open col\");\n-            return new TaskData(false);\n-        } finally {\n-            if (tmpCol != null) {\n-                tmpCol.close();\n+            try {\n+                // v2 scheduler?\n+                if (zip.getEntry(colname) == null) {\n+                    colname = CollectionHelper.COLLECTION_FILENAME;\n+                }\n+                Utils.unzipFiles(zip, dir.getAbsolutePath(), new String[] {colname, \"media\"}, null);\n+            } catch (IOException e) {\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - unzip\");\n+                return fromBoolean(false);\n+            }\n+            String colFile = new File(dir, colname).getAbsolutePath();\n+            if (!(new File(colFile)).exists()) {\n+                return fromBoolean(false);\n             }\n-        }\n-\n-        publishProgress(new TaskData(res.getString(R.string.importing_collection)));\n \n-        if (hasValidCol()) {\n-            // unload collection and trigger a backup\n-            Time time = CollectionHelper.getInstance().getTimeSafe(mContext);\n-            CollectionHelper.getInstance().closeCollection(true, \"Importing new collection\");\n-            CollectionHelper.getInstance().lockCollection();\n-            BackupManager.performBackupInBackground(colPath, true, time);\n-        }\n-        // overwrite collection\n-        File f = new File(colFile);\n-        if (!f.renameTo(new File(colPath))) {\n-            // Exit early if this didn't work\n-            return new TaskData(false);\n-        }\n-        int addedCount = -1;\n-        try {\n-            CollectionHelper.getInstance().unlockCollection();\n-\n-            // because users don't have a backup of media, it's safer to import new\n-            // data and rely on them running a media db check to get rid of any\n-            // unwanted media. in the future we might also want to duplicate this step\n-            // import media\n-            HashMap<String, String> nameToNum = new HashMap<>();\n-            HashMap<String, String> numToName = new HashMap<>();\n-            File mediaMapFile = new File(dir.getAbsolutePath(), \"media\");\n-            if (mediaMapFile.exists()) {\n-                JsonReader jr = new JsonReader(new FileReader(mediaMapFile));\n-                jr.beginObject();\n-                String name;\n-                String num;\n-                while (jr.hasNext()) {\n-                    num = jr.nextName();\n-                    name = jr.nextString();\n-                    nameToNum.put(name, num);\n-                    numToName.put(num, name);\n+            Collection tmpCol = null;\n+            try {\n+                tmpCol = Storage.Collection(context, colFile);\n+                if (!tmpCol.validCollection()) {\n+                    tmpCol.close();\n+                    return fromBoolean(false);\n                 }\n-                jr.endObject();\n-                jr.close();\n-            }\n-            String mediaDir = Media.getCollectionMediaPath(colPath);\n-            int total = nameToNum.size();\n-            int i = 0;\n-            for (Map.Entry<String, String> entry : nameToNum.entrySet()) {\n-                String file = entry.getKey();\n-                String c = entry.getValue();\n-                File of = new File(mediaDir, file);\n-                if (!of.exists()) {\n-                    Utils.unzipFiles(zip, mediaDir, new String[] { c }, numToName);\n+            } catch (Exception e) {\n+                Timber.e(\"Error opening new collection file... probably it's invalid\");\n+                try {\n+                    tmpCol.close();\n+                } catch (Exception e2) {\n+                    // do nothing\n                 }\n-                ++i;\n-                publishProgress(new TaskData(res.getString(R.string.import_media_count, (i + 1) * 100 / total)));\n-            }\n-            zip.close();\n-            // delete tmp dir\n-            BackupManager.removeDir(dir);\n-            return new TaskData(true);\n-        } catch (RuntimeException e) {\n-            Timber.e(e, \"doInBackgroundImportReplace - RuntimeException\");\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace1\");\n-            return new TaskData(false);\n-        } catch (FileNotFoundException e) {\n-            Timber.e(e, \"doInBackgroundImportReplace - FileNotFoundException\");\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace2\");\n-            return new TaskData(false);\n-        } catch (IOException e) {\n-            Timber.e(e, \"doInBackgroundImportReplace - IOException\");\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace3\");\n-            return new TaskData(false);\n-        }\n-    }\n-\n-\n-    private TaskData doInBackgroundExportApkg(TaskData param) {\n-        Timber.d(\"doInBackgroundExportApkg\");\n-        Object[] data = param.getObjArray();\n-        Collection col = (Collection) data[0];\n-        String apkgPath = (String) data[1];\n-        Long did = (Long) data[2];\n-        boolean includeSched = (Boolean) data[3];\n-        boolean includeMedia = (Boolean) data[4];\n-        \n-        try {\n-            AnkiPackageExporter exporter = new AnkiPackageExporter(col);\n-            exporter.setIncludeSched(includeSched);\n-            exporter.setIncludeMedia(includeMedia);\n-            exporter.setDid(did);\n-            exporter.exportInto(apkgPath, mContext);\n-        } catch (FileNotFoundException e) {\n-            Timber.e(e, \"FileNotFoundException in doInBackgroundExportApkg\");\n-            return new TaskData(false);\n-        } catch (IOException e) {\n-            Timber.e(e, \"IOException in doInBackgroundExportApkg\");\n-            return new TaskData(false);\n-        } catch (JSONException e) {\n-            Timber.e(e, \"JSOnException in doInBackgroundExportApkg\");\n-            return new TaskData(false);\n-        } catch (ImportExportException e) {\n-            Timber.e(e, \"ImportExportException in doInBackgroundExportApkg\");\n-            return new TaskData(e.getMessage(), true);\n-        }\n-        return new TaskData(apkgPath);\n-    }\n-\n-\n-    private TaskData doInBackgroundReorder(TaskData param) {\n-        Timber.d(\"doInBackgroundReorder\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        DeckConfig conf = (DeckConfig) data[0];\n-        col.getSched().resortConf(conf);\n-        return new TaskData(true);\n-    }\n-\n-\n-    private TaskData doInBackgroundConfChange(TaskData param) {\n-        Timber.d(\"doInBackgroundConfChange\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        Deck deck = (Deck) data[0];\n-        DeckConfig conf = (DeckConfig) data[1];\n-        try {\n-            long newConfId = conf.getLong(\"id\");\n-            // If new config has a different sorting order, reorder the cards\n-            int oldOrder = col.getDecks().getConf(deck.getLong(\"conf\")).getJSONObject(\"new\").getInt(\"order\");\n-            int newOrder = col.getDecks().getConf(newConfId).getJSONObject(\"new\").getInt(\"order\");\n-            if (oldOrder != newOrder) {\n-                switch (newOrder) {\n-                    case 0:\n-                        col.getSched().randomizeCards(deck.getLong(\"id\"));\n-                        break;\n-                    case 1:\n-                        col.getSched().orderCards(deck.getLong(\"id\"));\n-                        break;\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - open col\");\n+                return fromBoolean(false);\n+            } finally {\n+                if (tmpCol != null) {\n+                    tmpCol.close();\n                 }\n             }\n-            col.getDecks().setConf(deck, newConfId);\n-            col.save();\n-            return new TaskData(true);\n-        } catch (JSONException e) {\n-            return new TaskData(false);\n+\n+            collectionTask.doProgress(res.getString(R.string.importing_collection));\n+\n+            try {\n+                CollectionHelper.getInstance().getCol(context);\n+                // unload collection and trigger a backup\n+                Time time = CollectionHelper.getInstance().getTimeSafe(context);\n+                CollectionHelper.getInstance().closeCollection(true, \"Importing new collection\");\n+                CollectionHelper.getInstance().lockCollection();\n+                BackupManager.performBackupInBackground(colPath, true, time);\n+            } catch (Exception e) {\n+            }\n+            // overwrite collection\n+            File f = new File(colFile);\n+            if (!f.renameTo(new File(colPath))) {\n+                // Exit early if this didn't work\n+                return fromBoolean(false);\n+            }\n+            int addedCount = -1;\n+            try {\n+                CollectionHelper.getInstance().unlockCollection();\n+\n+                // because users don't have a backup of media, it's safer to import new\n+                // data and rely on them running a media db check to get rid of any\n+                // unwanted media. in the future we might also want to duplicate this step\n+                // import media\n+                HashMap<String, String> nameToNum = new HashMap<>();\n+                HashMap<String, String> numToName = new HashMap<>();\n+                File mediaMapFile = new File(dir.getAbsolutePath(), \"media\");\n+                if (mediaMapFile.exists()) {\n+                    JsonReader jr = new JsonReader(new FileReader(mediaMapFile));\n+                    jr.beginObject();\n+                    String name;\n+                    String num;\n+                    while (jr.hasNext()) {\n+                        num = jr.nextName();\n+                        name = jr.nextString();\n+                        nameToNum.put(name, num);\n+                        numToName.put(num, name);\n+                    }\n+                    jr.endObject();\n+                    jr.close();\n+                }\n+                String mediaDir = Media.getCollectionMediaPath(colPath);\n+                int total = nameToNum.size();\n+                int i = 0;\n+                for (Map.Entry<String, String> entry : nameToNum.entrySet()) {\n+                    String file = entry.getKey();\n+                    String c = entry.getValue();\n+                    File of = new File(mediaDir, file);\n+                    if (!of.exists()) {\n+                        Utils.unzipFiles(zip, mediaDir, new String[] {c}, numToName);\n+                    }\n+                    ++i;\n+                    collectionTask.doProgress(res.getString(R.string.import_media_count, (i + 1) * 100 / total));\n+                }\n+                zip.close();\n+                // delete tmp dir\n+                BackupManager.removeDir(dir);\n+                return fromBoolean(true);\n+            } catch (RuntimeException e) {\n+                Timber.e(e, \"doInBackgroundImportReplace - RuntimeException\");\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace1\");\n+                return fromBoolean(false);\n+            } catch (FileNotFoundException e) {\n+                Timber.e(e, \"doInBackgroundImportReplace - FileNotFoundException\");\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace2\");\n+                return fromBoolean(false);\n+            } catch (IOException e) {\n+                Timber.e(e, \"doInBackgroundImportReplace - IOException\");\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace3\");\n+                return fromBoolean(false);\n+            }\n         }\n     }\n \n \n-    private TaskData doInBackgroundConfReset(TaskData param) {\n-        Timber.d(\"doInBackgroundConfReset\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        DeckConfig conf = (DeckConfig) data[0];\n-        col.getDecks().restoreToDefault(conf);\n-        col.save();\n-        return new TaskData(true);\n+    public static class ExportApkg extends Task<Void, Pair<Boolean, String>> {\n+        private final String apkgPath;\n+        private final Long did;\n+        private final Boolean includeSched;\n+        private final Boolean includeMedia;\n+\n+\n+        public ExportApkg(String apkgPath, Long did, Boolean includeSched, Boolean includeMedia) {\n+            this.apkgPath = apkgPath;\n+            this.did = did;\n+            this.includeSched = includeSched;\n+            this.includeMedia = includeMedia;\n+        }\n+\n+\n+        protected Pair<Boolean, String> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundExportApkg\");\n+\n+            try {\n+                AnkiPackageExporter exporter = new AnkiPackageExporter(col);\n+                exporter.setIncludeSched(includeSched);\n+                exporter.setIncludeMedia(includeMedia);\n+                exporter.setDid(did);\n+                exporter.exportInto(apkgPath, col.getContext());\n+            } catch (FileNotFoundException e) {\n+                Timber.e(e, \"FileNotFoundException in doInBackgroundExportApkg\");\n+                return new Pair(false, null);\n+            } catch (IOException e) {\n+                Timber.e(e, \"IOException in doInBackgroundExportApkg\");\n+                return new Pair(false, null);\n+            } catch (JSONException e) {\n+                Timber.e(e, \"JSOnException in doInBackgroundExportApkg\");\n+                return new Pair(false, null);\n+            } catch (ImportExportException e) {\n+                Timber.e(e, \"ImportExportException in doInBackgroundExportApkg\");\n+                return new Pair(true, e.getMessage());\n+            }\n+            return new Pair(false, apkgPath);\n+        }\n     }\n \n \n-    private TaskData doInBackgroundConfRemove(TaskData param) {\n-        Timber.d(\"doInBackgroundConfRemove\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        DeckConfig conf = (DeckConfig) data[0];\n-        try {\n-            // Note: We do the actual removing of the options group in the main thread so that we \n-            // can ask the user to confirm if they're happy to do a full sync, and just do the resorting here\n+    public static class Reorder extends Task<Void, Boolean> {\n+        private final DeckConfig conf;\n+\n+\n+        public Reorder(DeckConfig conf) {\n+            this.conf = conf;\n+        }\n+\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundReorder\");\n+            col.getSched().resortConf(conf);\n+            return true;\n+        }\n+    }\n+\n+\n+    public static class ConfChange extends Task<Void, Boolean> {\n+        private final Deck deck;\n+        private final DeckConfig conf;\n+\n+\n+        public ConfChange(Deck deck, DeckConfig conf) {\n+            this.deck = deck;\n+            this.conf = conf;\n+        }\n \n-            // When a conf is deleted, all decks using it revert to the default conf.\n-            // Cards must be reordered according to the default conf.\n-            int order = conf.getJSONObject(\"new\").getInt(\"order\");\n-            int defaultOrder = col.getDecks().getConf(1).getJSONObject(\"new\").getInt(\"order\");\n-            if (order != defaultOrder) {\n-                conf.getJSONObject(\"new\").put(\"order\", defaultOrder);\n-                col.getSched().resortConf(conf);\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundConfChange\");\n+            try {\n+                long newConfId = conf.getLong(\"id\");\n+                // If new config has a different sorting order, reorder the cards\n+                int oldOrder = col.getDecks().getConf(deck.getLong(\"conf\")).getJSONObject(\"new\").getInt(\"order\");\n+                int newOrder = col.getDecks().getConf(newConfId).getJSONObject(\"new\").getInt(\"order\");\n+                if (oldOrder != newOrder) {\n+                    switch (newOrder) {\n+                        case 0:\n+                            col.getSched().randomizeCards(deck.getLong(\"id\"));\n+                            break;\n+                        case 1:\n+                            col.getSched().orderCards(deck.getLong(\"id\"));\n+                            break;\n+                    }\n+                }\n+                col.getDecks().setConf(deck, newConfId);\n+                col.save();\n+                return true;\n+            } catch (JSONException e) {\n+                return false;\n             }\n+        }\n+    }\n+\n+    public static class ConfReset extends Task<Void, Boolean> {\n+        private final DeckConfig conf;\n+\n+\n+        public ConfReset(DeckConfig conf) {\n+            this.conf = conf;\n+        }\n+\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundConfReset\");\n+            col.getDecks().restoreToDefault(conf);\n             col.save();\n-            return new TaskData(true);\n-        } catch (JSONException e) {\n-            return new TaskData(false);\n+            return null;\n         }\n     }\n \n \n-    private TaskData doInBackgroundConfSetSubdecks(TaskData param) {\n-        Timber.d(\"doInBackgroundConfSetSubdecks\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        Deck deck = (Deck) data[0];\n-        DeckConfig conf = (DeckConfig) data[1];\n-        try {\n-            TreeMap<String, Long> children = col.getDecks().children(deck.getLong(\"id\"));\n-            for (long childDid : children.values()) {\n-                Deck child = col.getDecks().get(childDid);\n-                if (child.getInt(\"dyn\") == 1) {\n-                    continue;\n+    public static class ConfRemove extends Task<Void, Boolean> {\n+        private final DeckConfig conf;\n+\n+\n+        public ConfRemove(DeckConfig conf) {\n+            this.conf = conf;\n+        }\n+\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundConfRemove\");\n+            try {\n+                // Note: We do the actual removing of the options group in the main thread so that we\n+                // can ask the user to confirm if they're happy to do a full sync, and just do the resorting here\n+\n+                // When a conf is deleted, all decks using it revert to the default conf.\n+                // Cards must be reordered according to the default conf.\n+                int order = conf.getJSONObject(\"new\").getInt(\"order\");\n+                int defaultOrder = col.getDecks().getConf(1).getJSONObject(\"new\").getInt(\"order\");\n+                if (order != defaultOrder) {\n+                    conf.getJSONObject(\"new\").put(\"order\", defaultOrder);\n+                    col.getSched().resortConf(conf);\n                 }\n-                TaskData newParam = new TaskData(new Object[] { child, conf });\n-                boolean changed = doInBackgroundConfChange(newParam).getBoolean();\n-                if (!changed) {\n-                    return new TaskData(false);\n+                col.save();\n+                return true;\n+            } catch (JSONException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    public static class ConfSetSubdecks extends Task<Void, Boolean> {\n+        private final Deck deck;\n+        private final DeckConfig conf;\n+\n+\n+        public ConfSetSubdecks(Deck deck, DeckConfig conf) {\n+            this.deck = deck;\n+            this.conf = conf;\n+        }\n+\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundConfSetSubdecks\");\n+            try {\n+                TreeMap<String, Long> children = col.getDecks().children(deck.getLong(\"id\"));\n+                for (long childDid : children.values()) {\n+                    Deck child = col.getDecks().get(childDid);\n+                    if (child.getInt(\"dyn\") == 1) {\n+                        continue;\n+                    }\n+                    boolean changed = new ConfChange(child, conf).task(col, collectionTask);\n+                    if (!changed) {\n+                        return false;\n+                    }\n                 }\n+                return true;\n+            } catch (JSONException e) {\n+                return false;\n             }\n-            return new TaskData(true);\n-        } catch (JSONException e) {\n-            return new TaskData(false);\n         }\n     }\n \n", "next_change": {"commit": "0b869c7bcd3aacfce7587704ba03f52b993979a7", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 9ad6fad8d..c0031a9e8 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1633,6 +1645,7 @@ public class CollectionTask<ProgressListener, ProgressBackground extends Progres\n                 }\n                 return true;\n             } catch (JSONException e) {\n+                Timber.w(e);\n                 return false;\n             }\n         }\n", "next_change": {"commit": "0627af25867890d1b5194ddc36ace470c6f74628", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\ndeleted file mode 100644\nindex c0031a9e8..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ /dev/null\n", "chunk": "@@ -1,1997 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2009 Daniel Sv\u00e4rd <daniel.svard@gmail.com>                             *\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *\n- * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-\n-package com.ichi2.async;\n-\n-import android.content.Context;\n-import android.content.res.Resources;\n-import android.os.AsyncTask;\n-import android.util.Pair;\n-\n-import com.google.gson.stream.JsonReader;\n-import com.ichi2.anki.AnkiDroidApp;\n-import com.ichi2.anki.BackupManager;\n-import com.ichi2.anki.CardBrowser;\n-import com.ichi2.anki.CardUtils;\n-import com.ichi2.anki.CollectionHelper;\n-import com.ichi2.anki.R;\n-import com.ichi2.anki.StudyOptionsFragment;\n-import com.ichi2.anki.TemporaryModel;\n-import com.ichi2.anki.exception.ConfirmModSchemaException;\n-import com.ichi2.anki.exception.ImportExportException;\n-import com.ichi2.libanki.Media;\n-import com.ichi2.libanki.Model;\n-import com.ichi2.libanki.Models;\n-import com.ichi2.libanki.Undoable;\n-import com.ichi2.libanki.WrongId;\n-import com.ichi2.libanki.sched.AbstractSched;\n-import com.ichi2.libanki.AnkiPackageExporter;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.DB;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Note;\n-import com.ichi2.libanki.Storage;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.DeckConfig;\n-import com.ichi2.libanki.Deck;\n-import com.ichi2.libanki.importer.AnkiPackageImporter;\n-\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.libanki.sched.DeckDueTreeNode;\n-import com.ichi2.libanki.sched.DeckTreeNode;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.utils.BooleanGetter;\n-import com.ichi2.utils.JSONArray;\n-import com.ichi2.utils.JSONException;\n-import com.ichi2.utils.JSONObject;\n-import com.ichi2.utils.PairWithBoolean;\n-import com.ichi2.utils.PairWithCard;\n-import com.ichi2.utils.SyncStatus;\n-import com.ichi2.utils.ThreadUtil;\n-import com.ichi2.utils.Triple;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeMap;\n-import java.util.concurrent.CancellationException;\n-import java.util.concurrent.ExecutionException;\n-\n-import org.apache.commons.compress.archivers.zip.ZipFile;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import timber.log.Timber;\n-\n-import static com.ichi2.async.TaskManager.setLatestInstance;\n-import static com.ichi2.libanki.Card.deepCopyCardArray;\n-import static com.ichi2.libanki.Collection.DismissType.BURY_CARD;\n-import static com.ichi2.libanki.Collection.DismissType.BURY_NOTE;\n-import static com.ichi2.libanki.Collection.DismissType.REPOSITION_CARDS;\n-import static com.ichi2.libanki.Collection.DismissType.RESCHEDULE_CARDS;\n-import static com.ichi2.libanki.Collection.DismissType.RESET_CARDS;\n-import static com.ichi2.libanki.Collection.DismissType.SUSPEND_NOTE;\n-import static com.ichi2.libanki.Consts.DECK_DYN;\n-import static com.ichi2.libanki.Undoable.*;\n-import static com.ichi2.utils.BooleanGetter.False;\n-import static com.ichi2.utils.BooleanGetter.True;\n-\n-/**\n- * Loading in the background, so that AnkiDroid does not look like frozen.\n- */\n-public class CollectionTask<ProgressListener, ProgressBackground extends ProgressListener, ResultListener, ResultBackground extends ResultListener> extends BaseAsyncTask<Void, ProgressBackground, ResultBackground> {\n-\n-    public abstract static class Task<ProgressBackground, ResultBackground> {\n-        protected abstract ResultBackground task(Collection col, ProgressSenderAndCancelListener<ProgressBackground> collectionTask);\n-    }\n-\n-    /**\n-     * A reference to the application context to use to fetch the current Collection object.\n-     */\n-    private Context mContext;\n-\n-    /**\n-     * Block the current thread until all CollectionTasks have finished.\n-     * @param timeoutSeconds timeout in seconds\n-     * @return whether all tasks exited successfully\n-     */\n-    @SuppressWarnings(\"UnusedReturnValue\")\n-    public static boolean waitForAllToFinish(Integer timeoutSeconds) {\n-        // HACK: This should be better - there is currently a race condition in sLatestInstance, and no means to obtain this information.\n-        // This should work in all reasonable cases given how few tasks we have concurrently blocking.\n-        boolean result;\n-        result = TaskManager.waitToFinish(timeoutSeconds / 4);\n-        ThreadUtil.sleep(10);\n-        result &= TaskManager.waitToFinish(timeoutSeconds / 4);\n-        ThreadUtil.sleep(10);\n-        result &= TaskManager.waitToFinish(timeoutSeconds / 4);\n-        ThreadUtil.sleep(10);\n-        result &= TaskManager.waitToFinish(timeoutSeconds / 4);\n-        ThreadUtil.sleep(10);\n-        Timber.i(\"Waited for all tasks to finish\");\n-        return result;\n-    }\n-\n-    /** Cancel the current task.\n-     * @return whether cancelling did occur.*/\n-    public boolean safeCancel() {\n-        try {\n-            if (getStatus() != AsyncTask.Status.FINISHED) {\n-                return cancel(true);\n-            }\n-        } catch (Exception e) {\n-            // Potentially catching SecurityException, from\n-            // Thread.interrupt from FutureTask.cancel from\n-            // AsyncTask.cancel\n-            Timber.w(e, \"Exception cancelling task\");\n-        } finally {\n-            TaskManager.removeTask(this);\n-        }\n-        return false;\n-    }\n-\n-    private Collection getCol() {\n-        return CollectionHelper.getInstance().getCol(mContext);\n-    }\n-\n-    protected Context getContext() {\n-        return mContext;\n-    }\n-\n-    private final Task<ProgressBackground, ResultBackground> mTask;\n-    public Task<ProgressBackground, ResultBackground> getTask() {\n-        return mTask;\n-    }\n-    private final TaskListener<ProgressListener, ResultListener> mListener;\n-    private CollectionTask mPreviousTask;\n-\n-\n-    protected CollectionTask(Task<ProgressBackground, ResultBackground> task, TaskListener<ProgressListener, ResultListener> listener, CollectionTask previousTask) {\n-        mTask = task;\n-        mListener = listener;\n-        mPreviousTask = previousTask;\n-        TaskManager.addTasks(this);\n-    }\n-\n-    @Override\n-    protected ResultBackground doInBackground(Void... params) {\n-        try {\n-            return actualDoInBackground();\n-        } finally {\n-            TaskManager.removeTask(this);\n-        }\n-    }\n-\n-    // This method and those that are called here are executed in a new thread\n-    protected ResultBackground actualDoInBackground() {\n-        super.doInBackground();\n-        // Wait for previous thread (if any) to finish before continuing\n-        if (mPreviousTask != null && mPreviousTask.getStatus() != AsyncTask.Status.FINISHED) {\n-            Timber.d(\"Waiting for %s to finish before starting %s\", mPreviousTask.mTask, mTask.getClass());\n-            try {\n-                mPreviousTask.get();\n-                Timber.d(\"Finished waiting for %s to finish. Status= %s\", mPreviousTask.mTask, mPreviousTask.getStatus());\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                // We have been interrupted, return immediately.\n-                Timber.d(e, \"interrupted while waiting for previous task: %s\", mPreviousTask.mTask.getClass());\n-                return null;\n-            } catch (ExecutionException e) {\n-                // Ignore failures in the previous task.\n-                Timber.e(e, \"previously running task failed with exception: %s\", mPreviousTask.mTask.getClass());\n-            } catch (CancellationException e) {\n-                // Ignore cancellation of previous task\n-                Timber.d(e, \"previously running task was cancelled: %s\", mPreviousTask.mTask.getClass());\n-            }\n-        }\n-        setLatestInstance(this);\n-        mContext = AnkiDroidApp.getInstance().getApplicationContext();\n-\n-        // Skip the task if the collection cannot be opened\n-        if ( mTask.getClass() != RepairCollectionn.class && mTask.getClass() != ImportReplace.class && CollectionHelper.getInstance().getColSafe(mContext) == null) {\n-            Timber.e(\"CollectionTask CollectionTask %s as Collection could not be opened\", mTask.getClass());\n-            return null;\n-        }\n-        // Actually execute the task now that we are at the front of the queue.\n-        return mTask.task(getCol(), this);\n-    }\n-\n-\n-    /** Delegates to the {@link TaskListener} for this task. */\n-    @Override\n-    protected void onPreExecute() {\n-        super.onPreExecute();\n-        if (mListener != null) {\n-            mListener.onPreExecute();\n-        }\n-    }\n-\n-\n-    /** Delegates to the {@link TaskListener} for this task. */\n-    @Override\n-    protected void onProgressUpdate(ProgressBackground... values) {\n-        super.onProgressUpdate(values);\n-        if (mListener != null) {\n-            mListener.onProgressUpdate(values[0]);\n-        }\n-    }\n-\n-\n-    /** Delegates to the {@link TaskListener} for this task. */\n-    @Override\n-    protected void onPostExecute(ResultBackground result) {\n-        super.onPostExecute(result);\n-        if (mListener != null) {\n-            mListener.onPostExecute(result);\n-        }\n-        Timber.d(\"enabling garbage collection of mPreviousTask...\");\n-        mPreviousTask = null;\n-    }\n-\n-    @Override\n-    protected void onCancelled(){\n-        TaskManager.removeTask(this);\n-        if (mListener != null) {\n-            mListener.onCancelled();\n-        }\n-    }\n-\n-    public static class AddNote extends Task<Integer, Boolean> {\n-        private final Note note;\n-        private final Models.AllowEmpty allowEmpty;\n-\n-\n-        public AddNote(Note note, Models.AllowEmpty allowEmpty) {\n-            this.note = note;\n-            this.allowEmpty = allowEmpty;\n-        }\n-\n-        public AddNote(Note note) {\n-            this(note, Models.AllowEmpty.ONLY_CLOZE);\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Integer> collectionTask) {\n-            Timber.d(\"doInBackgroundAddNote\");\n-            try {\n-                DB db = col.getDb();\n-                db.executeInTransaction(() -> {\n-                        int value = col.addNote(note, allowEmpty);\n-                        collectionTask.doProgress(value);\n-                    });\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundAddNote - RuntimeException on adding note\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundAddNote\");\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-\n-    public static class UpdateNote extends Task<PairWithCard<String>, BooleanGetter> {\n-        private final Card editCard;\n-        private final boolean fromReviewer;\n-        private final boolean canAccessScheduler;\n-\n-\n-        public UpdateNote(Card editCard, boolean fromReviewer, boolean canAccessScheduler) {\n-            this.editCard = editCard;\n-            this.fromReviewer = fromReviewer;\n-            this.canAccessScheduler = canAccessScheduler;\n-        }\n-\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<PairWithCard<String>> collectionTask) {\n-            Timber.d(\"doInBackgroundUpdateNote\");\n-            // Save the note\n-            AbstractSched sched = col.getSched();\n-            Note editNote = editCard.note();\n-\n-            try {\n-                col.getDb().executeInTransaction(() -> {\n-                    // TODO: undo integration\n-                    editNote.flush();\n-                    // flush card too, in case, did has been changed\n-                    editCard.flush();\n-                    if (fromReviewer) {\n-                        Card newCard;\n-                        if (col.getDecks().active().contains(editCard.getDid()) || !canAccessScheduler) {\n-                            newCard = editCard;\n-                            newCard.load();\n-                            // reload qa-cache\n-                            newCard.q(true);\n-                        } else {\n-                            newCard = sched.getCard();\n-                        }\n-                        collectionTask.doProgress(new PairWithCard<>(newCard, null)); // check: are there deleted too?\n-                    } else {\n-                        collectionTask.doProgress(new PairWithCard<>(editCard, editNote.stringTags()));\n-                    }\n-                });\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundUpdateNote - RuntimeException on updating note\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundUpdateNote\");\n-                return False;\n-            }\n-            return True;\n-        }\n-\n-        public boolean isFromReviewer() {\n-            return fromReviewer;\n-        }\n-    }\n-\n-    public static class GetCard extends Task<Card, BooleanGetter> {\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<Card> collectionTask) {\n-            AbstractSched sched = col.getSched();\n-            Timber.i(\"Obtaining card\");\n-            Card newCard = sched.getCard();\n-            if (newCard != null) {\n-                // render cards before locking database\n-                newCard._getQA(true);\n-            }\n-            collectionTask.doProgress(newCard);\n-            return True;\n-        }\n-    }\n-\n-    public static class AnswerAndGetCard extends GetCard {\n-        private final @NonNull Card oldCard;\n-        private final @Consts.BUTTON_TYPE int ease;\n-        public AnswerAndGetCard(@NonNull Card oldCard, @Consts.BUTTON_TYPE int ease) {\n-            this.oldCard = oldCard;\n-            this.ease = ease;\n-        }\n-\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<Card> collectionTask) {\n-            Timber.i(\"Answering card %d\", oldCard.getId());\n-            col.getSched().answerCard(oldCard, ease);\n-            return super.task(col, collectionTask);\n-        }\n-    }\n-\n-\n-    public static class LoadDeck extends Task<Void, List<DeckTreeNode>> {\n-        protected List<DeckTreeNode> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundLoadDeckCounts\");\n-            try {\n-                // Get due tree\n-                return col.getSched().quickDeckDueTree();\n-            } catch (RuntimeException e) {\n-                Timber.w(e, \"doInBackgroundLoadDeckCounts - error\");\n-                return null;\n-            }\n-        }\n-    }\n-\n-\n-    public static class LoadDeckCounts extends Task<Void, List<DeckDueTreeNode>> {\n-        protected List<DeckDueTreeNode> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundLoadDeckCounts\");\n-            try {\n-                // Get due tree\n-                return col.getSched().deckDueTree(collectionTask);\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");\n-                return null;\n-            }\n-        }\n-    }\n-\n-    public static class SaveCollection extends Task<Void, Void> {\n-        private final boolean syncIgnoresDatabaseModification;\n-\n-\n-        public SaveCollection(boolean syncIgnoresDatabaseModification) {\n-            this.syncIgnoresDatabaseModification = syncIgnoresDatabaseModification;\n-        }\n-\n-\n-        protected Void task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundSaveCollection\");\n-            if (col != null) {\n-                try {\n-                    if (syncIgnoresDatabaseModification) {\n-                        SyncStatus.ignoreDatabaseModification(col::save);\n-                    } else {\n-                        col.save();\n-                    }\n-                } catch (RuntimeException e) {\n-                    Timber.e(e, \"Error on saving deck in background\");\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-\n-\n-    private static class UndoSuspendCard extends Undoable {\n-        private final Card suspendedCard;\n-\n-\n-        public UndoSuspendCard(Card suspendedCard) {\n-            super(Collection.DismissType.SUSPEND_CARD);\n-            this.suspendedCard = suspendedCard;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"UNDO: Suspend Card %d\", suspendedCard.getId());\n-            suspendedCard.flush(false);\n-            return suspendedCard;\n-        }\n-    }\n-\n-\n-    private static class UndoDeleteNote extends Undoable {\n-        private final Note note;\n-        private final ArrayList<Card> allCs;\n-        private final @NonNull Card card;\n-\n-\n-        public UndoDeleteNote(Note note, ArrayList<Card> allCs, @NonNull Card card) {\n-            super(Collection.DismissType.DELETE_NOTE);\n-            this.note = note;\n-            this.allCs = allCs;\n-            this.card = card;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Delete note\");\n-            ArrayList<Long> ids = new ArrayList<>(allCs.size() + 1 );\n-            note.flush(note.getMod(), false);\n-            ids.add(note.getId());\n-            for (Card c : allCs) {\n-                c.flush(false);\n-                ids.add(c.getId());\n-            }\n-            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(ids));\n-            return card;\n-        }\n-    }\n-\n-\n-    public static class DismissNote extends Task<Card, BooleanGetter> {\n-        private final Card card;\n-        private final Collection.DismissType type;\n-\n-\n-        public DismissNote(Card card, Collection.DismissType type) {\n-            this.card = card;\n-            this.type = type;\n-        }\n-\n-\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<Card> collectionTask) {\n-            AbstractSched sched = col.getSched();\n-            Note note = card.note();\n-            try {\n-                col.getDb().executeInTransaction(() -> {\n-                    sched.deferReset();\n-                    switch (type) {\n-                        case BURY_CARD:\n-                            // collect undo information\n-                            col.markUndo(revertToProvidedState(BURY_CARD, card));\n-                            // then bury\n-                            sched.buryCards(new long[] {card.getId()});\n-                            break;\n-                        case BURY_NOTE:\n-                            // collect undo information\n-                            col.markUndo(revertToProvidedState(BURY_NOTE, card));\n-                            // then bury\n-                            sched.buryNote(note.getId());\n-                            break;\n-                        case SUSPEND_CARD:\n-                            // collect undo information\n-                            Card suspendedCard = card.clone();\n-                            col.markUndo(new UndoSuspendCard(suspendedCard));\n-                            // suspend card\n-                            if (card.getQueue() == Consts.QUEUE_TYPE_SUSPENDED) {\n-                                sched.unsuspendCards(new long[] {card.getId()});\n-                            } else {\n-                                sched.suspendCards(new long[] {card.getId()});\n-                            }\n-                            break;\n-                        case SUSPEND_NOTE: {\n-                            // collect undo information\n-                            ArrayList<Card> cards = note.cards();\n-                            long[] cids = new long[cards.size()];\n-                            for (int i = 0; i < cards.size(); i++) {\n-                                cids[i] = cards.get(i).getId();\n-                            }\n-                            col.markUndo(revertToProvidedState(SUSPEND_NOTE, card));\n-                            // suspend note\n-                            sched.suspendCards(cids);\n-                            break;\n-                        }\n-\n-                        case DELETE_NOTE: {\n-                            // collect undo information\n-                            ArrayList<Card> allCs = note.cards();\n-                            col.markUndo(new UndoDeleteNote(note, allCs, card));\n-                            // delete note\n-                            col.remNotes(new long[] {note.getId()});\n-                            break;\n-                        }\n-                    }\n-                    // With sHadCardQueue set, getCard() resets the scheduler prior to getting the next card\n-                    collectionTask.doProgress(col.getSched().getCard());\n-                });\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundDismissNote - RuntimeException on dismissing note, dismiss type %s\", type);\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundDismissNote\");\n-                return False;\n-            }\n-            return True;\n-        }\n-    }\n-\n-\n-    protected static class UndoSuspendCardMulti extends Undoable {\n-        private final Card[] cards;\n-        private final boolean[] originalSuspended;\n-\n-        /** @param hasUnsuspended  whether there were any unsuspended card (in which card the action was \"Suspend\",\n-         *                          otherwise the action was \"Unsuspend\")  */\n-        public UndoSuspendCardMulti(Card[] cards, boolean[] originalSuspended,\n-                                    boolean hasUnsuspended) {\n-            super((hasUnsuspended) ? Collection.DismissType.SUSPEND_CARD_MULTI: Collection.DismissType.UNSUSPEND_CARD_MULTI);\n-            this.cards = cards;\n-            this.originalSuspended = originalSuspended;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Suspend multiple cards\");\n-            int nbOfCards = cards.length;\n-            List<Long> toSuspendIds = new ArrayList<>(nbOfCards);\n-            List<Long> toUnsuspendIds = new ArrayList<>(nbOfCards);\n-            for (int i = 0; i < nbOfCards; i++) {\n-                Card card = cards[i];\n-                if (originalSuspended[i]) {\n-                    toSuspendIds.add(card.getId());\n-                } else {\n-                    toUnsuspendIds.add(card.getId());\n-                }\n-            }\n-\n-            // unboxing\n-            long[] toSuspendIdsArray = new long[toSuspendIds.size()];\n-            long[] toUnsuspendIdsArray = new long[toUnsuspendIds.size()];\n-            for (int i = 0; i < toSuspendIds.size(); i++) {\n-                toSuspendIdsArray[i] = toSuspendIds.get(i);\n-            }\n-            for (int i = 0; i < toUnsuspendIds.size(); i++) {\n-                toUnsuspendIdsArray[i] = toUnsuspendIds.get(i);\n-            }\n-\n-            col.getSched().suspendCards(toSuspendIdsArray);\n-            col.getSched().unsuspendCards(toUnsuspendIdsArray);\n-\n-            return null;  // don't fetch new card\n-\n-        }\n-    }\n-\n-\n-    private static class UndoDeleteNoteMulti extends Undoable {\n-        private final Note[] notesArr;\n-        private final List<Card> allCards;\n-\n-\n-        public UndoDeleteNoteMulti(Note[] notesArr, List<Card> allCards) {\n-            super(Collection.DismissType.DELETE_NOTE_MULTI);\n-            this.notesArr = notesArr;\n-            this.allCards = allCards;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Delete notes\");\n-            // undo all of these at once instead of one-by-one\n-            ArrayList<Long> ids = new ArrayList<>(notesArr.length + allCards.size());\n-            for (Note n : notesArr) {\n-                n.flush(n.getMod(), false);\n-                ids.add(n.getId());\n-            }\n-            for (Card c : allCards) {\n-                c.flush(false);\n-                ids.add(c.getId());\n-            }\n-            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(ids));\n-            return null;  // don't fetch new card\n-\n-        }\n-    }\n-\n-    \n-    private static class UndoChangeDeckMulti extends Undoable {\n-        private final Card[] cards;\n-        private final long[] originalDids;\n-\n-\n-        public UndoChangeDeckMulti(Card[] cards, long[] originalDids) {\n-            super(Collection.DismissType.CHANGE_DECK_MULTI);\n-            this.cards = cards;\n-            this.originalDids = originalDids;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Change Decks\");\n-            // move cards to original deck\n-            for (int i = 0; i < cards.length; i++) {\n-                Card card = cards[i];\n-                card.load();\n-                card.setDid(originalDids[i]);\n-                Note note = card.note();\n-                note.flush();\n-                card.flush();\n-            }\n-            return null;  // don't fetch new card\n-\n-        }\n-    }\n-\n-    private static class UndoMarkNoteMulti extends Undoable {\n-        private final List<Note> originalMarked;\n-        private final List<Note> originalUnmarked;\n-\n-        /** @param hasUnmarked whether there were any unmarked card (in which card the action was \"mark\",\n-         *                      otherwise the action was \"Unmark\")  */\n-        public UndoMarkNoteMulti(List<Note> originalMarked, List<Note> originalUnmarked, boolean hasUnmarked) {\n-            super((hasUnmarked) ? Collection.DismissType.MARK_NOTE_MULTI : Collection.DismissType.UNMARK_NOTE_MULTI);\n-            this.originalMarked = originalMarked;\n-            this.originalUnmarked = originalUnmarked;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Mark notes\");\n-            CardUtils.markAll(originalMarked, true);\n-            CardUtils.markAll(originalUnmarked, false);\n-            return null;  // don't fetch new card\n-        }\n-    }\n-\n-\n-    private static class UndoRepositionRescheduleResetCards extends Undoable {\n-        private final Card[] cards_copied;\n-\n-\n-        public UndoRepositionRescheduleResetCards(Collection.DismissType type, Card[] cards_copied) {\n-            super(type);\n-            this.cards_copied = cards_copied;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undoing action of type %s on %d cards\", getDismissType(), cards_copied.length);\n-            for (Card card : cards_copied) {\n-                card.flush(false);\n-            }\n-            // /* card schedule change undone, reset and get\n-            // new card */\n-            Timber.d(\"Single card non-review change undo succeeded\");\n-            col.reset();\n-            return col.getSched().getCard();\n-        }\n-    }\n-\n-    private static abstract class DismissNotes<Progress> extends Task<Progress, PairWithBoolean<Card[]>> {\n-        protected final List<Long> mCardIds;\n-\n-        public DismissNotes(List<Long> cardIds) {\n-            this.mCardIds = cardIds;\n-        }\n-\n-        protected PairWithBoolean<Card[]> task(Collection col, ProgressSenderAndCancelListener<Progress> collectionTask) {\n-            // query cards\n-            Card[] cards = new Card[mCardIds.size()];\n-            for (int i = 0; i < mCardIds.size(); i++) {\n-                cards[i] = col.getCard(mCardIds.get(i));\n-            }\n-\n-            try {\n-                col.getDb().getDatabase().beginTransaction();\n-                try {\n-                    PairWithBoolean<Card[]> ret = actualTask(col, collectionTask, cards);\n-                    if (ret != null) {\n-                        return ret;\n-                    }\n-                    col.getDb().getDatabase().setTransactionSuccessful();\n-                } finally {\n-                    DB.safeEndInTransaction(col.getDb());\n-                }\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundSuspendCard - RuntimeException on suspending card\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundSuspendCard\");\n-                return new PairWithBoolean<>(false, null);\n-            }\n-            // pass cards back so more actions can be performed by the caller\n-            // (querying the cards again is unnecessarily expensive)\n-            return new PairWithBoolean<>(true, cards);\n-        }\n-\n-        /**\n-         * @param col The collection\n-         * @param collectionTask, where to send progress and listen for cancellation\n-         * @param cards Cards to which the task should be applied\n-         * @return value to return, or null if `task` should deal with it directly.\n-         */\n-        protected abstract PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Progress> collectionTask, Card[] cards);\n-    }\n-\n-    public static class SuspendCardMulti extends DismissNotes<Void> {\n-        public SuspendCardMulti(List<Long> cardIds) {\n-            super(cardIds);\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Void> collectionTask, Card[] cards) {\n-            AbstractSched sched = col.getSched();\n-            // collect undo information\n-            long[] cids = new long[cards.length];\n-            boolean[] originalSuspended = new boolean[cards.length];\n-            boolean hasUnsuspended = false;\n-            for (int i = 0; i < cards.length; i++) {\n-                Card card = cards[i];\n-                cids[i] = card.getId();\n-                if (card.getQueue() != Consts.QUEUE_TYPE_SUSPENDED) {\n-                    hasUnsuspended = true;\n-                    originalSuspended[i] = false;\n-                } else {\n-                    originalSuspended[i] = true;\n-                }\n-            }\n-\n-            // if at least one card is unsuspended -> suspend all\n-            // otherwise unsuspend all\n-            if (hasUnsuspended) {\n-                sched.suspendCards(cids);\n-            } else {\n-                sched.unsuspendCards(cids);\n-            }\n-\n-            // mark undo for all at once\n-            col.markUndo(new UndoSuspendCardMulti(cards, originalSuspended, hasUnsuspended));\n-\n-            // reload cards because they'll be passed back to caller\n-            for (Card c : cards) {\n-                c.load();\n-            }\n-\n-            sched.deferReset();\n-            return null;\n-        }\n-    }\n-\n-    public static class Flag extends DismissNotes<Void> {\n-        private final int mFlag;\n-\n-        public Flag(List<Long> cardIds, int flag) {\n-            super(cardIds);\n-            mFlag = flag;\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Void> collectionTask, Card[] cards) {\n-            col.setUserFlag(mFlag, mCardIds);\n-            for (Card c : cards) {\n-                c.load();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class MarkNoteMulti extends DismissNotes<Void> {\n-        public MarkNoteMulti(List<Long> cardIds) {\n-            super(cardIds);\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Void> collectionTask, Card[] cards) {\n-            Set<Note> notes = CardUtils.getNotes(Arrays.asList(cards));\n-            // collect undo information\n-            List<Note> originalMarked = new ArrayList<>();\n-            List<Note> originalUnmarked = new ArrayList<>();\n-\n-            for (Note n : notes) {\n-                if (n.hasTag(\"marked\"))\n-                    originalMarked.add(n);\n-                else\n-                    originalUnmarked.add(n);\n-            }\n-\n-            boolean hasUnmarked = !originalUnmarked.isEmpty();\n-            CardUtils.markAll(new ArrayList<>(notes), hasUnmarked);\n-\n-            Undoable markNoteMulti = new UndoMarkNoteMulti(originalMarked, originalUnmarked, hasUnmarked);\n-            // mark undo for all at once\n-            col.markUndo(new UndoMarkNoteMulti(originalMarked, originalUnmarked, hasUnmarked));\n-\n-            // reload cards because they'll be passed back to caller\n-            for (Card c : cards) {\n-                c.load();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class DeleteNoteMulti extends DismissNotes<Card[]> {\n-\n-        public DeleteNoteMulti(List<Long> cardIds) {\n-            super(cardIds);\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Card[]> collectionTask, Card[] cards) {\n-            AbstractSched sched = col.getSched();\n-            // list of all ids to pass to remNotes method.\n-            // Need Set (-> unique) so we don't pass duplicates to col.remNotes()\n-            Set<Note> notes = CardUtils.getNotes(Arrays.asList(cards));\n-            List<Card> allCards = CardUtils.getAllCards(notes);\n-            // delete note\n-            long[] uniqueNoteIds = new long[notes.size()];\n-            Note[] notesArr = notes.toArray(new Note[notes.size()]);\n-            int count = 0;\n-            for (Note note : notes) {\n-                uniqueNoteIds[count] = note.getId();\n-                count++;\n-            }\n-\n-\n-\n-            col.markUndo(new UndoDeleteNoteMulti(notesArr, allCards));\n-\n-            col.remNotes(uniqueNoteIds);\n-            sched.deferReset();\n-            // pass back all cards because they can't be retrieved anymore by the caller (since the note is deleted)\n-            collectionTask.doProgress(allCards.toArray(new Card[allCards.size()]));\n-            return null;\n-        }\n-    }\n-\n-    public static class ChangeDeckMulti extends DismissNotes<Void> {\n-        private final long mNewDid;\n-        public ChangeDeckMulti(List<Long> cardIds, long newDid) {\n-            super(cardIds);\n-            mNewDid = newDid;\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Void> collectionTask, Card[] cards) {\n-            Timber.i(\"Changing %d cards to deck: '%d'\", cards.length, mNewDid);\n-            Deck deckData = col.getDecks().get(mNewDid);\n-\n-            if (Decks.isDynamic(deckData)) {\n-                //#5932 - can't change to a dynamic deck. Use \"Rebuild\"\n-                Timber.w(\"Attempted to move to dynamic deck. Cancelling task.\");\n-                return new PairWithBoolean<>(false, null);\n-            }\n-\n-            //Confirm that the deck exists (and is not the default)\n-            try {\n-                long actualId = deckData.getLong(\"id\");\n-                if (actualId != mNewDid) {\n-                    Timber.w(\"Attempted to move to deck %d, but got %d\", mNewDid, actualId);\n-                    return new PairWithBoolean<>(false, null);\n-                }\n-            } catch (Exception e) {\n-                Timber.e(e, \"failed to check deck\");\n-                return new PairWithBoolean<>(false, null);\n-            }\n-\n-            long[] changedCardIds = new long[cards.length];\n-            for (int i = 0; i < cards.length; i++) {\n-                changedCardIds[i] = cards[i].getId();\n-            }\n-            col.getSched().remFromDyn(changedCardIds);\n-\n-            long[] originalDids = new long[cards.length];\n-\n-            for (int i = 0; i < cards.length; i++) {\n-                Card card = cards[i];\n-                card.load();\n-                // save original did for undo\n-                originalDids[i] = card.getDid();\n-                // then set the card ID to the new deck\n-                card.setDid(mNewDid);\n-                Note note = card.note();\n-                note.flush();\n-                // flush card too, in case, did has been changed\n-                card.flush();\n-            }\n-\n-            Undoable changeDeckMulti = new UndoChangeDeckMulti(cards, originalDids);\n-            // mark undo for all at once\n-            col.markUndo(changeDeckMulti);\n-            return null;\n-        }\n-    }\n-\n-    private abstract static class RescheduleRepositionReset extends DismissNotes<Card> {\n-        private final Collection.DismissType mType;\n-        public RescheduleRepositionReset(List<Long> cardIds, Collection.DismissType type) {\n-            super(cardIds);\n-            mType = type;\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Card> collectionTask, Card[] cards) {\n-            AbstractSched sched = col.getSched();\n-            // collect undo information, sensitive to memory pressure, same for all 3 cases\n-            try {\n-                Timber.d(\"Saving undo information of type %s on %d cards\", mType, cards.length);\n-                Card[] cards_copied = deepCopyCardArray(cards, collectionTask);\n-                Undoable repositionRescheduleResetCards = new UndoRepositionRescheduleResetCards(mType, cards_copied);\n-                col.markUndo(repositionRescheduleResetCards);\n-            } catch (CancellationException ce) {\n-                Timber.i(ce, \"Cancelled while handling type %s, skipping undo\", mType);\n-            }\n-            actualActualTask(sched);\n-            // In all cases schedule a new card so Reviewer doesn't sit on the old one\n-            col.reset();\n-            collectionTask.doProgress(sched.getCard());\n-            return null;\n-        }\n-\n-        protected abstract void actualActualTask(AbstractSched sched);\n-    }\n-\n-    public static class RescheduleCards extends RescheduleRepositionReset {\n-        private final int mSchedule;\n-        public RescheduleCards(List<Long> cardIds, int schedule) {\n-            super(cardIds, RESCHEDULE_CARDS);\n-            this.mSchedule = schedule;\n-        }\n-\n-        @Override\n-        protected void actualActualTask(AbstractSched sched) {\n-            sched.reschedCards(mCardIds, mSchedule, mSchedule);\n-        }\n-    }\n-\n-    public static class RepositionCards extends RescheduleRepositionReset {\n-        private final int mPosition;\n-        public RepositionCards(List<Long> cardIds, int position) {\n-            super(cardIds, REPOSITION_CARDS);\n-            this.mPosition = position;\n-        }\n-\n-        @Override\n-        protected void actualActualTask(AbstractSched sched) {\n-            sched.sortCards(mCardIds, mPosition, 1, false, true);\n-        }\n-    }\n-\n-    public static class ResetCards extends RescheduleRepositionReset {\n-        public ResetCards(List<Long> cardIds) {\n-            super(cardIds, RESET_CARDS);\n-        }\n-\n-        @Override\n-        protected void actualActualTask(AbstractSched sched) {\n-            sched.forgetCards(mCardIds);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public static Card nonTaskUndo(Collection col) {\n-        AbstractSched sched = col.getSched();\n-        Card card = col.undo();\n-        if (card == null) {\n-            /* multi-card action undone, no action to take here */\n-            Timber.d(\"Multi-select undo succeeded\");\n-        } else {\n-            // cid is actually a card id.\n-            // a review was undone,\n-            /* card review undone, set up to review that card again */\n-            Timber.d(\"Single card review undo succeeded\");\n-            card.startTimer();\n-            col.reset();\n-            sched.deferReset(card);\n-        }\n-        return card;\n-    }\n-\n-    public static class Undo extends Task<Card, BooleanGetter> {\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<Card> collectionTask) {\n-            try {\n-                col.getDb().executeInTransaction(() -> {\n-                    Card card = nonTaskUndo(col);\n-                    collectionTask.doProgress(card);\n-                });\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundUndo - RuntimeException on undoing\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundUndo\");\n-                return False;\n-            }\n-            return True;\n-        }\n-    }\n-\n-    /**\n-     * A class allowing to send partial search result to the browser to display while the search ends\n-     */\n-    public static class PartialSearch implements ProgressSenderAndCancelListener<List<Long>> {\n-        private final List<CardBrowser.CardCache> mCards;\n-        private final int mColumn1Index, mColumn2Index;\n-        private final int mNumCardsToRender;\n-        private final ProgressSenderAndCancelListener<List<CardBrowser.CardCache>> mCollectionTask;\n-        private final Collection mCol;\n-\n-        public PartialSearch(List<CardBrowser.CardCache> cards, int columnIndex1, int columnIndex2, int numCardsToRender, ProgressSenderAndCancelListener<List<CardBrowser.CardCache>> collectionTask, Collection col) {\n-            mCards = cards;\n-            mColumn1Index = columnIndex1;\n-            mColumn2Index = columnIndex2;\n-            mNumCardsToRender = numCardsToRender;\n-            mCollectionTask = collectionTask;\n-            mCol = col;\n-        }\n-\n-        @Override\n-        public boolean isCancelled() {\n-            return mCollectionTask.isCancelled();\n-        }\n-\n-\n-        /**\n-         * @param cards Card ids to display in the browser. It is assumed that it is as least as long as mCards, and that\n-         *             mCards[i].cid = cards[i].  It add the cards in cards after `mPosition` to mCards\n-         */\n-        public void add(@NonNull List<Long> cards) {\n-            while (mCards.size() < cards.size()) {\n-                mCards.add(new CardBrowser.CardCache(cards.get(mCards.size()), mCol, mCards.size()));\n-            }\n-        }\n-\n-\n-        @Override\n-        public void doProgress(@NonNull List<Long> value) {\n-            add(value);\n-            for (CardBrowser.CardCache card : mCards) {\n-                if (isCancelled()) {\n-                    Timber.d(\"doInBackgroundSearchCards was cancelled so return\");\n-                    return;\n-                }\n-                card.load(false, mColumn1Index, mColumn2Index);\n-            }\n-            mCollectionTask.doProgress(mCards);\n-        }\n-\n-        public int getNumCardsToRender() {\n-            return mNumCardsToRender;\n-        }\n-    }\n-\n-\n-    public static class SearchCards extends Task<List<CardBrowser.CardCache>, List<CardBrowser.CardCache>> {\n-        private final String query;\n-        private final boolean order;\n-        private final int numCardsToRender;\n-        private final int column1Index;\n-        private final int column2Index;\n-\n-\n-        public SearchCards(String query, boolean order, int numCardsToRender, int column1Index, int column2Index) {\n-            this.query = query;\n-            this.order = order;\n-            this.numCardsToRender = numCardsToRender;\n-            this.column1Index = column1Index;\n-            this.column2Index = column2Index;\n-        }\n-\n-\n-        protected List<CardBrowser.CardCache> task(Collection col, ProgressSenderAndCancelListener<List<CardBrowser.CardCache>> collectionTask) {\n-            Timber.d(\"doInBackgroundSearchCards\");\n-            if (collectionTask.isCancelled()) {\n-                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-                return null;\n-            }\n-            List<CardBrowser.CardCache> searchResult = new ArrayList<>();\n-            List<Long> searchResult_ = col.findCards(query, order, new PartialSearch(searchResult, column1Index, column2Index, numCardsToRender, collectionTask, col));\n-            Timber.d(\"The search found %d cards\", searchResult_.size());\n-            int position = 0;\n-            for (Long cid : searchResult_) {\n-                CardBrowser.CardCache card = new CardBrowser.CardCache(cid, col, position++);\n-                searchResult.add(card);\n-            }\n-            // Render the first few items\n-            for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n-                if (collectionTask.isCancelled()) {\n-                    Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-                    return null;\n-                }\n-                searchResult.get(i).load(false, column1Index, column2Index);\n-            }\n-            // Finish off the task\n-            if (collectionTask.isCancelled()) {\n-                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-                return null;\n-            } else {\n-                return searchResult;\n-            }\n-        }\n-    }\n-\n-\n-    public static class RenderBrowserQA extends Task<Integer, Pair<CardBrowser.CardCollection<CardBrowser.CardCache>, List<Long>>> {\n-        private final CardBrowser.CardCollection<CardBrowser.CardCache> cards;\n-        private final Integer startPos;\n-        private final Integer n;\n-        private final int column1Index;\n-        private final int column2Index;\n-\n-\n-        public RenderBrowserQA(CardBrowser.CardCollection<CardBrowser.CardCache> cards, Integer mStartPos, Integer n, int column1Index, int column2Index) {\n-            this.cards = cards;\n-            this.startPos = mStartPos;\n-            this.n = n;\n-            this.column1Index = column1Index;\n-            this.column2Index = column2Index;\n-        }\n-\n-\n-        protected Pair<CardBrowser.CardCollection<CardBrowser.CardCache>, List<Long>> task(Collection col, ProgressSenderAndCancelListener<Integer> collectionTask) {\n-            Timber.d(\"doInBackgroundRenderBrowserQA\");\n-\n-            List<Long> invalidCardIds = new ArrayList<>();\n-            // for each specified card in the browser list\n-            for (int i = startPos; i < startPos + n; i++) {\n-                // Stop if cancelled\n-                if (collectionTask.isCancelled()) {\n-                    Timber.d(\"doInBackgroundRenderBrowserQA was aborted\");\n-                    return null;\n-                }\n-                if (i < 0 || i >= cards.size()) {\n-                    continue;\n-                }\n-                CardBrowser.CardCache card;\n-                try {\n-                    card = cards.get(i);\n-                }\n-                catch (IndexOutOfBoundsException e) {\n-                    //even though we test against card.size() above, there's still a race condition\n-                    //We might be able to optimise this to return here. Logically if we're past the end of the collection,\n-                    //we won't reach any more cards.\n-                    continue;\n-                }\n-                if (card.isLoaded()) {\n-                    //We've already rendered the answer, we don't need to do it again.\n-                    continue;\n-                }\n-                // Extract card item\n-                try {\n-                    // Ensure that card still exists.\n-                    card.getCard();\n-                } catch (WrongId e) {\n-                    //#5891 - card can be inconsistent between the deck browser screen and the collection.\n-                    //Realistically, we can skip any exception as it's a rendering task which should not kill the\n-                    //process\n-                    long cardId = card.getId();\n-                    Timber.e(e, \"Could not process card '%d' - skipping and removing from sight\", cardId);\n-                    invalidCardIds.add(cardId);\n-                    continue;\n-                }\n-                // Update item\n-                card.load(false, column1Index, column2Index);\n-                float progress = (float) i / n * 100;\n-                collectionTask.doProgress((int) progress);\n-            }\n-            return new Pair<>(cards, invalidCardIds);\n-        }\n-    }\n-\n-    public static class CheckDatabase extends Task<String, Pair<Boolean, Collection.CheckDatabaseResult>> {\n-    protected Pair<Boolean, Collection.CheckDatabaseResult> task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n-        Timber.d(\"doInBackgroundCheckDatabase\");\n-        // Don't proceed if collection closed\n-        if (col == null) {\n-            Timber.e(\"doInBackgroundCheckDatabase :: supplied collection was null\");\n-            return new Pair<>(false, null);\n-        }\n-\n-        Collection.CheckDatabaseResult result = col.fixIntegrity(new TaskManager.ProgressCallback(collectionTask, AnkiDroidApp.getAppResources()));\n-        if (result.getFailed()) {\n-            //we can fail due to a locked database, which requires knowledge of the failure.\n-            return new Pair<>(false, result);\n-        } else {\n-            // Close the collection and we restart the app to reload\n-            CollectionHelper.getInstance().closeCollection(true, \"Check Database Completed\");\n-            return new Pair<>(true, result);\n-        }\n-    }\n-    }\n-\n-\n-    public static class RepairCollectionn extends Task<Void, Boolean> {\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundRepairCollection\");\n-            if (col != null) {\n-                Timber.i(\"RepairCollection: Closing collection\");\n-                col.close(false);\n-            }\n-            return BackupManager.repairCollection(col);\n-        }\n-    }\n-\n-\n-    public static class UpdateValuesFromDeck extends Task<Void, StudyOptionsFragment.DeckStudyData> {\n-        private final boolean reset;\n-\n-\n-        public UpdateValuesFromDeck(boolean reset) {\n-            this.reset = reset;\n-        }\n-\n-\n-        public StudyOptionsFragment.DeckStudyData task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundUpdateValuesFromDeck\");\n-            try {\n-                AbstractSched sched = col.getSched();\n-                if (reset) {\n-                    // reset actually required because of counts, which is used in getCollectionTaskListener\n-                    sched.resetCounts();\n-                }\n-                Counts counts = sched.counts();\n-                int totalNewCount = sched.totalNewForCurrentDeck();\n-                int totalCount = sched.cardCount();\n-                return new StudyOptionsFragment.DeckStudyData(counts.getNew(), counts.getLrn(), counts.getRev(), totalNewCount,\n-                        totalCount, sched.eta(counts));\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundUpdateValuesFromDeck - an error occurred\");\n-                return null;\n-            }\n-        }\n-    }\n-\n-\n-    public static class DeleteDeck extends Task<Void, int[]> {\n-        private final long did;\n-\n-        public DeleteDeck(long did) {\n-            this.did = did;\n-        }\n-\n-        protected int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundDeleteDeck\");\n-            col.getDecks().rem(did, true);\n-            // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n-            col.clearUndo();\n-            return null;\n-        }\n-    }\n-\n-\n-    public static class RebuildCram extends Task<Void, StudyOptionsFragment.DeckStudyData> {\n-        protected StudyOptionsFragment.DeckStudyData task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundRebuildCram\");\n-            col.getSched().rebuildDyn(col.getDecks().selected());\n-            return new UpdateValuesFromDeck(true).task(col, collectionTask);\n-        }\n-    }\n-\n-    public static class EmptyCram extends Task<Void, StudyOptionsFragment.DeckStudyData> {\n-        protected StudyOptionsFragment.DeckStudyData task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundEmptyCram\");\n-            col.getSched().emptyDyn(col.getDecks().selected());\n-            return new UpdateValuesFromDeck(true).task(col, collectionTask);\n-        }\n-    }\n-\n-    public static class ImportAdd extends Task<String, Triple<AnkiPackageImporter, Boolean, String>> {\n-        private final String path;\n-\n-\n-        public ImportAdd(String path) {\n-            this.path = path;\n-        }\n-\n-\n-        protected Triple<AnkiPackageImporter, Boolean, String> task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n-            Timber.d(\"doInBackgroundImportAdd\");\n-            Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n-            AnkiPackageImporter imp = new AnkiPackageImporter(col, path);\n-            imp.setProgressCallback(new TaskManager.ProgressCallback(collectionTask, res));\n-            try {\n-                imp.run();\n-            } catch (ImportExportException e) {\n-                Timber.w(e);\n-                return new Triple(null, true, e.getMessage());\n-            }\n-            return new Triple<>(imp, false, null);\n-        }\n-    }\n-\n-\n-    public static class ImportReplace extends Task<String, BooleanGetter> {\n-        private final String path;\n-\n-\n-        public ImportReplace(String path) {\n-            this.path = path;\n-        }\n-\n-\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n-            Timber.d(\"doInBackgroundImportReplace\");\n-            Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n-            Context context = col.getContext();\n-\n-            // extract the deck from the zip file\n-            String colPath = CollectionHelper.getCollectionPath(context);\n-            File dir = new File(new File(colPath).getParentFile(), \"tmpzip\");\n-            if (dir.exists()) {\n-                BackupManager.removeDir(dir);\n-            }\n-\n-            // from anki2.py\n-            String colname = \"collection.anki21\";\n-            ZipFile zip;\n-            try {\n-                zip = new ZipFile(new File(path));\n-            } catch (IOException e) {\n-                Timber.e(e, \"doInBackgroundImportReplace - Error while unzipping\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace0\");\n-                return False;\n-            }\n-            try {\n-                // v2 scheduler?\n-                if (zip.getEntry(colname) == null) {\n-                    colname = CollectionHelper.COLLECTION_FILENAME;\n-                }\n-                Utils.unzipFiles(zip, dir.getAbsolutePath(), new String[] {colname, \"media\"}, null);\n-            } catch (IOException e) {\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - unzip\");\n-                return False;\n-            }\n-            String colFile = new File(dir, colname).getAbsolutePath();\n-            if (!(new File(colFile)).exists()) {\n-                return False;\n-            }\n-\n-            Collection tmpCol = null;\n-            try {\n-                tmpCol = Storage.Collection(context, colFile);\n-                if (!tmpCol.validCollection()) {\n-                    tmpCol.close();\n-                    return False;\n-                }\n-            } catch (Exception e) {\n-                Timber.e(\"Error opening new collection file... probably it's invalid\");\n-                try {\n-                    tmpCol.close();\n-                } catch (Exception e2) {\n-                    Timber.w(e2);\n-                    // do nothing\n-                }\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - open col\");\n-                return False;\n-            } finally {\n-                if (tmpCol != null) {\n-                    tmpCol.close();\n-                }\n-            }\n-\n-            collectionTask.doProgress(res.getString(R.string.importing_collection));\n-\n-            try {\n-                CollectionHelper.getInstance().getCol(context);\n-                // unload collection and trigger a backup\n-                Time time = CollectionHelper.getInstance().getTimeSafe(context);\n-                CollectionHelper.getInstance().closeCollection(true, \"Importing new collection\");\n-                CollectionHelper.getInstance().lockCollection();\n-                BackupManager.performBackupInBackground(colPath, true, time);\n-            } catch (Exception e) {\n-                Timber.w(e);\n-            }\n-            // overwrite collection\n-            File f = new File(colFile);\n-            if (!f.renameTo(new File(colPath))) {\n-                // Exit early if this didn't work\n-                return False;\n-            }\n-            int addedCount = -1;\n-            try {\n-                CollectionHelper.getInstance().unlockCollection();\n-\n-                // because users don't have a backup of media, it's safer to import new\n-                // data and rely on them running a media db check to get rid of any\n-                // unwanted media. in the future we might also want to duplicate this step\n-                // import media\n-                HashMap<String, String> nameToNum = new HashMap<>();\n-                HashMap<String, String> numToName = new HashMap<>();\n-                File mediaMapFile = new File(dir.getAbsolutePath(), \"media\");\n-                if (mediaMapFile.exists()) {\n-                    JsonReader jr = new JsonReader(new FileReader(mediaMapFile));\n-                    jr.beginObject();\n-                    String name;\n-                    String num;\n-                    while (jr.hasNext()) {\n-                        num = jr.nextName();\n-                        name = jr.nextString();\n-                        nameToNum.put(name, num);\n-                        numToName.put(num, name);\n-                    }\n-                    jr.endObject();\n-                    jr.close();\n-                }\n-                String mediaDir = Media.getCollectionMediaPath(colPath);\n-                int total = nameToNum.size();\n-                int i = 0;\n-                for (Map.Entry<String, String> entry : nameToNum.entrySet()) {\n-                    String file = entry.getKey();\n-                    String c = entry.getValue();\n-                    File of = new File(mediaDir, file);\n-                    if (!of.exists()) {\n-                        Utils.unzipFiles(zip, mediaDir, new String[] {c}, numToName);\n-                    }\n-                    ++i;\n-                    collectionTask.doProgress(res.getString(R.string.import_media_count, (i + 1) * 100 / total));\n-                }\n-                zip.close();\n-                // delete tmp dir\n-                BackupManager.removeDir(dir);\n-                return True;\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundImportReplace - RuntimeException\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace1\");\n-                return False;\n-            } catch (FileNotFoundException e) {\n-                Timber.e(e, \"doInBackgroundImportReplace - FileNotFoundException\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace2\");\n-                return False;\n-            } catch (IOException e) {\n-                Timber.e(e, \"doInBackgroundImportReplace - IOException\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace3\");\n-                return False;\n-            }\n-        }\n-    }\n-\n-\n-    public static class ExportApkg extends Task<Void, Pair<Boolean, String>> {\n-        private final String apkgPath;\n-        private final Long did;\n-        private final Boolean includeSched;\n-        private final Boolean includeMedia;\n-\n-\n-        public ExportApkg(String apkgPath, Long did, Boolean includeSched, Boolean includeMedia) {\n-            this.apkgPath = apkgPath;\n-            this.did = did;\n-            this.includeSched = includeSched;\n-            this.includeMedia = includeMedia;\n-        }\n-\n-\n-        protected Pair<Boolean, String> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundExportApkg\");\n-\n-            try {\n-                AnkiPackageExporter exporter = new AnkiPackageExporter(col, did, includeSched, includeMedia);\n-                exporter.exportInto(apkgPath, col.getContext());\n-            } catch (FileNotFoundException e) {\n-                Timber.e(e, \"FileNotFoundException in doInBackgroundExportApkg\");\n-                return new Pair<>(false, null);\n-            } catch (IOException e) {\n-                Timber.e(e, \"IOException in doInBackgroundExportApkg\");\n-                return new Pair<>(false, null);\n-            } catch (JSONException e) {\n-                Timber.e(e, \"JSOnException in doInBackgroundExportApkg\");\n-                return new Pair<>(false, null);\n-            } catch (ImportExportException e) {\n-                Timber.e(e, \"ImportExportException in doInBackgroundExportApkg\");\n-                return new Pair<>(true, e.getMessage());\n-            }\n-            return new Pair<>(false, apkgPath);\n-        }\n-    }\n-\n-\n-    public static class Reorder extends Task<Void, Boolean> {\n-        private final DeckConfig conf;\n-\n-\n-        public Reorder(DeckConfig conf) {\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundReorder\");\n-            col.getSched().resortConf(conf);\n-            return true;\n-        }\n-    }\n-\n-\n-    public static class ConfChange extends Task<Void, Boolean> {\n-        private final Deck deck;\n-        private final DeckConfig conf;\n-\n-\n-        public ConfChange(Deck deck, DeckConfig conf) {\n-            this.deck = deck;\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundConfChange\");\n-            try {\n-                long newConfId = conf.getLong(\"id\");\n-                // If new config has a different sorting order, reorder the cards\n-                int oldOrder = col.getDecks().getConf(deck.getLong(\"conf\")).getJSONObject(\"new\").getInt(\"order\");\n-                int newOrder = col.getDecks().getConf(newConfId).getJSONObject(\"new\").getInt(\"order\");\n-                if (oldOrder != newOrder) {\n-                    switch (newOrder) {\n-                        case 0:\n-                            col.getSched().randomizeCards(deck.getLong(\"id\"));\n-                            break;\n-                        case 1:\n-                            col.getSched().orderCards(deck.getLong(\"id\"));\n-                            break;\n-                    }\n-                }\n-                col.getDecks().setConf(deck, newConfId);\n-                col.save();\n-                return true;\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public static class ConfReset extends Task<Void, Boolean> {\n-        private final DeckConfig conf;\n-\n-\n-        public ConfReset(DeckConfig conf) {\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundConfReset\");\n-            col.getDecks().restoreToDefault(conf);\n-            col.save();\n-            return null;\n-        }\n-    }\n-\n-\n-    public static class ConfRemove extends Task<Void, Boolean> {\n-        private final DeckConfig conf;\n-\n-\n-        public ConfRemove(DeckConfig conf) {\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundConfRemove\");\n-            try {\n-                // Note: We do the actual removing of the options group in the main thread so that we\n-                // can ask the user to confirm if they're happy to do a full sync, and just do the resorting here\n-\n-                // When a conf is deleted, all decks using it revert to the default conf.\n-                // Cards must be reordered according to the default conf.\n-                int order = conf.getJSONObject(\"new\").getInt(\"order\");\n-                int defaultOrder = col.getDecks().getConf(1).getJSONObject(\"new\").getInt(\"order\");\n-                if (order != defaultOrder) {\n-                    conf.getJSONObject(\"new\").put(\"order\", defaultOrder);\n-                    col.getSched().resortConf(conf);\n-                }\n-                col.save();\n-                return true;\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public static class ConfSetSubdecks extends Task<Void, Boolean> {\n-        private final Deck deck;\n-        private final DeckConfig conf;\n-\n-\n-        public ConfSetSubdecks(Deck deck, DeckConfig conf) {\n-            this.deck = deck;\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundConfSetSubdecks\");\n-            try {\n-                TreeMap<String, Long> children = col.getDecks().children(deck.getLong(\"id\"));\n-                for (long childDid : children.values()) {\n-                    Deck child = col.getDecks().get(childDid);\n-                    if (child.isDyn()) {\n-                        continue;\n-                    }\n-                    boolean changed = new ConfChange(child, conf).task(col, collectionTask);\n-                    if (!changed) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * @return The results list from the check, or false if any errors.\n-     */\n-    public static class CheckMedia extends Task<Void, PairWithBoolean<List<List<String>>>> {\n-        @Override\n-        protected PairWithBoolean<List<List<String>>> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundCheckMedia\");\n-            // Ensure that the DB is valid - unknown why, but some users were missing the meta table.\n-            try {\n-                col.getMedia().rebuildIfInvalid();\n-            } catch (IOException e) {\n-                Timber.w(e);\n-                return new PairWithBoolean<>(false, null);\n-            }\n-            // A media check on AnkiDroid will also update the media db\n-            col.getMedia().findChanges(true);\n-            // Then do the actual check\n-            return new PairWithBoolean<>(true, col.getMedia().check());\n-        }\n-    }\n-\n-\n-    public static class DeleteMedia extends Task<Void, Integer> {\n-        private final List<String> unused;\n-\n-\n-        public DeleteMedia(List<String> unused) {\n-            this.unused = unused;\n-        }\n-\n-\n-        protected Integer task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            com.ichi2.libanki.Media m = col.getMedia();\n-            for (String fname : unused) {\n-                m.removeFile(fname);\n-            }\n-            return unused.size();\n-        }\n-    }\n-\n-\n-    /**\n-     * Handles everything for a model change at once - template add / deletes as well as content updates\n-     */\n-    public static class SaveModel extends Task<Void, Pair<Boolean, String>> {\n-        private final Model model;\n-        private final ArrayList<Object[]> templateChanges;\n-\n-\n-        public SaveModel(Model model, ArrayList<Object[]> templateChanges) {\n-            this.model = model;\n-            this.templateChanges = templateChanges;\n-        }\n-\n-\n-        protected Pair<Boolean, String> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundSaveModel\");\n-            Model oldModel = col.getModels().get(model.getLong(\"id\"));\n-\n-            // TODO need to save all the cards that will go away, for undo\n-            //  (do I need to remove them from graves during undo also?)\n-            //    - undo (except for cards) could just be Models.update(model) / Models.flush() / Collection.reset() (that was prior \"undo\")\n-            JSONArray newTemplates = model.getJSONArray(\"tmpls\");\n-\n-            col.getDb().getDatabase().beginTransaction();\n-\n-            try {\n-                for (Object[] change : templateChanges) {\n-                    JSONArray oldTemplates = oldModel.getJSONArray(\"tmpls\");\n-                    switch ((TemporaryModel.ChangeType) change[1]) {\n-                        case ADD:\n-                            Timber.d(\"doInBackgroundSaveModel() adding template %s\", change[0]);\n-                            try {\n-                                col.getModels().addTemplate(oldModel, newTemplates.getJSONObject((int) change[0]));\n-                            } catch (Exception e) {\n-                                Timber.e(e, \"Unable to add template %s to model %s\", change[0], model.getLong(\"id\"));\n-                                return new Pair<>(false, e.getLocalizedMessage());\n-                            }\n-                            break;\n-                        case DELETE:\n-                            Timber.d(\"doInBackgroundSaveModel() deleting template currently at ordinal %s\", change[0]);\n-                            try {\n-                                col.getModels().remTemplate(oldModel, oldTemplates.getJSONObject((int) change[0]));\n-                            } catch (Exception e) {\n-                                Timber.e(e, \"Unable to delete template %s from model %s\", change[0], model.getLong(\"id\"));\n-                                return new Pair<>(false, e.getLocalizedMessage());\n-                            }\n-                            break;\n-                        default:\n-                            Timber.w(\"Unknown change type? %s\", change[1]);\n-                            break;\n-                    }\n-                }\n-\n-                col.getModels().save(model, true);\n-                col.getModels().update(model);\n-                col.reset();\n-                col.save();\n-                if (col.getDb().getDatabase().inTransaction()) {\n-                    col.getDb().getDatabase().setTransactionSuccessful();\n-                } else {\n-                    Timber.i(\"CollectionTask::SaveModel was not in a transaction? Cannot mark transaction successful.\");\n-                }\n-            } finally {\n-                DB.safeEndInTransaction(col.getDb());\n-            }\n-            return new Pair<>(true, null);\n-        }\n-    }\n-\n-\n-    /*\n-     * Async task for the ModelBrowser Class\n-     * Returns an ArrayList of all models alphabetically ordered and the number of notes\n-     * associated with each model.\n-     *\n-     * @return {ArrayList<JSONObject> models, ArrayList<Integer> cardCount}\n-     */\n-    public static class CountModels extends Task<Void, Pair<ArrayList<Model>, ArrayList<Integer>>> {\n-        protected Pair<ArrayList<Model>, ArrayList<Integer>> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundLoadModels\");\n-\n-            ArrayList<Model> models = col.getModels().all();\n-            ArrayList<Integer> cardCount = new ArrayList<>();\n-            Collections.sort(models, (Comparator<JSONObject>) (a, b) -> a.getString(\"name\").compareTo(b.getString(\"name\")));\n-\n-            for (Model n : models) {\n-                if (collectionTask.isCancelled()) {\n-                    Timber.e(\"doInBackgroundLoadModels :: Cancelled\");\n-                    // onPostExecute not executed if cancelled. Return value not used.\n-                    return null;\n-                }\n-                cardCount.add(col.getModels().useCount(n));\n-            }\n-\n-            return new Pair<>(models, cardCount);\n-        }\n-    }\n-\n-\n-    /**\n-     * Deletes the given model\n-     * and all notes associated with it\n-     */\n-    public static class DeleteModel extends Task<Void, Boolean> {\n-        private final long modID;\n-\n-\n-        public DeleteModel(long modID) {\n-            this.modID = modID;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackGroundDeleteModel\");\n-            try {\n-                col.getModels().rem(col.getModels().get(modID));\n-                col.save();\n-            } catch (ConfirmModSchemaException e) {\n-                e.log();\n-                Timber.e(\"doInBackGroundDeleteModel :: ConfirmModSchemaException\");\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    /**\n-     * Deletes the given field in the given model\n-     */\n-    public static class DeleteField extends Task<Void, Boolean> {\n-        private final Model model;\n-        private final JSONObject field;\n-\n-\n-        public DeleteField(Model model, JSONObject field) {\n-            this.model = model;\n-            this.field = field;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask){\n-            Timber.d(\"doInBackGroundDeleteField\");\n-\n-\n-            try {\n-                col.getModels().remField(model, field);\n-                col.save();\n-            } catch (ConfirmModSchemaException e) {\n-                //Should never be reached\n-                e.log();\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    /**\n-     * Repositions the given field in the given model\n-     */\n-    public static class RepositionField extends Task<Void, Boolean> {\n-        private final Model model;\n-        private final JSONObject field;\n-        private final int index;\n-\n-\n-        public RepositionField(Model model, JSONObject field, int index) {\n-            this.model = model;\n-            this.field = field;\n-            this.index = index;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask){\n-            Timber.d(\"doInBackgroundRepositionField\");\n-\n-            try {\n-                col.getModels().moveField(model, field, index);\n-                col.save();\n-            } catch (ConfirmModSchemaException e) {\n-                e.log();\n-                //Should never be reached\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    /**\n-     * Adds a field with name in given model\n-     */\n-    public static class AddField extends Task<Void, Boolean> {\n-        private final Model model;\n-        private final String fieldName;\n-\n-\n-        public AddField(Model model, String fieldName) {\n-            this.model = model;\n-            this.fieldName = fieldName;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask){\n-            Timber.d(\"doInBackgroundRepositionField\");\n-            col.getModels().addFieldModChanged(model, col.getModels().newField(fieldName));\n-            col.save();\n-            return true;\n-        }\n-    }\n-\n-    /**\n-     * Adds a field of with name in given model\n-     */\n-    public static class ChangeSortField extends Task<Void, Boolean> {\n-        private final Model model;\n-        private final int idx;\n-\n-\n-        public ChangeSortField(Model model, int idx) {\n-            this.model = model;\n-            this.idx = idx;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask){\n-            try {\n-                Timber.d(\"doInBackgroundChangeSortField\");\n-                col.getModels().setSortIdx(model, idx);\n-                col.save();\n-            } catch(Exception e){\n-                Timber.e(e, \"Error changing sort field\");\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-    \n-    public static class FindEmptyCards extends Task<Integer, List<Long>> {\n-        protected List<Long> task(Collection col, ProgressSenderAndCancelListener<Integer> collectionTask) {\n-            return col.emptyCids(collectionTask);\n-        }\n-    }\n-\n-    /**\n-     * Goes through selected cards and checks selected and marked attribute\n-     * @return If there are unselected cards, if there are unmarked cards\n-     */\n-    public static class CheckCardSelection extends Task<Void, Pair<Boolean, Boolean>> {\n-        private final CardBrowser.CardCollection<CardBrowser.CardCache> checkedCards;\n-\n-\n-        public CheckCardSelection(CardBrowser.CardCollection<CardBrowser.CardCache> checkedCards) {\n-            this.checkedCards = checkedCards;\n-        }\n-\n-\n-        protected @Nullable Pair<Boolean, Boolean> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            boolean hasUnsuspended = false;\n-            boolean hasUnmarked = false;\n-            for (CardBrowser.CardCache c: checkedCards) {\n-                if (collectionTask.isCancelled()) {\n-                    Timber.v(\"doInBackgroundCheckCardSelection: cancelled.\");\n-                    return null;\n-                }\n-                Card card = c.getCard();\n-                hasUnsuspended = hasUnsuspended || card.getQueue() != Consts.QUEUE_TYPE_SUSPENDED;\n-                hasUnmarked = hasUnmarked || !card.note().hasTag(\"marked\");\n-                if (hasUnsuspended && hasUnmarked)\n-                    break;\n-            }\n-\n-            return new Pair<>(hasUnsuspended, hasUnmarked);\n-        }\n-    }\n-\n-    public static class PreloadNextCard extends Task<Void, Void> {\n-        public Void task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            try {\n-                col.getSched().counts(); // Ensure counts are recomputed if necessary, to know queue to look for\n-                col.getSched().preloadNextCard();\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundPreloadNextCard - RuntimeException on preloading card\");\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LoadCollectionComplete extends Task<Void, Void> {\n-        protected Void task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            if (col != null) {\n-                CollectionHelper.loadCollectionComplete(col);\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class Reset extends Task<Void, Void> {\n-        public Void task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            col.getSched().reset();\n-            return null;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 4c8416c27..c20123255 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -906,6 +974,10 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n         }\n         // Render the first few items\n         for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n+            if (isCancelled()) {\n+                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n+                return null;\n+            }\n             Card c = col.getCard(Long.parseLong(searchResult.get(i).get(\"id\")));\n             CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n", "next_change": {"commit": "1b8198ca33ba270ac5983ab76c3790778e22ca9e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex c20123255..bd8276640 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -978,7 +1189,7 @@ public class CollectionTask extends BaseAsyncTask<CollectionTask.TaskData, Colle\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            Card c = col.getCard(Long.parseLong(searchResult.get(i).get(\"id\")));\n+            Card c = col.getCard(Long.parseLong(searchResult.get(i).get(CardBrowser.ID)));\n             CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n         // Finish off the task\n", "next_change": {"commit": "f6b4230e354e2965089317b68124bf15bfa54b84", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex bd8276640..5b63ff47f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1189,7 +1188,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            Card c = col.getCard(Long.parseLong(searchResult.get(i).get(CardBrowser.ID)));\n+            Card c = col.getCard(searchResult.get(i).getId());\n             CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n         // Finish off the task\n", "next_change": {"commit": "0ed0b26615da7a6bca6313471ceda4e1162656b0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 5b63ff47f..4272ee460 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,7 +1188,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            Card c = col.getCard(searchResult.get(i).getId());\n+            Card c = searchResult.get(i).getCard();\n             CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n         // Finish off the task\n", "next_change": {"commit": "4a0d565455507e4b0a9123f13a6d23c539788df7", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 4272ee460..ba09fd15c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,7 +1188,9 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            Card c = searchResult.get(i).getCard();\n+            CardBrowser.CardCache card = searchResult.get(i);\n+            card.load(false);\n+            Card c = card.getCard();\n             CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n         }\n         // Finish off the task\n", "next_change": {"commit": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex ba09fd15c..c0ab1f715 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1191,7 +1191,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n             CardBrowser.CardCache card = searchResult.get(i);\n             card.load(false);\n             Card c = card.getCard();\n-            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c, col);\n+            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "25668235083fa2e4c0716fb177f0ed756d5f18f1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex c0ab1f715..7552fda8a 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1191,7 +1191,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n             CardBrowser.CardCache card = searchResult.get(i);\n             card.load(false);\n             Card c = card.getCard();\n-            CardBrowser.updateSearchItemQA(mContext, searchResult.get(i), c);\n+            CardBrowser.updateSearchItemQA(searchResult.get(i), c);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "216580a8bfebb2e94d3ee973e9c16dea5b45f6a2", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 7552fda8a..b7b8edeb1 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1190,8 +1190,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n             }\n             CardBrowser.CardCache card = searchResult.get(i);\n             card.load(false);\n-            Card c = card.getCard();\n-            CardBrowser.updateSearchItemQA(searchResult.get(i), c);\n+            CardBrowser.updateSearchItemQA(searchResult.get(i));\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "474450d513e379802bca25b64e9d2dccfa7dc105", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex b7b8edeb1..527f0c054 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,9 +1188,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            CardBrowser.CardCache card = searchResult.get(i);\n-            card.load(false);\n-            CardBrowser.updateSearchItemQA(searchResult.get(i));\n+            CardBrowser.CardCache card = searchResult.get(i).load(false);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "d90769e73040f4d591ed783b7d66a856c8bfe7e3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 527f0c054..28218624d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,7 +1188,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            CardBrowser.CardCache card = searchResult.get(i).load(false);\n+            searchResult.get(i).load(false);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "23d64c43221e83f1ca9b1dd0987e47a570a1f33c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 28218624d..19cc01d57 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1188,7 +1190,7 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n                 Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            searchResult.get(i).load(false);\n+            searchResult.get(i).load(false, column1Index, column2Index);\n         }\n         // Finish off the task\n         if (isCancelled()) {\n", "next_change": {"commit": "dbaf6549ec268333b20d160a0c40962d3135ba0d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 19cc01d57..83905c963 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1176,22 +1251,12 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n         }\n         int column1Index = (Integer) param.getObjArray()[3];\n         int column2Index = (Integer) param.getObjArray()[4];\n-        List<Long> searchResult_ = col.findCards(query, order, this);\n+        final List<CardBrowser.CardCache> searchResult = new ArrayList<>();\n+        PartialSearch partialSearch = new PartialSearch(searchResult, column1Index, column2Index, numCardsToRender);\n+        List<Long> searchResult_ = col.findCards(query, order, partialSearch);\n+        partialSearch.add(searchResult_);\n         int resultSize = searchResult_.size();\n-        List<CardBrowser.CardCache> searchResult = new ArrayList<>(resultSize);\n         Timber.d(\"The search found %d cards\", resultSize);\n-        for (Long cid: searchResult_) {\n-            CardBrowser.CardCache card = new CardBrowser.CardCache(cid, col);\n-            searchResult.add(card);\n-        }\n-        // Render the first few items\n-        for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n-            if (isCancelled()) {\n-                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-                return null;\n-            }\n-            searchResult.get(i).load(false, column1Index, column2Index);\n-        }\n         // Finish off the task\n         if (isCancelled()) {\n             Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n", "next_change": {"commit": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 83905c963..9ad6fad8d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1239,449 +1078,563 @@ public class CollectionTask extends BaseAsyncTask<TaskData, TaskData, TaskData>\n         }\n     }\n \n-    private TaskData doInBackgroundSearchCards(TaskData param) {\n-        Timber.d(\"doInBackgroundSearchCards\");\n-        Collection col = getCol();\n-        String query = (String) param.getObjArray()[0];\n-        Boolean order = (Boolean) param.getObjArray()[1];\n-        int numCardsToRender = (int) param.getObjArray()[2];\n-        if (isCancelled()) {\n-            Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-            return null;\n-        }\n-        int column1Index = (Integer) param.getObjArray()[3];\n-        int column2Index = (Integer) param.getObjArray()[4];\n-        final List<CardBrowser.CardCache> searchResult = new ArrayList<>();\n-        PartialSearch partialSearch = new PartialSearch(searchResult, column1Index, column2Index, numCardsToRender);\n-        List<Long> searchResult_ = col.findCards(query, order, partialSearch);\n-        partialSearch.add(searchResult_);\n-        int resultSize = searchResult_.size();\n-        Timber.d(\"The search found %d cards\", resultSize);\n-        // Finish off the task\n-        if (isCancelled()) {\n-            Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-            return null;\n-        } else {\n-            return new TaskData(searchResult);\n-        }\n-    }\n \n+    public static class SearchCards extends Task<List<CardBrowser.CardCache>, List<CardBrowser.CardCache>> {\n+        private final String query;\n+        private final boolean order;\n+        private final int numCardsToRender;\n+        private final int column1Index;\n+        private final int column2Index;\n \n-    private TaskData doInBackgroundRenderBrowserQA(TaskData param) {\n-        Timber.d(\"doInBackgroundRenderBrowserQA\");\n-        Collection col = getCol();\n-        List<CardBrowser.CardCache> cards = (List<CardBrowser.CardCache>) param.getObjArray()[0];\n-        Integer startPos = (Integer) param.getObjArray()[1];\n-        Integer n = (Integer) param.getObjArray()[2];\n-        int column1Index = (Integer) param.getObjArray()[3];\n-        int column2Index = (Integer) param.getObjArray()[4];\n \n-        List<Long> invalidCardIds = new ArrayList<>();\n-        // for each specified card in the browser list\n-        for (int i = startPos; i < startPos + n; i++) {\n-            // Stop if cancelled\n-            if (isCancelled()) {\n-                Timber.d(\"doInBackgroundRenderBrowserQA was aborted\");\n+        public SearchCards(String query, boolean order, int numCardsToRender, int column1Index, int column2Index) {\n+            this.query = query;\n+            this.order = order;\n+            this.numCardsToRender = numCardsToRender;\n+            this.column1Index = column1Index;\n+            this.column2Index = column2Index;\n+        }\n+\n+\n+        protected List<CardBrowser.CardCache> task(Collection col, ProgressSenderAndCancelListener<List<CardBrowser.CardCache>> collectionTask) {\n+            Timber.d(\"doInBackgroundSearchCards\");\n+            if (collectionTask.isCancelled()) {\n+                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n                 return null;\n             }\n-            if (i < 0 || i >= cards.size()) {\n-                continue;\n-            }\n-            CardBrowser.CardCache card;\n-            try {\n-                card = cards.get(i);\n-            }\n-            catch (IndexOutOfBoundsException e) {\n-                //even though we test against card.size() above, there's still a race condition\n-                //We might be able to optimise this to return here. Logically if we're past the end of the collection,\n-                //we won't reach any more cards.\n-                continue;\n+            List<CardBrowser.CardCache> searchResult = new ArrayList<>();\n+            List<Long> searchResult_ = col.findCards(query, order, new PartialSearch(searchResult, column1Index, column2Index, numCardsToRender, collectionTask, col));\n+            Timber.d(\"The search found %d cards\", searchResult_.size());\n+            int position = 0;\n+            for (Long cid : searchResult_) {\n+                CardBrowser.CardCache card = new CardBrowser.CardCache(cid, col, position++);\n+                searchResult.add(card);\n             }\n-            if (card.isLoaded()) {\n-                //We've already rendered the answer, we don't need to do it again.\n-                continue;\n+            // Render the first few items\n+            for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n+                if (collectionTask.isCancelled()) {\n+                    Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n+                    return null;\n+                }\n+                searchResult.get(i).load(false, column1Index, column2Index);\n             }\n-            // Extract card item\n-            try {\n-                // Ensure that card still exists.\n-                card.getCard();\n-            } catch (WrongId e) {\n-                //#5891 - card can be inconsistent between the deck browser screen and the collection.\n-                //Realistically, we can skip any exception as it's a rendering task which should not kill the\n-                //process\n-                long cardId = card.getId();\n-                Timber.e(e, \"Could not process card '%d' - skipping and removing from sight\", cardId);\n-                invalidCardIds.add(cardId);\n-                continue;\n+            // Finish off the task\n+            if (collectionTask.isCancelled()) {\n+                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n+                return null;\n+            } else {\n+                return searchResult;\n             }\n-            // Update item\n-            card.load(false, column1Index, column2Index);\n-            float progress = (float) i / n * 100;\n-            publishProgress(new TaskData((int) progress));\n         }\n-        return new TaskData(new Object[] { cards, invalidCardIds });\n     }\n \n \n-    private TaskData doInBackgroundCheckDatabase() {\n+    public static class RenderBrowserQA extends Task<Integer, Pair<CardBrowser.CardCollection<CardBrowser.CardCache>, List<Long>>> {\n+        private final CardBrowser.CardCollection<CardBrowser.CardCache> cards;\n+        private final Integer startPos;\n+        private final Integer n;\n+        private final int column1Index;\n+        private final int column2Index;\n+\n+\n+        public RenderBrowserQA(CardBrowser.CardCollection<CardBrowser.CardCache> cards, Integer mStartPos, Integer n, int column1Index, int column2Index) {\n+            this.cards = cards;\n+            this.startPos = mStartPos;\n+            this.n = n;\n+            this.column1Index = column1Index;\n+            this.column2Index = column2Index;\n+        }\n+\n+\n+        protected Pair<CardBrowser.CardCollection<CardBrowser.CardCache>, List<Long>> task(Collection col, ProgressSenderAndCancelListener<Integer> collectionTask) {\n+            Timber.d(\"doInBackgroundRenderBrowserQA\");\n+\n+            List<Long> invalidCardIds = new ArrayList<>();\n+            // for each specified card in the browser list\n+            for (int i = startPos; i < startPos + n; i++) {\n+                // Stop if cancelled\n+                if (collectionTask.isCancelled()) {\n+                    Timber.d(\"doInBackgroundRenderBrowserQA was aborted\");\n+                    return null;\n+                }\n+                if (i < 0 || i >= cards.size()) {\n+                    continue;\n+                }\n+                CardBrowser.CardCache card;\n+                try {\n+                    card = cards.get(i);\n+                }\n+                catch (IndexOutOfBoundsException e) {\n+                    //even though we test against card.size() above, there's still a race condition\n+                    //We might be able to optimise this to return here. Logically if we're past the end of the collection,\n+                    //we won't reach any more cards.\n+                    continue;\n+                }\n+                if (card.isLoaded()) {\n+                    //We've already rendered the answer, we don't need to do it again.\n+                    continue;\n+                }\n+                // Extract card item\n+                try {\n+                    // Ensure that card still exists.\n+                    card.getCard();\n+                } catch (WrongId e) {\n+                    //#5891 - card can be inconsistent between the deck browser screen and the collection.\n+                    //Realistically, we can skip any exception as it's a rendering task which should not kill the\n+                    //process\n+                    long cardId = card.getId();\n+                    Timber.e(e, \"Could not process card '%d' - skipping and removing from sight\", cardId);\n+                    invalidCardIds.add(cardId);\n+                    continue;\n+                }\n+                // Update item\n+                card.load(false, column1Index, column2Index);\n+                float progress = (float) i / n * 100;\n+                collectionTask.doProgress((int) progress);\n+            }\n+            return new Pair<>(cards, invalidCardIds);\n+        }\n+    }\n+\n+    public static class CheckDatabase extends Task<String, Pair<Boolean, Collection.CheckDatabaseResult>> {\n+    protected Pair<Boolean, Collection.CheckDatabaseResult> task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n         Timber.d(\"doInBackgroundCheckDatabase\");\n-        Collection col = getCol();\n         // Don't proceed if collection closed\n         if (col == null) {\n             Timber.e(\"doInBackgroundCheckDatabase :: supplied collection was null\");\n-            return new TaskData(false);\n+            return new Pair(false, null);\n         }\n \n-        Collection.CheckDatabaseResult result = col.fixIntegrity(new ProgressCallback(this, AnkiDroidApp.getAppResources()));\n+        Collection.CheckDatabaseResult result = col.fixIntegrity(new TaskManager.ProgressCallback(collectionTask, AnkiDroidApp.getAppResources()));\n         if (result.getFailed()) {\n             //we can fail due to a locked database, which requires knowledge of the failure.\n-            return new TaskData(false, new Object[] { result });\n+            return new Pair(false, result);\n         } else {\n             // Close the collection and we restart the app to reload\n             CollectionHelper.getInstance().closeCollection(true, \"Check Database Completed\");\n-            return new TaskData(true, new Object[] { result });\n+            return new Pair(true, result);\n         }\n     }\n+    }\n \n \n-    private TaskData doInBackgroundRepairCollection() {\n-        Timber.d(\"doInBackgroundRepairCollection\");\n-        Collection col = getCol();\n-        if (col != null) {\n-            Timber.i(\"RepairCollection: Closing collection\");\n-            col.close(false);\n+    public static class RepairCollectionn extends Task<Void, Boolean> {\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundRepairCollection\");\n+            if (col != null) {\n+                Timber.i(\"RepairCollection: Closing collection\");\n+                col.close(false);\n+            }\n+            return BackupManager.repairCollection(col);\n         }\n-        return new TaskData(BackupManager.repairCollection(col));\n     }\n \n \n-    private TaskData doInBackgroundUpdateValuesFromDeck(TaskData param) {\n-        Timber.d(\"doInBackgroundUpdateValuesFromDeck\");\n-        try {\n-            Collection col = getCol();\n-            AbstractSched sched = col.getSched();\n-            Object[] obj = param.getObjArray();\n-            boolean reset = (Boolean) obj[0];\n-            if (reset) {\n-                // reset actually required because of counts, which is used in getCollectionTaskListener\n-                sched.resetCounts();\n-            }\n-            Counts counts = sched.counts();\n-            int totalNewCount = sched.totalNewForCurrentDeck();\n-            int totalCount = sched.cardCount();\n-            return new TaskData(new Object[]{counts.getNew(), counts.getLrn(), counts.getRev(), totalNewCount,\n-                    totalCount, sched.eta(counts)});\n-        } catch (RuntimeException e) {\n-            Timber.e(e, \"doInBackgroundUpdateValuesFromDeck - an error occurred\");\n-            return null;\n+    public static class UpdateValuesFromDeck extends Task<Void, int[]> {\n+        private final boolean reset;\n+\n+\n+        public UpdateValuesFromDeck(boolean reset) {\n+            this.reset = reset;\n         }\n-    }\n \n \n-    private void doInBackgroundDeleteDeck(TaskData param) {\n-        Timber.d(\"doInBackgroundDeleteDeck\");\n-        Collection col = getCol();\n-        long did = param.getLong();\n-        col.getDecks().rem(did, true);\n-        // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n-        getCol().clearUndo();\n+        public int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundUpdateValuesFromDeck\");\n+            try {\n+                AbstractSched sched = col.getSched();\n+                if (reset) {\n+                    // reset actually required because of counts, which is used in getCollectionTaskListener\n+                    sched.resetCounts();\n+                }\n+                Counts counts = sched.counts();\n+                int totalNewCount = sched.totalNewForCurrentDeck();\n+                int totalCount = sched.cardCount();\n+                return new int[] {counts.getNew(), counts.getLrn(), counts.getRev(), totalNewCount,\n+                        totalCount, sched.eta(counts)};\n+            } catch (RuntimeException e) {\n+                Timber.e(e, \"doInBackgroundUpdateValuesFromDeck - an error occurred\");\n+                return null;\n+            }\n+        }\n     }\n \n \n-    private TaskData doInBackgroundRebuildCram() {\n-        Timber.d(\"doInBackgroundRebuildCram\");\n-        Collection col = getCol();\n-        col.getSched().rebuildDyn(col.getDecks().selected());\n-        return doInBackgroundUpdateValuesFromDeck(new TaskData(new Object[]{true}));\n-    }\n+    public static class DeleteDeck extends Task<Void, int[]> {\n+        private final long did;\n \n+        public DeleteDeck(long did) {\n+            this.did = did;\n+        }\n \n-    private TaskData doInBackgroundEmptyCram() {\n-        Timber.d(\"doInBackgroundEmptyCram\");\n-        Collection col = getCol();\n-        col.getSched().emptyDyn(col.getDecks().selected());\n-        return doInBackgroundUpdateValuesFromDeck(new TaskData(new Object[]{true}));\n+        protected int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundDeleteDeck\");\n+            col.getDecks().rem(did, true);\n+            // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n+            col.clearUndo();\n+            return null;\n+        }\n     }\n \n \n-    private TaskData doInBackgroundImportAdd(TaskData param) {\n-        Timber.d(\"doInBackgroundImportAdd\");\n-        Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n-        Collection col = getCol();\n-        String path = param.getString();\n-        AnkiPackageImporter imp = new AnkiPackageImporter(col, path);\n-        imp.setProgressCallback(new ProgressCallback(this, res));\n-        try {\n-            imp.run();\n-        } catch (ImportExportException e) {\n-            return new TaskData(e.getMessage(), true);\n+    public static class RebuildCram extends Task<Void, int[]> {\n+        protected int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundRebuildCram\");\n+            col.getSched().rebuildDyn(col.getDecks().selected());\n+            return new UpdateValuesFromDeck(true).task(col, collectionTask);\n+        }\n+    }\n+\n+    public static class EmptyCram extends Task<Void, int[]> {\n+        protected int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundEmptyCram\");\n+            col.getSched().emptyDyn(col.getDecks().selected());\n+            return new UpdateValuesFromDeck(true).task(col, collectionTask);\n         }\n-        return new TaskData(new Object[] {imp});\n     }\n \n+    public static class ImportAdd extends Task<String, Triple<AnkiPackageImporter, Boolean, String>> {\n+        private final String path;\n \n-    private TaskData doInBackgroundImportReplace(TaskData param) {\n-        Timber.d(\"doInBackgroundImportReplace\");\n-        String path = param.getString();\n-        Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n \n-        // extract the deck from the zip file\n-        String colPath = CollectionHelper.getCollectionPath(mContext);\n-        File dir = new File(new File(colPath).getParentFile(), \"tmpzip\");\n-        if (dir.exists()) {\n-            BackupManager.removeDir(dir);\n+        public ImportAdd(String path) {\n+            this.path = path;\n         }\n \n-        // from anki2.py\n-        String colname = \"collection.anki21\";\n-        ZipFile zip;\n-        try {\n-            zip = new ZipFile(new File(path));\n-        } catch (IOException e) {\n-            Timber.e(e, \"doInBackgroundImportReplace - Error while unzipping\");\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace0\");\n-            return new TaskData(false);\n-        }\n-        try {\n-            // v2 scheduler?\n-            if (zip.getEntry(colname) == null) {\n-                colname = CollectionHelper.COLLECTION_FILENAME;\n+\n+        protected Triple<AnkiPackageImporter, Boolean, String> task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n+            Timber.d(\"doInBackgroundImportAdd\");\n+            Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n+            AnkiPackageImporter imp = new AnkiPackageImporter(col, path);\n+            imp.setProgressCallback(new TaskManager.ProgressCallback(collectionTask, res));\n+            try {\n+                imp.run();\n+            } catch (ImportExportException e) {\n+                return new Triple(null, true, e.getMessage());\n             }\n-            Utils.unzipFiles(zip, dir.getAbsolutePath(), new String[] { colname, \"media\" }, null);\n-        } catch (IOException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - unzip\");\n-            return new TaskData(false);\n+            return new Triple<>(imp, false, null);\n         }\n-        String colFile = new File(dir, colname).getAbsolutePath();\n-        if (!(new File(colFile)).exists()) {\n-            return new TaskData(false);\n+    }\n+\n+\n+    public static class ImportReplace extends Task<String, BooleanGetter> {\n+        private final String path;\n+\n+\n+        public ImportReplace(String path) {\n+            this.path = path;\n         }\n \n-        Collection tmpCol = null;\n-        try {\n-            tmpCol = Storage.Collection(mContext, colFile);\n-            if (!tmpCol.validCollection()) {\n-                tmpCol.close();\n-                return new TaskData(false);\n+\n+        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n+            Timber.d(\"doInBackgroundImportReplace\");\n+            Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n+            Context context = col.getContext();\n+\n+            // extract the deck from the zip file\n+            String colPath = CollectionHelper.getCollectionPath(context);\n+            File dir = new File(new File(colPath).getParentFile(), \"tmpzip\");\n+            if (dir.exists()) {\n+                BackupManager.removeDir(dir);\n             }\n-        } catch (Exception e) {\n-            Timber.e(\"Error opening new collection file... probably it's invalid\");\n+\n+            // from anki2.py\n+            String colname = \"collection.anki21\";\n+            ZipFile zip;\n             try {\n-                tmpCol.close();\n-            } catch (Exception e2) {\n-                // do nothing\n+                zip = new ZipFile(new File(path));\n+            } catch (IOException e) {\n+                Timber.e(e, \"doInBackgroundImportReplace - Error while unzipping\");\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace0\");\n+                return fromBoolean(false);\n             }\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - open col\");\n-            return new TaskData(false);\n-        } finally {\n-            if (tmpCol != null) {\n-                tmpCol.close();\n+            try {\n+                // v2 scheduler?\n+                if (zip.getEntry(colname) == null) {\n+                    colname = CollectionHelper.COLLECTION_FILENAME;\n+                }\n+                Utils.unzipFiles(zip, dir.getAbsolutePath(), new String[] {colname, \"media\"}, null);\n+            } catch (IOException e) {\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - unzip\");\n+                return fromBoolean(false);\n+            }\n+            String colFile = new File(dir, colname).getAbsolutePath();\n+            if (!(new File(colFile)).exists()) {\n+                return fromBoolean(false);\n             }\n-        }\n-\n-        publishProgress(new TaskData(res.getString(R.string.importing_collection)));\n \n-        if (hasValidCol()) {\n-            // unload collection and trigger a backup\n-            Time time = CollectionHelper.getInstance().getTimeSafe(mContext);\n-            CollectionHelper.getInstance().closeCollection(true, \"Importing new collection\");\n-            CollectionHelper.getInstance().lockCollection();\n-            BackupManager.performBackupInBackground(colPath, true, time);\n-        }\n-        // overwrite collection\n-        File f = new File(colFile);\n-        if (!f.renameTo(new File(colPath))) {\n-            // Exit early if this didn't work\n-            return new TaskData(false);\n-        }\n-        int addedCount = -1;\n-        try {\n-            CollectionHelper.getInstance().unlockCollection();\n-\n-            // because users don't have a backup of media, it's safer to import new\n-            // data and rely on them running a media db check to get rid of any\n-            // unwanted media. in the future we might also want to duplicate this step\n-            // import media\n-            HashMap<String, String> nameToNum = new HashMap<>();\n-            HashMap<String, String> numToName = new HashMap<>();\n-            File mediaMapFile = new File(dir.getAbsolutePath(), \"media\");\n-            if (mediaMapFile.exists()) {\n-                JsonReader jr = new JsonReader(new FileReader(mediaMapFile));\n-                jr.beginObject();\n-                String name;\n-                String num;\n-                while (jr.hasNext()) {\n-                    num = jr.nextName();\n-                    name = jr.nextString();\n-                    nameToNum.put(name, num);\n-                    numToName.put(num, name);\n+            Collection tmpCol = null;\n+            try {\n+                tmpCol = Storage.Collection(context, colFile);\n+                if (!tmpCol.validCollection()) {\n+                    tmpCol.close();\n+                    return fromBoolean(false);\n                 }\n-                jr.endObject();\n-                jr.close();\n-            }\n-            String mediaDir = Media.getCollectionMediaPath(colPath);\n-            int total = nameToNum.size();\n-            int i = 0;\n-            for (Map.Entry<String, String> entry : nameToNum.entrySet()) {\n-                String file = entry.getKey();\n-                String c = entry.getValue();\n-                File of = new File(mediaDir, file);\n-                if (!of.exists()) {\n-                    Utils.unzipFiles(zip, mediaDir, new String[] { c }, numToName);\n+            } catch (Exception e) {\n+                Timber.e(\"Error opening new collection file... probably it's invalid\");\n+                try {\n+                    tmpCol.close();\n+                } catch (Exception e2) {\n+                    // do nothing\n                 }\n-                ++i;\n-                publishProgress(new TaskData(res.getString(R.string.import_media_count, (i + 1) * 100 / total)));\n-            }\n-            zip.close();\n-            // delete tmp dir\n-            BackupManager.removeDir(dir);\n-            return new TaskData(true);\n-        } catch (RuntimeException e) {\n-            Timber.e(e, \"doInBackgroundImportReplace - RuntimeException\");\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace1\");\n-            return new TaskData(false);\n-        } catch (FileNotFoundException e) {\n-            Timber.e(e, \"doInBackgroundImportReplace - FileNotFoundException\");\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace2\");\n-            return new TaskData(false);\n-        } catch (IOException e) {\n-            Timber.e(e, \"doInBackgroundImportReplace - IOException\");\n-            AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace3\");\n-            return new TaskData(false);\n-        }\n-    }\n-\n-\n-    private TaskData doInBackgroundExportApkg(TaskData param) {\n-        Timber.d(\"doInBackgroundExportApkg\");\n-        Object[] data = param.getObjArray();\n-        Collection col = (Collection) data[0];\n-        String apkgPath = (String) data[1];\n-        Long did = (Long) data[2];\n-        boolean includeSched = (Boolean) data[3];\n-        boolean includeMedia = (Boolean) data[4];\n-        \n-        try {\n-            AnkiPackageExporter exporter = new AnkiPackageExporter(col);\n-            exporter.setIncludeSched(includeSched);\n-            exporter.setIncludeMedia(includeMedia);\n-            exporter.setDid(did);\n-            exporter.exportInto(apkgPath, mContext);\n-        } catch (FileNotFoundException e) {\n-            Timber.e(e, \"FileNotFoundException in doInBackgroundExportApkg\");\n-            return new TaskData(false);\n-        } catch (IOException e) {\n-            Timber.e(e, \"IOException in doInBackgroundExportApkg\");\n-            return new TaskData(false);\n-        } catch (JSONException e) {\n-            Timber.e(e, \"JSOnException in doInBackgroundExportApkg\");\n-            return new TaskData(false);\n-        } catch (ImportExportException e) {\n-            Timber.e(e, \"ImportExportException in doInBackgroundExportApkg\");\n-            return new TaskData(e.getMessage(), true);\n-        }\n-        return new TaskData(apkgPath);\n-    }\n-\n-\n-    private TaskData doInBackgroundReorder(TaskData param) {\n-        Timber.d(\"doInBackgroundReorder\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        DeckConfig conf = (DeckConfig) data[0];\n-        col.getSched().resortConf(conf);\n-        return new TaskData(true);\n-    }\n-\n-\n-    private TaskData doInBackgroundConfChange(TaskData param) {\n-        Timber.d(\"doInBackgroundConfChange\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        Deck deck = (Deck) data[0];\n-        DeckConfig conf = (DeckConfig) data[1];\n-        try {\n-            long newConfId = conf.getLong(\"id\");\n-            // If new config has a different sorting order, reorder the cards\n-            int oldOrder = col.getDecks().getConf(deck.getLong(\"conf\")).getJSONObject(\"new\").getInt(\"order\");\n-            int newOrder = col.getDecks().getConf(newConfId).getJSONObject(\"new\").getInt(\"order\");\n-            if (oldOrder != newOrder) {\n-                switch (newOrder) {\n-                    case 0:\n-                        col.getSched().randomizeCards(deck.getLong(\"id\"));\n-                        break;\n-                    case 1:\n-                        col.getSched().orderCards(deck.getLong(\"id\"));\n-                        break;\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - open col\");\n+                return fromBoolean(false);\n+            } finally {\n+                if (tmpCol != null) {\n+                    tmpCol.close();\n                 }\n             }\n-            col.getDecks().setConf(deck, newConfId);\n-            col.save();\n-            return new TaskData(true);\n-        } catch (JSONException e) {\n-            return new TaskData(false);\n+\n+            collectionTask.doProgress(res.getString(R.string.importing_collection));\n+\n+            try {\n+                CollectionHelper.getInstance().getCol(context);\n+                // unload collection and trigger a backup\n+                Time time = CollectionHelper.getInstance().getTimeSafe(context);\n+                CollectionHelper.getInstance().closeCollection(true, \"Importing new collection\");\n+                CollectionHelper.getInstance().lockCollection();\n+                BackupManager.performBackupInBackground(colPath, true, time);\n+            } catch (Exception e) {\n+            }\n+            // overwrite collection\n+            File f = new File(colFile);\n+            if (!f.renameTo(new File(colPath))) {\n+                // Exit early if this didn't work\n+                return fromBoolean(false);\n+            }\n+            int addedCount = -1;\n+            try {\n+                CollectionHelper.getInstance().unlockCollection();\n+\n+                // because users don't have a backup of media, it's safer to import new\n+                // data and rely on them running a media db check to get rid of any\n+                // unwanted media. in the future we might also want to duplicate this step\n+                // import media\n+                HashMap<String, String> nameToNum = new HashMap<>();\n+                HashMap<String, String> numToName = new HashMap<>();\n+                File mediaMapFile = new File(dir.getAbsolutePath(), \"media\");\n+                if (mediaMapFile.exists()) {\n+                    JsonReader jr = new JsonReader(new FileReader(mediaMapFile));\n+                    jr.beginObject();\n+                    String name;\n+                    String num;\n+                    while (jr.hasNext()) {\n+                        num = jr.nextName();\n+                        name = jr.nextString();\n+                        nameToNum.put(name, num);\n+                        numToName.put(num, name);\n+                    }\n+                    jr.endObject();\n+                    jr.close();\n+                }\n+                String mediaDir = Media.getCollectionMediaPath(colPath);\n+                int total = nameToNum.size();\n+                int i = 0;\n+                for (Map.Entry<String, String> entry : nameToNum.entrySet()) {\n+                    String file = entry.getKey();\n+                    String c = entry.getValue();\n+                    File of = new File(mediaDir, file);\n+                    if (!of.exists()) {\n+                        Utils.unzipFiles(zip, mediaDir, new String[] {c}, numToName);\n+                    }\n+                    ++i;\n+                    collectionTask.doProgress(res.getString(R.string.import_media_count, (i + 1) * 100 / total));\n+                }\n+                zip.close();\n+                // delete tmp dir\n+                BackupManager.removeDir(dir);\n+                return fromBoolean(true);\n+            } catch (RuntimeException e) {\n+                Timber.e(e, \"doInBackgroundImportReplace - RuntimeException\");\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace1\");\n+                return fromBoolean(false);\n+            } catch (FileNotFoundException e) {\n+                Timber.e(e, \"doInBackgroundImportReplace - FileNotFoundException\");\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace2\");\n+                return fromBoolean(false);\n+            } catch (IOException e) {\n+                Timber.e(e, \"doInBackgroundImportReplace - IOException\");\n+                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace3\");\n+                return fromBoolean(false);\n+            }\n         }\n     }\n \n \n-    private TaskData doInBackgroundConfReset(TaskData param) {\n-        Timber.d(\"doInBackgroundConfReset\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        DeckConfig conf = (DeckConfig) data[0];\n-        col.getDecks().restoreToDefault(conf);\n-        col.save();\n-        return new TaskData(true);\n+    public static class ExportApkg extends Task<Void, Pair<Boolean, String>> {\n+        private final String apkgPath;\n+        private final Long did;\n+        private final Boolean includeSched;\n+        private final Boolean includeMedia;\n+\n+\n+        public ExportApkg(String apkgPath, Long did, Boolean includeSched, Boolean includeMedia) {\n+            this.apkgPath = apkgPath;\n+            this.did = did;\n+            this.includeSched = includeSched;\n+            this.includeMedia = includeMedia;\n+        }\n+\n+\n+        protected Pair<Boolean, String> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundExportApkg\");\n+\n+            try {\n+                AnkiPackageExporter exporter = new AnkiPackageExporter(col);\n+                exporter.setIncludeSched(includeSched);\n+                exporter.setIncludeMedia(includeMedia);\n+                exporter.setDid(did);\n+                exporter.exportInto(apkgPath, col.getContext());\n+            } catch (FileNotFoundException e) {\n+                Timber.e(e, \"FileNotFoundException in doInBackgroundExportApkg\");\n+                return new Pair(false, null);\n+            } catch (IOException e) {\n+                Timber.e(e, \"IOException in doInBackgroundExportApkg\");\n+                return new Pair(false, null);\n+            } catch (JSONException e) {\n+                Timber.e(e, \"JSOnException in doInBackgroundExportApkg\");\n+                return new Pair(false, null);\n+            } catch (ImportExportException e) {\n+                Timber.e(e, \"ImportExportException in doInBackgroundExportApkg\");\n+                return new Pair(true, e.getMessage());\n+            }\n+            return new Pair(false, apkgPath);\n+        }\n     }\n \n \n-    private TaskData doInBackgroundConfRemove(TaskData param) {\n-        Timber.d(\"doInBackgroundConfRemove\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        DeckConfig conf = (DeckConfig) data[0];\n-        try {\n-            // Note: We do the actual removing of the options group in the main thread so that we \n-            // can ask the user to confirm if they're happy to do a full sync, and just do the resorting here\n+    public static class Reorder extends Task<Void, Boolean> {\n+        private final DeckConfig conf;\n+\n+\n+        public Reorder(DeckConfig conf) {\n+            this.conf = conf;\n+        }\n+\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundReorder\");\n+            col.getSched().resortConf(conf);\n+            return true;\n+        }\n+    }\n+\n+\n+    public static class ConfChange extends Task<Void, Boolean> {\n+        private final Deck deck;\n+        private final DeckConfig conf;\n+\n+\n+        public ConfChange(Deck deck, DeckConfig conf) {\n+            this.deck = deck;\n+            this.conf = conf;\n+        }\n \n-            // When a conf is deleted, all decks using it revert to the default conf.\n-            // Cards must be reordered according to the default conf.\n-            int order = conf.getJSONObject(\"new\").getInt(\"order\");\n-            int defaultOrder = col.getDecks().getConf(1).getJSONObject(\"new\").getInt(\"order\");\n-            if (order != defaultOrder) {\n-                conf.getJSONObject(\"new\").put(\"order\", defaultOrder);\n-                col.getSched().resortConf(conf);\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundConfChange\");\n+            try {\n+                long newConfId = conf.getLong(\"id\");\n+                // If new config has a different sorting order, reorder the cards\n+                int oldOrder = col.getDecks().getConf(deck.getLong(\"conf\")).getJSONObject(\"new\").getInt(\"order\");\n+                int newOrder = col.getDecks().getConf(newConfId).getJSONObject(\"new\").getInt(\"order\");\n+                if (oldOrder != newOrder) {\n+                    switch (newOrder) {\n+                        case 0:\n+                            col.getSched().randomizeCards(deck.getLong(\"id\"));\n+                            break;\n+                        case 1:\n+                            col.getSched().orderCards(deck.getLong(\"id\"));\n+                            break;\n+                    }\n+                }\n+                col.getDecks().setConf(deck, newConfId);\n+                col.save();\n+                return true;\n+            } catch (JSONException e) {\n+                return false;\n             }\n+        }\n+    }\n+\n+    public static class ConfReset extends Task<Void, Boolean> {\n+        private final DeckConfig conf;\n+\n+\n+        public ConfReset(DeckConfig conf) {\n+            this.conf = conf;\n+        }\n+\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundConfReset\");\n+            col.getDecks().restoreToDefault(conf);\n             col.save();\n-            return new TaskData(true);\n-        } catch (JSONException e) {\n-            return new TaskData(false);\n+            return null;\n         }\n     }\n \n \n-    private TaskData doInBackgroundConfSetSubdecks(TaskData param) {\n-        Timber.d(\"doInBackgroundConfSetSubdecks\");\n-        Collection col = getCol();\n-        Object[] data = param.getObjArray();\n-        Deck deck = (Deck) data[0];\n-        DeckConfig conf = (DeckConfig) data[1];\n-        try {\n-            TreeMap<String, Long> children = col.getDecks().children(deck.getLong(\"id\"));\n-            for (long childDid : children.values()) {\n-                Deck child = col.getDecks().get(childDid);\n-                if (child.getInt(\"dyn\") == 1) {\n-                    continue;\n+    public static class ConfRemove extends Task<Void, Boolean> {\n+        private final DeckConfig conf;\n+\n+\n+        public ConfRemove(DeckConfig conf) {\n+            this.conf = conf;\n+        }\n+\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundConfRemove\");\n+            try {\n+                // Note: We do the actual removing of the options group in the main thread so that we\n+                // can ask the user to confirm if they're happy to do a full sync, and just do the resorting here\n+\n+                // When a conf is deleted, all decks using it revert to the default conf.\n+                // Cards must be reordered according to the default conf.\n+                int order = conf.getJSONObject(\"new\").getInt(\"order\");\n+                int defaultOrder = col.getDecks().getConf(1).getJSONObject(\"new\").getInt(\"order\");\n+                if (order != defaultOrder) {\n+                    conf.getJSONObject(\"new\").put(\"order\", defaultOrder);\n+                    col.getSched().resortConf(conf);\n                 }\n-                TaskData newParam = new TaskData(new Object[] { child, conf });\n-                boolean changed = doInBackgroundConfChange(newParam).getBoolean();\n-                if (!changed) {\n-                    return new TaskData(false);\n+                col.save();\n+                return true;\n+            } catch (JSONException e) {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    public static class ConfSetSubdecks extends Task<Void, Boolean> {\n+        private final Deck deck;\n+        private final DeckConfig conf;\n+\n+\n+        public ConfSetSubdecks(Deck deck, DeckConfig conf) {\n+            this.deck = deck;\n+            this.conf = conf;\n+        }\n+\n+\n+        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n+            Timber.d(\"doInBackgroundConfSetSubdecks\");\n+            try {\n+                TreeMap<String, Long> children = col.getDecks().children(deck.getLong(\"id\"));\n+                for (long childDid : children.values()) {\n+                    Deck child = col.getDecks().get(childDid);\n+                    if (child.getInt(\"dyn\") == 1) {\n+                        continue;\n+                    }\n+                    boolean changed = new ConfChange(child, conf).task(col, collectionTask);\n+                    if (!changed) {\n+                        return false;\n+                    }\n                 }\n+                return true;\n+            } catch (JSONException e) {\n+                return false;\n             }\n-            return new TaskData(true);\n-        } catch (JSONException e) {\n-            return new TaskData(false);\n         }\n     }\n \n", "next_change": {"commit": "0b869c7bcd3aacfce7587704ba03f52b993979a7", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\nindex 9ad6fad8d..c0031a9e8 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n", "chunk": "@@ -1633,6 +1645,7 @@ public class CollectionTask<ProgressListener, ProgressBackground extends Progres\n                 }\n                 return true;\n             } catch (JSONException e) {\n+                Timber.w(e);\n                 return false;\n             }\n         }\n", "next_change": {"commit": "0627af25867890d1b5194ddc36ace470c6f74628", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java b/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\ndeleted file mode 100644\nindex c0031a9e8..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java\n+++ /dev/null\n", "chunk": "@@ -1,1997 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2009 Daniel Sv\u00e4rd <daniel.svard@gmail.com>                             *\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *\n- * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-\n-package com.ichi2.async;\n-\n-import android.content.Context;\n-import android.content.res.Resources;\n-import android.os.AsyncTask;\n-import android.util.Pair;\n-\n-import com.google.gson.stream.JsonReader;\n-import com.ichi2.anki.AnkiDroidApp;\n-import com.ichi2.anki.BackupManager;\n-import com.ichi2.anki.CardBrowser;\n-import com.ichi2.anki.CardUtils;\n-import com.ichi2.anki.CollectionHelper;\n-import com.ichi2.anki.R;\n-import com.ichi2.anki.StudyOptionsFragment;\n-import com.ichi2.anki.TemporaryModel;\n-import com.ichi2.anki.exception.ConfirmModSchemaException;\n-import com.ichi2.anki.exception.ImportExportException;\n-import com.ichi2.libanki.Media;\n-import com.ichi2.libanki.Model;\n-import com.ichi2.libanki.Models;\n-import com.ichi2.libanki.Undoable;\n-import com.ichi2.libanki.WrongId;\n-import com.ichi2.libanki.sched.AbstractSched;\n-import com.ichi2.libanki.AnkiPackageExporter;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.DB;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Note;\n-import com.ichi2.libanki.Storage;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.DeckConfig;\n-import com.ichi2.libanki.Deck;\n-import com.ichi2.libanki.importer.AnkiPackageImporter;\n-\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.libanki.sched.DeckDueTreeNode;\n-import com.ichi2.libanki.sched.DeckTreeNode;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.utils.BooleanGetter;\n-import com.ichi2.utils.JSONArray;\n-import com.ichi2.utils.JSONException;\n-import com.ichi2.utils.JSONObject;\n-import com.ichi2.utils.PairWithBoolean;\n-import com.ichi2.utils.PairWithCard;\n-import com.ichi2.utils.SyncStatus;\n-import com.ichi2.utils.ThreadUtil;\n-import com.ichi2.utils.Triple;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeMap;\n-import java.util.concurrent.CancellationException;\n-import java.util.concurrent.ExecutionException;\n-\n-import org.apache.commons.compress.archivers.zip.ZipFile;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import timber.log.Timber;\n-\n-import static com.ichi2.async.TaskManager.setLatestInstance;\n-import static com.ichi2.libanki.Card.deepCopyCardArray;\n-import static com.ichi2.libanki.Collection.DismissType.BURY_CARD;\n-import static com.ichi2.libanki.Collection.DismissType.BURY_NOTE;\n-import static com.ichi2.libanki.Collection.DismissType.REPOSITION_CARDS;\n-import static com.ichi2.libanki.Collection.DismissType.RESCHEDULE_CARDS;\n-import static com.ichi2.libanki.Collection.DismissType.RESET_CARDS;\n-import static com.ichi2.libanki.Collection.DismissType.SUSPEND_NOTE;\n-import static com.ichi2.libanki.Consts.DECK_DYN;\n-import static com.ichi2.libanki.Undoable.*;\n-import static com.ichi2.utils.BooleanGetter.False;\n-import static com.ichi2.utils.BooleanGetter.True;\n-\n-/**\n- * Loading in the background, so that AnkiDroid does not look like frozen.\n- */\n-public class CollectionTask<ProgressListener, ProgressBackground extends ProgressListener, ResultListener, ResultBackground extends ResultListener> extends BaseAsyncTask<Void, ProgressBackground, ResultBackground> {\n-\n-    public abstract static class Task<ProgressBackground, ResultBackground> {\n-        protected abstract ResultBackground task(Collection col, ProgressSenderAndCancelListener<ProgressBackground> collectionTask);\n-    }\n-\n-    /**\n-     * A reference to the application context to use to fetch the current Collection object.\n-     */\n-    private Context mContext;\n-\n-    /**\n-     * Block the current thread until all CollectionTasks have finished.\n-     * @param timeoutSeconds timeout in seconds\n-     * @return whether all tasks exited successfully\n-     */\n-    @SuppressWarnings(\"UnusedReturnValue\")\n-    public static boolean waitForAllToFinish(Integer timeoutSeconds) {\n-        // HACK: This should be better - there is currently a race condition in sLatestInstance, and no means to obtain this information.\n-        // This should work in all reasonable cases given how few tasks we have concurrently blocking.\n-        boolean result;\n-        result = TaskManager.waitToFinish(timeoutSeconds / 4);\n-        ThreadUtil.sleep(10);\n-        result &= TaskManager.waitToFinish(timeoutSeconds / 4);\n-        ThreadUtil.sleep(10);\n-        result &= TaskManager.waitToFinish(timeoutSeconds / 4);\n-        ThreadUtil.sleep(10);\n-        result &= TaskManager.waitToFinish(timeoutSeconds / 4);\n-        ThreadUtil.sleep(10);\n-        Timber.i(\"Waited for all tasks to finish\");\n-        return result;\n-    }\n-\n-    /** Cancel the current task.\n-     * @return whether cancelling did occur.*/\n-    public boolean safeCancel() {\n-        try {\n-            if (getStatus() != AsyncTask.Status.FINISHED) {\n-                return cancel(true);\n-            }\n-        } catch (Exception e) {\n-            // Potentially catching SecurityException, from\n-            // Thread.interrupt from FutureTask.cancel from\n-            // AsyncTask.cancel\n-            Timber.w(e, \"Exception cancelling task\");\n-        } finally {\n-            TaskManager.removeTask(this);\n-        }\n-        return false;\n-    }\n-\n-    private Collection getCol() {\n-        return CollectionHelper.getInstance().getCol(mContext);\n-    }\n-\n-    protected Context getContext() {\n-        return mContext;\n-    }\n-\n-    private final Task<ProgressBackground, ResultBackground> mTask;\n-    public Task<ProgressBackground, ResultBackground> getTask() {\n-        return mTask;\n-    }\n-    private final TaskListener<ProgressListener, ResultListener> mListener;\n-    private CollectionTask mPreviousTask;\n-\n-\n-    protected CollectionTask(Task<ProgressBackground, ResultBackground> task, TaskListener<ProgressListener, ResultListener> listener, CollectionTask previousTask) {\n-        mTask = task;\n-        mListener = listener;\n-        mPreviousTask = previousTask;\n-        TaskManager.addTasks(this);\n-    }\n-\n-    @Override\n-    protected ResultBackground doInBackground(Void... params) {\n-        try {\n-            return actualDoInBackground();\n-        } finally {\n-            TaskManager.removeTask(this);\n-        }\n-    }\n-\n-    // This method and those that are called here are executed in a new thread\n-    protected ResultBackground actualDoInBackground() {\n-        super.doInBackground();\n-        // Wait for previous thread (if any) to finish before continuing\n-        if (mPreviousTask != null && mPreviousTask.getStatus() != AsyncTask.Status.FINISHED) {\n-            Timber.d(\"Waiting for %s to finish before starting %s\", mPreviousTask.mTask, mTask.getClass());\n-            try {\n-                mPreviousTask.get();\n-                Timber.d(\"Finished waiting for %s to finish. Status= %s\", mPreviousTask.mTask, mPreviousTask.getStatus());\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                // We have been interrupted, return immediately.\n-                Timber.d(e, \"interrupted while waiting for previous task: %s\", mPreviousTask.mTask.getClass());\n-                return null;\n-            } catch (ExecutionException e) {\n-                // Ignore failures in the previous task.\n-                Timber.e(e, \"previously running task failed with exception: %s\", mPreviousTask.mTask.getClass());\n-            } catch (CancellationException e) {\n-                // Ignore cancellation of previous task\n-                Timber.d(e, \"previously running task was cancelled: %s\", mPreviousTask.mTask.getClass());\n-            }\n-        }\n-        setLatestInstance(this);\n-        mContext = AnkiDroidApp.getInstance().getApplicationContext();\n-\n-        // Skip the task if the collection cannot be opened\n-        if ( mTask.getClass() != RepairCollectionn.class && mTask.getClass() != ImportReplace.class && CollectionHelper.getInstance().getColSafe(mContext) == null) {\n-            Timber.e(\"CollectionTask CollectionTask %s as Collection could not be opened\", mTask.getClass());\n-            return null;\n-        }\n-        // Actually execute the task now that we are at the front of the queue.\n-        return mTask.task(getCol(), this);\n-    }\n-\n-\n-    /** Delegates to the {@link TaskListener} for this task. */\n-    @Override\n-    protected void onPreExecute() {\n-        super.onPreExecute();\n-        if (mListener != null) {\n-            mListener.onPreExecute();\n-        }\n-    }\n-\n-\n-    /** Delegates to the {@link TaskListener} for this task. */\n-    @Override\n-    protected void onProgressUpdate(ProgressBackground... values) {\n-        super.onProgressUpdate(values);\n-        if (mListener != null) {\n-            mListener.onProgressUpdate(values[0]);\n-        }\n-    }\n-\n-\n-    /** Delegates to the {@link TaskListener} for this task. */\n-    @Override\n-    protected void onPostExecute(ResultBackground result) {\n-        super.onPostExecute(result);\n-        if (mListener != null) {\n-            mListener.onPostExecute(result);\n-        }\n-        Timber.d(\"enabling garbage collection of mPreviousTask...\");\n-        mPreviousTask = null;\n-    }\n-\n-    @Override\n-    protected void onCancelled(){\n-        TaskManager.removeTask(this);\n-        if (mListener != null) {\n-            mListener.onCancelled();\n-        }\n-    }\n-\n-    public static class AddNote extends Task<Integer, Boolean> {\n-        private final Note note;\n-        private final Models.AllowEmpty allowEmpty;\n-\n-\n-        public AddNote(Note note, Models.AllowEmpty allowEmpty) {\n-            this.note = note;\n-            this.allowEmpty = allowEmpty;\n-        }\n-\n-        public AddNote(Note note) {\n-            this(note, Models.AllowEmpty.ONLY_CLOZE);\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Integer> collectionTask) {\n-            Timber.d(\"doInBackgroundAddNote\");\n-            try {\n-                DB db = col.getDb();\n-                db.executeInTransaction(() -> {\n-                        int value = col.addNote(note, allowEmpty);\n-                        collectionTask.doProgress(value);\n-                    });\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundAddNote - RuntimeException on adding note\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundAddNote\");\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-\n-    public static class UpdateNote extends Task<PairWithCard<String>, BooleanGetter> {\n-        private final Card editCard;\n-        private final boolean fromReviewer;\n-        private final boolean canAccessScheduler;\n-\n-\n-        public UpdateNote(Card editCard, boolean fromReviewer, boolean canAccessScheduler) {\n-            this.editCard = editCard;\n-            this.fromReviewer = fromReviewer;\n-            this.canAccessScheduler = canAccessScheduler;\n-        }\n-\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<PairWithCard<String>> collectionTask) {\n-            Timber.d(\"doInBackgroundUpdateNote\");\n-            // Save the note\n-            AbstractSched sched = col.getSched();\n-            Note editNote = editCard.note();\n-\n-            try {\n-                col.getDb().executeInTransaction(() -> {\n-                    // TODO: undo integration\n-                    editNote.flush();\n-                    // flush card too, in case, did has been changed\n-                    editCard.flush();\n-                    if (fromReviewer) {\n-                        Card newCard;\n-                        if (col.getDecks().active().contains(editCard.getDid()) || !canAccessScheduler) {\n-                            newCard = editCard;\n-                            newCard.load();\n-                            // reload qa-cache\n-                            newCard.q(true);\n-                        } else {\n-                            newCard = sched.getCard();\n-                        }\n-                        collectionTask.doProgress(new PairWithCard<>(newCard, null)); // check: are there deleted too?\n-                    } else {\n-                        collectionTask.doProgress(new PairWithCard<>(editCard, editNote.stringTags()));\n-                    }\n-                });\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundUpdateNote - RuntimeException on updating note\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundUpdateNote\");\n-                return False;\n-            }\n-            return True;\n-        }\n-\n-        public boolean isFromReviewer() {\n-            return fromReviewer;\n-        }\n-    }\n-\n-    public static class GetCard extends Task<Card, BooleanGetter> {\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<Card> collectionTask) {\n-            AbstractSched sched = col.getSched();\n-            Timber.i(\"Obtaining card\");\n-            Card newCard = sched.getCard();\n-            if (newCard != null) {\n-                // render cards before locking database\n-                newCard._getQA(true);\n-            }\n-            collectionTask.doProgress(newCard);\n-            return True;\n-        }\n-    }\n-\n-    public static class AnswerAndGetCard extends GetCard {\n-        private final @NonNull Card oldCard;\n-        private final @Consts.BUTTON_TYPE int ease;\n-        public AnswerAndGetCard(@NonNull Card oldCard, @Consts.BUTTON_TYPE int ease) {\n-            this.oldCard = oldCard;\n-            this.ease = ease;\n-        }\n-\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<Card> collectionTask) {\n-            Timber.i(\"Answering card %d\", oldCard.getId());\n-            col.getSched().answerCard(oldCard, ease);\n-            return super.task(col, collectionTask);\n-        }\n-    }\n-\n-\n-    public static class LoadDeck extends Task<Void, List<DeckTreeNode>> {\n-        protected List<DeckTreeNode> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundLoadDeckCounts\");\n-            try {\n-                // Get due tree\n-                return col.getSched().quickDeckDueTree();\n-            } catch (RuntimeException e) {\n-                Timber.w(e, \"doInBackgroundLoadDeckCounts - error\");\n-                return null;\n-            }\n-        }\n-    }\n-\n-\n-    public static class LoadDeckCounts extends Task<Void, List<DeckDueTreeNode>> {\n-        protected List<DeckDueTreeNode> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundLoadDeckCounts\");\n-            try {\n-                // Get due tree\n-                return col.getSched().deckDueTree(collectionTask);\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");\n-                return null;\n-            }\n-        }\n-    }\n-\n-    public static class SaveCollection extends Task<Void, Void> {\n-        private final boolean syncIgnoresDatabaseModification;\n-\n-\n-        public SaveCollection(boolean syncIgnoresDatabaseModification) {\n-            this.syncIgnoresDatabaseModification = syncIgnoresDatabaseModification;\n-        }\n-\n-\n-        protected Void task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundSaveCollection\");\n-            if (col != null) {\n-                try {\n-                    if (syncIgnoresDatabaseModification) {\n-                        SyncStatus.ignoreDatabaseModification(col::save);\n-                    } else {\n-                        col.save();\n-                    }\n-                } catch (RuntimeException e) {\n-                    Timber.e(e, \"Error on saving deck in background\");\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-\n-\n-\n-    private static class UndoSuspendCard extends Undoable {\n-        private final Card suspendedCard;\n-\n-\n-        public UndoSuspendCard(Card suspendedCard) {\n-            super(Collection.DismissType.SUSPEND_CARD);\n-            this.suspendedCard = suspendedCard;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"UNDO: Suspend Card %d\", suspendedCard.getId());\n-            suspendedCard.flush(false);\n-            return suspendedCard;\n-        }\n-    }\n-\n-\n-    private static class UndoDeleteNote extends Undoable {\n-        private final Note note;\n-        private final ArrayList<Card> allCs;\n-        private final @NonNull Card card;\n-\n-\n-        public UndoDeleteNote(Note note, ArrayList<Card> allCs, @NonNull Card card) {\n-            super(Collection.DismissType.DELETE_NOTE);\n-            this.note = note;\n-            this.allCs = allCs;\n-            this.card = card;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Delete note\");\n-            ArrayList<Long> ids = new ArrayList<>(allCs.size() + 1 );\n-            note.flush(note.getMod(), false);\n-            ids.add(note.getId());\n-            for (Card c : allCs) {\n-                c.flush(false);\n-                ids.add(c.getId());\n-            }\n-            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(ids));\n-            return card;\n-        }\n-    }\n-\n-\n-    public static class DismissNote extends Task<Card, BooleanGetter> {\n-        private final Card card;\n-        private final Collection.DismissType type;\n-\n-\n-        public DismissNote(Card card, Collection.DismissType type) {\n-            this.card = card;\n-            this.type = type;\n-        }\n-\n-\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<Card> collectionTask) {\n-            AbstractSched sched = col.getSched();\n-            Note note = card.note();\n-            try {\n-                col.getDb().executeInTransaction(() -> {\n-                    sched.deferReset();\n-                    switch (type) {\n-                        case BURY_CARD:\n-                            // collect undo information\n-                            col.markUndo(revertToProvidedState(BURY_CARD, card));\n-                            // then bury\n-                            sched.buryCards(new long[] {card.getId()});\n-                            break;\n-                        case BURY_NOTE:\n-                            // collect undo information\n-                            col.markUndo(revertToProvidedState(BURY_NOTE, card));\n-                            // then bury\n-                            sched.buryNote(note.getId());\n-                            break;\n-                        case SUSPEND_CARD:\n-                            // collect undo information\n-                            Card suspendedCard = card.clone();\n-                            col.markUndo(new UndoSuspendCard(suspendedCard));\n-                            // suspend card\n-                            if (card.getQueue() == Consts.QUEUE_TYPE_SUSPENDED) {\n-                                sched.unsuspendCards(new long[] {card.getId()});\n-                            } else {\n-                                sched.suspendCards(new long[] {card.getId()});\n-                            }\n-                            break;\n-                        case SUSPEND_NOTE: {\n-                            // collect undo information\n-                            ArrayList<Card> cards = note.cards();\n-                            long[] cids = new long[cards.size()];\n-                            for (int i = 0; i < cards.size(); i++) {\n-                                cids[i] = cards.get(i).getId();\n-                            }\n-                            col.markUndo(revertToProvidedState(SUSPEND_NOTE, card));\n-                            // suspend note\n-                            sched.suspendCards(cids);\n-                            break;\n-                        }\n-\n-                        case DELETE_NOTE: {\n-                            // collect undo information\n-                            ArrayList<Card> allCs = note.cards();\n-                            col.markUndo(new UndoDeleteNote(note, allCs, card));\n-                            // delete note\n-                            col.remNotes(new long[] {note.getId()});\n-                            break;\n-                        }\n-                    }\n-                    // With sHadCardQueue set, getCard() resets the scheduler prior to getting the next card\n-                    collectionTask.doProgress(col.getSched().getCard());\n-                });\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundDismissNote - RuntimeException on dismissing note, dismiss type %s\", type);\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundDismissNote\");\n-                return False;\n-            }\n-            return True;\n-        }\n-    }\n-\n-\n-    protected static class UndoSuspendCardMulti extends Undoable {\n-        private final Card[] cards;\n-        private final boolean[] originalSuspended;\n-\n-        /** @param hasUnsuspended  whether there were any unsuspended card (in which card the action was \"Suspend\",\n-         *                          otherwise the action was \"Unsuspend\")  */\n-        public UndoSuspendCardMulti(Card[] cards, boolean[] originalSuspended,\n-                                    boolean hasUnsuspended) {\n-            super((hasUnsuspended) ? Collection.DismissType.SUSPEND_CARD_MULTI: Collection.DismissType.UNSUSPEND_CARD_MULTI);\n-            this.cards = cards;\n-            this.originalSuspended = originalSuspended;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Suspend multiple cards\");\n-            int nbOfCards = cards.length;\n-            List<Long> toSuspendIds = new ArrayList<>(nbOfCards);\n-            List<Long> toUnsuspendIds = new ArrayList<>(nbOfCards);\n-            for (int i = 0; i < nbOfCards; i++) {\n-                Card card = cards[i];\n-                if (originalSuspended[i]) {\n-                    toSuspendIds.add(card.getId());\n-                } else {\n-                    toUnsuspendIds.add(card.getId());\n-                }\n-            }\n-\n-            // unboxing\n-            long[] toSuspendIdsArray = new long[toSuspendIds.size()];\n-            long[] toUnsuspendIdsArray = new long[toUnsuspendIds.size()];\n-            for (int i = 0; i < toSuspendIds.size(); i++) {\n-                toSuspendIdsArray[i] = toSuspendIds.get(i);\n-            }\n-            for (int i = 0; i < toUnsuspendIds.size(); i++) {\n-                toUnsuspendIdsArray[i] = toUnsuspendIds.get(i);\n-            }\n-\n-            col.getSched().suspendCards(toSuspendIdsArray);\n-            col.getSched().unsuspendCards(toUnsuspendIdsArray);\n-\n-            return null;  // don't fetch new card\n-\n-        }\n-    }\n-\n-\n-    private static class UndoDeleteNoteMulti extends Undoable {\n-        private final Note[] notesArr;\n-        private final List<Card> allCards;\n-\n-\n-        public UndoDeleteNoteMulti(Note[] notesArr, List<Card> allCards) {\n-            super(Collection.DismissType.DELETE_NOTE_MULTI);\n-            this.notesArr = notesArr;\n-            this.allCards = allCards;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Delete notes\");\n-            // undo all of these at once instead of one-by-one\n-            ArrayList<Long> ids = new ArrayList<>(notesArr.length + allCards.size());\n-            for (Note n : notesArr) {\n-                n.flush(n.getMod(), false);\n-                ids.add(n.getId());\n-            }\n-            for (Card c : allCards) {\n-                c.flush(false);\n-                ids.add(c.getId());\n-            }\n-            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(ids));\n-            return null;  // don't fetch new card\n-\n-        }\n-    }\n-\n-    \n-    private static class UndoChangeDeckMulti extends Undoable {\n-        private final Card[] cards;\n-        private final long[] originalDids;\n-\n-\n-        public UndoChangeDeckMulti(Card[] cards, long[] originalDids) {\n-            super(Collection.DismissType.CHANGE_DECK_MULTI);\n-            this.cards = cards;\n-            this.originalDids = originalDids;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Change Decks\");\n-            // move cards to original deck\n-            for (int i = 0; i < cards.length; i++) {\n-                Card card = cards[i];\n-                card.load();\n-                card.setDid(originalDids[i]);\n-                Note note = card.note();\n-                note.flush();\n-                card.flush();\n-            }\n-            return null;  // don't fetch new card\n-\n-        }\n-    }\n-\n-    private static class UndoMarkNoteMulti extends Undoable {\n-        private final List<Note> originalMarked;\n-        private final List<Note> originalUnmarked;\n-\n-        /** @param hasUnmarked whether there were any unmarked card (in which card the action was \"mark\",\n-         *                      otherwise the action was \"Unmark\")  */\n-        public UndoMarkNoteMulti(List<Note> originalMarked, List<Note> originalUnmarked, boolean hasUnmarked) {\n-            super((hasUnmarked) ? Collection.DismissType.MARK_NOTE_MULTI : Collection.DismissType.UNMARK_NOTE_MULTI);\n-            this.originalMarked = originalMarked;\n-            this.originalUnmarked = originalUnmarked;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undo: Mark notes\");\n-            CardUtils.markAll(originalMarked, true);\n-            CardUtils.markAll(originalUnmarked, false);\n-            return null;  // don't fetch new card\n-        }\n-    }\n-\n-\n-    private static class UndoRepositionRescheduleResetCards extends Undoable {\n-        private final Card[] cards_copied;\n-\n-\n-        public UndoRepositionRescheduleResetCards(Collection.DismissType type, Card[] cards_copied) {\n-            super(type);\n-            this.cards_copied = cards_copied;\n-        }\n-\n-\n-        public @Nullable Card undo(@NonNull Collection col) {\n-            Timber.i(\"Undoing action of type %s on %d cards\", getDismissType(), cards_copied.length);\n-            for (Card card : cards_copied) {\n-                card.flush(false);\n-            }\n-            // /* card schedule change undone, reset and get\n-            // new card */\n-            Timber.d(\"Single card non-review change undo succeeded\");\n-            col.reset();\n-            return col.getSched().getCard();\n-        }\n-    }\n-\n-    private static abstract class DismissNotes<Progress> extends Task<Progress, PairWithBoolean<Card[]>> {\n-        protected final List<Long> mCardIds;\n-\n-        public DismissNotes(List<Long> cardIds) {\n-            this.mCardIds = cardIds;\n-        }\n-\n-        protected PairWithBoolean<Card[]> task(Collection col, ProgressSenderAndCancelListener<Progress> collectionTask) {\n-            // query cards\n-            Card[] cards = new Card[mCardIds.size()];\n-            for (int i = 0; i < mCardIds.size(); i++) {\n-                cards[i] = col.getCard(mCardIds.get(i));\n-            }\n-\n-            try {\n-                col.getDb().getDatabase().beginTransaction();\n-                try {\n-                    PairWithBoolean<Card[]> ret = actualTask(col, collectionTask, cards);\n-                    if (ret != null) {\n-                        return ret;\n-                    }\n-                    col.getDb().getDatabase().setTransactionSuccessful();\n-                } finally {\n-                    DB.safeEndInTransaction(col.getDb());\n-                }\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundSuspendCard - RuntimeException on suspending card\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundSuspendCard\");\n-                return new PairWithBoolean<>(false, null);\n-            }\n-            // pass cards back so more actions can be performed by the caller\n-            // (querying the cards again is unnecessarily expensive)\n-            return new PairWithBoolean<>(true, cards);\n-        }\n-\n-        /**\n-         * @param col The collection\n-         * @param collectionTask, where to send progress and listen for cancellation\n-         * @param cards Cards to which the task should be applied\n-         * @return value to return, or null if `task` should deal with it directly.\n-         */\n-        protected abstract PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Progress> collectionTask, Card[] cards);\n-    }\n-\n-    public static class SuspendCardMulti extends DismissNotes<Void> {\n-        public SuspendCardMulti(List<Long> cardIds) {\n-            super(cardIds);\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Void> collectionTask, Card[] cards) {\n-            AbstractSched sched = col.getSched();\n-            // collect undo information\n-            long[] cids = new long[cards.length];\n-            boolean[] originalSuspended = new boolean[cards.length];\n-            boolean hasUnsuspended = false;\n-            for (int i = 0; i < cards.length; i++) {\n-                Card card = cards[i];\n-                cids[i] = card.getId();\n-                if (card.getQueue() != Consts.QUEUE_TYPE_SUSPENDED) {\n-                    hasUnsuspended = true;\n-                    originalSuspended[i] = false;\n-                } else {\n-                    originalSuspended[i] = true;\n-                }\n-            }\n-\n-            // if at least one card is unsuspended -> suspend all\n-            // otherwise unsuspend all\n-            if (hasUnsuspended) {\n-                sched.suspendCards(cids);\n-            } else {\n-                sched.unsuspendCards(cids);\n-            }\n-\n-            // mark undo for all at once\n-            col.markUndo(new UndoSuspendCardMulti(cards, originalSuspended, hasUnsuspended));\n-\n-            // reload cards because they'll be passed back to caller\n-            for (Card c : cards) {\n-                c.load();\n-            }\n-\n-            sched.deferReset();\n-            return null;\n-        }\n-    }\n-\n-    public static class Flag extends DismissNotes<Void> {\n-        private final int mFlag;\n-\n-        public Flag(List<Long> cardIds, int flag) {\n-            super(cardIds);\n-            mFlag = flag;\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Void> collectionTask, Card[] cards) {\n-            col.setUserFlag(mFlag, mCardIds);\n-            for (Card c : cards) {\n-                c.load();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class MarkNoteMulti extends DismissNotes<Void> {\n-        public MarkNoteMulti(List<Long> cardIds) {\n-            super(cardIds);\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Void> collectionTask, Card[] cards) {\n-            Set<Note> notes = CardUtils.getNotes(Arrays.asList(cards));\n-            // collect undo information\n-            List<Note> originalMarked = new ArrayList<>();\n-            List<Note> originalUnmarked = new ArrayList<>();\n-\n-            for (Note n : notes) {\n-                if (n.hasTag(\"marked\"))\n-                    originalMarked.add(n);\n-                else\n-                    originalUnmarked.add(n);\n-            }\n-\n-            boolean hasUnmarked = !originalUnmarked.isEmpty();\n-            CardUtils.markAll(new ArrayList<>(notes), hasUnmarked);\n-\n-            Undoable markNoteMulti = new UndoMarkNoteMulti(originalMarked, originalUnmarked, hasUnmarked);\n-            // mark undo for all at once\n-            col.markUndo(new UndoMarkNoteMulti(originalMarked, originalUnmarked, hasUnmarked));\n-\n-            // reload cards because they'll be passed back to caller\n-            for (Card c : cards) {\n-                c.load();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class DeleteNoteMulti extends DismissNotes<Card[]> {\n-\n-        public DeleteNoteMulti(List<Long> cardIds) {\n-            super(cardIds);\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Card[]> collectionTask, Card[] cards) {\n-            AbstractSched sched = col.getSched();\n-            // list of all ids to pass to remNotes method.\n-            // Need Set (-> unique) so we don't pass duplicates to col.remNotes()\n-            Set<Note> notes = CardUtils.getNotes(Arrays.asList(cards));\n-            List<Card> allCards = CardUtils.getAllCards(notes);\n-            // delete note\n-            long[] uniqueNoteIds = new long[notes.size()];\n-            Note[] notesArr = notes.toArray(new Note[notes.size()]);\n-            int count = 0;\n-            for (Note note : notes) {\n-                uniqueNoteIds[count] = note.getId();\n-                count++;\n-            }\n-\n-\n-\n-            col.markUndo(new UndoDeleteNoteMulti(notesArr, allCards));\n-\n-            col.remNotes(uniqueNoteIds);\n-            sched.deferReset();\n-            // pass back all cards because they can't be retrieved anymore by the caller (since the note is deleted)\n-            collectionTask.doProgress(allCards.toArray(new Card[allCards.size()]));\n-            return null;\n-        }\n-    }\n-\n-    public static class ChangeDeckMulti extends DismissNotes<Void> {\n-        private final long mNewDid;\n-        public ChangeDeckMulti(List<Long> cardIds, long newDid) {\n-            super(cardIds);\n-            mNewDid = newDid;\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Void> collectionTask, Card[] cards) {\n-            Timber.i(\"Changing %d cards to deck: '%d'\", cards.length, mNewDid);\n-            Deck deckData = col.getDecks().get(mNewDid);\n-\n-            if (Decks.isDynamic(deckData)) {\n-                //#5932 - can't change to a dynamic deck. Use \"Rebuild\"\n-                Timber.w(\"Attempted to move to dynamic deck. Cancelling task.\");\n-                return new PairWithBoolean<>(false, null);\n-            }\n-\n-            //Confirm that the deck exists (and is not the default)\n-            try {\n-                long actualId = deckData.getLong(\"id\");\n-                if (actualId != mNewDid) {\n-                    Timber.w(\"Attempted to move to deck %d, but got %d\", mNewDid, actualId);\n-                    return new PairWithBoolean<>(false, null);\n-                }\n-            } catch (Exception e) {\n-                Timber.e(e, \"failed to check deck\");\n-                return new PairWithBoolean<>(false, null);\n-            }\n-\n-            long[] changedCardIds = new long[cards.length];\n-            for (int i = 0; i < cards.length; i++) {\n-                changedCardIds[i] = cards[i].getId();\n-            }\n-            col.getSched().remFromDyn(changedCardIds);\n-\n-            long[] originalDids = new long[cards.length];\n-\n-            for (int i = 0; i < cards.length; i++) {\n-                Card card = cards[i];\n-                card.load();\n-                // save original did for undo\n-                originalDids[i] = card.getDid();\n-                // then set the card ID to the new deck\n-                card.setDid(mNewDid);\n-                Note note = card.note();\n-                note.flush();\n-                // flush card too, in case, did has been changed\n-                card.flush();\n-            }\n-\n-            Undoable changeDeckMulti = new UndoChangeDeckMulti(cards, originalDids);\n-            // mark undo for all at once\n-            col.markUndo(changeDeckMulti);\n-            return null;\n-        }\n-    }\n-\n-    private abstract static class RescheduleRepositionReset extends DismissNotes<Card> {\n-        private final Collection.DismissType mType;\n-        public RescheduleRepositionReset(List<Long> cardIds, Collection.DismissType type) {\n-            super(cardIds);\n-            mType = type;\n-        }\n-\n-        protected PairWithBoolean<Card[]> actualTask(Collection col, ProgressSenderAndCancelListener<Card> collectionTask, Card[] cards) {\n-            AbstractSched sched = col.getSched();\n-            // collect undo information, sensitive to memory pressure, same for all 3 cases\n-            try {\n-                Timber.d(\"Saving undo information of type %s on %d cards\", mType, cards.length);\n-                Card[] cards_copied = deepCopyCardArray(cards, collectionTask);\n-                Undoable repositionRescheduleResetCards = new UndoRepositionRescheduleResetCards(mType, cards_copied);\n-                col.markUndo(repositionRescheduleResetCards);\n-            } catch (CancellationException ce) {\n-                Timber.i(ce, \"Cancelled while handling type %s, skipping undo\", mType);\n-            }\n-            actualActualTask(sched);\n-            // In all cases schedule a new card so Reviewer doesn't sit on the old one\n-            col.reset();\n-            collectionTask.doProgress(sched.getCard());\n-            return null;\n-        }\n-\n-        protected abstract void actualActualTask(AbstractSched sched);\n-    }\n-\n-    public static class RescheduleCards extends RescheduleRepositionReset {\n-        private final int mSchedule;\n-        public RescheduleCards(List<Long> cardIds, int schedule) {\n-            super(cardIds, RESCHEDULE_CARDS);\n-            this.mSchedule = schedule;\n-        }\n-\n-        @Override\n-        protected void actualActualTask(AbstractSched sched) {\n-            sched.reschedCards(mCardIds, mSchedule, mSchedule);\n-        }\n-    }\n-\n-    public static class RepositionCards extends RescheduleRepositionReset {\n-        private final int mPosition;\n-        public RepositionCards(List<Long> cardIds, int position) {\n-            super(cardIds, REPOSITION_CARDS);\n-            this.mPosition = position;\n-        }\n-\n-        @Override\n-        protected void actualActualTask(AbstractSched sched) {\n-            sched.sortCards(mCardIds, mPosition, 1, false, true);\n-        }\n-    }\n-\n-    public static class ResetCards extends RescheduleRepositionReset {\n-        public ResetCards(List<Long> cardIds) {\n-            super(cardIds, RESET_CARDS);\n-        }\n-\n-        @Override\n-        protected void actualActualTask(AbstractSched sched) {\n-            sched.forgetCards(mCardIds);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public static Card nonTaskUndo(Collection col) {\n-        AbstractSched sched = col.getSched();\n-        Card card = col.undo();\n-        if (card == null) {\n-            /* multi-card action undone, no action to take here */\n-            Timber.d(\"Multi-select undo succeeded\");\n-        } else {\n-            // cid is actually a card id.\n-            // a review was undone,\n-            /* card review undone, set up to review that card again */\n-            Timber.d(\"Single card review undo succeeded\");\n-            card.startTimer();\n-            col.reset();\n-            sched.deferReset(card);\n-        }\n-        return card;\n-    }\n-\n-    public static class Undo extends Task<Card, BooleanGetter> {\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<Card> collectionTask) {\n-            try {\n-                col.getDb().executeInTransaction(() -> {\n-                    Card card = nonTaskUndo(col);\n-                    collectionTask.doProgress(card);\n-                });\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundUndo - RuntimeException on undoing\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundUndo\");\n-                return False;\n-            }\n-            return True;\n-        }\n-    }\n-\n-    /**\n-     * A class allowing to send partial search result to the browser to display while the search ends\n-     */\n-    public static class PartialSearch implements ProgressSenderAndCancelListener<List<Long>> {\n-        private final List<CardBrowser.CardCache> mCards;\n-        private final int mColumn1Index, mColumn2Index;\n-        private final int mNumCardsToRender;\n-        private final ProgressSenderAndCancelListener<List<CardBrowser.CardCache>> mCollectionTask;\n-        private final Collection mCol;\n-\n-        public PartialSearch(List<CardBrowser.CardCache> cards, int columnIndex1, int columnIndex2, int numCardsToRender, ProgressSenderAndCancelListener<List<CardBrowser.CardCache>> collectionTask, Collection col) {\n-            mCards = cards;\n-            mColumn1Index = columnIndex1;\n-            mColumn2Index = columnIndex2;\n-            mNumCardsToRender = numCardsToRender;\n-            mCollectionTask = collectionTask;\n-            mCol = col;\n-        }\n-\n-        @Override\n-        public boolean isCancelled() {\n-            return mCollectionTask.isCancelled();\n-        }\n-\n-\n-        /**\n-         * @param cards Card ids to display in the browser. It is assumed that it is as least as long as mCards, and that\n-         *             mCards[i].cid = cards[i].  It add the cards in cards after `mPosition` to mCards\n-         */\n-        public void add(@NonNull List<Long> cards) {\n-            while (mCards.size() < cards.size()) {\n-                mCards.add(new CardBrowser.CardCache(cards.get(mCards.size()), mCol, mCards.size()));\n-            }\n-        }\n-\n-\n-        @Override\n-        public void doProgress(@NonNull List<Long> value) {\n-            add(value);\n-            for (CardBrowser.CardCache card : mCards) {\n-                if (isCancelled()) {\n-                    Timber.d(\"doInBackgroundSearchCards was cancelled so return\");\n-                    return;\n-                }\n-                card.load(false, mColumn1Index, mColumn2Index);\n-            }\n-            mCollectionTask.doProgress(mCards);\n-        }\n-\n-        public int getNumCardsToRender() {\n-            return mNumCardsToRender;\n-        }\n-    }\n-\n-\n-    public static class SearchCards extends Task<List<CardBrowser.CardCache>, List<CardBrowser.CardCache>> {\n-        private final String query;\n-        private final boolean order;\n-        private final int numCardsToRender;\n-        private final int column1Index;\n-        private final int column2Index;\n-\n-\n-        public SearchCards(String query, boolean order, int numCardsToRender, int column1Index, int column2Index) {\n-            this.query = query;\n-            this.order = order;\n-            this.numCardsToRender = numCardsToRender;\n-            this.column1Index = column1Index;\n-            this.column2Index = column2Index;\n-        }\n-\n-\n-        protected List<CardBrowser.CardCache> task(Collection col, ProgressSenderAndCancelListener<List<CardBrowser.CardCache>> collectionTask) {\n-            Timber.d(\"doInBackgroundSearchCards\");\n-            if (collectionTask.isCancelled()) {\n-                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-                return null;\n-            }\n-            List<CardBrowser.CardCache> searchResult = new ArrayList<>();\n-            List<Long> searchResult_ = col.findCards(query, order, new PartialSearch(searchResult, column1Index, column2Index, numCardsToRender, collectionTask, col));\n-            Timber.d(\"The search found %d cards\", searchResult_.size());\n-            int position = 0;\n-            for (Long cid : searchResult_) {\n-                CardBrowser.CardCache card = new CardBrowser.CardCache(cid, col, position++);\n-                searchResult.add(card);\n-            }\n-            // Render the first few items\n-            for (int i = 0; i < Math.min(numCardsToRender, searchResult.size()); i++) {\n-                if (collectionTask.isCancelled()) {\n-                    Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-                    return null;\n-                }\n-                searchResult.get(i).load(false, column1Index, column2Index);\n-            }\n-            // Finish off the task\n-            if (collectionTask.isCancelled()) {\n-                Timber.d(\"doInBackgroundSearchCards was cancelled so return null\");\n-                return null;\n-            } else {\n-                return searchResult;\n-            }\n-        }\n-    }\n-\n-\n-    public static class RenderBrowserQA extends Task<Integer, Pair<CardBrowser.CardCollection<CardBrowser.CardCache>, List<Long>>> {\n-        private final CardBrowser.CardCollection<CardBrowser.CardCache> cards;\n-        private final Integer startPos;\n-        private final Integer n;\n-        private final int column1Index;\n-        private final int column2Index;\n-\n-\n-        public RenderBrowserQA(CardBrowser.CardCollection<CardBrowser.CardCache> cards, Integer mStartPos, Integer n, int column1Index, int column2Index) {\n-            this.cards = cards;\n-            this.startPos = mStartPos;\n-            this.n = n;\n-            this.column1Index = column1Index;\n-            this.column2Index = column2Index;\n-        }\n-\n-\n-        protected Pair<CardBrowser.CardCollection<CardBrowser.CardCache>, List<Long>> task(Collection col, ProgressSenderAndCancelListener<Integer> collectionTask) {\n-            Timber.d(\"doInBackgroundRenderBrowserQA\");\n-\n-            List<Long> invalidCardIds = new ArrayList<>();\n-            // for each specified card in the browser list\n-            for (int i = startPos; i < startPos + n; i++) {\n-                // Stop if cancelled\n-                if (collectionTask.isCancelled()) {\n-                    Timber.d(\"doInBackgroundRenderBrowserQA was aborted\");\n-                    return null;\n-                }\n-                if (i < 0 || i >= cards.size()) {\n-                    continue;\n-                }\n-                CardBrowser.CardCache card;\n-                try {\n-                    card = cards.get(i);\n-                }\n-                catch (IndexOutOfBoundsException e) {\n-                    //even though we test against card.size() above, there's still a race condition\n-                    //We might be able to optimise this to return here. Logically if we're past the end of the collection,\n-                    //we won't reach any more cards.\n-                    continue;\n-                }\n-                if (card.isLoaded()) {\n-                    //We've already rendered the answer, we don't need to do it again.\n-                    continue;\n-                }\n-                // Extract card item\n-                try {\n-                    // Ensure that card still exists.\n-                    card.getCard();\n-                } catch (WrongId e) {\n-                    //#5891 - card can be inconsistent between the deck browser screen and the collection.\n-                    //Realistically, we can skip any exception as it's a rendering task which should not kill the\n-                    //process\n-                    long cardId = card.getId();\n-                    Timber.e(e, \"Could not process card '%d' - skipping and removing from sight\", cardId);\n-                    invalidCardIds.add(cardId);\n-                    continue;\n-                }\n-                // Update item\n-                card.load(false, column1Index, column2Index);\n-                float progress = (float) i / n * 100;\n-                collectionTask.doProgress((int) progress);\n-            }\n-            return new Pair<>(cards, invalidCardIds);\n-        }\n-    }\n-\n-    public static class CheckDatabase extends Task<String, Pair<Boolean, Collection.CheckDatabaseResult>> {\n-    protected Pair<Boolean, Collection.CheckDatabaseResult> task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n-        Timber.d(\"doInBackgroundCheckDatabase\");\n-        // Don't proceed if collection closed\n-        if (col == null) {\n-            Timber.e(\"doInBackgroundCheckDatabase :: supplied collection was null\");\n-            return new Pair<>(false, null);\n-        }\n-\n-        Collection.CheckDatabaseResult result = col.fixIntegrity(new TaskManager.ProgressCallback(collectionTask, AnkiDroidApp.getAppResources()));\n-        if (result.getFailed()) {\n-            //we can fail due to a locked database, which requires knowledge of the failure.\n-            return new Pair<>(false, result);\n-        } else {\n-            // Close the collection and we restart the app to reload\n-            CollectionHelper.getInstance().closeCollection(true, \"Check Database Completed\");\n-            return new Pair<>(true, result);\n-        }\n-    }\n-    }\n-\n-\n-    public static class RepairCollectionn extends Task<Void, Boolean> {\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundRepairCollection\");\n-            if (col != null) {\n-                Timber.i(\"RepairCollection: Closing collection\");\n-                col.close(false);\n-            }\n-            return BackupManager.repairCollection(col);\n-        }\n-    }\n-\n-\n-    public static class UpdateValuesFromDeck extends Task<Void, StudyOptionsFragment.DeckStudyData> {\n-        private final boolean reset;\n-\n-\n-        public UpdateValuesFromDeck(boolean reset) {\n-            this.reset = reset;\n-        }\n-\n-\n-        public StudyOptionsFragment.DeckStudyData task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundUpdateValuesFromDeck\");\n-            try {\n-                AbstractSched sched = col.getSched();\n-                if (reset) {\n-                    // reset actually required because of counts, which is used in getCollectionTaskListener\n-                    sched.resetCounts();\n-                }\n-                Counts counts = sched.counts();\n-                int totalNewCount = sched.totalNewForCurrentDeck();\n-                int totalCount = sched.cardCount();\n-                return new StudyOptionsFragment.DeckStudyData(counts.getNew(), counts.getLrn(), counts.getRev(), totalNewCount,\n-                        totalCount, sched.eta(counts));\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundUpdateValuesFromDeck - an error occurred\");\n-                return null;\n-            }\n-        }\n-    }\n-\n-\n-    public static class DeleteDeck extends Task<Void, int[]> {\n-        private final long did;\n-\n-        public DeleteDeck(long did) {\n-            this.did = did;\n-        }\n-\n-        protected int[] task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundDeleteDeck\");\n-            col.getDecks().rem(did, true);\n-            // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n-            col.clearUndo();\n-            return null;\n-        }\n-    }\n-\n-\n-    public static class RebuildCram extends Task<Void, StudyOptionsFragment.DeckStudyData> {\n-        protected StudyOptionsFragment.DeckStudyData task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundRebuildCram\");\n-            col.getSched().rebuildDyn(col.getDecks().selected());\n-            return new UpdateValuesFromDeck(true).task(col, collectionTask);\n-        }\n-    }\n-\n-    public static class EmptyCram extends Task<Void, StudyOptionsFragment.DeckStudyData> {\n-        protected StudyOptionsFragment.DeckStudyData task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundEmptyCram\");\n-            col.getSched().emptyDyn(col.getDecks().selected());\n-            return new UpdateValuesFromDeck(true).task(col, collectionTask);\n-        }\n-    }\n-\n-    public static class ImportAdd extends Task<String, Triple<AnkiPackageImporter, Boolean, String>> {\n-        private final String path;\n-\n-\n-        public ImportAdd(String path) {\n-            this.path = path;\n-        }\n-\n-\n-        protected Triple<AnkiPackageImporter, Boolean, String> task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n-            Timber.d(\"doInBackgroundImportAdd\");\n-            Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n-            AnkiPackageImporter imp = new AnkiPackageImporter(col, path);\n-            imp.setProgressCallback(new TaskManager.ProgressCallback(collectionTask, res));\n-            try {\n-                imp.run();\n-            } catch (ImportExportException e) {\n-                Timber.w(e);\n-                return new Triple(null, true, e.getMessage());\n-            }\n-            return new Triple<>(imp, false, null);\n-        }\n-    }\n-\n-\n-    public static class ImportReplace extends Task<String, BooleanGetter> {\n-        private final String path;\n-\n-\n-        public ImportReplace(String path) {\n-            this.path = path;\n-        }\n-\n-\n-        protected BooleanGetter task(Collection col, ProgressSenderAndCancelListener<String> collectionTask) {\n-            Timber.d(\"doInBackgroundImportReplace\");\n-            Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();\n-            Context context = col.getContext();\n-\n-            // extract the deck from the zip file\n-            String colPath = CollectionHelper.getCollectionPath(context);\n-            File dir = new File(new File(colPath).getParentFile(), \"tmpzip\");\n-            if (dir.exists()) {\n-                BackupManager.removeDir(dir);\n-            }\n-\n-            // from anki2.py\n-            String colname = \"collection.anki21\";\n-            ZipFile zip;\n-            try {\n-                zip = new ZipFile(new File(path));\n-            } catch (IOException e) {\n-                Timber.e(e, \"doInBackgroundImportReplace - Error while unzipping\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace0\");\n-                return False;\n-            }\n-            try {\n-                // v2 scheduler?\n-                if (zip.getEntry(colname) == null) {\n-                    colname = CollectionHelper.COLLECTION_FILENAME;\n-                }\n-                Utils.unzipFiles(zip, dir.getAbsolutePath(), new String[] {colname, \"media\"}, null);\n-            } catch (IOException e) {\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - unzip\");\n-                return False;\n-            }\n-            String colFile = new File(dir, colname).getAbsolutePath();\n-            if (!(new File(colFile)).exists()) {\n-                return False;\n-            }\n-\n-            Collection tmpCol = null;\n-            try {\n-                tmpCol = Storage.Collection(context, colFile);\n-                if (!tmpCol.validCollection()) {\n-                    tmpCol.close();\n-                    return False;\n-                }\n-            } catch (Exception e) {\n-                Timber.e(\"Error opening new collection file... probably it's invalid\");\n-                try {\n-                    tmpCol.close();\n-                } catch (Exception e2) {\n-                    Timber.w(e2);\n-                    // do nothing\n-                }\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace - open col\");\n-                return False;\n-            } finally {\n-                if (tmpCol != null) {\n-                    tmpCol.close();\n-                }\n-            }\n-\n-            collectionTask.doProgress(res.getString(R.string.importing_collection));\n-\n-            try {\n-                CollectionHelper.getInstance().getCol(context);\n-                // unload collection and trigger a backup\n-                Time time = CollectionHelper.getInstance().getTimeSafe(context);\n-                CollectionHelper.getInstance().closeCollection(true, \"Importing new collection\");\n-                CollectionHelper.getInstance().lockCollection();\n-                BackupManager.performBackupInBackground(colPath, true, time);\n-            } catch (Exception e) {\n-                Timber.w(e);\n-            }\n-            // overwrite collection\n-            File f = new File(colFile);\n-            if (!f.renameTo(new File(colPath))) {\n-                // Exit early if this didn't work\n-                return False;\n-            }\n-            int addedCount = -1;\n-            try {\n-                CollectionHelper.getInstance().unlockCollection();\n-\n-                // because users don't have a backup of media, it's safer to import new\n-                // data and rely on them running a media db check to get rid of any\n-                // unwanted media. in the future we might also want to duplicate this step\n-                // import media\n-                HashMap<String, String> nameToNum = new HashMap<>();\n-                HashMap<String, String> numToName = new HashMap<>();\n-                File mediaMapFile = new File(dir.getAbsolutePath(), \"media\");\n-                if (mediaMapFile.exists()) {\n-                    JsonReader jr = new JsonReader(new FileReader(mediaMapFile));\n-                    jr.beginObject();\n-                    String name;\n-                    String num;\n-                    while (jr.hasNext()) {\n-                        num = jr.nextName();\n-                        name = jr.nextString();\n-                        nameToNum.put(name, num);\n-                        numToName.put(num, name);\n-                    }\n-                    jr.endObject();\n-                    jr.close();\n-                }\n-                String mediaDir = Media.getCollectionMediaPath(colPath);\n-                int total = nameToNum.size();\n-                int i = 0;\n-                for (Map.Entry<String, String> entry : nameToNum.entrySet()) {\n-                    String file = entry.getKey();\n-                    String c = entry.getValue();\n-                    File of = new File(mediaDir, file);\n-                    if (!of.exists()) {\n-                        Utils.unzipFiles(zip, mediaDir, new String[] {c}, numToName);\n-                    }\n-                    ++i;\n-                    collectionTask.doProgress(res.getString(R.string.import_media_count, (i + 1) * 100 / total));\n-                }\n-                zip.close();\n-                // delete tmp dir\n-                BackupManager.removeDir(dir);\n-                return True;\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundImportReplace - RuntimeException\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace1\");\n-                return False;\n-            } catch (FileNotFoundException e) {\n-                Timber.e(e, \"doInBackgroundImportReplace - FileNotFoundException\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace2\");\n-                return False;\n-            } catch (IOException e) {\n-                Timber.e(e, \"doInBackgroundImportReplace - IOException\");\n-                AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundImportReplace3\");\n-                return False;\n-            }\n-        }\n-    }\n-\n-\n-    public static class ExportApkg extends Task<Void, Pair<Boolean, String>> {\n-        private final String apkgPath;\n-        private final Long did;\n-        private final Boolean includeSched;\n-        private final Boolean includeMedia;\n-\n-\n-        public ExportApkg(String apkgPath, Long did, Boolean includeSched, Boolean includeMedia) {\n-            this.apkgPath = apkgPath;\n-            this.did = did;\n-            this.includeSched = includeSched;\n-            this.includeMedia = includeMedia;\n-        }\n-\n-\n-        protected Pair<Boolean, String> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundExportApkg\");\n-\n-            try {\n-                AnkiPackageExporter exporter = new AnkiPackageExporter(col, did, includeSched, includeMedia);\n-                exporter.exportInto(apkgPath, col.getContext());\n-            } catch (FileNotFoundException e) {\n-                Timber.e(e, \"FileNotFoundException in doInBackgroundExportApkg\");\n-                return new Pair<>(false, null);\n-            } catch (IOException e) {\n-                Timber.e(e, \"IOException in doInBackgroundExportApkg\");\n-                return new Pair<>(false, null);\n-            } catch (JSONException e) {\n-                Timber.e(e, \"JSOnException in doInBackgroundExportApkg\");\n-                return new Pair<>(false, null);\n-            } catch (ImportExportException e) {\n-                Timber.e(e, \"ImportExportException in doInBackgroundExportApkg\");\n-                return new Pair<>(true, e.getMessage());\n-            }\n-            return new Pair<>(false, apkgPath);\n-        }\n-    }\n-\n-\n-    public static class Reorder extends Task<Void, Boolean> {\n-        private final DeckConfig conf;\n-\n-\n-        public Reorder(DeckConfig conf) {\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundReorder\");\n-            col.getSched().resortConf(conf);\n-            return true;\n-        }\n-    }\n-\n-\n-    public static class ConfChange extends Task<Void, Boolean> {\n-        private final Deck deck;\n-        private final DeckConfig conf;\n-\n-\n-        public ConfChange(Deck deck, DeckConfig conf) {\n-            this.deck = deck;\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundConfChange\");\n-            try {\n-                long newConfId = conf.getLong(\"id\");\n-                // If new config has a different sorting order, reorder the cards\n-                int oldOrder = col.getDecks().getConf(deck.getLong(\"conf\")).getJSONObject(\"new\").getInt(\"order\");\n-                int newOrder = col.getDecks().getConf(newConfId).getJSONObject(\"new\").getInt(\"order\");\n-                if (oldOrder != newOrder) {\n-                    switch (newOrder) {\n-                        case 0:\n-                            col.getSched().randomizeCards(deck.getLong(\"id\"));\n-                            break;\n-                        case 1:\n-                            col.getSched().orderCards(deck.getLong(\"id\"));\n-                            break;\n-                    }\n-                }\n-                col.getDecks().setConf(deck, newConfId);\n-                col.save();\n-                return true;\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public static class ConfReset extends Task<Void, Boolean> {\n-        private final DeckConfig conf;\n-\n-\n-        public ConfReset(DeckConfig conf) {\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundConfReset\");\n-            col.getDecks().restoreToDefault(conf);\n-            col.save();\n-            return null;\n-        }\n-    }\n-\n-\n-    public static class ConfRemove extends Task<Void, Boolean> {\n-        private final DeckConfig conf;\n-\n-\n-        public ConfRemove(DeckConfig conf) {\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundConfRemove\");\n-            try {\n-                // Note: We do the actual removing of the options group in the main thread so that we\n-                // can ask the user to confirm if they're happy to do a full sync, and just do the resorting here\n-\n-                // When a conf is deleted, all decks using it revert to the default conf.\n-                // Cards must be reordered according to the default conf.\n-                int order = conf.getJSONObject(\"new\").getInt(\"order\");\n-                int defaultOrder = col.getDecks().getConf(1).getJSONObject(\"new\").getInt(\"order\");\n-                if (order != defaultOrder) {\n-                    conf.getJSONObject(\"new\").put(\"order\", defaultOrder);\n-                    col.getSched().resortConf(conf);\n-                }\n-                col.save();\n-                return true;\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public static class ConfSetSubdecks extends Task<Void, Boolean> {\n-        private final Deck deck;\n-        private final DeckConfig conf;\n-\n-\n-        public ConfSetSubdecks(Deck deck, DeckConfig conf) {\n-            this.deck = deck;\n-            this.conf = conf;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundConfSetSubdecks\");\n-            try {\n-                TreeMap<String, Long> children = col.getDecks().children(deck.getLong(\"id\"));\n-                for (long childDid : children.values()) {\n-                    Deck child = col.getDecks().get(childDid);\n-                    if (child.isDyn()) {\n-                        continue;\n-                    }\n-                    boolean changed = new ConfChange(child, conf).task(col, collectionTask);\n-                    if (!changed) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            } catch (JSONException e) {\n-                Timber.w(e);\n-                return false;\n-            }\n-        }\n-    }\n-\n-\n-    /**\n-     * @return The results list from the check, or false if any errors.\n-     */\n-    public static class CheckMedia extends Task<Void, PairWithBoolean<List<List<String>>>> {\n-        @Override\n-        protected PairWithBoolean<List<List<String>>> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundCheckMedia\");\n-            // Ensure that the DB is valid - unknown why, but some users were missing the meta table.\n-            try {\n-                col.getMedia().rebuildIfInvalid();\n-            } catch (IOException e) {\n-                Timber.w(e);\n-                return new PairWithBoolean<>(false, null);\n-            }\n-            // A media check on AnkiDroid will also update the media db\n-            col.getMedia().findChanges(true);\n-            // Then do the actual check\n-            return new PairWithBoolean<>(true, col.getMedia().check());\n-        }\n-    }\n-\n-\n-    public static class DeleteMedia extends Task<Void, Integer> {\n-        private final List<String> unused;\n-\n-\n-        public DeleteMedia(List<String> unused) {\n-            this.unused = unused;\n-        }\n-\n-\n-        protected Integer task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            com.ichi2.libanki.Media m = col.getMedia();\n-            for (String fname : unused) {\n-                m.removeFile(fname);\n-            }\n-            return unused.size();\n-        }\n-    }\n-\n-\n-    /**\n-     * Handles everything for a model change at once - template add / deletes as well as content updates\n-     */\n-    public static class SaveModel extends Task<Void, Pair<Boolean, String>> {\n-        private final Model model;\n-        private final ArrayList<Object[]> templateChanges;\n-\n-\n-        public SaveModel(Model model, ArrayList<Object[]> templateChanges) {\n-            this.model = model;\n-            this.templateChanges = templateChanges;\n-        }\n-\n-\n-        protected Pair<Boolean, String> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundSaveModel\");\n-            Model oldModel = col.getModels().get(model.getLong(\"id\"));\n-\n-            // TODO need to save all the cards that will go away, for undo\n-            //  (do I need to remove them from graves during undo also?)\n-            //    - undo (except for cards) could just be Models.update(model) / Models.flush() / Collection.reset() (that was prior \"undo\")\n-            JSONArray newTemplates = model.getJSONArray(\"tmpls\");\n-\n-            col.getDb().getDatabase().beginTransaction();\n-\n-            try {\n-                for (Object[] change : templateChanges) {\n-                    JSONArray oldTemplates = oldModel.getJSONArray(\"tmpls\");\n-                    switch ((TemporaryModel.ChangeType) change[1]) {\n-                        case ADD:\n-                            Timber.d(\"doInBackgroundSaveModel() adding template %s\", change[0]);\n-                            try {\n-                                col.getModels().addTemplate(oldModel, newTemplates.getJSONObject((int) change[0]));\n-                            } catch (Exception e) {\n-                                Timber.e(e, \"Unable to add template %s to model %s\", change[0], model.getLong(\"id\"));\n-                                return new Pair<>(false, e.getLocalizedMessage());\n-                            }\n-                            break;\n-                        case DELETE:\n-                            Timber.d(\"doInBackgroundSaveModel() deleting template currently at ordinal %s\", change[0]);\n-                            try {\n-                                col.getModels().remTemplate(oldModel, oldTemplates.getJSONObject((int) change[0]));\n-                            } catch (Exception e) {\n-                                Timber.e(e, \"Unable to delete template %s from model %s\", change[0], model.getLong(\"id\"));\n-                                return new Pair<>(false, e.getLocalizedMessage());\n-                            }\n-                            break;\n-                        default:\n-                            Timber.w(\"Unknown change type? %s\", change[1]);\n-                            break;\n-                    }\n-                }\n-\n-                col.getModels().save(model, true);\n-                col.getModels().update(model);\n-                col.reset();\n-                col.save();\n-                if (col.getDb().getDatabase().inTransaction()) {\n-                    col.getDb().getDatabase().setTransactionSuccessful();\n-                } else {\n-                    Timber.i(\"CollectionTask::SaveModel was not in a transaction? Cannot mark transaction successful.\");\n-                }\n-            } finally {\n-                DB.safeEndInTransaction(col.getDb());\n-            }\n-            return new Pair<>(true, null);\n-        }\n-    }\n-\n-\n-    /*\n-     * Async task for the ModelBrowser Class\n-     * Returns an ArrayList of all models alphabetically ordered and the number of notes\n-     * associated with each model.\n-     *\n-     * @return {ArrayList<JSONObject> models, ArrayList<Integer> cardCount}\n-     */\n-    public static class CountModels extends Task<Void, Pair<ArrayList<Model>, ArrayList<Integer>>> {\n-        protected Pair<ArrayList<Model>, ArrayList<Integer>> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackgroundLoadModels\");\n-\n-            ArrayList<Model> models = col.getModels().all();\n-            ArrayList<Integer> cardCount = new ArrayList<>();\n-            Collections.sort(models, (Comparator<JSONObject>) (a, b) -> a.getString(\"name\").compareTo(b.getString(\"name\")));\n-\n-            for (Model n : models) {\n-                if (collectionTask.isCancelled()) {\n-                    Timber.e(\"doInBackgroundLoadModels :: Cancelled\");\n-                    // onPostExecute not executed if cancelled. Return value not used.\n-                    return null;\n-                }\n-                cardCount.add(col.getModels().useCount(n));\n-            }\n-\n-            return new Pair<>(models, cardCount);\n-        }\n-    }\n-\n-\n-    /**\n-     * Deletes the given model\n-     * and all notes associated with it\n-     */\n-    public static class DeleteModel extends Task<Void, Boolean> {\n-        private final long modID;\n-\n-\n-        public DeleteModel(long modID) {\n-            this.modID = modID;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            Timber.d(\"doInBackGroundDeleteModel\");\n-            try {\n-                col.getModels().rem(col.getModels().get(modID));\n-                col.save();\n-            } catch (ConfirmModSchemaException e) {\n-                e.log();\n-                Timber.e(\"doInBackGroundDeleteModel :: ConfirmModSchemaException\");\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    /**\n-     * Deletes the given field in the given model\n-     */\n-    public static class DeleteField extends Task<Void, Boolean> {\n-        private final Model model;\n-        private final JSONObject field;\n-\n-\n-        public DeleteField(Model model, JSONObject field) {\n-            this.model = model;\n-            this.field = field;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask){\n-            Timber.d(\"doInBackGroundDeleteField\");\n-\n-\n-            try {\n-                col.getModels().remField(model, field);\n-                col.save();\n-            } catch (ConfirmModSchemaException e) {\n-                //Should never be reached\n-                e.log();\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    /**\n-     * Repositions the given field in the given model\n-     */\n-    public static class RepositionField extends Task<Void, Boolean> {\n-        private final Model model;\n-        private final JSONObject field;\n-        private final int index;\n-\n-\n-        public RepositionField(Model model, JSONObject field, int index) {\n-            this.model = model;\n-            this.field = field;\n-            this.index = index;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask){\n-            Timber.d(\"doInBackgroundRepositionField\");\n-\n-            try {\n-                col.getModels().moveField(model, field, index);\n-                col.save();\n-            } catch (ConfirmModSchemaException e) {\n-                e.log();\n-                //Should never be reached\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    /**\n-     * Adds a field with name in given model\n-     */\n-    public static class AddField extends Task<Void, Boolean> {\n-        private final Model model;\n-        private final String fieldName;\n-\n-\n-        public AddField(Model model, String fieldName) {\n-            this.model = model;\n-            this.fieldName = fieldName;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask){\n-            Timber.d(\"doInBackgroundRepositionField\");\n-            col.getModels().addFieldModChanged(model, col.getModels().newField(fieldName));\n-            col.save();\n-            return true;\n-        }\n-    }\n-\n-    /**\n-     * Adds a field of with name in given model\n-     */\n-    public static class ChangeSortField extends Task<Void, Boolean> {\n-        private final Model model;\n-        private final int idx;\n-\n-\n-        public ChangeSortField(Model model, int idx) {\n-            this.model = model;\n-            this.idx = idx;\n-        }\n-\n-\n-        protected Boolean task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask){\n-            try {\n-                Timber.d(\"doInBackgroundChangeSortField\");\n-                col.getModels().setSortIdx(model, idx);\n-                col.save();\n-            } catch(Exception e){\n-                Timber.e(e, \"Error changing sort field\");\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-    \n-    public static class FindEmptyCards extends Task<Integer, List<Long>> {\n-        protected List<Long> task(Collection col, ProgressSenderAndCancelListener<Integer> collectionTask) {\n-            return col.emptyCids(collectionTask);\n-        }\n-    }\n-\n-    /**\n-     * Goes through selected cards and checks selected and marked attribute\n-     * @return If there are unselected cards, if there are unmarked cards\n-     */\n-    public static class CheckCardSelection extends Task<Void, Pair<Boolean, Boolean>> {\n-        private final CardBrowser.CardCollection<CardBrowser.CardCache> checkedCards;\n-\n-\n-        public CheckCardSelection(CardBrowser.CardCollection<CardBrowser.CardCache> checkedCards) {\n-            this.checkedCards = checkedCards;\n-        }\n-\n-\n-        protected @Nullable Pair<Boolean, Boolean> task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            boolean hasUnsuspended = false;\n-            boolean hasUnmarked = false;\n-            for (CardBrowser.CardCache c: checkedCards) {\n-                if (collectionTask.isCancelled()) {\n-                    Timber.v(\"doInBackgroundCheckCardSelection: cancelled.\");\n-                    return null;\n-                }\n-                Card card = c.getCard();\n-                hasUnsuspended = hasUnsuspended || card.getQueue() != Consts.QUEUE_TYPE_SUSPENDED;\n-                hasUnmarked = hasUnmarked || !card.note().hasTag(\"marked\");\n-                if (hasUnsuspended && hasUnmarked)\n-                    break;\n-            }\n-\n-            return new Pair<>(hasUnsuspended, hasUnmarked);\n-        }\n-    }\n-\n-    public static class PreloadNextCard extends Task<Void, Void> {\n-        public Void task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            try {\n-                col.getSched().counts(); // Ensure counts are recomputed if necessary, to know queue to look for\n-                col.getSched().preloadNextCard();\n-            } catch (RuntimeException e) {\n-                Timber.e(e, \"doInBackgroundPreloadNextCard - RuntimeException on preloading card\");\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class LoadCollectionComplete extends Task<Void, Void> {\n-        protected Void task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            if (col != null) {\n-                CollectionHelper.loadCollectionComplete(col);\n-            }\n-            return null;\n-        }\n-    }\n-\n-    public static class Reset extends Task<Void, Void> {\n-        public Void task(Collection col, ProgressSenderAndCancelListener<Void> collectionTask) {\n-            col.getSched().reset();\n-            return null;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "d98f55f399b7e718f15623a8af1c566b6deb0bf6", "message": "Merge commit", "committedDate": null}, {"oid": "ea4d3bff6f62ccb10afb415cf6f6860cc05b6489", "committedDate": "2020-06-07 10:58:00 -0500", "message": "NF: Correct comment"}, {"oid": "125aec6eacc3c223fe2d518125301daae1a9cce9", "committedDate": "2020-06-08 08:42:27 -0500", "message": "NF: remove unused getComparator"}, {"oid": "5942ebb3e835206d7179ac2e50baf1d83d1f99e3", "committedDate": "2020-06-08 08:42:27 -0500", "message": "NF: remove unused constructor"}, {"oid": "8bb6aa707499f757978f7f5c87de4bb8cb96659e", "committedDate": "2020-06-08 08:42:27 -0500", "message": "NF: remove unused member"}, {"oid": "da4acac7e4c72713a99c909aa22bf32a527041aa", "committedDate": "2020-06-08 08:42:27 -0500", "message": "NF: remove unused argument params"}, {"oid": "253680ad3322d1395bac9c08387ddde529789cbc", "committedDate": "2020-06-08 08:42:27 -0500", "message": "NF: allow tasks to return void"}, {"oid": "a9eb3d79ba51a88c339a3ed0e1ac172aa711d6ab", "committedDate": "2020-06-08 08:42:27 -0500", "message": "NF: add new line between cases"}, {"oid": "a31c16254ee853b69cc794fd519c20bcdc07dba6", "committedDate": "2020-06-10 09:47:28 -0500", "message": "Add Exception reports on more import failures"}, {"oid": "699d925106608f19d37f36cd94ccf9cb0ca528d5", "committedDate": "2020-06-12 17:21:17 -0500", "message": "Edit templates in memory, save to db only on confirm"}, {"oid": "089bc8e3a693fca34324941a9186b3185cdb1816", "committedDate": "2020-06-12 17:21:17 -0500", "message": "Improve error handling on template save"}, {"oid": "754861c87d9bad33130009ff5a600996876a4846", "committedDate": "2020-06-12 17:21:17 -0500", "message": "Separate adjustments to ordinal-based (UI) or changelist based"}, {"oid": "0e59da2b7dfe2fb29733b929e6afbbe26fdafe9a", "committedDate": "2020-06-12 17:21:17 -0500", "message": "Use up to date templates from database model for save iteration"}, {"oid": "44c7b798a13abc71a6ccf9e92acb00143b6dc018", "committedDate": "2020-06-12 23:28:57 -0500", "message": "Convert import/export to commons-compress"}, {"oid": "5cbac24f145f8b4b418ff5b64b502d0cf123ce8e", "committedDate": "2020-06-15 11:35:26 -0500", "message": "NF: introduce exception WrongId"}, {"oid": "59037efdd08d08df77084db88918c69c2d0a887f", "committedDate": "2020-07-01 10:27:33 -0500", "message": "Undo: decrement count AFTER reset"}, {"oid": "e4543a40de9b69a8533bddb0346ee3c3e0c34b91", "committedDate": "2020-07-01 12:21:57 -0500", "message": "LINT: InnerClassMayBeStatic"}, {"oid": "b91a511d46b57a88b2a000ca2f6a2375dfbe3bdd", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Task type becomes an enum"}, {"oid": "017cb41d04e55b284f5e11410c50f63d2b368d38", "committedDate": "2020-07-04 11:53:02 -0500", "message": "NF: Remove TASK_TYPE from enum name"}, {"oid": "ba936de334853d5b63141ea160b1f04f32b70b88", "committedDate": "2020-07-05 14:42:15 +0100", "message": "NF: remove a method unused"}, {"oid": "6a075d0d12cd6777e0e8355d28485d5fef46e1e2", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: split doInBackground split in two"}, {"oid": "61a557b4363642158070dfaedefa155fde11e69a", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: sTasks"}, {"oid": "e9f2e39c4fe32e76769e6cf7e6c9e2aa7a41b71c", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: Move comments to javadoc"}, {"oid": "e9fa4a03a5ca1e726a6e2e1e00d30acea33e647c", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: assign to local variable to avoid concurrent chnage"}, {"oid": "719e470e3181da0eec5bcebd5dab2e6f084e0342", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: safeCancel, allow to cancel task"}, {"oid": "6a7f8d895eaaa08df21998a02c09a7c754ddeb97", "committedDate": "2020-07-05 08:46:49 -0500", "message": "cancelTask(type) cancel all tasks of given type"}, {"oid": "c18a421db5329cf3f2b86e62a819e5a116265f60", "committedDate": "2020-07-05 08:46:49 -0500", "message": "NF: cancelTask to cancelCurrentlyExecutingTask"}, {"oid": "2d5b504a8584f12ca60770eb33936ca26525a671", "committedDate": "2020-07-05 08:54:47 -0500", "message": "NF: Renaming Deck to Collection"}, {"oid": "755ac02e79987c042a1b053ffe6ce0d1caba1e0d", "committedDate": "2020-07-05 14:22:38 -0500", "message": "NF: mCurrentCard"}, {"oid": "5d7df0aa541d3b2d8f592ea5f71cfb73af8701ae", "committedDate": "2020-07-05 14:22:57 -0500", "message": "NF: remove a try catch"}, {"oid": "cadeb647a7f28f56ca75c3283cc624c43950c055", "committedDate": "2020-07-05 16:59:28 -0500", "message": "loadAfterGUI"}, {"oid": "d3edc4145c32181c386a6e7264906869c2d7c493", "committedDate": "2020-07-05 23:25:37 -0500", "message": "NF: avoid going from id to count model to id"}, {"oid": "263de1b770469dc2d9c278d304611a5f40da853f", "committedDate": "2020-07-05 23:25:37 -0500", "message": "NF: uses sql's count instead of list size"}, {"oid": "d1d1a699bf4dcdda2c1f3a08a113295f40955eb5", "committedDate": "2020-07-05 23:25:37 -0500", "message": "NF: doInBackgroundLoadModels cancellable"}, {"oid": "0cb1d97ca9b5ca5ab5174629603655506f9ffad2", "committedDate": "2020-07-06 00:59:42 -0500", "message": "NF: card search: cancelling checked more often"}, {"oid": "79e6be0fe9cf3a792a2525ce431abd4249c50870", "committedDate": "2020-07-21 15:50:01 -0500", "message": "NF: DConf type"}, {"oid": "c126ac42a5eac08fba6d54d531c0821df0193c68", "committedDate": "2020-07-21 15:50:01 -0500", "message": "NF: Deck type"}, {"oid": "59822264e6481a2fae8e620de6f94aa230f6c052", "committedDate": "2020-07-21 15:50:01 -0500", "message": "NF: Model type"}, {"oid": "c7cf43052fc60997534451ef90b0bc4c5044e20c", "committedDate": "2020-07-22 13:49:20 -0500", "message": "NF: remove a useles object for BURY_CARD"}, {"oid": "1b3d8f59b9bf51557697e3485fd31132276ad46b", "committedDate": "2020-07-22 13:49:20 -0500", "message": "NF: Undo"}, {"oid": "8e81be46787086ffdf6bcdeb54753e124edf16a9", "committedDate": "2020-07-22 13:49:20 -0500", "message": "NF: move clone in caller."}, {"oid": "087dafa806a212b54826e9596ab39d8cc5c7ab8c", "committedDate": "2020-07-22 13:49:20 -0500", "message": "NF: Uses constant for undo"}, {"oid": "03aa2f4cd0aea7032cc93d27d8676be51154db3c", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: import static com.ichi2.async.CollectionTask.TaskData;"}, {"oid": "1df6f2510ed5c6d410b98c8955a0c230e1ffb309", "committedDate": "2020-07-23 09:07:32 -0500", "message": "NF: TaskData in a separate file"}, {"oid": "37f81f71675b9f439cec2060512863be539110b8", "committedDate": "2020-07-23 10:33:13 -0500", "message": "NF: CollectionTask.getCol()"}, {"oid": "75d5e4e170e1e1f34452ebacec9cea5ab11831b0", "committedDate": "2020-07-24 09:57:39 -0500", "message": "CollectionTask Constructor private"}, {"oid": "11c9bb1920d69dc8541d0debcebab349ce0ea086", "committedDate": "2020-07-24 12:33:20 -0500", "message": "NF: Single Listener"}, {"oid": "dbe63247493fa247043565a3315fd2b3f69a02a7", "committedDate": "2020-07-25 12:17:00 -0500", "message": "NF: CountModel does not return constant"}, {"oid": "706de590aac0fafb3482e1c9e53ce719e29a79d6", "committedDate": "2020-07-25 12:17:00 -0500", "message": "NF: doInBackgroundImportReplace only return boolean"}, {"oid": "74aaebfbebf1b5c48414eb55a400b2405f54efc9", "committedDate": "2020-07-25 15:14:41 -0500", "message": "NF: doInBackgroundDeleteDeck don't return"}, {"oid": "6d8d7d4abdc604c7edc5ed97da47b57cb9b076a1", "committedDate": "2020-07-25 15:14:56 -0500", "message": "NF: listener's onProgressUpdate take a single element"}, {"oid": "7ffb46948605d4c32d1cf9fac3d833ad0b5c29f1", "committedDate": "2020-07-26 11:55:45 -0500", "message": "NF: Task takes at most one task data"}, {"oid": "31542918e96b334e551b8c2a41348f38c89603d8", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: BuryCard simplified"}, {"oid": "70792cf74befd966dcd0c88591c5bceab4c8d7ce", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: UndoableBuryNote simplified"}, {"oid": "8f38d3e027641f16b2dbef6ab91596a9675fef59", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: suspend Card undo simpler"}, {"oid": "72a51b0c52fb539ec6ce8e3b95a3e8bf6516c2c6", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: simplify suspendCardMulti undo"}, {"oid": "ccbee25952688bf78fc205e4d96e9257f6ad3e8c", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: UndoableDeleteNote simplified"}, {"oid": "b8c93d826948e17703ca726343940cfe671286d4", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: UndoableDeleteNoteMulti simplified"}, {"oid": "c21c7d3ad0d21a0b0aaa1c70752e3210763fa91a", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: simplifies UndoableSuspendNote"}, {"oid": "e9a750e91db90fcb51146e920fbace1e8948ec04", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: UndoableChangeDeckMulti simplified"}, {"oid": "6319fd46d1805575fb643859e500e98b88b9a1b5", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: simplifies undoable mark note multi"}, {"oid": "b280d41bfe4fb0f6615095fb4e3295b94c8a4527", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: simplifies undo Reposition rescheduler reset cards"}, {"oid": "34507a8b607598cebfd3501d6f305b1c16f51cf2", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: UndoableFlushAll -> revertToProvidedState"}, {"oid": "5d636a11f2b2956ff9408a3189edcc7c6cd5b834", "committedDate": "2020-07-29 10:56:55 -0500", "message": "NF: simplifies revertToProvidedState"}, {"oid": "dbc307e365de61e0d13f7766815778552d54727d", "committedDate": "2020-08-03 16:17:04 -0500", "message": "NF: Button type annotation"}, {"oid": "4d4abb8e0736cf5f08ed38ee9278df677e24f057", "committedDate": "2020-08-03 22:52:50 -0500", "message": "DeckPicker: no pending sync icon if deck changed"}, {"oid": "cc662ae5da6d76dee3b82b2210432e8d08428e65", "committedDate": "2020-08-06 09:34:02 -0500", "message": "Fix ConcurrentModificationException: task cancel"}, {"oid": "2392458fdb2a22ad4e6bf4a4af898b0c61d62d82", "committedDate": "2020-08-06 17:06:44 -0500", "message": "NF: move clearUndo to background"}, {"oid": "88d43bcb29ff93541e249449b97de27601346a0a", "committedDate": "2020-08-07 09:54:28 -0500", "message": "NF: removing UPDATE_NOTES_MULTI never used"}, {"oid": "e39b6d08427150c324e47d20cb1aa05feac67822", "committedDate": "2020-08-07 09:54:28 -0500", "message": "NF: remove unused ADD_TEMPLATE"}, {"oid": "818c07aaa1f96a8464e45343537cb853a6673df4", "committedDate": "2020-08-07 09:54:28 -0500", "message": "NF: remove unused REMOVE_TEMPLATE"}, {"oid": "3ae67895c4667b6c83acef6b3b27945553354963", "committedDate": "2020-08-07 12:25:13 -0500", "message": "NF: replace reset by resetCounts"}, {"oid": "2f0af8ff7c5cc18d850aa1fc8c1bdd2c39a6bb1c", "committedDate": "2020-08-08 09:05:50 -0500", "message": "NF: Listener as separate file"}, {"oid": "d4267b868d9b4e584d186f667de2f48636b333be", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: create type cardCache"}, {"oid": "1b8198ca33ba270ac5983ab76c3790778e22ca9e", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: \"id\" to ID"}, {"oid": "f6b4230e354e2965089317b68124bf15bfa54b84", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: id in CardCache"}, {"oid": "0ed0b26615da7a6bca6313471ceda4e1162656b0", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardClass has card accessor"}, {"oid": "4a0d565455507e4b0a9123f13a6d23c539788df7", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache deal with loading"}, {"oid": "05bdfeab6c832ff56880b3cc85af9f7c69206823", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused paramater, varilable and comment"}, {"oid": "25668235083fa2e4c0716fb177f0ed756d5f18f1", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: context is got directly in updateSearchItemQA"}, {"oid": "216580a8bfebb2e94d3ee973e9c16dea5b45f6a2", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: updateSearchItemQA don't take card, but get it from CardCache"}, {"oid": "474450d513e379802bca25b64e9d2dccfa7dc105", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: Question/Answer in Content"}, {"oid": "d90769e73040f4d591ed783b7d66a856c8bfe7e3", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: CardCache deal with loading"}, {"oid": "23d64c43221e83f1ca9b1dd0987e47a570a1f33c", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: don't compute question/answer if it's not used"}, {"oid": "23caa8ecb5b24de130671b569ab6fc649480e4b5", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: cardCache constructor takes position"}, {"oid": "2ea7d9a79284cbf6464e6be6a5286a2965859475", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: mCheckedCardPositions becomes a list of CardCache"}, {"oid": "b2b9e2d47025883aea6ce571c858ddf61d9281f0", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused parameter cards"}, {"oid": "7d190c795f34e5baebb1ab308ff4a783acd5a48c", "committedDate": "2020-08-15 17:59:18 -0500", "message": "NF: remove unused variable col"}, {"oid": "34b1ad683497e2b81311764bfab3c8e5c7c99cf1", "committedDate": "2020-08-15 18:05:57 -0500", "message": "NF: loadQA in card cache"}, {"oid": "9b91c6bf5609250abf46624a9f602ccba2d2ed01", "committedDate": "2020-08-21 11:43:54 -0500", "message": "Reset counts if required"}, {"oid": "241adade677ac1ec1695bcc2fae0eca248f7d8b5", "committedDate": "2020-08-22 14:28:46 -0500", "message": "NF: performBackupInBackground takse time"}, {"oid": "8f4ff92f8f883c8a9e3d6d710d7466204b31e814", "committedDate": "2020-08-26 14:49:06 -0500", "message": "NF: quickDeckDueTree"}, {"oid": "31b232e7c773fea80ac1a48b55c3e16008a47f3e", "committedDate": "2020-08-30 18:24:07 -0500", "message": "NF: split undo for testing"}, {"oid": "a615dfc66545e82589ad63835b78639c9dd0cd00", "committedDate": "2020-08-30 18:24:07 -0500", "message": "Going back to a simple mCurrentCard"}, {"oid": "1a6b368607c482af389a1f151453dd407bb40569", "committedDate": "2020-09-02 16:43:36 -0500", "message": "NF: remove NO_REVIEW"}, {"oid": "45a6dd28ec6ca53431c830118c6a40f03126fa4c", "committedDate": "2020-09-02 16:43:36 -0500", "message": "NF: undo return card"}, {"oid": "32a4e06304dcafc47d7048586c482bbbd209a84d", "committedDate": "2020-09-06 18:40:40 -0500", "message": "NF: alow to cancel Task_type_Check_Card_selection"}, {"oid": "796e2e7c6367bc1dc0cc3af2927f965705f9f30e", "committedDate": "2020-09-13 14:03:06 -0500", "message": "IMPORT_REPLACE can run when collection corrupt"}, {"oid": "3ea1a2f3a158b7128c6a14608f52518d8886084a", "committedDate": "2020-09-14 12:13:22 -0500", "message": "[BugFix]: Restore backups as writable database"}, {"oid": "081a8b54990e3e9ceacd240931e2a936b54a723b", "committedDate": "2020-09-20 11:01:31 -0500", "message": "NF: undo message is more specific"}, {"oid": "a4d1643b4723b8d4bd43ff375e0e061baa2a2a5a", "committedDate": "2020-09-21 12:21:31 -0500", "message": "NF: Remove warning about useless int instead of advanced loop"}, {"oid": "c0595464b0b205d704b293f64543e5f54e4b2612", "committedDate": "2020-09-22 09:09:16 -0500", "message": "NF: remove warning Convert2Lambda"}, {"oid": "b6ab21bf0086676013450fb09eb786944aac4a4a", "committedDate": "2020-09-22 09:13:07 -0500", "message": "NF: represents counts as a class"}, {"oid": "1f785c1b8c324266fdf652e84c9d9309d7278392", "committedDate": "2020-09-23 11:08:06 -0500", "message": "NF: Remove warning about parameter that could be final"}, {"oid": "b96e0eed677a101a5e3a2608cd503f7edd7e37f6", "committedDate": "2020-09-24 00:19:55 -0500", "message": "Converted void methods to executeInTransaction"}, {"oid": "c84a8cd5c0629da7d73a4e52a64c7a1713dfcef4", "committedDate": "2020-09-24 00:19:55 -0500", "message": "Added DB.safeEndInTransaction"}, {"oid": "b77b3b29dc79bda8b84227de897c40e5a7597887", "committedDate": "2020-09-27 08:33:18 -0500", "message": "Add a progress dialog when deleting media files"}, {"oid": "646572f5d6c71ecc75d1259711a7e2df95dc0214", "committedDate": "2020-09-27 08:33:18 -0500", "message": "Add a result dialog after deleting media files"}, {"oid": "fe6a93e79014acd6ae7ae04ca34447f4cb3bc0a3", "committedDate": "2020-09-28 11:24:51 -0500", "message": "NF: CardBrowser - Improve comments"}, {"oid": "954e1527d9e786eaa28476b95b378123ecd992a1", "committedDate": "2020-09-30 17:57:42 -0500", "message": "NF: remove uneccessary semicolon"}, {"oid": "95ef38823a93ae21f328dc6381d7d93ae3e89c50", "committedDate": "2020-10-04 16:25:33 -0500", "message": "Lint: Utilize Java 8 features"}, {"oid": "f6f82c275e9d2fe079ca560cc0ba1d3565e4bd7f", "committedDate": "2020-10-14 16:14:43 -0500", "message": "NF: ProgressSender"}, {"oid": "39036ef13d50107104b9fe5a463912e8a5700db3", "committedDate": "2020-10-14 16:14:43 -0500", "message": "Empty card update on number of card checked"}, {"oid": "382519a3ae5835d5f3f768574337c3072f68cac7", "committedDate": "2020-10-28 22:49:33 -0500", "message": "NF: avoid entry set when onl value/key are used"}, {"oid": "2d96e47e9e3f7d72c019d1231aa3df7fe060f9c1", "committedDate": "2020-11-08 14:48:41 -0500", "message": "NF: calls ids2String without useless conversions"}, {"oid": "4a144890b52f3b45cb50b1c1b4506a505dacd73e", "committedDate": "2020-11-09 11:32:19 -0500", "message": "NF: Rename param: timeout -> timeoutSeconds"}, {"oid": "5c668de802ff1e57a45033e1adeb01c71b1cb869", "committedDate": "2020-11-09 11:32:19 -0500", "message": "Add gesture to abort reviewing and sync"}, {"oid": "2d37ec49787b2e9e3ef2d88b1c68b6f4683ad22b", "committedDate": "2020-11-10 18:38:03 -0500", "message": "Check Media: Rebuild database on schema error"}, {"oid": "4cbe8f4881ed75922c89861288b0a2d4fb8867ec", "committedDate": "2020-11-14 08:35:32 -0500", "message": "NF: replace a line by its def"}, {"oid": "bcaad03cf2bd88a0df2dbf2114ca2875ce96899d", "committedDate": "2020-11-20 11:31:55 +0000", "message": "NF: indicates clearly that `markUndo` takes NonNull"}, {"oid": "dbaf6549ec268333b20d160a0c40962d3135ba0d", "committedDate": "2020-11-20 07:54:40 -0500", "message": "Show partial result in browser before showing all"}, {"oid": "57902ab91f61fbb18d6fb48d03c975b0bb5d4264", "committedDate": "2020-12-08 09:27:51 -0500", "message": "LOG: UPDATE_NOTE - Log if card changes"}, {"oid": "cce056d89cb1cc4176faf3a4b4be5f9bd8c31283", "committedDate": "2020-12-08 09:27:51 -0500", "message": "BugFix - Previewer: Display same card after edit"}, {"oid": "c7cb9b2dd6f2f2c361c825b8e31e424b0e4812d5", "committedDate": "2020-12-08 10:03:02 -0500", "message": "NF: add a background task to reset counts"}, {"oid": "f404883b22429de39573389a0f270c5082145a23", "committedDate": "2020-12-08 12:25:08 -0500", "message": "NF: Cancel UpdateValuesFormDeck when StudyOptionsFragment closes"}, {"oid": "fb3e451ffb1f421cc48241006bd3ef5905774d4f", "committedDate": "2020-12-08 13:07:30 -0500", "message": "NF: remove transaction and try/catch in doInBackgroundAnswerCard"}, {"oid": "7b607d2ee38fad34102f3dbc033e2b4d225e7943", "committedDate": "2020-12-08 13:07:30 -0500", "message": "NF: split AnswerCard in GetCard and GetAndAnswerCard"}, {"oid": "5128cc2c756ce1434367eb58807650581f26c661", "committedDate": "2020-12-09 11:27:39 -0500", "message": "NF: init capacity of list, map and set"}, {"oid": "ec80d4eb9fb57fd538bccdc8c7e52b8545c4af3e", "committedDate": "2020-12-09 11:44:05 -0500", "message": "NF: Dismiss_multi first argument is List<Long>"}, {"oid": "23158d37a7743112e6122fb67e0bfa8c618c1eb9", "committedDate": "2020-12-09 11:44:05 -0500", "message": "NF: avoid useless type conversion list to array"}, {"oid": "d4b3f57e74ed6d56305f6cf6968757054fd237e2", "committedDate": "2020-12-09 12:17:48 -0500", "message": "NF: Move static part of CollectionTask to other class"}, {"oid": "7a31ed7521d3ca1e5d2cd3dd7f155c2c39ed8760", "committedDate": "2020-12-09 12:17:48 -0500", "message": "NF: progressCallback gets a function as constructor"}, {"oid": "980cafa3e781c99197dee8470b48e6cde851c53b", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: Split actualDoInBackground"}, {"oid": "fd90cf9152022dd0b5cf6529b77cccb29fecf361", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: remove hasValidCol"}, {"oid": "7a722e2c8253f5f0f2d6221609691f7185dc68b9", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: replace getCol by its definition"}, {"oid": "266cb892e484456a6b33281be1590a6945581b1c", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: uses col variable in CollectionTask"}, {"oid": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "committedDate": "2020-12-10 14:22:22 -0500", "message": "NF: Add Type Task, type CollectionTask and TaskListener"}, {"oid": "930bd70272c2acda40e3da35e1ed454b91176a1b", "committedDate": "2020-12-12 14:14:20 +0100", "message": "NF: correct typing of tasks"}, {"oid": "9e34babb11eb947d538f0730021f59e043c0d240", "committedDate": "2020-12-13 08:05:27 -0500", "message": "NF: add brackets to pairs"}, {"oid": "da44e472f0bba97a62c04ebbcb21142c0efc0759", "committedDate": "2020-12-13 08:05:27 -0500", "message": "NF: return pair in correct order"}, {"oid": "6f565d2a3b3a433e6538b0b5bc8edc8ea78cb29c", "committedDate": "2020-12-13 08:23:32 -0500", "message": "NF: doProgress takes a single parameter"}, {"oid": "240cf81d608b9a0f1ddadd34f1ca50dc7e4f98b2", "committedDate": "2020-12-21 13:16:51 -0500", "message": "Solve #7918"}, {"oid": "013448829b1b82ad15d65e581ee92d3b390a57b7", "committedDate": "2021-01-11 11:15:33 -0500", "message": "NF: Uses constant for decks \"dyn\" value"}, {"oid": "9f7e772fe875efcec4556cc6d010977ed01666f4", "committedDate": "2021-02-13 12:53:34 -0500", "message": "NF: use more isStd on deck"}, {"oid": "5e1b4a191432e09a4ffc50644d44a6c9824a7ff4", "committedDate": "2021-03-18 14:17:51 +0100", "message": "Remove setters from Exporter classes"}, {"oid": "0e28ebd64c5a092e74e3023a58556750c31ccd21", "committedDate": "2021-03-22 07:04:56 +0100", "message": "NF: Add options to control adding note with only empty card"}, {"oid": "6cbece273ff36d8b059290e10a31ff98c2016398", "committedDate": "2021-03-24 12:03:56 -0500", "message": "NF: use a tuple class instead of int[]"}, {"oid": "0b869c7bcd3aacfce7587704ba03f52b993979a7", "committedDate": "2021-03-24 14:32:35 -0500", "message": "Timber all exceptions catched not re-thrown"}, {"oid": "5283cfa25155b2bf73cb234b22bfd874002c71ee", "committedDate": "2021-03-30 20:09:13 +0200", "message": "NF: addTasks -> addTask (#8392)"}, {"oid": "a18fc25f8babb93ba73abcd9f30c6ab172793026", "committedDate": "2021-04-02 13:59:50 -0500", "message": "NF: Split Dismiss task"}, {"oid": "48eaec826892b940182fb6bdee7a53c2d44ea53e", "committedDate": "2021-04-02 13:59:50 -0500", "message": "NF: remove the enum DismissType"}, {"oid": "38134343a85b1dc9446f6fbbcbfbad404478996c", "committedDate": "2021-04-03 03:15:42 +0200", "message": "NF: moving waitForAllToFinish to TaskManager"}, {"oid": "ff4c760d5a48423623b910cca37524ce21d39b17", "committedDate": "2021-04-03 03:15:42 +0200", "message": "NF: move addTask entirely in TaskManager"}, {"oid": "aa0c51bcae88ffbfa76224c27beed0c6d923dcd9", "committedDate": "2021-04-06 06:42:36 +0200", "message": "Code Style: Fix Constant naming"}, {"oid": "daa7526eb4899da1b7b478a14faef8e3ae5a0f4d", "committedDate": "2021-04-07 22:43:34 -0500", "message": "code style - m prefix for non-public, non-static fields #8387 (#8503)"}, {"oid": "9b46eaf6caa77c65ae4b10d7f40e63182b9b9cd9", "committedDate": "2021-04-10 17:20:35 +0100", "message": "NF: remove an unused variable with no side effect"}, {"oid": "794a42073340c5d0f2a81c1990be560f7d8ed9eb", "committedDate": "2021-04-11 14:43:02 +0100", "message": "NF: rename `Undoable` to `UndoAction`"}, {"oid": "db3b52eec8f7bae1e2875c7efd36ae9eba35a990", "committedDate": "2021-04-13 22:16:16 -0500", "message": "NF: comment and simplify DismissNote"}, {"oid": "2c8861256927a04fe404e46ba048e0c5ffea7388", "committedDate": "2021-04-13 22:18:19 -0500", "message": "NF: `DismissNotes`'s `actualTask` return whether it succeeded"}, {"oid": "694e8dcadea79d9ddf2eaab6eb2c36ec0d57fc99", "committedDate": "2021-04-14 13:13:15 -0500", "message": "NF: NonNull on task"}, {"oid": "3dafbb2953546654a858c3e5f08ed2b99f9b7ee1", "committedDate": "2021-04-14 17:30:26 -0500", "message": "NF: Refactor `Finder`"}, {"oid": "30e3529f3129a6e88c1d7fd01736f0244a284b5f", "committedDate": "2021-04-15 23:18:03 -0500", "message": "NF: rename `revertToProvidedState` to `revertNoteToProvidedState`"}, {"oid": "64c9d8f9d6b63a13d69c3605c410dbcfea48c2b6", "committedDate": "2021-04-15 23:18:03 -0500", "message": "NF: add `revertCardToProvidedState`"}, {"oid": "5f709dfe16e0450922c84ea60bd660559a4e39f7", "committedDate": "2021-04-15 23:18:03 -0500", "message": "NF: BuryCard undo's affect the Card"}, {"oid": "143d7bbf7c9aa87f842d44c240c07b7cb2bd9285", "committedDate": "2021-04-18 12:28:39 -0500", "message": "Fix: Duplicate cards shown in Card Browser"}, {"oid": "521fc16582193d475ebff92de370b86206f33615", "committedDate": "2021-04-30 19:45:07 +0200", "message": "NF: RepairCollectionn typo"}, {"oid": "a10214b2ec7061bc46863467ed32a73b81b1f355", "committedDate": "2021-04-30 14:53:54 -0500", "message": "Ensure that CheckCardSelection gets only checked cards"}, {"oid": "4fe6635b27a4a4a5698f7513098307476b484830", "committedDate": "2021-05-01 16:13:53 -0500", "message": "NF: add `requireAnOpenCollection` to Task"}, {"oid": "e5f0dabb29a96b6edc0310bbdd8b4a36af1a9c6d", "committedDate": "2021-05-03 16:03:04 -0500", "message": "NF: remove ProgressListener type from Task"}, {"oid": "0711bcde77f417bf274abee7b16c4b5b8f2e1b0a", "committedDate": "2021-05-03 16:03:04 -0500", "message": "NF: remove ResultListener type from Task"}, {"oid": "defd14d4943427c49aa193933187ca10066309d5", "committedDate": "2021-05-12 01:08:58 +0200", "message": "NF: replace gson with jackson"}, {"oid": "29f76dd0c9a03f1662d20cc9f6473547832182f0", "committedDate": "2021-05-12 01:08:58 +0200", "message": "NF: initialize jackson objects once"}, {"oid": "eb85b0dcc44c9c60e8f04c8461f5c334ec438068", "committedDate": "2021-05-12 01:08:58 +0200", "message": "NF: use try with resources"}, {"oid": "858f7370b269104e15a16fb3c562fd43435f637a", "committedDate": "2021-06-04 10:56:14 -0500", "message": "NF: remove mNumCardsToRender as it was useless"}, {"oid": "74c3dddec01f2fef6dac1aad0034a7650e8e2d23", "committedDate": "2021-06-06 00:32:39 +0200", "message": "NF: remove background suffix from tasks-related classes"}, {"oid": "a453d28fcd255eb2d6b844fea6f2ae5cc458e396", "committedDate": "2021-06-06 00:32:39 +0200", "message": "NF: comment Tasks related class"}, {"oid": "034ec28daa1ba4ac922cc77d1ff274c3d739edde", "committedDate": "2021-06-19 23:54:44 -0500", "message": "NF: remove usage of CardGetter/PairWithCard"}, {"oid": "becea6decc0023dedf3fd20c7c82f2592bb17cdb", "committedDate": "2021-06-19 23:54:44 -0500", "message": "NF: delete unused classes CardGetter/PairWithCard"}, {"oid": "8152f0338f5be50badd336cd53950c575b6be6cc", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: pair with boolean takes an argument for success."}, {"oid": "67b673034d0e7fe454fb5d91dbd3ed58f4f6574b", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: uses a single False"}, {"oid": "18484277785d09d82c557b051bed7874acd2ec2a", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: move True as PairWithBoolean"}, {"oid": "34ed57bde71765358351e61803d373a90c7d30cb", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: remove BooleanGetter"}, {"oid": "732d55668cb0657f56d8dd932a52f2350ee56375", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename True/False to OK/Err"}, {"oid": "22e0854ccc348a1ac395e1b9a73245a34621545f", "committedDate": "2021-06-26 07:46:27 -0500", "message": "NF: rename PairWithBoolean to Computation"}, {"oid": "3cd0b7fa0f550fba5e52b5527ba45fab48f37f34", "committedDate": "2021-06-27 18:27:30 +0200", "message": "NF: comment and rename Task related classes"}, {"oid": "58e23a5d86dd95be22ed1f8206ef3a08b9429414", "committedDate": "2021-06-27 20:07:21 -0500", "message": "NF: remove AddNote duplicate constructor"}, {"oid": "b3b1cfa8d63d2dc009398a222f92717c32505fa2", "committedDate": "2021-06-27 20:07:21 -0500", "message": "NF: remove mAllowEmpty which have a single value"}, {"oid": "0fd714aa3a0b6254069f4d02225ea8ff1425474e", "committedDate": "2021-06-27 20:07:21 -0500", "message": "NF: re-indent"}, {"oid": "90d3bb68524c90662184877914fb8e78c3630308", "committedDate": "2021-07-16 11:20:53 -0500", "message": "NF: add UNDO_NAME_ID IntDef"}, {"oid": "57f6bfab423362125e40ea81eb27d4a5925e3223", "committedDate": "2021-07-16 18:41:35 +0100", "message": "NF: launchCollectionTask return Cancellable"}, {"oid": "0a3a0fa0be7faa0468453ebf94c5c8f4ce9e86b2", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: remove AsyncTask import"}, {"oid": "89864ed56540339c51e4884b40baeb9d79336ed2", "committedDate": "2021-07-29 20:39:05 -0500", "message": "nf: add deprecation warning on AsyncTask"}, {"oid": "250097f54e0bf28371770275b613bc0e5e5b3248", "committedDate": "2021-08-27 08:15:20 -0500", "message": "nf: Avoid use of field prefixes for variable names"}, {"oid": "1670ca2845543ebe28aada4ba24a5fe75c7da235", "committedDate": "2021-08-31 12:55:46 -0500", "message": "models: return list from `all()`"}, {"oid": "308f4dff2fdd6d5d4c918c7649d0989d32c69e56", "committedDate": "2021-09-22 03:41:14 +0100", "message": "fix: SaveModel (v16)"}, {"oid": "59239944b222274d183b469600ae151244995833", "committedDate": "2021-10-18 12:10:56 -0500", "message": "replace Computation.ERR with computation.err()"}, {"oid": "680c5f005faba38f28959556f78ad03c2ca383bc", "committedDate": "2021-10-18 12:10:56 -0500", "message": "Computation: remove constructor invocation"}, {"oid": "e3078a2eac2dd0f2bde939250b8fcb41a059a03e", "committedDate": "2021-10-18 12:10:56 -0500", "message": "Convert Computation to Kotlin"}, {"oid": "551f922c0d726dcacfac7522a86a0463a9dbf86b", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: convert DismissNote async style"}, {"oid": "c88bc2e14bf2691c597b8702f701801c99632e2a", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert ScheduleCollectionTask async style"}, {"oid": "cb57ff16f3d8131cfd797b2e2f4a2771419adb9b", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert RescheduleRepositionReset async style"}, {"oid": "6aacb38fc115bfdf7c038f74aa0c9757ebf446a0", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert GetCard async style"}, {"oid": "bd8f85f29633812b249152b8e4dac986d89ae49f", "committedDate": "2021-10-18 12:10:56 -0500", "message": "nf: Convert Undo async style"}, {"oid": "1c0fa70b13d270cd2f230c0fb87d9e9347e75320", "committedDate": "2021-10-24 18:13:15 -0500", "message": "refactor: extract NoteService.isMarked"}, {"oid": "b0cb2174c467f769393d063944344fd5b927679a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: Introduce SortOrder class"}, {"oid": "019c32c32827080d1de8259c0212b9057d46c3bc", "committedDate": "2021-10-31 13:32:07 -0500", "message": "refactor: extract SearchCardsResult"}, {"oid": "1b3c687bfc7a4da0df1a1a90ebbc680f65650b6a", "committedDate": "2021-10-31 13:32:07 -0500", "message": "feat(v16): implement findCards in backend"}, {"oid": "a1fd4336f1c8930583ff9ac846c8f2524426cdc9", "committedDate": "2021-11-13 07:33:34 -0500", "message": "feat: add UpdateMultipleNotes task"}, {"oid": "c08a17b93c9258a6ac71ab2ddca21ae35eae5f29", "committedDate": "2022-01-16 15:13:43 -0500", "message": "NF: path is always non null"}, {"oid": "9039426e02d06df6c22b61deaecad09401ce155d", "committedDate": "2022-02-23 11:47:37 -0500", "message": "remove backup creation after restore"}, {"oid": "132b502db4cd5d0273660c973792ebd41ec35062", "committedDate": "2022-04-17 14:38:36 -0500", "message": "refactor: extract TreeNode from AbstractDeckTreeNode"}, {"oid": "2f85b2407441d7ab42150535c5395e84a0682ca6", "committedDate": "2022-04-19 18:28:13 -0500", "message": "refactor: Split out 'TaskDelegateBase'"}, {"oid": "14eb4d5506f98b008b521c5fcde3d6fbec817c05", "committedDate": "2022-04-19 18:28:13 -0500", "message": "refactor: Add 'UnsafeTaskDelegate'"}, {"oid": "0627af25867890d1b5194ddc36ace470c6f74628", "committedDate": "2022-04-22 15:01:34 -0500", "message": "refactor: Rename CollectionTask.java to .kt"}]}, {"oid": "fb983f23d1bdd251c2d5c8e28e1970ef5cbc0571", "url": "https://github.com/ankidroid/Anki-Android/commit/fb983f23d1bdd251c2d5c8e28e1970ef5cbc0571", "message": "Timber size of result of search", "committedDate": "2020-06-04T22:02:10Z", "type": "forcePushed"}, {"oid": "19a0e6bcff769fb2a79b4b0350d28774b7ceb335", "url": "https://github.com/ankidroid/Anki-Android/commit/19a0e6bcff769fb2a79b4b0350d28774b7ceb335", "message": "Timber size of result of search", "committedDate": "2020-06-04T23:00:59Z", "type": "forcePushed"}, {"oid": "783609ad81e5b933cd8b93bdc4a5d8ed0596029e", "url": "https://github.com/ankidroid/Anki-Android/commit/783609ad81e5b933cd8b93bdc4a5d8ed0596029e", "message": "checking which cards are marked is moved to CardBrowser\n\nCurrently, asking the browser to show the whole collection takes\nmultiple minutes. On a smaller deck, it takes 40 seconds, out of which\n15 are spent executing the regexp and looking for marked cards.\n\nMoving it to updateSearchItemQA ensure it is executed only for card we\nintend to display and save most of this time.\n\nSince \"marked\" is computed later, the color of the browser line is\ncomputed at the same time than the text, instead of being\npre-computed. So it makes the following difference:\n* before this commit, all lines are directly colored\n* after this commit, if you scroll quickly, all lines are white and\n  they become colored at the moment when they get their text.\n\n(To be even more precise, the text is filled or not depending on the\ncolumns. \"sort field\" is always filled while \"question\" is filled only\nafter the line appear on screen.)", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "4570aeb1e44bd78877deee85d0b82019f355d1fb", "url": "https://github.com/ankidroid/Anki-Android/commit/4570aeb1e44bd78877deee85d0b82019f355d1fb", "message": "NF: compile pattern for marked cards", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "7f3377f414da2c71ef50b87b1b6c209d0c8b2945", "url": "https://github.com/ankidroid/Anki-Android/commit/7f3377f414da2c71ef50b87b1b6c209d0c8b2945", "message": "NF: Finder._where is private", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "3e276fc2272e917b7fec775761eda846b8f387fb", "url": "https://github.com/ankidroid/Anki-Android/commit/3e276fc2272e917b7fec775761eda846b8f387fb", "message": "NF: unused findCardsForCardBrowser with String", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "6306e410f54d38069690d0bf7f784bbe853b3797", "url": "https://github.com/ankidroid/Anki-Android/commit/6306e410f54d38069690d0bf7f784bbe853b3797", "message": "NF: findCardsForCardBrowser removes an useless indirection", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "c675255c2dd305af7da3b6d8730de04c9684ef91", "url": "https://github.com/ankidroid/Anki-Android/commit/c675255c2dd305af7da3b6d8730de04c9684ef91", "message": "NF: remove useless findCards", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "f884e785d57513c684fa992df32dcd234078a385", "url": "https://github.com/ankidroid/Anki-Android/commit/f884e785d57513c684fa992df32dcd234078a385", "message": "NF: move computation of flag string to card browser", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "4a178ba8419c9ca4da29fecd639f2e00c0ba141c", "url": "https://github.com/ankidroid/Anki-Android/commit/4a178ba8419c9ca4da29fecd639f2e00c0ba141c", "message": "NF: add variable note in updateSearchItemQA", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "ba3088dca4876c86e1feb0f0335ce8b218bbafac", "url": "https://github.com/ankidroid/Anki-Android/commit/ba3088dca4876c86e1feb0f0335ce8b218bbafac", "message": "NF: tags put in cardbrowser and not finder", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "654b5f00e2da527c2dea394210524cdce275a9ce", "url": "https://github.com/ankidroid/Anki-Android/commit/654b5f00e2da527c2dea394210524cdce275a9ce", "message": "NF: move suspended to cardbrowser", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "e6e96b8a762942a18b24787a4ec3e91d6070479b", "url": "https://github.com/ankidroid/Anki-Android/commit/e6e96b8a762942a18b24787a4ec3e91d6070479b", "message": "NF: add col parameter to updateSearchItemQA", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "d02c4af7f391992ac9ec3c7ed2d5e8113ad28f13", "url": "https://github.com/ankidroid/Anki-Android/commit/d02c4af7f391992ac9ec3c7ed2d5e8113ad28f13", "message": "NF: Deck name is put in card browser", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "db867c9006c24de3f8ad5ea0e6f68e35fe13e66c", "url": "https://github.com/ankidroid/Anki-Android/commit/db867c9006c24de3f8ad5ea0e6f68e35fe13e66c", "message": "NF: SFLD put in cardbrowser and not Finder", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "3bec1daed99ac459f39a7ab311ea6b85565b9fe1", "url": "https://github.com/ankidroid/Anki-Android/commit/3bec1daed99ac459f39a7ab311ea6b85565b9fe1", "message": "NF: remove place holders for Question/Answer\n\nSeems they are not checked anymore anyplace", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "00e1bb835fd81d304cb4c709947e480725fe8bca", "url": "https://github.com/ankidroid/Anki-Android/commit/00e1bb835fd81d304cb4c709947e480725fe8bca", "message": "NF: find cards with boolean", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "8293ad235b65d93695ed4d8eeb1b4b421d8c2d56", "url": "https://github.com/ankidroid/Anki-Android/commit/8293ad235b65d93695ed4d8eeb1b4b421d8c2d56", "message": "NF: uses findCards and not forCardBrowser", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "d57fc520792964beb32dbd95761f30a48f2e39a4", "url": "https://github.com/ankidroid/Anki-Android/commit/d57fc520792964beb32dbd95761f30a48f2e39a4", "message": "NF: remove unused findCardsForCardBrowser", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "085b1b0fcd928f4417b784d6874a51fcfbf26d25", "url": "https://github.com/ankidroid/Anki-Android/commit/085b1b0fcd928f4417b784d6874a51fcfbf26d25", "message": "NF: remove unused findCardsForCardBrowser", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "baa0ac4c03547dec5b71c44cf30a88b79cac434a", "url": "https://github.com/ankidroid/Anki-Android/commit/baa0ac4c03547dec5b71c44cf30a88b79cac434a", "message": "NF: Remove unused _queryForCardBrowser", "committedDate": "2020-06-05T11:30:27Z", "type": "commit"}, {"oid": "7fccc05cde4e26216a73054bd61bd5278c507f6d", "url": "https://github.com/ankidroid/Anki-Android/commit/7fccc05cde4e26216a73054bd61bd5278c507f6d", "message": "NF: use enum for column", "committedDate": "2020-06-05T14:34:04Z", "type": "forcePushed"}, {"oid": "2114aeedad26a5384d6d6a46289f72e405f8c9e9", "url": "https://github.com/ankidroid/Anki-Android/commit/2114aeedad26a5384d6d6a46289f72e405f8c9e9", "message": "NF: Integer.toString instead of new Integer().toString", "committedDate": "2020-06-05T14:55:29Z", "type": "forcePushed"}, {"oid": "c47f1e596152a515866c87d7098d9d269709fea5", "url": "https://github.com/ankidroid/Anki-Android/commit/c47f1e596152a515866c87d7098d9d269709fea5", "message": "Timber size of result of search", "committedDate": "2020-06-05T15:13:37Z", "type": "commit"}, {"oid": "daa3086e96b6ef50a1e526f126920025a2c28c6f", "url": "https://github.com/ankidroid/Anki-Android/commit/daa3086e96b6ef50a1e526f126920025a2c28c6f", "message": "NF: Integer.toString instead of new Integer().toString", "committedDate": "2020-06-05T15:13:37Z", "type": "commit"}, {"oid": "daa3086e96b6ef50a1e526f126920025a2c28c6f", "url": "https://github.com/ankidroid/Anki-Android/commit/daa3086e96b6ef50a1e526f126920025a2c28c6f", "message": "NF: Integer.toString instead of new Integer().toString", "committedDate": "2020-06-05T15:13:37Z", "type": "forcePushed"}]}