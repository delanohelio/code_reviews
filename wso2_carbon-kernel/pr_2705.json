{"pr_number": 2705, "pr_title": "Update multi-valued user claims independently from non-multi-valued claims", "pr_createdAt": "2020-06-15T11:58:23Z", "pr_url": "https://github.com/wso2/carbon-kernel/pull/2705", "merge_commit": "518b7af0f2f3740d640e87b712d71a2a8dd54fa9", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwODQ4Mw==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r442708483", "body": "Can you create an issue to track this requirement?", "bodyText": "Can you create an issue to track this requirement?", "bodyHTML": "<p dir=\"auto\">Can you create an issue to track this requirement?</p>", "author": "madurangasiriwardena", "createdAt": "2020-06-19T08:31:25Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/jdbc/JDBCUserStoreManager.java", "diffHunk": "@@ -2229,6 +2230,15 @@ public void doSetUserClaimValues(String userName, Map<String, String> claims, St\n         super.doSetUserClaimValues(userName, claims, profileName);\n     }\n \n+    @Override\n+    public void doSetUserClaimValues(String userName, Map<String, List<String>> multiValuedClaimsToAdd,\n+                                           Map<String, List<String>> multiValuedClaimsToDelete,\n+                                           Map<String, List<String>> claimsExcludingMultiValuedClaims,\n+                                           String profileName) throws UserStoreException, NotImplementedException {\n+\n+        throw new NotImplementedException(\"This functionality is not yet implemented for JDBC userstores.\");", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjEwOTU1OQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r452109559", "bodyText": "created the git issue : wso2/product-is#8659", "author": "AnuradhaSK", "createdAt": "2020-07-09T10:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwODQ4Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNjQyMA==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463906420", "body": "Shall we add this as a `default` method?", "bodyText": "Shall we add this as a default method?", "bodyHTML": "<p dir=\"auto\">Shall we add this as a <code>default</code> method?</p>", "author": "somindatommy", "createdAt": "2020-08-01T01:58:38Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java", "diffHunk": "@@ -236,6 +236,23 @@ void setUserClaimValueWithID(String userID, String claimURI, String claimValue,\n     void setUserClaimValuesWithID(String userID, Map<String, String> claims, String profileName)\n             throws UserStoreException;\n \n+    /**\n+     * Set user claim values.\n+     *\n+     * @param userID                           UserID of the user.\n+     * @param oldClaimMap                      A map of existing claim URIs of the user against values.\n+     * @param multiValuedClaimsToAdd           A map of multi-valued claim URIs against values to add.\n+     * @param multiValuedClaimsToDelete        A map of multi-valued claim URIs against values to delete.\n+     * @param claimsExcludingMultiValuedClaims A map of non-multi-valued claim URIs against values to replace.\n+     * @param profileName                      The profile name, can be null. If null the default profile is considered.\n+     * @throws UserStoreException Thrown if an error occurred in userstore operation.\n+     */\n+    void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjcyMQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499736721", "bodyText": "addressed in fb430db", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNjQyMA=="}], "type": "inlineReview", "revised_code": {"commit": "3f2294363dedc5b782da00e295e7e75f500b9646", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\nindex cbc42c1cf..fbd52c4d7 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\n", "chunk": "@@ -247,11 +247,14 @@ public interface UniqueIDUserStoreManager extends UserStoreManager {\n      * @param profileName                      The profile name, can be null. If null the default profile is considered.\n      * @throws UserStoreException Thrown if an error occurred in userstore operation.\n      */\n-    void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n+    default void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n                                   Map<String, List<String>> multiValuedClaimsToAdd,\n                                   Map<String, List<String>> multiValuedClaimsToDelete,\n                                   Map<String, List<String>> claimsExcludingMultiValuedClaims,\n-                                  String profileName) throws UserStoreException;\n+                                  String profileName) throws UserStoreException {\n+\n+        throw new UserStoreException(\"Operation is not supported.\");\n+    }\n \n     /**\n      * Retrieves a list of users for given user claim value.\n", "next_change": {"commit": "fcde39da236f7f4061e3b5644117c3d04f8adba7", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\nindex fbd52c4d7..7beee02c9 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\n", "chunk": "@@ -236,26 +236,6 @@ public interface UniqueIDUserStoreManager extends UserStoreManager {\n     void setUserClaimValuesWithID(String userID, Map<String, String> claims, String profileName)\n             throws UserStoreException;\n \n-    /**\n-     * Set user claim values.\n-     *\n-     * @param userID                           UserID of the user.\n-     * @param oldClaimMap                      A map of existing claim URIs of the user against values.\n-     * @param multiValuedClaimsToAdd           A map of multi-valued claim URIs against values to add.\n-     * @param multiValuedClaimsToDelete        A map of multi-valued claim URIs against values to delete.\n-     * @param claimsExcludingMultiValuedClaims A map of non-multi-valued claim URIs against values to replace.\n-     * @param profileName                      The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException Thrown if an error occurred in userstore operation.\n-     */\n-    default void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n-                                  Map<String, List<String>> multiValuedClaimsToAdd,\n-                                  Map<String, List<String>> multiValuedClaimsToDelete,\n-                                  Map<String, List<String>> claimsExcludingMultiValuedClaims,\n-                                  String profileName) throws UserStoreException {\n-\n-        throw new UserStoreException(\"Operation is not supported.\");\n-    }\n-\n     /**\n      * Retrieves a list of users for given user claim value.\n      *\n", "next_change": {"commit": "e08b9e45db7e61ed00333444cf76f9044095e50c", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\nindex 7beee02c9..cbc42c1cf 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\n", "chunk": "@@ -236,6 +236,23 @@ public interface UniqueIDUserStoreManager extends UserStoreManager {\n     void setUserClaimValuesWithID(String userID, Map<String, String> claims, String profileName)\n             throws UserStoreException;\n \n+    /**\n+     * Set user claim values.\n+     *\n+     * @param userID                           UserID of the user.\n+     * @param oldClaimMap                      A map of existing claim URIs of the user against values.\n+     * @param multiValuedClaimsToAdd           A map of multi-valued claim URIs against values to add.\n+     * @param multiValuedClaimsToDelete        A map of multi-valued claim URIs against values to delete.\n+     * @param claimsExcludingMultiValuedClaims A map of non-multi-valued claim URIs against values to replace.\n+     * @param profileName                      The profile name, can be null. If null the default profile is considered.\n+     * @throws UserStoreException Thrown if an error occurred in userstore operation.\n+     */\n+    void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n+                                  Map<String, List<String>> multiValuedClaimsToAdd,\n+                                  Map<String, List<String>> multiValuedClaimsToDelete,\n+                                  Map<String, List<String>> claimsExcludingMultiValuedClaims,\n+                                  String profileName) throws UserStoreException;\n+\n     /**\n      * Retrieves a list of users for given user claim value.\n      *\n", "next_change": {"commit": "fc932b05f8215d6d5fc6bfe0ca30902a75f64eb1", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\nindex cbc42c1cf..fbd52c4d7 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/UniqueIDUserStoreManager.java\n", "chunk": "@@ -247,11 +247,14 @@ public interface UniqueIDUserStoreManager extends UserStoreManager {\n      * @param profileName                      The profile name, can be null. If null the default profile is considered.\n      * @throws UserStoreException Thrown if an error occurred in userstore operation.\n      */\n-    void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n+    default void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n                                   Map<String, List<String>> multiValuedClaimsToAdd,\n                                   Map<String, List<String>> multiValuedClaimsToDelete,\n                                   Map<String, List<String>> claimsExcludingMultiValuedClaims,\n-                                  String profileName) throws UserStoreException;\n+                                  String profileName) throws UserStoreException {\n+\n+        throw new UserStoreException(\"Operation is not supported.\");\n+    }\n \n     /**\n      * Retrieves a list of users for given user claim value.\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNjY4Ng==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463906686", "body": "In my opinion, we do not need this log. WDYT?", "bodyText": "In my opinion, we do not need this log. WDYT?", "bodyHTML": "<p dir=\"auto\">In my opinion, we do not need this log. WDYT?</p>", "author": "somindatommy", "createdAt": "2020-08-01T02:01:07Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -595,6 +595,29 @@ protected void doSetUserAttributes(String userName, Map<String, String> processe\n         throw new NotImplementedException(\"doSetUserAttributes operation is not implemented in: \" + this.getClass());\n     }\n \n+    /**\n+     * Set the user attributes of a user.\n+     *\n+     * @param userName                 UserName of the user.\n+     * @param claimAttributesToAdd     A processed map of userstore attribute values to add.\n+     * @param claimAttributesToDelete  A processed map of userstore attribute values to delte.\n+     * @param claimAttributesToReplace A processed map of userstore attribute values to replace.\n+     * @param profileName              The profile name, can be null. If null the default profile is considered.\n+     * @throws UserStoreException      Thrown if the userstore operation fails.\n+     * @throws NotImplementedException Thrown if the operation is not implemented in the underlying userstore.\n+     */\n+    protected void doSetUserAttributes(String userName, Map<String, List<String>> claimAttributesToAdd,\n+                                             Map<String, List<String>> claimAttributesToDelete,\n+                                             Map<String, List<String>> claimAttributesToReplace, String profileName)\n+            throws UserStoreException, NotImplementedException {\n+\n+        if (log.isDebugEnabled()) {", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1OTcwNQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r500459705", "bodyText": "fixed in 0b9e061", "author": "AnuradhaSK", "createdAt": "2020-10-06T17:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNjY4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0b9e0615f73df04ff560b0323874d376248c8758", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 86f03821a..66e178591 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -611,10 +615,6 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n                                              Map<String, List<String>> claimAttributesToReplace, String profileName)\n             throws UserStoreException, NotImplementedException {\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doSetUserAttributes operation is not implemented in: \" + this.getClass());\n-        }\n-\n         throw new NotImplementedException(\"doSetUserAttributes operation is not implemented in: \" + this.getClass());\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNjc1MQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463906751", "body": "In my opinion, we do not need this log. WDYT?", "bodyText": "In my opinion, we do not need this log. WDYT?", "bodyHTML": "<p dir=\"auto\">In my opinion, we do not need this log. WDYT?</p>", "author": "somindatommy", "createdAt": "2020-08-01T02:01:48Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -615,6 +638,29 @@ protected void doSetUserAttributesWithID(String userID,\n                 + this.getClass());\n     }\n \n+    /**\n+     * Set the user attributes of a user.\n+     *\n+     * @param userID                   UserID of the user.\n+     * @param claimAttributesToAdd     A processed map of userstore attribute values to add.\n+     * @param claimAttributesToDelete  A processed map of userstore attribute values to delete.\n+     * @param claimAttributesToReplace A processed map of userstore attribute values to replace.\n+     * @param profileName              The profile name, can be null. If null the default profile is considered.\n+     * @throws UserStoreException      Thrown if the userstore operation fails.\n+     * @throws NotImplementedException Thrown if the operation is not implemented in the underlying userstore.\n+     */\n+    protected void doSetUserAttributesWithID(String userID, Map<String, List<String>> claimAttributesToAdd,\n+                                             Map<String, List<String>> claimAttributesToDelete,\n+                                             Map<String, List<String>> claimAttributesToReplace, String profileName)\n+            throws UserStoreException, NotImplementedException {\n+\n+        if (log.isDebugEnabled()) {", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1OTY0NA==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r500459644", "bodyText": "fixed in 0b9e061", "author": "AnuradhaSK", "createdAt": "2020-10-06T17:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNjc1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0b9e0615f73df04ff560b0323874d376248c8758", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 86f03821a..66e178591 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -654,9 +654,6 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n                                              Map<String, List<String>> claimAttributesToReplace, String profileName)\n             throws UserStoreException, NotImplementedException {\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doSetUserAttributesWithID operation is not implemented in: \" + this.getClass());\n-        }\n         throw new NotImplementedException(\"doSetUserAttributesWithID operation is not implemented in: \"\n                 + this.getClass());\n     }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "518b7af0f2f3740d640e87b712d71a2a8dd54fa9", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 86f03821a..66e178591 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -654,9 +654,6 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n                                              Map<String, List<String>> claimAttributesToReplace, String profileName)\n             throws UserStoreException, NotImplementedException {\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doSetUserAttributesWithID operation is not implemented in: \" + this.getClass());\n-        }\n         throw new NotImplementedException(\"doSetUserAttributesWithID operation is not implemented in: \"\n                 + this.getClass());\n     }\n", "next_change": {"commit": "224cc38bdaf5d709293e8a85116585ef69ee6745", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 66e178591..fe6bdb8e2 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -38,15426 +47,3558 @@ import org.wso2.carbon.user.core.authorization.AuthorizationCache;\n import org.wso2.carbon.user.core.claim.Claim;\n import org.wso2.carbon.user.core.claim.ClaimManager;\n import org.wso2.carbon.user.core.claim.ClaimMapping;\n-import org.wso2.carbon.user.core.config.UserStorePreferenceOrderSupplier;\n-import org.wso2.carbon.user.core.constants.UserCoreClaimConstants;\n-import org.wso2.carbon.user.core.constants.UserCoreErrorConstants;\n-import org.wso2.carbon.user.core.constants.UserCoreErrorConstants.ErrorMessages;\n import org.wso2.carbon.user.core.dto.RoleDTO;\n import org.wso2.carbon.user.core.hybrid.HybridRoleManager;\n import org.wso2.carbon.user.core.internal.UMListenerServiceComponent;\n-import org.wso2.carbon.user.core.internal.UserStoreMgtDSComponent;\n-import org.wso2.carbon.user.core.jdbc.JDBCUserStoreManager;\n import org.wso2.carbon.user.core.ldap.LDAPConstants;\n-import org.wso2.carbon.user.core.listener.SecretHandleableListener;\n-import org.wso2.carbon.user.core.listener.UniqueIDUserManagementErrorEventListener;\n-import org.wso2.carbon.user.core.listener.UniqueIDUserOperationEventListener;\n-import org.wso2.carbon.user.core.listener.UserManagementErrorEventListener;\n import org.wso2.carbon.user.core.listener.UserOperationEventListener;\n import org.wso2.carbon.user.core.listener.UserStoreManagerConfigurationListener;\n import org.wso2.carbon.user.core.listener.UserStoreManagerListener;\n-import org.wso2.carbon.user.core.model.Condition;\n-import org.wso2.carbon.user.core.model.ExpressionCondition;\n-import org.wso2.carbon.user.core.model.ExpressionOperation;\n-import org.wso2.carbon.user.core.model.OperationalCondition;\n-import org.wso2.carbon.user.core.model.OperationalOperation;\n-import org.wso2.carbon.user.core.model.UniqueIDUserClaimSearchEntry;\n-import org.wso2.carbon.user.core.model.UserClaimSearchEntry;\n-import org.wso2.carbon.user.core.model.UserMgtContext;\n import org.wso2.carbon.user.core.profile.ProfileConfigurationManager;\n-import org.wso2.carbon.user.core.service.RealmService;\n import org.wso2.carbon.user.core.system.SystemUserRoleManager;\n import org.wso2.carbon.user.core.util.UserCoreUtil;\n-import org.wso2.carbon.utils.Secret;\n-import org.wso2.carbon.utils.UnsupportedSecretTypeException;\n+import org.wso2.carbon.utils.multitenancy.MultitenantConstants;\n import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n \n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-import java.nio.CharBuffer;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.UUID;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n+public abstract class AbstractUserStoreManager implements UserStoreManager {\n+\n+\tprivate static Log log = LogFactory.getLog(AbstractUserStoreManager.class);\n+\n+\tprotected int tenantId;\n+\tprotected DataSource dataSource = null;\n+\tprotected RealmConfiguration realmConfig = null;\n+\tprotected ClaimManager claimManager = null;\n+\tprotected UserRealm userRealm = null;\n+\tprotected HybridRoleManager hybridRoleManager = null;\n+\n+\t// User roles cache\n+\tprotected UserRolesCache userRolesCache = null;\n+\tprotected SystemUserRoleManager systemUserRoleManager = null;\n+\tprotected boolean readGroupsEnabled = false;\n+\tprotected boolean writeGroupsEnabled = false;\n+\tprivate UserStoreManager secondaryUserStoreManager;\n+\tprivate boolean userRolesCacheEnabled = true;\n+\tprivate String cacheIdentifier;\n+\tprivate boolean replaceEscapeCharactersAtUserLogin = true;\n+\tprivate Map<String, UserStoreManager> userStoreManagerHolder = new HashMap<String, UserStoreManager>();\n+\tprivate Map<String, Integer> maxUserListCount = null;\n+\tprivate Map<String, Integer> maxRoleListCount = null;\n+\tprivate List<UserStoreManagerConfigurationListener> listener = new ArrayList<UserStoreManagerConfigurationListener>();\n+\n+\tprivate static final String MAX_LIST_LENGTH = \"100\";\n+\n+\tprotected static final String TRUE_VALUE = \"true\";\n+\tprotected static final String FALSE_VALUE = \"false\";\n+\n+\t/**\n+\t * This method is used by the support system to read properties\n+\t */\n+\tprotected abstract Map<String, String> getUserPropertyValues(String userName,\n+\t\t\tString[] propertyNames, String profileName) throws UserStoreException;\n+\n+\t/**\n+\t * \n+\t * @param roleName\n+\t * @return\n+\t */\n+\tprotected abstract boolean doCheckExistingRole(String roleName) throws UserStoreException;\n \n-import javax.sql.DataSource;\n+    /**\n+     * Creates the search base and other relevant parameters for the provided role name\n+     * @param roleName\n+     * @return\n+     */\n+    protected abstract RoleContext createRoleContext(String roleName) throws UserStoreException;\n \n-import static org.wso2.carbon.user.core.UserCoreConstants.SYSTEM_DOMAIN_NAME;\n-import static org.wso2.carbon.user.core.UserStoreConfigConstants.RESOLVE_USER_ID_FROM_USER_NAME_CACHE_NAME;\n-import static org.wso2.carbon.user.core.UserStoreConfigConstants.RESOLVE_USER_NAME_FROM_UNIQUE_USER_ID_CACHE_NAME;\n-import static org.wso2.carbon.user.core.UserStoreConfigConstants.RESOLVE_USER_NAME_FROM_USER_ID_CACHE_NAME;\n-import static org.wso2.carbon.user.core.UserStoreConfigConstants.RESOLVE_USER_UNIQUE_ID_FROM_USER_NAME_CACHE_NAME;\n-import static org.wso2.carbon.user.core.constants.UserCoreErrorConstants.ErrorMessages.ERROR_CODE_DUPLICATE_WHILE_ADDING_A_HYBRID_ROLE;\n-import static org.wso2.carbon.user.core.constants.UserCoreErrorConstants.ErrorMessages.ERROR_CODE_DUPLICATE_WHILE_ADDING_A_SYSTEM_ROLE;\n-import static org.wso2.carbon.user.core.constants.UserCoreErrorConstants.ErrorMessages.ERROR_CODE_DUPLICATE_WHILE_ADDING_A_SYSTEM_USER;\n-import static org.wso2.carbon.user.core.constants.UserCoreErrorConstants.ErrorMessages.ERROR_CODE_DUPLICATE_WHILE_ADDING_A_USER;\n-import static org.wso2.carbon.user.core.constants.UserCoreErrorConstants.ErrorMessages.ERROR_CODE_DUPLICATE_WHILE_ADDING_ROLE;\n-import static org.wso2.carbon.user.core.constants.UserCoreErrorConstants.ErrorMessages.ERROR_CODE_ROLE_ALREADY_EXISTS;\n-import static org.wso2.carbon.utils.multitenancy.MultitenantConstants.SUPER_TENANT_ID;\n-\n-public abstract class AbstractUserStoreManager implements PaginatedUserStoreManager,\n-        UniqueIDUserStoreManager {\n-\n-    protected static final String TRUE_VALUE = \"true\";\n-    protected static final String FALSE_VALUE = \"false\";\n-    protected static final String QUERY_FILTER_STRING_ANY = \"*\";\n-    protected static final int QUERY_MAX_ITEM_LIMIT_ANY = -1;\n-    private static final String MAX_LIST_LENGTH = \"100\";\n-    private static final int MAX_ITEM_LIMIT_UNLIMITED = -1;\n-    private static final String MULIPLE_ATTRIBUTE_ENABLE = \"MultipleAttributeEnable\";\n-    private static final String DISAPLAY_NAME_CLAIM = \"http://wso2.org/claims/displayName\";\n-    private static final String SCIM_USERNAME_CLAIM_URI = \"urn:scim:schemas:core:1.0:userName\";\n-    private static final String SCIM2_USERNAME_CLAIM_URI = \"urn:ietf:params:scim:schemas:core:2.0:User:userName\";\n-    protected static final String USERNAME_CLAIM_URI = \"http://wso2.org/claims/username\";\n-    private static final String APPLICATION_DOMAIN = \"Application\";\n-    private static final String WORKFLOW_DOMAIN = \"Workflow\";\n-    private static final String INVALID_CLAIM_URL = \"InvalidClaimUrl\";\n-    private static final String INVALID_USER_NAME = \"InvalidUserName\";\n-    private static final String READ_ONLY_STORE = \"ReadOnlyUserStoreManager\";\n-    private static final String READ_ONLY_PRIMARY_STORE = \"ReadOnlyPrimaryUserStoreManager\";\n-    private static final String ADMIN_USER = \"AdminUser\";\n-    private static final String PROPERTY_PASSWORD_ERROR_MSG = \"PasswordJavaRegExViolationErrorMsg\";\n-    private static final String MULTI_ATTRIBUTE_SEPARATOR = \"MultiAttributeSeparator\";\n-    private static Log log = LogFactory.getLog(AbstractUserStoreManager.class);\n-    protected int tenantId;\n-    protected DataSource dataSource = null;\n-    protected RealmConfiguration realmConfig = null;\n-    protected ClaimManager claimManager = null;\n-    protected UserRealm userRealm = null;\n-    protected HybridRoleManager hybridRoleManager = null;\n-    // User roles cache\n-    protected UserRolesCache userRolesCache = null;\n-    protected SystemUserRoleManager systemUserRoleManager = null;\n-    protected boolean readGroupsEnabled = false;\n-    protected boolean writeGroupsEnabled = false;\n-    private UserStoreManager secondaryUserStoreManager;\n-    private boolean userRolesCacheEnabled = true;\n-    private String cacheIdentifier;\n-    private boolean replaceEscapeCharactersAtUserLogin = true;\n-    private Map<String, UserStoreManager> userStoreManagerHolder = new HashMap<String, UserStoreManager>();\n-    private Map<String, Integer> maxUserListCount = null;\n-    private Map<String, Integer> maxRoleListCount = null;\n-    private List<UserStoreManagerConfigurationListener> listener = new ArrayList<UserStoreManagerConfigurationListener>();\n-    private static final ThreadLocal<Boolean> isSecureCall = new ThreadLocal<Boolean>() {\n-        @Override\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n+\t/**\n+\t * \n+\t * @param userName\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected abstract boolean doCheckExistingUser(String userName) throws UserStoreException;\n+\n+\t/**\n+\t * Retrieves a list of user names for given user's property in user profile\n+\t * \n+\t * @param property user property in user profile\n+\t * @param value value of property\n+\t * @param profileName profile name, can be null. If null the default profile is considered.\n+\t * @return An array of user names\n+\t * @throws UserStoreException if the operation failed\n+\t */\n+\tprotected abstract String[] getUserListFromProperties(String property, String value,\n+\t\t\tString profileName) throws UserStoreException;\n+\n+\t/**\n+\t * Given the user name and a credential object, the implementation code must validate whether\n+\t * the user is authenticated.\n+\t * \n+\t * @param userName The user name\n+\t * @param credential The credential of a user\n+\t * @return If the value is true the provided credential match with the user name. False is\n+\t *         returned for invalid credential, invalid user name and mismatching credential with\n+\t *         user name.\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract boolean doAuthenticate(String userName, Object credential)\n+\t\t\tthrows UserStoreException;\n+\n+\t/**\n+\t * Add a user to the user store.\n+\t * \n+\t * @param userName User name of the user\n+\t * @param credential The credential/password of the user\n+\t * @param roleList The roles that user belongs\n+\t * @param claims Properties of the user\n+\t * @param profileName profile name, can be null. If null the default profile is considered.\n+\t * @param requirePasswordChange whether password required is need\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doAddUser(String userName, Object credential, String[] roleList,\n+\t\t\tMap<String, String> claims, String profileName, boolean requirePasswordChange)\n+\t\t\tthrows UserStoreException;\n+\n+\t/**\n+\t * Update the credential/password of the user\n+\t * \n+\t * @param userName The user name\n+\t * @param newCredential The new credential/password\n+\t * @param oldCredential The old credential/password\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doUpdateCredential(String userName, Object newCredential,\n+\t\t\tObject oldCredential) throws UserStoreException;\n+\n+\t/**\n+\t * Update credential/password by the admin of another user\n+\t * \n+\t * @param userName The user name\n+\t * @param newCredential The new credential\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doUpdateCredentialByAdmin(String userName, Object newCredential)\n+\t\t\tthrows UserStoreException;\n+\n+\t/**\n+\t * Delete the user with the given user name\n+\t * \n+\t * @param userName The user name\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doDeleteUser(String userName) throws UserStoreException;\n+\n+\t/**\n+\t * Set a single user claim value\n+\t * \n+\t * @param userName The user name\n+\t * @param claimURI The claim URI\n+\t * @param claimValue The value\n+\t * @param profileName The profile name, can be null. If null the default profile is considered.\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doSetUserClaimValue(String userName, String claimURI,\n+\t\t\tString claimValue, String profileName) throws UserStoreException;\n+\n+\t/**\n+\t * Set many user claim values\n+\t * \n+\t * @param userName The user name\n+\t * @param claims Map of claim URIs against values\n+\t * @param profileName The profile name, can be null. If null the default profile is considered.\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doSetUserClaimValues(String userName, Map<String, String> claims,\n+\t\t\tString profileName) throws UserStoreException;\n+\n+\t/**\n+\t * o * Delete a single user claim value\n+\t * \n+\t * @param userName The user name\n+\t * @param claimURI Name of the claim\n+\t * @param profileName The profile name, can be null. If null the default profile is considered.\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doDeleteUserClaimValue(String userName, String claimURI,\n+\t\t\tString profileName) throws UserStoreException;\n+\n+\t/**\n+\t * Delete many user claim values.\n+\t * \n+\t * @param userName The user name\n+\t * @param claims URIs of the claims to be deleted.\n+\t * @param profileName The profile name, can be null. If null the default profile is considered.\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doDeleteUserClaimValues(String userName, String[] claims,\n+\t\t\tString profileName) throws UserStoreException;\n+\n+\t/**\n+\t * Update user list of a particular role\n+\t * \n+\t * @param roleName The role name\n+\t * @param deletedUsers Array of user names, that is going to be removed from the role\n+\t * @param newUsers Array of user names, that is going to be added to the role\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doUpdateUserListOfRole(String roleName, String[] deletedUsers,\n+\t\t\tString[] newUsers) throws UserStoreException;\n+\n+\t/**\n+\t * Update role list of a particular user\n+\t * \n+\t * @param userName The user name\n+\t * @param deletedRoles Array of role names, that is going to be removed from the user\n+\t * @param newRoles Array of role names, that is going to be added to the user\n+\t * @throws UserStoreException An unexpected exception has occurred\n+\t */\n+\tprotected abstract void doUpdateRoleListOfUser(String userName, String[] deletedRoles,\n+\t\t\tString[] newRoles) throws UserStoreException;\n+\n+\t/**\n+\t * Only gets the internal roles of the user with internal domain name\n+\t * \n+\t * @param userName Name of the user - who we need to find roles.\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected String[] doGetInternalRoleListOfUser(String userName, String filter) throws UserStoreException {\n+\t\treturn hybridRoleManager.getHybridRoleListOfUser(userName, filter);\n+\t}\n+\n+\t/**\n+\t * Only gets the external roles of the user.\n+\t * \n+\t * @param userName Name of the user - who we need to find roles.\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected abstract String[] doGetExternalRoleListOfUser(String userName, String filter)\n+\t\t\tthrows UserStoreException;\n+\t\n+\n+\t/**\n+\t * Returns the shared roles list of the user\n+\t * \n+\t * @param userName\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected abstract String[] doGetSharedRoleListOfUser(String userName,\n+                                    String tenantDomain, String filter) throws UserStoreException;\n+\n+\t/**\n+\t * Add role with a list of users and permissions provided.\n+\t * \n+\t * @param roleName\n+\t * @param userList\n+\t * @throws UserStoreException\n+\t */\n+\tprotected abstract void doAddRole(String roleName, String[] userList, boolean shared) throws UserStoreException;\n+\n+\n+\t/**\n+\t * delete the role.\n+\t * \n+\t * @param roleName\n+\t * @throws UserStoreException\n+\t */\n+\tprotected abstract void doDeleteRole(String roleName) throws UserStoreException;\n+\n+\t/**\n+\t * update the role name with the new name\n+\t * \n+\t * @param roleName\n+\t * @param newRoleName\n+\t * @throws UserStoreException\n+\t */\n+\tprotected abstract void doUpdateRoleName(String roleName, String newRoleName)\n+\t\t\tthrows UserStoreException;\n+\n+\t/**\n+\t * This method would returns the role Name actually this must be implemented in interface. As it\n+\t * is not good to change the API in point release. This has been added to Abstract class\n+\t * \n+\t * @param filter\n+\t * @param maxItemLimit\n+\t * @return\n+\t * @throws .UserStoreException\n+\t */\n+\tprotected abstract String[] doGetRoleNames(String filter, int maxItemLimit)\n+\t\t\tthrows UserStoreException;\n+\t\t\n+\t/**\n+\t * \n+\t * @param filter\n+\t * @param maxItemLimit\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected abstract String[] doListUsers(String filter, int maxItemLimit)\n+\t\t\tthrows UserStoreException;\n \n-    private UserUniqueIDManger userUniqueIDManger = new UserUniqueIDManger();\n-    private UserUniqueIDDomainResolver userUniqueIDDomainResolver;\n+    /*This is to get the display names of users in hybrid role according to the underlying user store, to be shown in UI*/\n+    protected abstract String[] doGetDisplayNamesForInternalRole(String[] userNames)\n+            throws UserStoreException;\n \n-    private void setClaimManager(ClaimManager claimManager) throws IllegalAccessException {\n-        if (Boolean.parseBoolean(realmConfig.getRealmProperty(UserCoreClaimConstants.INITIALIZE_NEW_CLAIM_MANAGER))) {\n-            this.claimManager = claimManager;\n-        } else {\n-            throw new IllegalAccessException(\"Set claim manager is not allowed\");\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final boolean authenticate(String userName, Object credential) throws UserStoreException {\n+        if (userName == null || credential == null) {\n+            log.error(\"Authentication failure. Either Username or Password is null\");\n+            return false;\n+        }\n+        int index = userName != null ? userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) : -1;\n+\t\tboolean domainProvided = index > 0;\n+\t\treturn authenticate(userName, credential, domainProvided);\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param userName\n+\t * @param credential\n+\t * @param domainProvided\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected boolean authenticate(String userName, Object credential, boolean domainProvided)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tboolean authenticated = false;\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\treturn userStore.getUserStoreManager().authenticate(userStore.getDomainFreeName(),\n+\t\t\t\t\tcredential, domainProvided);\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserStoreManagerListeners()) {\n+\t\t\tif (!listener.authenticate(userName, credential, this)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreAuthenticate(userName, credential, this)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\t// We are here due to two reason. Either there is no secondary UserStoreManager or no\n+\t\t// domain name provided with user name.\n+\t\t\n+\t\ttry {\n+\t\t\t// Let's authenticate with the primary UserStoreManager.\n+\t\t\tauthenticated = doAuthenticate(userName, credential);\n+\t\t} catch (Exception e) {\n+\t\t\t// We can ignore and proceed. Ignore the results from this user store.\n+\t\t\tlog.error(e);\n+\t\t\tauthenticated = false;\n+\t\t}\n+\t\t\n+\t\tif (authenticated) {\n+\t\t\t// Set domain in thread local variable for subsequent operations\n+            String domain = UserCoreUtil.getDomainName(this.realmConfig);\n+            if (domain != null) {\n+                UserCoreUtil.setDomainInThreadLocal(domain.toUpperCase());\n+            }\n+        }\n+\n+\t\t// If authentication fails in the previous step and if the user has not specified a\n+\t\t// domain- then we need to execute chained UserStoreManagers recursively.\n+\t\tif (!authenticated && !domainProvided && this.getSecondaryUserStoreManager() != null) {\n+\t\t\tauthenticated = ((AbstractUserStoreManager) this.getSecondaryUserStoreManager())\n+\t\t\t\t\t.authenticate(userName, credential, domainProvided);\n+            return authenticated;\n+\t\t}\n+\n+\t\t// You cannot change authentication decision in post handler to TRUE\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostAuthenticate(userName, authenticated, this)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (log.isDebugEnabled()) {\n+\t\t\tif (!authenticated) {\n+\t\t\t\tlog.debug(\"Authentication failure. Wrong username or password is provided.\");\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn authenticated;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final String getUserClaimValue(String userName, String claim, String profileName)\n+\t\t\tthrows UserStoreException {\n+\n+        // If user does not exist, just return\n+        if (!isExistingUser(userName)) {\n+            return null;\n         }\n-    }\n \n-    /**\n-     * This method is used by the APIs' in the AbstractUserStoreManager\n-     * to make compatible with Java Security Manager.\n-     */\n-    private Object callSecure(final String methodName, final Object[] objects, final Class[] argTypes)\n-            throws UserStoreException {\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\treturn userStore.getUserStoreManager().getUserClaimValue(userStore.getDomainFreeName(),\n+\t\t\t\t\tclaim, profileName);\n+\t\t}\n \n-        final AbstractUserStoreManager instance = this;\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n \n-        isSecureCall.set(Boolean.TRUE);\n-        final Method method;\n-        try {\n-            Class clazz = Class.forName(\"org.wso2.carbon.user.core.common.AbstractUserStoreManager\");\n-            method = clazz.getDeclaredMethod(methodName, argTypes);\n-\n-        } catch (NoSuchMethodException e) {\n-            log.error(\"Error occurred when calling method \" + methodName, e);\n-            throw new UserStoreException(e);\n-        } catch (ClassNotFoundException e) {\n-            log.error(\"Error occurred when calling class \" + methodName, e);\n-            throw new UserStoreException(e);\n-        }\n \n-        try {\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n-                @Override\n-                public Object run() throws Exception {\n-                    return method.invoke(instance, objects);\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            if (e.getCause() != null && e.getCause().getCause() != null && e.getCause().getCause() instanceof\n-                    UserStoreException) {\n-                if (((UserStoreException) e.getCause().getCause()).getErrorCode() != null) {\n-                    throw new UserStoreException(e.getCause().getCause().getMessage(),\n-                            ((UserStoreException) e.getCause().getCause()).getErrorCode(), e);\n-                }\n-                // Actual UserStoreException get wrapped with two exceptions\n-                throw new UserStoreException(e.getCause().getCause().getMessage(), e);\n \n-            } else {\n-                String msg;\n-                if (objects != null && argTypes != null) {\n-                    msg = \"Error occurred while accessing Java Security Manager Privilege Block when called by \" +\n-                            \"method \" + methodName + \" with \" + objects.length + \" length of Objects and argTypes \" +\n-                            Arrays.toString(argTypes);\n-                } else {\n-                    msg = \"Error occurred while accessing Java Security Manager Privilege Block\";\n-                }\n-                log.error(msg);\n-                throw new UserStoreException(msg, e);\n-            }\n-        } finally {\n-            isSecureCall.set(Boolean.FALSE);\n+        Map<String, String> finalValues = doGetUserClaimValues(userName, new String[] {claim}, \n+                userStore.getDomainName(), profileName);\n+\n+        String value = null;\n+\n+        if(finalValues != null){\n+\t\t    value = finalValues.get(claim);\n         }\n-    }\n \n-    /**\n-     * This method is used by the support system to read properties\n-     */\n-    protected abstract Map<String, String> getUserPropertyValues(String userName,\n-                                                                 String[] propertyNames, String profileName)\n-            throws UserStoreException;\n+\t\t// #################### <Listeners> #####################################################\n \n-    /**\n-     * This method is used to read properties of the given user.\n-     *\n-     * @param userID        user ID.\n-     * @param propertyNames property names.\n-     * @param profileName   profile name.\n-     * @return user properties of the given user.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected Map<String, String> getUserPropertyValuesWithID(String userID, String[] propertyNames, String profileName)\n-            throws UserStoreException {\n+        List<String> list = new ArrayList<String>();\n+\t\tif (value != null) {\n+\t\t\tlist.add(value);\n+\t\t}\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"getUserPropertyValuesWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"getUserPropertyValuesWithID operation is not implemented in: \" + this.getClass());\n-    }\n-    /**\n-     * @param roleName\n-     * @return\n-     */\n-    protected abstract boolean doCheckExistingRole(String roleName) throws UserStoreException;\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (listener instanceof AbstractUserOperationEventListener) {\n+\t\t\t\tAbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n+\t\t\t\tif (!newListener.doPostGetUserClaimValue(userName, claim, list, profileName, this)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n \n-    /**\n-     * Creates the search base and other relevant parameters for the provided role name\n-     *\n-     * @param roleName\n-     * @return\n-     */\n-    protected abstract RoleContext createRoleContext(String roleName) throws UserStoreException;\n+\t\treturn value;\n+\t}\n \n-    /**\n-     * @param userName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    protected abstract boolean doCheckExistingUser(String userName) throws UserStoreException;\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final Claim[] getUserClaimValues(String userName, String profileName)\n+\t\t\tthrows UserStoreException {\n \n-    /**\n-     * Check whether the username exists in the systems which supports unique user ID feature.\n-     *\n-     * @param userName user name.\n-     * @return Whether the user is existing in the user store.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected boolean doCheckExistingUserNameWithIDImpl(String userName) throws UserStoreException {\n+        // If user does not exist, just return\n+        if (!isExistingUser(userName)) {\n+            return null;\n+        }\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doCheckExistingUserNameWithIDImpl operation is not implemented in: \" + this.getClass());\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\treturn userStore.getUserStoreManager().getUserClaimValues(\n+\t\t\t\t\tuserStore.getDomainFreeName(), profileName);\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif (profileName == null || profileName.trim().length() == 0) {\n+\t\t\tprofileName = UserCoreConstants.DEFAULT_PROFILE;\n+\t\t}\n+\n+\t\tString[] claims;\n+\t\ttry {\n+\t\t\tclaims = claimManager.getAllClaimUris();\n+\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n+\t\t\tthrow new UserStoreException(e);\n+\t\t}\n+\n+\t\tMap<String, String> values = this.getUserClaimValues(userName, claims, profileName);\n+\t\tClaim[] finalValues = new Claim[values.size()];\n+\t\tint i = 0;\n+\t\tfor (Iterator<Map.Entry<String, String>> ite = values.entrySet().iterator(); ite.hasNext();) {\n+\t\t\tMap.Entry<String, String> entry = ite.next();\n+\t\t\tClaim claim = new Claim();\n+\t\t\tclaim.setValue(entry.getValue());\n+\t\t\tclaim.setClaimUri(entry.getKey());\n+\t\t\tString displayTag;\n+\t\t\ttry {\n+\t\t\t\tdisplayTag = claimManager.getClaim(entry.getKey()).getDisplayTag();\n+\t\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n+\t\t\t\tthrow new UserStoreException(e);\n+\t\t\t}\n+\t\t\tclaim.setDisplayTag(displayTag);\n+\t\t\tfinalValues[i] = claim;\n+\t\t\ti++;\n+\t\t}\n+\n+\t\treturn finalValues;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final Map<String, String> getUserClaimValues(String userName, String[] claims,\n+\t\t\tString profileName) throws UserStoreException {\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\treturn userStore.getUserStoreManager().getUserClaimValues(\n+\t\t\t\t\tuserStore.getDomainFreeName(), claims, profileName);\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tMap<String, String> finalValues = doGetUserClaimValues(userName, claims,\n+                userStore.getDomainName(), profileName);\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (listener instanceof AbstractUserOperationEventListener) {\n+\t\t\t\tAbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n+\t\t\t\tif (!newListener.doPostGetUserClaimValues(userStore.getDomainFreeName(), claims, profileName,\n+\t\t\t\t\t\tfinalValues, this)) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\treturn finalValues;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc} TODO : This does not support multiple user stores yet.\n+\t */\n+\tpublic final String[] getUserList(String claim, String claimValue, String profileName)\n+\t                                                                                      throws UserStoreException {\n+\n+\t\tString property;\n+\t\tString domainName = null;\n+\t\ttry {\n+\t\t\t// Attributed id from corresponding to the underlying user store,\n+\t\t\t// corresponding to the\n+\t\t\t// domain which this user store manager belongs to.\n+\t\t\tdomainName = this.getMyDomainName();\n+\t\t\tif (domainName != null && !domainName.isEmpty() &&\n+\t\t\t    !domainName.equals(UserStoreConfigConstants.PRIMARY)) {\n+\t\t\t\tproperty = claimManager.getAttributeName(domainName, claim);\n+\t\t\t\tif (property == null) {\n+\t\t\t\t\t// claim is not defined for the secondary user store. In\n+\t\t\t\t\t// this case property is taken from the primary user store\n+\t\t\t\t\tproperty = claimManager.getAttributeName(claim);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tproperty = claimManager.getAttributeName(claim);\n+\t\t\t}\n+\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n+\t\t\tthrow new UserStoreException(e);\n+\t\t}\n+\n+\t\tif (property == null) {\n+\t\t\tthrow new UserStoreException(\"Claim \" + claim + \" is not defined for \" +\n+\t\t\t                             this.getMyDomainName());\n+\t\t}\n+\n+\t\tString[] userList = getUserListFromProperties(property, claimValue, profileName);\n+\n+\t\tif ((userList == null || userList.length < 1) &&\n+\t\t    this.getSecondaryUserStoreManager() != null) {\n+\t\t\tif (log.isDebugEnabled()) {\n+\t\t\t\tString currentDomain = this.getMyDomainName();\n+\t\t\t\tString childDomain =\n+\t\t\t\t                     ((AbstractUserStoreManager) this.getSecondaryUserStoreManager()).getMyDomainName();\n+\t\t\t\tlog.debug(\"No users found in: \" + currentDomain +\n+\t\t\t\t          \" Looking in the secondary user store \" + childDomain);\n+\t\t\t}\n+\t\t\tuserList =\n+\t\t\t           ((AbstractUserStoreManager) this.getSecondaryUserStoreManager()).getUserList(claim,\n+\t\t\t                                                                                        claimValue,\n+\t\t\t                                                                                        profileName);\n+\n+\t\t} else if (!UserStoreConfigConstants.PRIMARY.equals(domainName)) {\n+\t\t\t// if we find any result, we should append the domain\n+\t\t\tList<String> usersWithDomain = new ArrayList<String>();\n+\t\t\tfor (String user : userList) {\n+\t\t\t\tif (log.isDebugEnabled()) {\n+\t\t\t\t\tlog.debug(\"Found user: \" + user);\n+\t\t\t\t}\n+\t\t\t\tString nameWithDomain = UserCoreUtil.addDomainToName(user, domainName);\n+\t\t\t\tusersWithDomain.add(nameWithDomain);\n+\t\t\t}\n+\t\t\treturn usersWithDomain.toArray(new String[usersWithDomain.size()]);\n+\t\t}\n+\t\t// no multipe user store configs\n+\t\treturn userList;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void updateCredential(String userName, Object newCredential, Object oldCredential)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().updateCredential(userStore.getDomainFreeName(),\n+\t\t\t\t\tnewCredential, oldCredential);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserStoreManagerListeners()) {\n+\t\t\tif (!listener.updateCredential(userName, newCredential, oldCredential, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreUpdateCredential(userName, newCredential, oldCredential, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\t// This user name here is domain-less.\n+\t\t// We directly authenticate user against the selected UserStoreManager.\n+\t\tboolean isAuth = this.doAuthenticate(userName, oldCredential);\n+\n+\t\tif (isAuth) {\n+\n+\t\t\tthis.doUpdateCredential(userName, newCredential, oldCredential);\n+\n+\t\t\t// #################### <Listeners> ##################################################\n+\t\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\t\tif (!listener.doPostUpdateCredential(userName, newCredential, this)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// #################### </Listeners> ##################################################\n+\n+\t\t\treturn;\n+\t\t} else {\n+\t\t\tthrow new UserStoreException(\n+\t\t\t\t\t\"Old credential does not match with the existing credentials.\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void updateCredentialByAdmin(String userName, Object newCredential)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().updateCredentialByAdmin(userStore.getDomainFreeName(),\n+\t\t\t\t\tnewCredential);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserStoreManagerListeners()) {\n+\t\t\tif (!listener.updateCredentialByAdmin(userName, newCredential, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// using string buffers to allow the password to be changed by listener\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif(newCredential == null) { // a default password will be set\n+\t\t\t\tStringBuffer credBuff = new StringBuffer();\n+\t\t\t\tif (!listener.doPreUpdateCredentialByAdmin(userName, newCredential, this)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tnewCredential = credBuff.toString(); // reading the modified value\n+\t\t\t} else if (newCredential instanceof String) {\n+\t\t\t\tStringBuffer credBuff = new StringBuffer((String)newCredential);\n+\t\t\t\tif (!listener.doPreUpdateCredentialByAdmin(userName, credBuff, this)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tnewCredential = credBuff.toString(); // reading the modified value\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tdoUpdateCredentialByAdmin(userName, newCredential);\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostUpdateCredentialByAdmin(userName, newCredential, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n+\t\n+\t/**\n+\t * Get the attribute for the provided claim uri and identifier.\n+\t * \n+\t * @param claimURI\n+\t * @param identifier\n+\t *            user name or role.\n+\t * @param domainName TODO\n+\t * @return claim attribute value. NULL if attribute is not defined for the\n+\t *         claim uri\n+\t * @throws org.wso2.carbon.user.api.UserStoreException\n+\t */\n+\tprotected String getClaimAtrribute(String claimURI, String identifier, String domainName)\n+\t                                                                      throws org.wso2.carbon.user.api.UserStoreException {\n+\t\tdomainName =\n+\t\t             (domainName == null || domainName.isEmpty())\n+\t\t                                                         ? (identifier.indexOf(UserCoreConstants.DOMAIN_SEPARATOR) > -1\n+\t\t                                                                                                                       ? identifier.split(UserCoreConstants.DOMAIN_SEPARATOR)[0]\n+\t\t                                                                                                                       : realmConfig.getUserStoreProperty(UserStoreConfigConstants.DOMAIN_NAME))\n+\t\t                                                         : domainName;\n+\t\tString attributeName = null;\n+\t\tif (domainName != null && !domainName.equals(UserStoreConfigConstants.PRIMARY)) {\n+\t\t\tattributeName = claimManager.getAttributeName(domainName, claimURI);\n+\t\t}\n+\t\tif (attributeName == null || attributeName.isEmpty()) {\n+\t\t\tattributeName = claimManager.getAttributeName(claimURI);\n+\t\t}\n+\t\treturn attributeName != null ? attributeName : claimURI;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void deleteUser(String userName) throws UserStoreException {\n+\t\t\n+\t\tString loggedInUser = CarbonContext.getThreadLocalCarbonContext().getUsername();\n+\t\tif(loggedInUser!= null && loggedInUser.equals(userName)) {\n+\t\t\tlog.debug(\"User \" + userName + \" tried to delete him/her self\");\n+\t\t\tthrow new UserStoreException(\"Cannot delete logged in user\");\n+\t\t}\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().deleteUser(userStore.getDomainFreeName());\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif (UserCoreUtil.isPrimaryAdminUser(userName, realmConfig)) {\n+\t\t\tthrow new UserStoreException(\"Cannot delete admin user\");\n+\t\t}\n+\n+\t\tif (UserCoreUtil.isRegistryAnnonymousUser(userName)) {\n+\t\t\tthrow new UserStoreException(\"Cannot delete anonymous user\");\n+\t\t}\n+\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserStoreManagerListeners()) {\n+\t\t\tif (!listener.deleteUser(userName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreDeleteUser(userName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tif (!doCheckExistingUser(userName)) {\n+\t\t\tthrow new UserStoreException(\"Cannot delete user who is not exist\");\n+\t\t}\n+\n+\t\t// Remove users from internal role mapping\n+\t\thybridRoleManager.deleteUser(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n+\n+\t\tdoDeleteUser(userName);\n+\n+\t\t// Needs to clear roles cache upon deletion of a user\n+        clearUserRolesCache(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostDeleteUser(userName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void setUserClaimValue(String userName, String claimURI, String claimValue,\n+\t\t\tString profileName) throws UserStoreException {\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().setUserClaimValue(userStore.getDomainFreeName(),\n+\t\t\t\t\tclaimURI, claimValue, profileName);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreSetUserClaimValue(userName, claimURI, claimValue, profileName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tdoSetUserClaimValue(userName, claimURI, claimValue, profileName);\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostSetUserClaimValue(userName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void setUserClaimValues(String userName, Map<String, String> claims,\n+\t\t\tString profileName) throws UserStoreException {\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().setUserClaimValues(userStore.getDomainFreeName(),\n+\t\t\t\t\tclaims, profileName);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreSetUserClaimValues(userName, claims, profileName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tdoSetUserClaimValues(userName, claims, profileName);\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostSetUserClaimValues(userName, claims, profileName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void deleteUserClaimValue(String userName, String claimURI, String profileName)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().deleteUserClaimValue(userStore.getDomainFreeName(),\n+\t\t\t\t\tclaimURI, profileName);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreDeleteUserClaimValue(userName, claimURI, profileName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tdoDeleteUserClaimValue(userName, claimURI, profileName);\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostDeleteUserClaimValue(userName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void deleteUserClaimValues(String userName, String[] claims, String profileName)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().deleteUserClaimValues(userStore.getDomainFreeName(),\n+\t\t\t\t\tclaims, profileName);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreDeleteUserClaimValues(userName, claims, profileName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tdoDeleteUserClaimValues(userName, claims, profileName);\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostDeleteUserClaimValues(userName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void addUser(String userName, Object credential, String[] roleList,\n+\t\t\tMap<String, String> claims, String profileName, boolean requirePasswordChange)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().addUser(userStore.getDomainFreeName(), credential,\n+\t\t\t\t\troleList, claims, profileName, requirePasswordChange);\n+\t\t\treturn;\n+\t\t}\n+        \n+        if(userStore.isSystemStore()){\n+            systemUserRoleManager.addSystemUser(userName, credential, roleList);\n+            return;\n         }\n-        throw new NotImplementedException(\n-                \"doCheckExistingUserNameWithIDImpl operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Check whether the userID exists in the system.\n-     *\n-     * @param userID user ID.\n-     * @return Whether the user is existing in the user store.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected boolean doCheckExistingUserWithID(String userID) throws UserStoreException {\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n+\t\t}\n+\n+\t\t// This happens only once during first startup - adding administrator user/role.\n+\t\tif (userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n+\t\t\tuserName = userStore.getDomainFreeName();\n+\t\t\troleList = UserCoreUtil.removeDomainFromNames(roleList);\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserStoreManagerListeners()) {\n+\t\t\tif (!listener.addUser(userName, credential, roleList, claims, profileName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// String buffers are used to let listeners to modify passwords\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif(credential == null) { // a default password will be set\n+\t\t\t\tStringBuffer credBuff = new StringBuffer();\n+\t\t\t\tif (!listener.doPreAddUser(userName, credBuff, roleList, claims, profileName,\n+\t\t\t\t                           this)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcredential = credBuff.toString(); // reading the modified value\n+\t\t\t} else if (credential instanceof String) {\n+\t\t\t\tStringBuffer credBuff = new StringBuffer((String)credential);\n+\t\t\t\tif (!listener.doPreAddUser(userName, credBuff, roleList, claims, profileName,\n+\t\t\t\t                           this)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcredential = credBuff.toString(); // reading the modified value\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tif (!checkUserNameValid(userStore.getDomainFreeName())) {\n+\t\t\tString message = \"Username \"+ userStore.getDomainFreeName() +\" is not valid. User name must be a non null string with following format, \";\n+\t\t\tString regEx = realmConfig\n+\t\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG_EX);\n+\t\t\tthrow new UserStoreException(message + regEx);\n+\t\t}\n+\n+\t\tif (!checkUserPasswordValid(credential)) {\n+\t\t\tString message = \"Credential not valid. Credential must be a non null string with following format, \";\n+\t\t\tString regEx = realmConfig\n+\t\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX);\n+\t\t\tthrow new UserStoreException(message + regEx);\n+\t\t}\n+\n+\t\tif (doCheckExistingUser(userStore.getDomainFreeName())) {\n+\t\t\tthrow new UserStoreException(\"Username '\" + userName\n+\t\t\t\t\t+ \"' already exists in the system. Please pick another username.\");\n+\t\t}\n+        \n+        \n+   \n+\t\tList<String> internalRoles = new ArrayList<String>();\n+\t\tList<String> externalRoles = new ArrayList<String>();\n+\t\tint index;\n+\t\tif (roleList != null) {\n+\t\t\tfor (String role : roleList) {\n+                if(role != null && role.trim().length() > 0){\n+                    index = role.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n+                    if (index > 0) {\n+                        String domain = role.substring(0, index);\n+                        if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain)) {\n+                            internalRoles.add(UserCoreUtil.removeDomainFromName(role));\n+                            continue;\n+                        }\n+                    }\n+                    externalRoles.add(UserCoreUtil.removeDomainFromName(role));\n+                }\n+\t\t\t}\n+\t\t}\n+        \n+        // check existance of roles and claims before user is adding\n+        for(String internalRole : internalRoles){\n+            if(!hybridRoleManager.isExistingRole(internalRole)){\n+                throw new UserStoreException(\"Internal role is not exist : \" + internalRole);\n+            }\n+        }\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doCheckExistingUserWithID operation is not implemented in: \" + this.getClass());\n+        for(String externalRole : externalRoles){\n+            if(!doCheckExistingRole(externalRole)){\n+                throw new UserStoreException(\"External role is not exist : \" + externalRole);\n+            }\n         }\n-        throw new NotImplementedException(\n-                \"doCheckExistingUserWithID operation is not implemented in: \" + this.getClass());\n-    }\n+        \n+        if(claims != null){\n+            for(Map.Entry<String, String> entry : claims.entrySet()){\n+                ClaimMapping claimMapping = null;\n+                try {\n+                    claimMapping = (ClaimMapping)claimManager.getClaimMapping(entry.getKey());\n+                } catch (org.wso2.carbon.user.api.UserStoreException e) {\n+                    String errorMessage = \"Error in obtaining claim mapping for persisting user attributes.\";\n+                    throw new UserStoreException(errorMessage, e);                    \n+                }\n+                if(claimMapping == null){\n+                    String errorMessage = \"Invalid claim uri has been provided.\";\n+                    throw new UserStoreException(errorMessage);\n+                }\n+            }\n+        }\n+        \n+\t\tdoAddUser(userName, credential, externalRoles.toArray(new String[externalRoles.size()]),\n+\t\t\t\tclaims, profileName, requirePasswordChange);\n+\n+\t\tif (internalRoles.size() > 0) {\n+\t\t\thybridRoleManager.updateHybridRoleListOfUser(userName, null,\n+\t\t\t\t\tinternalRoles.toArray(new String[internalRoles.size()]));\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostAddUser(userName, credential, roleList, claims, profileName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic void addUser(String userName, Object credential, String[] roleList,\n+\t\t\tMap<String, String> claims, String profileName) throws UserStoreException {\n+\t\tthis.addUser(userName, credential, roleList, claims, profileName, false);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void updateUserListOfRole(String roleName, String[] deletedUsers, String[] newUsers)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tString primaryDomain = getMyDomainName();\n+\t\tif (primaryDomain != null) {\n+\t\t\tprimaryDomain += CarbonConstants.DOMAIN_SEPARATOR;\n+\t\t}\n+\n+\t\tif (deletedUsers != null && deletedUsers.length > 0) {\n+\t\t\tArrays.sort(deletedUsers);\n+\t\t\t// Updating the user list of a role belong to the primary domain.\n+\t\t\tif (UserCoreUtil.isPrimaryAdminRole(roleName, realmConfig)) {\n+\t\t\t\tfor (int i = 0; i < deletedUsers.length; i++) {\n+\t\t\t\t\tif (deletedUsers[i].equalsIgnoreCase(realmConfig.getAdminUserName())\n+\t\t\t\t\t\t\t|| (primaryDomain + deletedUsers[i]).equalsIgnoreCase(realmConfig\n+\t\t\t\t\t\t\t\t\t.getAdminUserName())) {\n+\t\t\t\t\t\tthrow new UserStoreException(\"Cannot remove Admin user from Admin role\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tUserStore userStore = getUserStore(roleName);\n \n-    /**\n-     * Retrieves a list of user names for given user's property in user profile\n-     *\n-     * @param property    user property in user profile\n-     * @param value       value of property\n-     * @param profileName profile name, can be null. If null the default profile is considered.\n-     * @return An array of user names\n-     * @throws UserStoreException if the operation failed\n-     */\n-    protected abstract String[] getUserListFromProperties(String property, String value,\n-                                                          String profileName) throws UserStoreException;\n+        if (userStore.isHybridRole()) {\n+\t\t\t// Check whether someone is trying to update Everyone role.\n+\t\t\tif (UserCoreUtil.isEveryoneRole(roleName, realmConfig)) {\n+\t\t\t\tthrow new UserStoreException(\"Cannot update everyone role\");\n+\t\t\t}\n \n-    /**\n-     * Retrieves a list of user IDs for given user's property in user profile.\n-     *\n-     * @param property    user property in user profile\n-     * @param value       value of property\n-     * @param profileName profile name, can be null. If null the default profile is considered.\n-     * @return An array of user names\n-     * @throws UserStoreException if the operation failed\n-     */\n-    protected List<String> doGetUserListFromPropertiesWithID(String property, String value, String profileName)\n-            throws UserStoreException {\n+            hybridRoleManager.updateUserListOfHybridRole(userStore.getDomainFreeName(),\n+                                                         deletedUsers, newUsers);\n+            clearUserRolesCacheByTenant(this.tenantId);\n+\t\t\treturn;\n+\t\t}\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetUserListFromPropertiesWithID operation is not implemented in: \" + this.getClass());\n+        if(userStore.isSystemStore()){\n+            systemUserRoleManager.updateUserListOfSystemRole(userStore.getDomainFreeName(),\n+                                                UserCoreUtil.removeDomainFromNames(deletedUsers),\n+                                                UserCoreUtil.removeDomainFromNames(newUsers));\n+            return;\n         }\n-        throw new NotImplementedException(\n-                \"doGetUserListFromPropertiesWithID operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Given the user name and a credential object, the implementation code must validate whether\n-     * the user is authenticated.\n-     *\n-     * @param userName   The user name\n-     * @param credential The credential of a user\n-     * @return If the value is true the provided credential match with the user name. False is\n-     * returned for invalid credential, invalid user name and mismatching credential with\n-     * user name.\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract boolean doAuthenticate(String userName, Object credential)\n-            throws UserStoreException;\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().updateUserListOfRole(userStore.getDomainFreeName(),\n+\t\t\t\t\tUserCoreUtil.removeDomainFromNames(deletedUsers),\n+\t\t\t\t\tUserCoreUtil.removeDomainFromNames(newUsers));\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreUpdateUserListOfRole(roleName, deletedUsers,\n+\t\t\t                                        newUsers, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tif ((deletedUsers != null && deletedUsers.length > 0)\n+\t\t\t\t|| (newUsers != null && newUsers.length > 0)) {\n+\t\t\tif (!isReadOnly() && writeGroupsEnabled) {\n+\t\t\t\tdoUpdateUserListOfRole(userStore.getDomainFreeName(),\n+\t\t\t\t\t\tUserCoreUtil.removeDomainFromNames(deletedUsers),\n+\t\t\t\t\t\tUserCoreUtil.removeDomainFromNames(newUsers));\n+\t\t\t} else {\n+\t\t\t\tthrow new UserStoreException(\n+\t\t\t\t\t\t\"Read-only user store.Roles cannot be added or modfified\");\n+\t\t\t}\n+\t\t}\n+\n+\t\t// need to clear user roles cache upon roles update\n+\t\tclearUserRolesCacheByTenant(this.tenantId);\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostUpdateUserListOfRole(roleName, deletedUsers,\n+\t\t\t                                         newUsers, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void updateRoleListOfUser(String userName, String[] deletedRoles, String[] newRoles)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tString primaryDomain = realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n+\t\tif (primaryDomain != null) {\n+\t\t\tprimaryDomain += CarbonConstants.DOMAIN_SEPARATOR;\n+\t\t}\n+\n+\t\tif (deletedRoles != null && deletedRoles.length > 0) {\n+\t\t\tArrays.sort(deletedRoles);\n+\t\t\tif (UserCoreUtil.isPrimaryAdminUser(userName, realmConfig)) {\n+\t\t\t\tfor (int i = 0; i < deletedRoles.length; i++) {\n+\t\t\t\t\tif (deletedRoles[i].equalsIgnoreCase(realmConfig.getAdminRoleName())\n+\t\t\t\t\t\t\t|| (primaryDomain + deletedRoles[i]).equalsIgnoreCase(realmConfig\n+\t\t\t\t\t\t\t\t\t.getAdminRoleName())) {\n+\t\t\t\t\t\tthrow new UserStoreException(\"Cannot remove Admin user from Admin role\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().updateRoleListOfUser(userStore.getDomainFreeName(),\n+\t\t\t\t\tUserCoreUtil.removeDomainFromNames(deletedRoles),\n+\t\t\t\t\tUserCoreUtil.removeDomainFromNames(newRoles));\n+\t\t\treturn;\n+\t\t}\n+\n+        if(userStore.isSystemStore()){\n+            systemUserRoleManager.updateSystemRoleListOfUser(userStore.getDomainFreeName(),\n+                    UserCoreUtil.removeDomainFromNames(deletedRoles),\n+                    UserCoreUtil.removeDomainFromNames(newRoles));\n+            return;\n+        }\n \n-    /**\n-     * Given the preferred user name and a credential object, the implementation code must\n-     * validate whether the user is authenticated.\n-     *\n-     * @param preferredUserNameProperty The preferred user name property.\n-     * @param preferredUserNameValue    The preferred user name value.\n-     * @param credential                The credential of a user.\n-     * @return @see AuthenticationResult.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected AuthenticationResult doAuthenticateWithID(String preferredUserNameProperty, String preferredUserNameValue,\n-            Object credential, String profileName) throws UserStoreException {\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doAuthenticateWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"doAuthenticateWithID operation is not implemented in: \" + this.getClass());\n-    }\n+\t\t// This happens only once during first startup - adding administrator user/role.\n+\t\tif (userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n+\t\t\tuserName = userStore.getDomainFreeName();\n+\t\t\tdeletedRoles = UserCoreUtil.removeDomainFromNames(deletedRoles);\n+\t\t\tnewRoles = UserCoreUtil.removeDomainFromNames(newRoles);\n+\t\t}\n \n-    /**\n-     * Given the login identifiers and a credential object, the implementation code must\n-     * validate whether the user is authenticated.\n-     *\n-     * @param loginIdentifiers The login identifiers.\n-     * @param credential       The credential of a user.\n-     * @return @see AuthenticationResult.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected AuthenticationResult doAuthenticateWithID(List<LoginIdentifier> loginIdentifiers, Object credential)\n-            throws UserStoreException {\n+\t\tList<String> internalRoleDel = new ArrayList<String>();\n+\t\tList<String> internalRoleNew = new ArrayList<String>();\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doAuthenticateWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"doAuthenticateWithID operation is not implemented in: \" + this.getClass());\n-    }\n+\t\tList<String> roleDel = new ArrayList<String>();\n+\t\tList<String> roleNew = new ArrayList<String>();\n \n-    /**\n-     * Given the user ID and a credential object, the implementation code must validate whether\n-     * the user is authenticated.\n-     *\n-     * @param userID     The user ID.\n-     * @param credential The credential of a user.\n-     * @return @see AuthenticationResult.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected AuthenticationResult doAuthenticateWithID(String userID, Object credential) throws UserStoreException {\n+\t\tif (deletedRoles != null && deletedRoles.length > 0) {\n+\t\t\tfor (String deleteRole : deletedRoles) {\n+                if (UserCoreUtil.isEveryoneRole(deleteRole, realmConfig)) {\n+\t\t\t\t\tthrow new UserStoreException(\"Everyone role cannot be updated\");\n+\t\t\t\t}\n+\t\t\t\tString domain = null;\n+\t\t\t\tint index1 = deleteRole.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n+\t\t\t\tif (index1 > 0) {\n+\t\t\t\t\tdomain = deleteRole.substring(0, index1);\n+\t\t\t\t}\n+\t\t\t\tif (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain) || this.isReadOnly()) {\n+\t\t\t\t\tinternalRoleDel.add(UserCoreUtil.removeDomainFromName(deleteRole));\n+\t\t\t\t} else {\n+\t\t\t\t\t// This is domain free role name.\n+\t\t\t\t\troleDel.add(UserCoreUtil.removeDomainFromName(deleteRole));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tdeletedRoles = roleDel.toArray(new String[roleDel.size()]);\n+\t\t}\n+\n+\t\tif (newRoles != null && newRoles.length > 0) {\n+\t\t\tfor (String newRole : newRoles) {\n+\t\t\t\tif (UserCoreUtil.isEveryoneRole(newRole, realmConfig)) {\n+\t\t\t\t\tthrow new UserStoreException(\"Everyone role cannot be updated\");\n+\t\t\t\t}\n+\t\t\t\tString domain = null;\n+\t\t\t\tint index2 = newRole.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n+\t\t\t\tif (index2 > 0) {\n+\t\t\t\t\tdomain = newRole.substring(0, index2);\n+\t\t\t\t}\n+\t\t\t\tif (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain) || this.isReadOnly()) {\n+\t\t\t\t\tinternalRoleNew.add(UserCoreUtil.removeDomainFromName(newRole));\n+\t\t\t\t} else {\n+\t\t\t\t\troleNew.add(UserCoreUtil.removeDomainFromName(newRole));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tnewRoles = roleNew.toArray(new String[roleNew.size()]);\n+\t\t}\n+\n+\t\tif (internalRoleDel.size() > 0 || internalRoleNew.size() > 0) {\n+\t\t\thybridRoleManager.updateHybridRoleListOfUser(userStore.getDomainFreeName(),\n+\t\t\t\t\tinternalRoleDel.toArray(new String[internalRoleDel.size()]),\n+\t\t\t\t\tinternalRoleNew.toArray(new String[internalRoleNew.size()]));\n+\t\t}\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreUpdateRoleListOfUser(userName, deletedRoles, newRoles, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\tif ((deletedRoles != null && deletedRoles.length > 0)\n+\t\t\t\t|| (newRoles != null && newRoles.length > 0)) {\n+\t\t\tif (!isReadOnly() && writeGroupsEnabled) {\n+\t\t\t\tdoUpdateRoleListOfUser(userName, deletedRoles, newRoles);\n+\t\t\t} else {\n+\t\t\t\tthrow new UserStoreException(\"Read-only user store. Cannot add/modify roles.\");\n+\t\t\t}\n+\t\t}\n+\n+        clearUserRolesCache(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostUpdateRoleListOfUser(userName, deletedRoles, newRoles, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void updateRoleName(String roleName, String newRoleName) throws UserStoreException {\n+\n+\t\tif (UserCoreUtil.isPrimaryAdminRole(newRoleName, realmConfig)) {\n+\t\t\tthrow new UserStoreException(\"Cannot rename admin role\");\n+\t\t}\n+\n+\t\tif (UserCoreUtil.isEveryoneRole(newRoleName, realmConfig)) {\n+\t\t\tthrow new UserStoreException(\"Cannot rename everyone role\");\n+\t\t}\n+\n+\t\tUserStore userStore = getUserStore(roleName);\n+\t\tUserStore userStoreNew = getUserStore(newRoleName);\n+\n+\t\tif (!UserCoreUtil.canRoleBeRenamed(userStore, userStoreNew, realmConfig)) {\n+\t\t\tthrow new UserStoreException(\"The role cannot be renamed\");\n+\t\t}\n+\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().updateRoleName(userStore.getDomainFreeName(),\n+\t\t\t\t\tuserStoreNew.getDomainFreeName());\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif (userStore.isHybridRole()) {\n+\t\t\thybridRoleManager.updateHybridRoleName(userStore.getDomainFreeName(),\n+\t\t\t\t\tuserStoreNew.getDomainFreeName());\n+\n+\t\t\t// This is a special case. We need to pass roles with domains.\n+\t\t\tuserRealm.getAuthorizationManager().resetPermissionOnUpdateRole(\n+\t\t\t\t\tuserStore.getDomainAwareName(), userStoreNew.getDomainAwareName());\n+\n+\t\t\t// Need to update user role cache upon update of role names\n+\t\t\tclearUserRolesCacheByTenant(this.tenantId);\n+\t\t\treturn;\n+\t\t}\n+//\n+//\t\tRoleContext ctx = createRoleContext(roleName);\n+//        if (isOthersSharedRole(roleName)) {          // TODO do we need this\n+//            throw new UserStoreException(\n+//                    \"Logged in user doesn't have permission to delete a role belong to other tenant\");\n+//        }\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doAuthenticateWithID operation is not implemented in: \" + this.getClass());\n+        if (isExistingRole(newRoleName)) {\n+            throw new UserStoreException(\"Role name: \" + newRoleName\n+                    + \" in the system. Please pick another role name.\");\n         }\n-        throw new NotImplementedException(\"doAuthenticateWithID operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Add a user to the user store.\n-     *\n-     * @param userName              User name of the user\n-     * @param credential            The credential/password of the user\n-     * @param roleList              The roles that user belongs\n-     * @param claims                Properties of the user\n-     * @param profileName           profile name, can be null. If null the default profile is considered.\n-     * @param requirePasswordChange whether password required is need\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract void  doAddUser(String userName, Object credential, String[] roleList,\n-                                      Map<String, String> claims, String profileName, boolean requirePasswordChange)\n-            throws UserStoreException;\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreUpdateRoleName(roleName, newRoleName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n \n-    /**\n-     * Add a user to the user store.\n-     *\n-     * @param userName              User name of the user.\n-     * @param credential            The credential/password of the user.\n-     * @param roleList              The roles that user belongs.\n-     * @param claims                Properties of the user.\n-     * @param profileName           profile name, can be null. If null the default profile is considered.\n-     * @param requirePasswordChange whether password required is need.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected User doAddUserWithID(String userName, Object credential, String[] roleList, Map<String, String> claims,\n-            String profileName, boolean requirePasswordChange) throws UserStoreException {\n+\t\tif (!isReadOnly() && writeGroupsEnabled) {\n+\t\t\tdoUpdateRoleName(userStore.getDomainFreeName(), userStoreNew.getDomainFreeName());\n+\t\t} else {\n+\t\t\tthrow new UserStoreException(\n+\t\t\t\t\t\"Read-only UserStoreManager. Roles cannot be added or modified.\");\n+\t\t}\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doAddUserWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"doAddUserWithID operation is not implemented in: \" + this.getClass());\n-    }\n+\t\t// This is a special case. We need to pass domain aware name.\n+\t\tuserRealm.getAuthorizationManager().resetPermissionOnUpdateRole(\n+\t\t\t\tuserStore.getDomainAwareName(), userStoreNew.getDomainAwareName());\n \n-    /**\n-     * Update the credential/password of the user\n-     *\n-     * @param userName      The user name\n-     * @param newCredential The new credential/password\n-     * @param oldCredential The old credential/password\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract void doUpdateCredential(String userName, Object newCredential,\n-                                               Object oldCredential) throws UserStoreException;\n+\t\t// need to update user role cache upon update of role names\n+\t\tclearUserRolesCacheByTenant(tenantId);\n \n-    /**\n-     * Update the credential/password of the user.\n-     *\n-     * @param userID        The user ID.\n-     * @param newCredential The new credential/password.\n-     * @param oldCredential The old credential/password.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doUpdateCredentialWithID(String userID, Object newCredential, Object oldCredential)\n-            throws UserStoreException {\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostUpdateRoleName(roleName, newRoleName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doUpdateCredentialWithID operation is not implemented in: \" + this.getClass());\n+\n+    @Override\n+    public boolean isExistingRole(String roleName, boolean shared) throws org.wso2.carbon.user.api.UserStoreException {\n+        if(shared){\n+            return isExistingShareRole(roleName);\n+        } else {\n+            return isExistingRole(roleName);\n         }\n-        throw new NotImplementedException(\n-                \"doUpdateCredentialWithID operation is not implemented in: \" + this.getClass());\n     }\n \n     /**\n-     * Update credential/password by the admin of another user\n-     *\n-     * @param userName      The user name\n-     * @param newCredential The new credential\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract void doUpdateCredentialByAdmin(String userName, Object newCredential)\n-            throws UserStoreException;\n+\t * {@inheritDoc}\n+\t */\n+\tpublic boolean isExistingRole(String roleName) throws UserStoreException {\n \n-    /**\n-     * Update credential/password by the admin of another user.\n-     *\n-     * @param userID        The user ID.\n-     * @param newCredential The new credential.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doUpdateCredentialByAdminWithID(String userID, Object newCredential) throws UserStoreException {\n+\t\tUserStore userStore = getUserStore(roleName);\n+\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\treturn userStore.getUserStoreManager().isExistingRole(userStore.getDomainFreeName());\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doUpdateCredentialByAdminWithID operation is not implemented in: \" + this.getClass());\n+        if(userStore.isSystemStore()){\n+            return systemUserRoleManager.isExistingRole(userStore.getDomainFreeName());\n         }\n-        throw new NotImplementedException(\n-                \"doUpdateCredentialByAdminWithID operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Delete the user with the given user name\n-     *\n-     * @param userName The user name\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract void doDeleteUser(String userName) throws UserStoreException;\n+\t\tif (userStore.isHybridRole()) {\n+\t\t\tboolean exist = hybridRoleManager.isExistingRole(userStore.getDomainFreeName());\n+\t\t\tif(exist) {\n+\t\t\t\treturn true;\n+\t\t\t} else if(!readGroupsEnabled) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n \n-    /**\n-     * Delete the user with the given user ID.\n-     *\n-     * @param userID The user ID.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doDeleteUserWithID(String userID) throws UserStoreException {\n+\t\t// This happens only once during first startup - adding administrator user/role.\n+\t\troleName = userStore.getDomainFreeName();\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doDeleteUserWithID operation is not implemented in: \" + this.getClass());\n+        // you can not check existence of shared role using this method.\n+        if(isSharedGroupEnabled() && roleName.contains(UserCoreConstants.TENANT_DOMAIN_COMBINER)){\n+            return false;\n         }\n-        throw new NotImplementedException(\"doDeleteUserWithID operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    /**\n-     * Set a single user claim value.\n-     *\n-     * @param userName    The user name.\n-     * @param claimURI    The claim URI.\n-     * @param claimValue  The value.\n-     * @param profileName The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doSetUserClaimValue(String userName, String claimURI,\n-                                       String claimValue, String profileName) throws UserStoreException {\n+        \n+\t\tboolean isExisting = doCheckExistingRole(roleName);\n \n-        try {\n-            String attributeName = getClaimAtrribute(claimURI, userName, null);\n-            Map<String, String> userStoreAttributeValueMap = new HashMap<>();\n+\t\tif (!isExisting && (isReadOnly() || !readGroupsEnabled)) {\n+\t\t\tisExisting = hybridRoleManager.isExistingRole(roleName);\n+\t\t}\n \n-            userStoreAttributeValueMap.put(attributeName, claimValue);\n-            processAttributesBeforeUpdate(userName, userStoreAttributeValueMap, profileName);\n+\t\tif (!isExisting) {\n+\t\t\tif (systemUserRoleManager.isExistingRole(roleName)) {\n+\t\t\t\tisExisting = true;\n+\t\t\t}\n+\t\t}\n \n-            for (Map.Entry<String, String> entry : userStoreAttributeValueMap.entrySet()) {\n-                doSetUserAttribute(userName, entry.getKey(), entry.getValue(), profileName);\n-            }\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            throw new UserStoreException(\n-                    \"Error occurred while getting the claim attribute for claimURI: \" + claimURI + \" of the user: \"\n-                            + userName, e);\n-        }\n-    }\n+\t\treturn isExisting;\n+\t}\n \n+//////////////////////////////////// Shared role APIs start //////////////////////////////////////////\n     /**\n-     * Set the user attribute of the user.\n-     *\n-     * @param userName      User name.\n-     * @param attributeName Attribute name.\n-     * @param value         Attribute value.\n-     * @param profileName   profile name.\n+     * TODO move to API\n+     * @param roleName\n+     * @return\n+     * @throws UserStoreException\n      */\n-    protected void doSetUserAttribute(String userName, String attributeName, String value, String profileName)\n-            throws UserStoreException {\n+    public boolean isExistingShareRole(String roleName) throws UserStoreException {\n+\n+        UserStoreManager manager  = getUserStoreWithSharedRoles();\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doSetUserAttribute operation is not implemented in: \" + this.getClass());\n+        if(manager == null){\n+            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n         }\n \n-        throw new NotImplementedException(\"doSetUserAttribute operation is not implemented in: \" + this.getClass());\n+        return ((AbstractUserStoreManager)manager).doCheckExistingRole(roleName);\n     }\n \n     /**\n-     * Set the user attribute of the user.\n-     *\n-     * @param userID        User ID.\n-     * @param attributeName Attribute name.\n-     * @param value         Attribute value.\n-     * @param profileName   Profile Name.\n-     * @throws UserStoreException Thrown if the operation is not implemented in the underlying user store.\n+     * TODO  move to API\n+     * @param roleName\n+     * @param deletedUsers\n+     * @param newUsers\n+     * @throws UserStoreException\n      */\n-    protected void doSetUserAttributeWithID(String userID, String attributeName, String value, String profileName)\n-            throws UserStoreException {\n+    public void updateUsersOfSharedRole(String roleName,\n+                                String[] deletedUsers, String[] newUsers) throws UserStoreException{\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doSetUserAttributeWithID operation is not implemented in: \" + this.getClass());\n+        UserStoreManager manager  = getUserStoreWithSharedRoles();\n+\n+        if(manager == null){\n+            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n         }\n \n-        throw new NotImplementedException(\"doSetUserAttributeWithID operation is not implemented in: \"\n-                + this.getClass());\n+        ((AbstractUserStoreManager)manager).doUpdateUserListOfRole(roleName, deletedUsers, newUsers);\n     }\n-\n     /**\n-     * Set the user attributes of a user.\n-     *\n-     * @param userName                 UserName of the user.\n-     * @param processedClaimAttributes A processed map of user store attribute values.\n-     * @param profileName              The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException Thrown if the operation is not implemented in the underlying user store.\n+     * TODO move to API\n+     * @return\n+     * @throws UserStoreException\n      */\n-    protected void doSetUserAttributes(String userName, Map<String, String> processedClaimAttributes,\n-                                       String profileName) throws UserStoreException {\n+    public String[] getSharedRolesOfUser(String userName,\n+                                    String tenantDomain, String filter) throws UserStoreException {\n+\n+        UserStore userStore = getUserStore(userName);\n+        UserStoreManager manager  = userStore.getUserStoreManager();\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doSetUserAttributes operation is not implemented in: \" + this.getClass());\n+        if(!((AbstractUserStoreManager)manager).isSharedGroupEnabled()){\n+            throw new UserStoreException(\"Share Groups are not supported by user store\");\n         }\n \n-        throw new NotImplementedException(\"doSetUserAttributes operation is not implemented in: \" + this.getClass());\n+        String[] sharedRoles = ((AbstractUserStoreManager)manager).\n+                doGetSharedRoleListOfUser(userStore.getDomainFreeName(), tenantDomain, filter);\n+        return UserCoreUtil. removeDomainFromNames(sharedRoles);\n     }\n \n     /**\n-     * Set the user attributes of a user.\n-     *\n-     * @param userName                 UserName of the user.\n-     * @param claimAttributesToAdd     A processed map of userstore attribute values to add.\n-     * @param claimAttributesToDelete  A processed map of userstore attribute values to delte.\n-     * @param claimAttributesToReplace A processed map of userstore attribute values to replace.\n-     * @param profileName              The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException      Thrown if the userstore operation fails.\n-     * @throws NotImplementedException Thrown if the operation is not implemented in the underlying userstore.\n+     * TODO move to API\n+     * @return\n+     * @throws UserStoreException\n      */\n-    protected void doSetUserAttributes(String userName, Map<String, List<String>> claimAttributesToAdd,\n-                                             Map<String, List<String>> claimAttributesToDelete,\n-                                             Map<String, List<String>> claimAttributesToReplace, String profileName)\n-            throws UserStoreException, NotImplementedException {\n-\n-        throw new NotImplementedException(\"doSetUserAttributes operation is not implemented in: \" + this.getClass());\n-    }\n+    public String[] getUsersOfSharedRole(String roleName, String filter) throws UserStoreException {\n \n-    /**\n-     * Set the user attributes of a user.\n-     *\n-     * @param processedClaimAttributes A processed map of user store attribute values.\n-     * @param userID                   UserID of the user.\n-     * @param profileName              The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException Thrown if the operation is not implemented in the underlying user store.\n-     */\n-    protected void doSetUserAttributesWithID(String userID,\n-                                             Map<String, String> processedClaimAttributes, String profileName)\n-            throws UserStoreException {\n+        UserStoreManager manager  = getUserStoreWithSharedRoles();\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doSetUserAttributesWithID operation is not implemented in: \" + this.getClass());\n+        if(manager == null){\n+            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n         }\n \n-        throw new NotImplementedException(\"doSetUserAttributesWithID operation is not implemented in: \"\n-                + this.getClass());\n+        String[] users = ((AbstractUserStoreManager)manager).doGetUserListOfRole(roleName, filter);\n+        return UserCoreUtil. removeDomainFromNames(users);\n     }\n \n     /**\n-     * Set the user attributes of a user.\n-     *\n-     * @param userID                   UserID of the user.\n-     * @param claimAttributesToAdd     A processed map of userstore attribute values to add.\n-     * @param claimAttributesToDelete  A processed map of userstore attribute values to delete.\n-     * @param claimAttributesToReplace A processed map of userstore attribute values to replace.\n-     * @param profileName              The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException      Thrown if the userstore operation fails.\n-     * @throws NotImplementedException Thrown if the operation is not implemented in the underlying userstore.\n+     * TODO move to API\n+     * @return\n+     * @throws UserStoreException\n      */\n-    protected void doSetUserAttributesWithID(String userID, Map<String, List<String>> claimAttributesToAdd,\n-                                             Map<String, List<String>> claimAttributesToDelete,\n-                                             Map<String, List<String>> claimAttributesToReplace, String profileName)\n-            throws UserStoreException, NotImplementedException {\n+    public String[] getSharedRoleNames(String tenantDomain, String filter,\n+                                                    int maxItemLimit) throws UserStoreException {\n \n-        throw new NotImplementedException(\"doSetUserAttributesWithID operation is not implemented in: \"\n-                + this.getClass());\n-    }\n \n-    /**\n-     * Set a single user claim value.\n-     *\n-     * @param userID      The user ID.\n-     * @param claimURI    The claim URI.\n-     * @param claimValue  The value.\n-     * @param profileName The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doSetUserClaimValueWithID(String userID, String claimURI, String claimValue, String profileName)\n-            throws UserStoreException {\n+        UserStoreManager manager  = getUserStoreWithSharedRoles();\n \n-        try {\n-            String attributeName = getClaimAtrribute(claimURI, userID, null);\n-            Map<String, String> userStoreAttributeValueMap = new HashMap<>();\n-            userStoreAttributeValueMap.put(attributeName, claimValue);\n-            processAttributesBeforeUpdateWithID(userID, userStoreAttributeValueMap, profileName);\n+        if(manager == null){\n+            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n+        }\n \n-            for (Map.Entry<String, String> entry : userStoreAttributeValueMap.entrySet()) {\n-                doSetUserAttributeWithID(userID, entry.getKey(), entry.getValue(), profileName);\n-            }\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            throw new UserStoreException(\n-                    \"Error occurred while getting the claim attribute for claimURI: \" + claimURI + \" of the user: \"\n-                            + userID, e);\n+        String[] sharedRoles = null;\n+        try{\n+            sharedRoles = ((AbstractUserStoreManager)manager).\n+                                        doGetSharedRoleNames(tenantDomain, filter, maxItemLimit);\n+        } catch (UserStoreException e){\n+            throw new UserStoreException(\"Error while retrieving shared roles\", e);\n         }\n+        return UserCoreUtil. removeDomainFromNames(sharedRoles);\n     }\n \n+\n     /**\n-     * Set many user claim values.\n-     *\n-     * @param userName    The user name.\n-     * @param claims      Map of claim URIs against values.\n-     * @param profileName The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException An unexpected exception has occurred.\n+     * TODO move to API\n+     * @return\n+     * @throws UserStoreException\n      */\n-    public void doSetUserClaimValues(String userName, Map<String, String> claims,\n-                                        String profileName) throws UserStoreException {\n-\n-        if (profileName == null) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n+    public String[] getSharedRoleNames(String filter, int maxItemLimit) throws UserStoreException {\n \n-        // Resolving claims to user store attributes.\n-        Map<String, String> claimAttributeValueMapForPersist = resolveUserStoreAttributeValueMap(userName, claims);\n+        UserStoreManager manager  = getUserStoreWithSharedRoles();\n \n-        processAttributesBeforeUpdate(userName, claimAttributeValueMapForPersist, profileName);\n+        if(manager == null){\n+            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n+        }\n \n-        // Persist the attribute values map.\n-        doSetUserAttributes(userName, claimAttributeValueMapForPersist, profileName);\n+        String[] sharedRoles = null;\n+        try{\n+            sharedRoles = ((AbstractUserStoreManager)manager).\n+                    doGetSharedRoleNames(null, filter, maxItemLimit);\n+        } catch (UserStoreException e){\n+            throw new UserStoreException(\"Error while retrieving shared roles\", e);\n+        }\n+        return UserCoreUtil. removeDomainFromNames(sharedRoles);\n     }\n \n-    /**\n-     * Set many user claim values by treating multi-valued claims independently from simple claims.\n-     *\n-     * @param userName                         User's username.\n-     * @param multiValuedClaimsToAdd           Map of multi-valued claim URIs against values to be added.\n-     * @param multiValuedClaimsToDelete        Map of multi-valued claim URIs against values to be deleted.\n-     * @param claimsExcludingMultiValuedClaims Map of claim URIs excluding multi-valued claims against values\n-     *                                         to be modified.\n-     * @param profileName                      The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException      An unexpected exception has occurred.\n-     * @throws NotImplementedException Functionality is not implemented exception.\n-     */\n-    protected void doSetUserClaimValues(String userName, Map<String, List<String>> multiValuedClaimsToAdd,\n-                                        Map<String, List<String>> multiValuedClaimsToDelete,\n-                                        Map<String, List<String>> claimsExcludingMultiValuedClaims,\n-                                        String profileName)\n-            throws UserStoreException, NotImplementedException {\n-\n-        if (StringUtils.isBlank(profileName)) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n \n-        // Resolving claims to user store attributes.\n-        Map<String, List<String>> claimAttributeValueMapToAdd =\n-                resolveUserStoreAttributeValueMaps(userName, multiValuedClaimsToAdd);\n-        Map<String, List<String>> claimAttributeValueMapToDelete =\n-                resolveUserStoreAttributeValueMaps(userName, multiValuedClaimsToDelete);\n-        Map<String, List<String>> claimAttributeValueMapToModify =\n-                resolveUserStoreAttributeValueMaps(userName, claimsExcludingMultiValuedClaims);\n-\n-        processAttributesBeforeUpdate(userName, claimAttributeValueMapToAdd, profileName);\n-        processAttributesBeforeUpdate(userName, claimAttributeValueMapToDelete, profileName);\n-        processAttributesBeforeUpdate(userName, claimAttributeValueMapToModify, profileName);\n-\n-        // Persist the attribute values map.\n-        doSetUserAttributes(userName, claimAttributeValueMapToAdd, claimAttributeValueMapToDelete,\n-                claimAttributeValueMapToModify, profileName);\n+    public void addInternalRole(String roleName, String[] userList,\n+                    org.wso2.carbon.user.api.Permission[] permission) throws UserStoreException {\n+        doAddInternalRole(roleName, userList, permission);\n     }\n \n-    /**\n-     * Resolves claim URIs as user store properties.\n-     *\n-     * @param userIdentifier Username of the user.\n-     * @param claims         A map of claim URIs to be resolved.\n-     * @return A map of user store property values.\n-     * @throws UserStoreException Thrown if a particular claim URI could not be resolved.\n-     */\n-    private Map<String, String> resolveUserStoreAttributeValueMap(String userIdentifier, Map<String, String> claims)\n-            throws UserStoreException {\n-\n-        Map<String, String> userStoreAttributeValueMap = new HashMap<>();\n-\n-        try {\n-            for (Map.Entry<String, String> claimEntry : claims.entrySet()) {\n-                String claimURI = claimEntry.getKey();\n-                String attributeName = getClaimAtrribute(claimURI, userIdentifier, null);\n-                userStoreAttributeValueMap.put(attributeName, claimEntry.getValue());\n-            }\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            String errorMessage = \"Error occurred while getting claim attribute for user : \" + userIdentifier;\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(errorMessage, e);\n-            }\n-\n-            throw new UserStoreException(errorMessage, e);\n+    private UserStoreManager getUserStoreWithSharedRoles() throws UserStoreException {\n+        \n+        UserStoreManager sharedRoleManager = null;\n+        \n+        if(isSharedGroupEnabled()) {\n+            return this;\n         }\n-        return userStoreAttributeValueMap;\n-    }\n-\n-    private Map<String, List<String>> resolveUserStoreAttributeValueMaps(String userIdentifier,\n-                                                                         Map<String, List<String>> claims)\n-            throws UserStoreException {\n-\n-        Map<String, List<String>> userStoreAttributeValueMap = new HashMap<>();\n-        try {\n-            for (Map.Entry<String, List<String>> claimEntry : claims.entrySet()) {\n-                String claimURI = claimEntry.getKey();\n-                String attributeName = getClaimAtrribute(claimURI, userIdentifier, null);\n-                userStoreAttributeValueMap.put(attributeName, claimEntry.getValue());\n-            }\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            String errorMessage = \"Error occurred while getting claim attribute for user : \" + userIdentifier;\n-            if (log.isDebugEnabled()) {\n-                log.debug(errorMessage, e);\n+        \n+        for(Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()){\n+            UserStoreManager manager = entry.getValue();\n+            if(manager != null && ((AbstractUserStoreManager)manager).isSharedGroupEnabled()){\n+                if(sharedRoleManager != null){\n+                    throw new UserStoreException(\"There can not be more than one user store that support\" +\n+                            \"shared groups\");\n+                }\n+                sharedRoleManager =  manager;               \n             }\n-            throw new UserStoreException(errorMessage, e);\n         }\n-        return userStoreAttributeValueMap;\n+        \n+        return  sharedRoleManager;\n     }\n \n     /**\n-     * Set many user claim values.\n-     *\n-     * @param userID      The user ID.\n-     * @param claims      Map of claim URIs against values.\n-     * @param profileName The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException An unexpected exception has occurred.\n+     * TODO move to API\n+     * @param userName\n+     * @param roleName\n+     * @return\n+     * @throws UserStoreException\n      */\n-    protected void doSetUserClaimValuesWithID(String userID, Map<String, String> claims, String profileName)\n-            throws UserStoreException {\n+    public boolean isUserInRole(String userName, String roleName) throws UserStoreException {\n \n-        if (profileName == null) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n+        if(roleName == null || roleName.trim().length() == 0 || userName == null ||\n+                userName.trim().length() == 0){\n+            return false;\n+        }\n+        \n+        // anonymous user is always assigned to  anonymous role\n+        if(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME.equalsIgnoreCase(roleName) &&\n+                        CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userName)){\n+            return true;\n         }\n \n-        // Resolving claims to user store attributes.\n-        Map<String, String> claimAttributeValueMapForPersist = resolveUserStoreAttributeValueMap(userID, claims);\n-\n-        processAttributesBeforeUpdateWithID(userID, claimAttributeValueMapForPersist, profileName);\n-\n-        // Persist the attribute values map.\n-        doSetUserAttributesWithID(userID, claimAttributeValueMapForPersist, profileName);\n-    }\n-\n-    /**\n-     * Set many user claim values.\n-     *\n-     * @param userID                           The user ID.\n-     * @param multiValuedClaimsToAdd           Map of multi-valued claim URIs against values to add.\n-     * @param multiValuedClaimsToDelete        Map of multi-valued claim URIs against values to delete.\n-     * @param claimsExcludingMultiValuedClaims Map of non-multi-valued claim URIs against values to replace.\n-     * @param profileName                      The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException      Thrown if an unexpected exception has occurred in userstore operation.\n-     * @throws NotImplementedException Thrown if the operation is not implemented in the underlying userstore.\n-     */\n-    protected void doSetUserClaimValuesWithID(String userID, Map<String, List<String>> multiValuedClaimsToAdd,\n-                                              Map<String, List<String>> multiValuedClaimsToDelete,\n-                                              Map<String, List<String>> claimsExcludingMultiValuedClaims,\n-                                              String profileName) throws UserStoreException, NotImplementedException {\n-\n-        if (profileName == null) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n+        if(!CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userName) &&\n+                realmConfig.getEveryOneRoleName().equalsIgnoreCase(roleName) &&\n+                !systemUserRoleManager.isExistingSystemUser(UserCoreUtil.\n+                        removeDomainFromName(userName))) {\n+            return true;\n         }\n-        // Resolving claims to user store attributes.\n-        Map<String, List<String>> claimAttributeValueMapToAdd =\n-                resolveUserStoreAttributeValueMaps(userID, multiValuedClaimsToAdd);\n-        Map<String, List<String>> claimAttributeValueMapToDelete =\n-                resolveUserStoreAttributeValueMaps(userID, multiValuedClaimsToDelete);\n-        Map<String, List<String>> claimAttributeValueMapToModify =\n-                resolveUserStoreAttributeValueMaps(userID, claimsExcludingMultiValuedClaims);\n-\n-        processAttributesBeforeUpdateWithID(userID, claimAttributeValueMapToAdd, profileName);\n-        processAttributesBeforeUpdateWithID(userID, claimAttributeValueMapToDelete, profileName);\n-        processAttributesBeforeUpdateWithID(userID, claimAttributeValueMapToModify, profileName);\n-        // Persist the attribute values map.\n-        doSetUserAttributesWithID(userID, claimAttributeValueMapToAdd, claimAttributeValueMapToDelete,\n-                claimAttributeValueMapToModify, profileName);\n-    }\n+        \n+        \n \n-    /**\n-     * Delete a single user claim value\n-     *\n-     * @param userName    The user name\n-     * @param claimURI    Name of the claim\n-     * @param profileName The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract void doDeleteUserClaimValue(String userName, String claimURI,\n-                                                   String profileName) throws UserStoreException;\n+        String[] roles = null;\n \n-    /**\n-     * Delete a single user claim value.\n-     *\n-     * @param userID      The user ID.\n-     * @param claimURI    Name of the claim.\n-     * @param profileName The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doDeleteUserClaimValueWithID(String userID, String claimURI, String profileName)\n-            throws UserStoreException {\n+        try{\n+            roles = getRoleListOfUserFromCache(tenantId, userName);\n+        } catch (Exception e){\n+            //ignore\n+        }\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doDeleteUserClaimValueWithID operation is not implemented in: \" + this.getClass());\n+        if(roles != null){\n+            if(UserCoreUtil.isContain(roleName, roles)){\n+                return true;\n+            }\n         }\n-        throw new NotImplementedException(\n-                \"doDeleteUserClaimValueWithID operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Delete many user claim values.\n-     *\n-     * @param userName    The user name\n-     * @param claims      URIs of the claims to be deleted.\n-     * @param profileName The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract void doDeleteUserClaimValues(String userName, String[] claims,\n-                                                    String profileName) throws UserStoreException;\n+        // TODO create new cache for this method\n+        String  modifiedUserName =  UserCoreConstants.IS_USER_IN_ROLE_CACHE_IDENTIFIER + userName;\n+        try{\n+            roles = getRoleListOfUserFromCache(tenantId, modifiedUserName);\n+        } catch (Exception e){\n+            //ignore\n+        }\n \n-    /**\n-     * Delete many user claim values.\n-     *\n-     * @param userID      The user ID.\n-     * @param claims      URIs of the claims to be deleted.\n-     * @param profileName The profile name, can be null. If null the default profile is considered.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doDeleteUserClaimValuesWithID(String userID, String[] claims, String profileName)\n-            throws UserStoreException {\n+        if(roles != null){\n+            if(UserCoreUtil.isContain(roleName, roles)){\n+                return true;\n+            }\n+        }\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doDeleteUserClaimValuesWithID operation is not implemented in: \" + this.getClass());\n+        if(UserCoreConstants.INTERNAL_DOMAIN.\n+                                equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName))){\n+            String[] internalRoles = doGetInternalRoleListOfUser(userName, \"*\");\n+            if(UserCoreUtil.isContain(roleName, internalRoles)){\n+                addToIsUserHasRole(modifiedUserName, roleName, roles);\n+                return true;\n+            }\n         }\n-        throw new NotImplementedException(\n-                \"doDeleteUserClaimValuesWithID operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Update user list of a particular role\n-     *\n-     * @param roleName     The role name\n-     * @param deletedUsers Array of user names, that is going to be removed from the role\n-     * @param newUsers     Array of user names, that is going to be added to the role\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract void doUpdateUserListOfRole(String roleName, String[] deletedUsers,\n-                                                   String[] newUsers) throws UserStoreException;\n+        UserStore userStore = getUserStore(userName);\n+        if (userStore.isRecurssive()) {\n+            return userStore.getUserStoreManager().isUserInRole(userStore.getDomainFreeName(), roleName);\n+        }\n \n-    /**\n-     * Update user list of a particular role.\n-     *\n-     * @param roleName     The role name.\n-     * @param deletedUsers Array of user IDs, that is going to be removed from the role.\n-     * @param newUsers     Array of user IDs, that is going to be added to the role.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doUpdateUserListOfRoleWithID(String roleName, String[] deletedUsers, String[] newUsers)\n-            throws UserStoreException {\n+        // #################### Domain Name Free Zone Starts Here ################################\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doUpdateUserListOfRoleWithID operation is not implemented in: \" + this.getClass());\n+        if(userStore.isSystemStore()){\n+            return systemUserRoleManager.isUserInRole(userStore.getDomainFreeName(),\n+                                                    UserCoreUtil.removeDomainFromName(roleName));\n+        }\n+        // admin user is always assigned to admin role if it is in primary user store\n+        if(realmConfig.isPrimary() && roleName.equalsIgnoreCase(realmConfig.getAdminRoleName()) &&\n+                                userName.equalsIgnoreCase(realmConfig.getAdminUserName())){\n+            return true;\n         }\n-        throw new NotImplementedException(\n-                \"doUpdateUserListOfRoleWithID operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Update role list of a particular user.\n-     *\n-     * @param userName     The user name\n-     * @param deletedRoles Array of role names, that is going to be removed from the user\n-     * @param newRoles     Array of role names, that is going to be added to the user\n-     * @throws UserStoreException An unexpected exception has occurred\n-     */\n-    protected abstract void doUpdateRoleListOfUser(String userName, String[] deletedRoles,\n-                                                   String[] newRoles) throws UserStoreException;\n+        String roleDomainName = UserCoreUtil.extractDomainFromName(roleName);\n \n-    /**\n-     * Update role list of a particular user.\n-     *\n-     * @param userID       The user ID.\n-     * @param deletedRoles Array of role names, that is going to be removed from the user.\n-     * @param newRoles     Array of role names, that is going to be added to the user.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doUpdateRoleListOfUserWithID(String userID, String[] deletedRoles, String[] newRoles)\n-            throws UserStoreException {\n+        String roleDomainNameForForest = realmConfig.\n+                getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_GROUP_SEARCH_DOMAINS);\n+        if(roleDomainNameForForest != null && roleDomainNameForForest.trim().length() > 0){\n+            String[] values = roleDomainNameForForest.split(\"#\");\n+            for(String value : values){\n+                if(value != null && !value.trim().equalsIgnoreCase(roleDomainName)){\n+                    return false;\n+                }\n+            }\n+        } else if (!userStore.getDomainName().equalsIgnoreCase(roleDomainName)) {\n+            return false;\n+        }\n+        \n+        boolean success = false;\n+        if(readGroupsEnabled){        \n+            success = doCheckIsUserInRole(userStore.getDomainFreeName(),\n+                                                    UserCoreUtil.removeDomainFromName(roleName));\n+        }\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doUpdateRoleListOfUserWithID operation is not implemented in: \" + this.getClass());\n+        // add to cache\n+        if(success){\n+            addToIsUserHasRole(modifiedUserName, roleName, roles);\n         }\n-        throw new NotImplementedException(\n-                \"doUpdateRoleListOfUserWithID operation is not implemented in: \" + this.getClass());\n+        return success;\n     }\n \n     /**\n-     * Only gets the internal roles of the user with internal domain name\n-     *\n-     * @param userName Name of the user - who we need to find roles.\n+     * \n+     * @param userName\n+     * @param roleName\n      * @return\n      * @throws UserStoreException\n      */\n-    protected String[] doGetInternalRoleListOfUser(String userName, String filter) throws UserStoreException {\n-\n-        if (Boolean.parseBoolean(realmConfig.getUserStoreProperty(MULIPLE_ATTRIBUTE_ENABLE))) {\n-            String userNameAttribute = realmConfig.getUserStoreProperty(LDAPConstants.USER_NAME_ATTRIBUTE);\n-            if (userNameAttribute != null && userNameAttribute.trim().length() > 0) {\n-                Map<String, String> map = getUserPropertyValues(userName, new String[]{userNameAttribute}, null);\n-                String tempUserName = map.get(userNameAttribute);\n-                if (tempUserName != null) {\n-                    userName = tempUserName;\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Replaced user name : \" + userName + \" from user property value : \" + tempUserName);\n-                    }\n-                }\n-            }\n-        }\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Retrieving internal roles for user name :  \" + userName + \" and search filter : \" + filter);\n-        }\n-        return hybridRoleManager.getHybridRoleListOfUser(userName, filter);\n-    }\n+    public abstract boolean doCheckIsUserInRole(String userName, String roleName) throws UserStoreException;\n \n     /**\n-     * Only gets the internal roles of the user with internal domain name.\n-     *\n-     * @param userID ID of the user.\n-     * @return internal roles list of the user.\n-     * @throws UserStoreException An unexpected exception has occurred.\n+     * Helper method\n+     * @param userName\n+     * @param roleName\n+     * @param currentRoles\n      */\n-    protected List<String> doGetInternalRoleListOfUserWithID(String userID, String filter) throws UserStoreException {\n-\n-        String username = doGetUserNameFromUserID(userID);\n-        if (StringUtils.isEmpty(username)) {\n-            throw new UserStoreException(\"No user found with UserID: \" + userID);\n+    private void addToIsUserHasRole(String userName, String roleName, String[] currentRoles){\n+        List<String> roles;\n+        if(currentRoles != null){\n+            roles = new ArrayList<String>(Arrays.asList(currentRoles));\n+        } else {\n+            roles = new ArrayList<String>();\n         }\n-        return Arrays.asList(hybridRoleManager.getHybridRoleListOfUser(username, filter));\n-    }\n+        roles.add(roleName);\n+        addToUserRolesCache(tenantId, UserCoreUtil.addDomainToName(userName, getMyDomainName()),\n+                roles.toArray(new String[roles.size()]));\n+    }    \n \n-    protected Map<String, List<String>> doGetInternalRoleListOfUsers(List<String> userNames, String domainName)\n-            throws UserStoreException {\n-\n-        if (Boolean.parseBoolean(realmConfig.getUserStoreProperty(MULIPLE_ATTRIBUTE_ENABLE))) {\n-            List<String> updatedUserNameList = new ArrayList<>();\n-            for (String userName : userNames) {\n-                String userNameAttribute = realmConfig.getUserStoreProperty(LDAPConstants.USER_NAME_ATTRIBUTE);\n-                if (userNameAttribute != null && userNameAttribute.trim().length() > 0) {\n-                    Map<String, String> map = getUserPropertyValues(userName, new String[] { userNameAttribute }, null);\n-                    String tempUserName = map.get(userNameAttribute);\n-                    if (tempUserName != null) {\n-                        updatedUserNameList.add(tempUserName);\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\n-                                    \"Replaced user name : \" + userName + \" from user property value : \" + tempUserName);\n+//////////////////////////////////// Shared role APIs finish //////////////////////////////////////////\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic boolean isExistingUser(String userName) throws UserStoreException {\n+\n+\t\tif (UserCoreUtil.isRegistrySystemUser(userName)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\treturn userStore.getUserStoreManager().isExistingUser(userStore.getDomainFreeName());\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif(userStore.isSystemStore()){\n+            systemUserRoleManager.isExistingSystemUser(userName);\n+        }\n+        \n+        \n+        return doCheckExistingUser(userStore.getDomainFreeName());\n+\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final String[] listUsers(String filter, int maxItemLimit) throws UserStoreException {\n+\n+\t\tint index;\n+\t\tindex = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n+\n+\t\t// Check whether we have a secondary UserStoreManager setup.\n+\t\tif (index > 0) {\n+\t\t\t// Using the short-circuit. User name comes with the domain name.\n+\t\t\tString domain = filter.substring(0, index);\n+\n+\t\t\tUserStoreManager secManager = getSecondaryUserStoreManager(domain);\n+\t\t\tif (secManager != null) {\n+\t\t\t\t// We have a secondary UserStoreManager registered for this domain.\n+\t\t\t\tfilter = filter.substring(index + 1);\n+\t\t\t\tif (secManager instanceof AbstractUserStoreManager) {\n+\t\t\t\t\treturn ((AbstractUserStoreManager) secManager)\n+\t\t\t\t\t\t\t.doListUsers(filter, maxItemLimit);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// Exception is not need to as listing of users\n+\t\t\t\t// throw new UserStoreException(\"Invalid Domain Name\");\n+\t\t\t}\n+\t\t} else if (index == 0) {\n+\t\t\treturn doListUsers(filter.substring(index + 1), maxItemLimit);\n+\t\t}\n+\n+\t\tString[] userList = doListUsers(filter, maxItemLimit);\n+\n+\t\tString primaryDomain = realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n+\n+\t\tif (this.getSecondaryUserStoreManager() != null) {\n+\t\t\tfor (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n+\t\t\t\tif (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tUserStoreManager storeManager = entry.getValue();\n+\t\t\t\tif (storeManager instanceof AbstractUserStoreManager) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tString[] secondUserList = ((AbstractUserStoreManager) storeManager)\n+\t\t\t\t\t\t\t\t.doListUsers(filter, maxItemLimit);\n+\t\t\t\t\t\tuserList = UserCoreUtil.combineArrays(userList, secondUserList);\n+\t\t\t\t\t} catch (UserStoreException ex) {\n+\t\t\t\t\t\t// We can ignore and proceed. Ignore the results from this user store.\n+\t\t\t\t\t\tlog.error(ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn userList;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final String[] getUserListOfRole(String roleName) throws UserStoreException {\n+\n+\t\tString[] userNames = new String[0];\n+\n+\t\t// If role does not exit, just return\n+\t\tif (!isExistingRole(roleName)) {\n+\t\t\treturn userNames;\n+\t\t}\n+\n+\t\tUserStore userStore = getUserStore(roleName);\n+\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\treturn userStore.getUserStoreManager().getUserListOfRole(userStore.getDomainFreeName());\n+\t\t}\n+\n+\n+\t\t// #################### Domain Name Free Zone Starts Here\n+\t\t// ################################\n+\n+        if(userStore.isSystemStore()){\n+            return systemUserRoleManager.getUserListOfSystemRole(userStore.getDomainFreeName());\n+        }\n+\n+        String[] userNamesInHybrid = new String[0];\n+\t\tif (userStore.isHybridRole()) {\n+\t\t\tuserNamesInHybrid =\n+\t\t\t                    hybridRoleManager.getUserListOfHybridRole(userStore.getDomainFreeName());\n+\t\t\t// remove domain\n+\t\t\tList<String> finalNameList = new ArrayList<String>();\n+            String displayNameAttribute =\n+                    this.realmConfig.getUserStoreProperty(LDAPConstants.DISPLAY_NAME_ATTRIBUTE);\n+\n+            if(userNamesInHybrid != null  && userNamesInHybrid.length > 0){\n+                if(displayNameAttribute != null && displayNameAttribute.trim().length() > 0){\n+                    for (String userName : userNamesInHybrid) {\n+                        String domainName = UserCoreUtil.extractDomainFromName(userName);\n+                        if(domainName == null || domainName.trim().length() == 0){\n+                            finalNameList.add(userName);\n+                        }\n+                        UserStoreManager userManager = userStoreManagerHolder.get(domainName);\n+                        userName = UserCoreUtil.removeDomainFromName(userName);\n+                        if(userManager != null){\n+                            // get displayNames\n+                            String[] displayNames =  ((AbstractUserStoreManager) userManager).\n+                                                    doGetDisplayNamesForInternalRole(new String[]{userName});\n+                            for (String displayName : displayNames) {\n+                                // if domain names are not added by above method, add it\n+                                // here\n+                                String nameWithDomain = UserCoreUtil.addDomainToName(displayName, domainName);\n+                                finalNameList.add(nameWithDomain);\n+                            }\n                         }\n-                    } else {\n-                        updatedUserNameList.add(userName);\n                     }\n                 } else {\n-                    updatedUserNameList.add(userName);\n+                    return userNamesInHybrid;\n                 }\n             }\n-            userNames = updatedUserNameList;\n+\t\t\treturn finalNameList.toArray(new String[finalNameList.size()]);\n+\t\t\t// return\n+\t\t\t// hybridRoleManager.getUserListOfHybridRole(userStore.getDomainFreeName());\n+\t\t}\n+\n+\t\tif (readGroupsEnabled) {\n+\t\t\tuserNames = doGetUserListOfRole(roleName, \"*\");\n+\t\t}\n+\n+\t\treturn userNames;\n+\t}\n+\t\n+\tpublic String[] getRoleListOfUser(String userName) throws UserStoreException {\n+\t\tString[] roleNames = null;\n+\n+\t\t// If user does not exist, just return\n+\t\tif (!isExistingUser(userName)) {\n+\t\t\treturn new String[0];\n+\t\t}\n+\n+\t\t// Check whether roles exist in cache\n+\t\ttry {\n+\t\t\troleNames = getRoleListOfUserFromCache(this.tenantId, userName);\n+\t\t\tif (roleNames != null) {\n+\t\t\t\treturn roleNames;\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\t// If not exist in cache, continue\n+\t\t}\n+\n+\t\tUserStore userStore = getUserStore(userName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\treturn userStore.getUserStoreManager().getRoleListOfUser(userStore.getDomainFreeName());\n+\t\t}\n+\n+        if(userStore.isSystemStore()){\n+            return systemUserRoleManager.getSystemRoleListOfUser(userStore.getDomainFreeName());\n         }\n-        return hybridRoleManager.getHybridRoleListOfUsers(userNames, domainName);\n-    }\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n \n-    protected Map<String, List<String>> doGetInternalRoleListOfUsersWithID(List<String> userIDs, String domainName)\n-            throws UserStoreException {\n+        roleNames = doGetRoleListOfUser(userName, \"*\");\n \n-        List<String> userNamesFromUserIDs = getUserNamesFromUserIDs(userIDs);\n-        Map<String, List<String>> hybridRoleList = new HashMap<>();\n-        Map<String, List<String>> hybridRoleListOfUsers =\n-                hybridRoleManager.getHybridRoleListOfUsers(userNamesFromUserIDs, domainName);\n-        for (Map.Entry<String, List<String>> hybridRoleListOfUser : hybridRoleListOfUsers.entrySet()) {\n-            hybridRoleList.put(getUserIDFromUserName(hybridRoleListOfUser.getKey()), hybridRoleListOfUser.getValue());\n-        }\n-        return hybridRoleList;\n-    }\n+\t\taddToUserRolesCache(this.tenantId,\n+\t\t\t\tUserCoreUtil.addDomainToName(userName, getMyDomainName()), roleNames);\n \n-    /**\n-     * Get hybrid role list of groups.\n-     *\n-     * @param groupNames Group names list.\n-     * @param domainName Domain name of the groups.\n-     * @return Map of hybrid role list of groups.\n-     * @throws UserStoreException userStoreException.\n-     */\n-    public Map<String, List<String>> getHybridRoleListOfGroups(List<String> groupNames, String domainName)\n-            throws UserStoreException {\n-\n-        // Filter hybrid roles if there are any.\n-        List<String> externalGroupNames = new ArrayList<>();\n-        for (String groupName : groupNames) {\n-            String roleDomainName = UserCoreUtil.extractDomainFromName(groupName);\n-            if (UserCoreConstants.INTERNAL_DOMAIN.\n-                    equalsIgnoreCase(roleDomainName) || APPLICATION_DOMAIN.equalsIgnoreCase(roleDomainName)\n-                    || WORKFLOW_DOMAIN.equalsIgnoreCase(roleDomainName) || SYSTEM_DOMAIN_NAME\n-                    .equalsIgnoreCase(roleDomainName)) {\n-                continue;\n-            }\n-            externalGroupNames.add(groupName);\n-        }\n+\t\treturn roleNames;\n \n-        return hybridRoleManager.getHybridRoleListOfGroups(externalGroupNames, domainName);\n-    }\n+\t}\n \n-    /**\n-     * Get hybrid role list of a group.\n-     *\n-     * @param groupName Group name.\n-     * @param domainName Domain name of the group.\n-     * @return List of hybrid roles of the group.\n-     * @throws UserStoreException userStoreException.\n-     */\n-    public List<String> getHybridRoleListOfGroup(String groupName, String domainName) throws UserStoreException {\n+\t/**\n+\t * Getter method for claim manager property specifically to be used in the implementations of\n+\t * UserOperationEventListener implementations\n+\t * \n+\t * @return\n+\t */\n+\tpublic ClaimManager getClaimManager() {\n+\t\treturn claimManager;\n+\t}\n \n-        return getHybridRoleListOfGroups(new ArrayList<>(Collections.singleton(groupName)), domainName)\n-                .getOrDefault(groupName, new ArrayList<>());\n-    }\n+\t/**\n+\t * \n+\t */\n+\tpublic void addRole(String roleName, String[] userList,\n+\t\t\torg.wso2.carbon.user.api.Permission[] permissions, boolean isSharedRole)\n+\t\t\tthrows org.wso2.carbon.user.api.UserStoreException {\n \n-    /**\n-     * Get hybrid role list of users.\n-     *\n-     * @param userNames User names list.\n-     * @param domainName Domain name of the users.\n-     * @return Map of hybrid role list of users.\n-     * @throws UserStoreException userStoreException.\n-     */\n-    public Map<String, List<String>> getHybridRoleListOfUsers(List<String> userNames, String domainName)\n-            throws UserStoreException {\n+\t\tUserStore userStore = getUserStore(roleName);\n+\t\t\n+\t\tif (isSharedRole && !isSharedGroupEnabled()) {\n+\t\t\tthrow new org.wso2.carbon.user.api.UserStoreException(\n+\t\t\t                                                      \"User store doesn't support shared user roles functionality\");\n+\t\t}\n \n-        return hybridRoleManager.getHybridRoleListOfUsers(userNames, domainName);\n-    }\n+        if (userStore.isHybridRole()) {\n+\t\t\tdoAddInternalRole(userStore.getDomainFreeName(), userList, permissions);\n+\t\t\treturn;\n+\t\t}\n+        \n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().addRole(userStore.getDomainFreeName(),\n+\t\t\t\t\tUserCoreUtil.removeDomainFromNames(userList), permissions, isSharedRole);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\t// This happens only once during first startup - adding administrator user/role.\n+\t\tif (roleName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n+\t\t\troleName = userStore.getDomainFreeName();\n+\t\t\tuserList = UserCoreUtil.removeDomainFromNames(userList);\n+\t\t}\n+\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreAddRole(roleName, userList, permissions, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t\t// Check for validations\n+\t\tif (isReadOnly()) {\n+\t\t\tthrow new UserStoreException(\n+\t\t\t\t\t\"Cannot add role to Read Only user store unless it is primary\");\n+\t\t}\n+\n+\t\tif (!isRoleNameValid(roleName)) {\n+\t\t\tString regEx = realmConfig\n+\t\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n+\t\t\tthrow new UserStoreException(\n+\t\t\t\t\t\"Role name not valid. Role name must be a non null string with following format, \"\n+\t\t\t\t\t\t\t+ regEx);\n+\t\t}\n+\n+\t\tif (doCheckExistingRole(roleName)) {\n+\t\t\tthrow new UserStoreException(\"Role name: \" + roleName +\n+\t\t\t                             \" in the system. Please pick another role name.\");\n+\t\t}\n+\n+\t\tString roleWithDomain = null;\n+\t\tif (!isReadOnly() && writeGroupsEnabled) {\n+\t\t\t// add role in to actual user store\n+\t\t\tdoAddRole(roleName, userList,isSharedRole);\n+\n+\t\t\troleWithDomain = UserCoreUtil.addDomainToName(roleName, getMyDomainName());\n+\t\t} else {\n+\t\t\tthrow new UserStoreException(\n+                         \"Role cannot be added. User store is read only or cannot write groups.\");\n+\t\t}\n+\n+\t\t// add permission in to the the permission store\n+\t\tif (permissions != null) {\n+\t\t\tfor (org.wso2.carbon.user.api.Permission permission : permissions) {\n+\t\t\t\tString resourceId = permission.getResourceId();\n+\t\t\t\tString action = permission.getAction();\n+                if(resourceId == null || resourceId.trim().length() ==0 ){\n+                    continue;\n+                }\n \n-    /**\n-     * Get hybrid role list of a user.\n-     *\n-     * @param userName User name.\n-     * @param domainName Domain name of the user.\n-     * @return List of hybrid roles of the user.\n-     * @throws UserStoreException userStoreException.\n-     */\n-    public List<String> getHybridRoleListOfUser(String userName, String domainName) throws UserStoreException {\n+                if(action == null || action.trim().length() ==0 ){\n+                    // default action value // TODO\n+                    action = \"read\";\n+                }\n+\t\t\t\t// This is a special case. We need to pass domain aware name.\n+\t\t\t\tuserRealm.getAuthorizationManager().authorizeRole(roleWithDomain, resourceId,\n+\t\t\t\t\t\taction);\n+\t\t\t}\n+\t\t}\n \n-        return getHybridRoleListOfUsers(new ArrayList<>(Collections.singleton(userName)), domainName)\n-                .getOrDefault(userName, new ArrayList<>());\n-    }\n+\t\t// if existing users are added to role, need to update user role cache\n+\t\tif ((userList != null) && (userList.length > 0)) {\n+\t\t\tclearUserRolesCacheByTenant(tenantId);\n+\t\t}\n \n-    /**\n-     * Check whether the given hybrid role is exist in the system.\n-     *\n-     * @param roleName Role name.\n-     * @return {@code true} if the given role is exist in the system.\n-     * @throws UserStoreException UserStoreException.\n-     */\n-    public boolean isExistingHybridRole(String roleName) throws UserStoreException {\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostAddRole(roleName, userList, permissions, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n \n-        return hybridRoleManager.isExistingRole(removeInternalDomain(roleName));\n-    }\n+\t}\n \n     /**\n-     * Update group list of role.\n+     * TODO move to API\n      *\n-     * @param roleName      Role name.\n-     * @param deletedGroups Deleted groups.\n-     * @param newGroups     New groups.\n-     * @throws UserStoreException UserStoreException.\n+     * @return\n      */\n-    public void updateGroupListOfHybridRole(String roleName, String[] deletedGroups, String[] newGroups)\n-            throws UserStoreException {\n-\n-        hybridRoleManager.updateGroupListOfHybridRole(removeInternalDomain(roleName), deletedGroups, newGroups);\n-    }\n+\tpublic boolean isSharedGroupEnabled() {\n+\t\tString value = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.SHARED_GROUPS_ENABLED);\n+\t\ttry {\n+\t\t\treturn realmConfig.isPrimary() && !isReadOnly() && TRUE_VALUE.equalsIgnoreCase(value);\n+\t\t} catch (UserStoreException e) {\n+\t\t\tlog.error(e);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Removes the shared roles relevant to the provided tenant domain\n+\t * \n+\t * @param sharedRoles\n+\t * @param tenantDomain\n+\t */\n+\tprotected void filterSharedRoles(List<String> sharedRoles, String tenantDomain) {\n+\t\tif (tenantDomain != null) {\n+\t\t\tfor (Iterator<String> i = sharedRoles.iterator(); i.hasNext();) {\n+\t\t\t\tString role = i.next();\n+\t\t\t\tif (role.indexOf(tenantDomain) > -1) {\n+\t\t\t\t\ti.remove();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Delete the role with the given role name\n+\t * \n+\t * @param roleName The role name\n+\t * @throws org.wso2.carbon.user.core.UserStoreException\n+\t * \n+\t */\n+\tpublic final void deleteRole(String roleName) throws UserStoreException {\n+\n+\t\tif (UserCoreUtil.isPrimaryAdminRole(roleName, realmConfig)) {\n+\t\t\tthrow new UserStoreException(\"Cannot delete admin role\");\n+\t\t}\n+\t\tif (UserCoreUtil.isEveryoneRole(roleName, realmConfig)) {\n+\t\t\tthrow new UserStoreException(\"Cannot delete everyone role\");\n+\t\t}\n+\n+\t\tUserStore userStore = getUserStore(roleName);\n+\t\tif (userStore.isRecurssive()) {\n+\t\t\tuserStore.getUserStoreManager().deleteRole(userStore.getDomainFreeName());\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif (userStore.isHybridRole()) {\n+\t\t\thybridRoleManager.deleteHybridRole(userStore.getDomainFreeName());\n+            clearUserRolesCacheByTenant(tenantId);\n+\t\t\treturn;\n+\t\t}\n+//\n+//\t\tRoleContext ctx = createRoleContext(roleName);\n+//\t\tif (isOthersSharedRole(roleName)) {\n+//\t\t\tthrow new UserStoreException(\n+//\t\t\t                             \"Logged in user doesn't have permission to delete a role belong to other tenant\");\n+//\t\t}\n \n-    private String removeInternalDomain(String roleName) {\n \n-        if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName))) {\n-            return UserCoreUtil.removeDomainFromName(roleName);\n+        if (!doCheckExistingRole(roleName)) {\n+            throw new UserStoreException(\"Can not delete non exiting role\");\n         }\n-        return roleName;\n-    }\n \n-    /**\n-     * Convert a map of lists to a set of unique elements.\n-     *\n-     * @param mapOfLists Map of lists.\n-     * @return list with unique elements.\n-     */\n-    private Set<String> getUniqueSet(Map<String, List<String>> mapOfLists) {\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPreDeleteRole(roleName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n \n-        Set<String> fullSet = new HashSet<>();\n-        for (List<String> list : mapOfLists.values()) {\n-            fullSet.addAll(list);\n-        }\n-        return fullSet;\n-    }\n+\t\tif (!isReadOnly() && writeGroupsEnabled) {\n+\t\t\tdoDeleteRole(roleName);\n+\t\t} else {\n+\t\t\tthrow new UserStoreException(\n+\t\t\t                             \"Role cannot be deleted. User store is read only or cannot write groups.\");\n+\t\t}\n \n-    /**\n-     * Only gets the external roles of the user.\n-     *\n-     * @param userName Name of the user - who we need to find roles.\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    protected abstract String[] doGetExternalRoleListOfUser(String userName, String filter)\n-            throws UserStoreException;\n+        // clear role authorization\n+        userRealm.getAuthorizationManager().clearRoleAuthorization(roleName);\n \n-    /**\n-     * Only gets the external roles of the user.\n-     *\n-     * @param userID user ID of the user.\n-     * @return external roles list of the user.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected String[] doGetExternalRoleListOfUserWithID(String userID, String filter) throws UserStoreException {\n+        // clear cache\n+\t\tclearUserRolesCacheByTenant(tenantId);\n+\n+\t\t// #################### <Listeners> #####################################################\n+\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n+\t\t\t\t.getUserOperationEventListeners()) {\n+\t\t\tif (!listener.doPostDeleteRole(roleName, this)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\t// #################### </Listeners> #####################################################\n+\n+\t}\n+\n+\t/**\n+\t *\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprivate UserStore getUserStore(String user) throws UserStoreException {\n+\n+\t\tint index;\n+\t\tindex = user.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n+\t\tUserStore userStore = new UserStore();\n+\t\tString domainFreeName = null;\n+\n+\t\t// Check whether we have a secondary UserStoreManager setup.\n+\t\tif (index > 0) {\n+\t\t\t// Using the short-circuit. User name comes with the domain name.\n+\t\t\tString domain = user.substring(0, index);\n+\t\t\tUserStoreManager secManager = getSecondaryUserStoreManager(domain);\n+\t\t\tdomainFreeName = user.substring(index + 1);\n+\n+\t\t\tif (secManager != null) {\n+\t\t\t\tuserStore.setUserStoreManager((AbstractUserStoreManager) secManager);\n+\t\t\t\tuserStore.setDomainAwareName(user);\n+\t\t\t\tuserStore.setDomainFreeName(domainFreeName);\n+\t\t\t\tuserStore.setDomainName(domain);\n+\t\t\t\tuserStore.setRecurssive(true);\n+\t\t\t\treturn userStore;\n+\t\t\t} else {\n+\t\t\t\tif (!domain.equalsIgnoreCase(getMyDomainName())) {\n+\t\t\t\t\tif ((UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain))) {\n+\t\t\t\t\t\tuserStore.setHybridRole(true);\n+                    } else if(UserCoreConstants.SYSTEM_DOMAIN_NAME.equalsIgnoreCase(domain)) {\n+                        userStore.setSystemStore(true);\n+\t\t\t\t\t} else {\n+                        throw new UserStoreException(\"Invalid Domain Name\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tString domain = UserCoreUtil.getDomainName(realmConfig);\n+\t\tuserStore.setUserStoreManager(this);\n+\t\tif (index > 0) {\n+\t\t\tuserStore.setDomainAwareName(user);\n+\t\t\tuserStore.setDomainFreeName(domainFreeName);\n+\t\t} else {\n+\t\t\tuserStore.setDomainAwareName(domain + CarbonConstants.DOMAIN_SEPARATOR + user);\n+\t\t\tuserStore.setDomainFreeName(user);\n+\t\t}\n+\t\tuserStore.setRecurssive(false);\n+\t\tuserStore.setDomainName(domain);\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetExternalRoleListOfUserWithID operation is not implemented in: \" + this.getClass());\n+        return userStore;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final UserStoreManager getSecondaryUserStoreManager() {\n+\t\treturn secondaryUserStoreManager;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final UserStoreManager getSecondaryUserStoreManager(String userDomain) {\n+\t\tif (userDomain == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn userStoreManagerHolder.get(userDomain.toUpperCase());\n+\t}\n+\n+\t/**\n+\t * \n+\t */\n+\tpublic final void setSecondaryUserStoreManager(UserStoreManager secondaryUserStoreManager) {\n+\t\tthis.secondaryUserStoreManager = secondaryUserStoreManager;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final void addSecondaryUserStoreManager(String userDomain,\n+\t\t\tUserStoreManager userStoreManager) {\n+\t\tif (userDomain != null) {\n+\t\t\tuserStoreManagerHolder.put(userDomain.toUpperCase(), userStoreManager);\n+\t\t}\n+\t}\n+\t\n+    public final void clearAllSecondaryUserStores() {\n+        userStoreManagerHolder.clear();\n+        \n+        if (getMyDomainName() != null) {\n+            userStoreManagerHolder.put(getMyDomainName().toUpperCase(), this);\n         }\n-        throw new NotImplementedException(\n-                \"doGetExternalRoleListOfUserWithID operation is not implemented in: \" + this.getClass());\n     }\n \n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final String[] getAllSecondaryRoles() throws UserStoreException {\n+\t\tUserStoreManager secondary = this.getSecondaryUserStoreManager();\n+\t\tList<String> roleList = new ArrayList<String>();\n+\t\twhile (secondary != null) {\n+\t\t\tString[] roles = secondary.getRoleNames(true);\n+\t\t\tif (roles != null && roles.length > 0) {\n+\t\t\t\tCollections.addAll(roleList, roles);\n+\t\t\t}\n+\t\t\tsecondary = secondary.getSecondaryUserStoreManager();\n+\t\t}\n+\t\treturn roleList.toArray(new String[roleList.size()]);\n+\t}\n+\n+\t/**\n+\t * \n+\t * @return\n+\t */\n+\tpublic boolean isSCIMEnabled() {\n+\t\tString scimEnabled = realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_SCIM_ENABLED);\n+\t\tif (scimEnabled != null) {\n+\t\t\treturn Boolean.parseBoolean(scimEnabled);\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}                  doAddInternalRole\n+\t */\n+\tpublic final String[] getHybridRoles() throws UserStoreException {\n+\t\treturn hybridRoleManager.getHybridRoles(\"*\");\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final String[] getRoleNames() throws UserStoreException {\n+\t\treturn getRoleNames(false);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tpublic final String[] getRoleNames(boolean noHybridRoles) throws UserStoreException {\n+\t\treturn getRoleNames(\"*\", -1, noHybridRoles, true, true);\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param roleName\n+\t * @param userList\n+\t * @param permissions\n+\t * @throws UserStoreException\n+\t */\n+\tprotected void doAddInternalRole(String roleName, String[] userList,\n+                                                org.wso2.carbon.user.api.Permission [] permissions)\n+\t\t\tthrows UserStoreException {\n+\n+\t\t// #################### Domain Name Free Zone Starts Here ################################\n+\n+\t\tif (hybridRoleManager.isExistingRole(UserCoreUtil.removeDomainFromName(roleName))) {\n+\t\t\tthrow new UserStoreException(\"Role name: \" + roleName\n+\t\t\t\t\t+ \" in the system. Please pick another role name.\");\n+\t\t}\n+\n+\t\thybridRoleManager.addHybridRole(UserCoreUtil.removeDomainFromName(roleName), userList);\n+\n+\t\tif (permissions != null) {\n+\t\t\tfor (org.wso2.carbon.user.api.Permission  permission : permissions) {\n+\t\t\t\tString resourceId = permission.getResourceId();\n+\t\t\t\tString action = permission.getAction();\n+\t\t\t\t// This is a special case. We need to pass domain aware name.\n+\t\t\t\tuserRealm.getAuthorizationManager().authorizeRole(\n+\t\t\t\t\t\tUserCoreUtil.addInternalDomainName(roleName), resourceId, action);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif ((userList != null) && (userList.length > 0)) {\n+\t\t\tclearUserRolesCacheByTenant(this.tenantId);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Returns the set of shared roles which applicable for the logged in tenant\n+\t * \n+\t * @param tenantDomain tenant domain of the shared roles. If this is null, \n+     *                     returns all shared roles of available tenant domains\n+     * @param filter\n+\t * @param maxItemLimit\n+\t * @return\n+\t */\n+\tprotected abstract String[] doGetSharedRoleNames(String tenantDomain, String filter, \n+                                                     int maxItemLimit) throws UserStoreException;\n \n-    /**\n-     * Returns the shared roles list of the user\n-     *\n-     * @param userName\n+\t/**\n+\t * TODO This method would returns the role Name actually this must be implemented in interface.\n+\t * As it is not good to change the API in point release. This has been added to Abstract class\n+\t * \n+\t * @param filter\n+\t * @param maxItemLimit\n+\t * @param noInternalRoles\n      * @return\n-     * @throws UserStoreException\n-     */\n-    protected abstract String[] doGetSharedRoleListOfUser(String userName,\n-                                                          String tenantDomain, String filter) throws UserStoreException;\n-\n-    /**\n-     * Only gets the shared roles of the user.\n-     *\n-     * @param userID user ID.\n-     * @return roles list.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected String[] doGetSharedRoleListOfUserWithID(String userID, String tenantDomain, String filter)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetSharedRoleListOfUserWithID operation is not implemented in: \" + this.getClass());\n+\t * @throws UserStoreException\n+\t */\n+\tpublic final String[] getRoleNames(String filter, int maxItemLimit, boolean noInternalRoles,\n+                                                    boolean noSystemRole, boolean  noSharedRoles)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tString[] roleList = new String[0];\n+\n+\t\tif (!noInternalRoles) {\n+\t\t\troleList = hybridRoleManager.getHybridRoles(UserCoreUtil.removeDomainFromName(filter));\n+\t\t}\n+        \n+        if(!noSystemRole){\n+            String[] systemRoles = systemUserRoleManager.getSystemRoles();\n+            roleList = UserCoreUtil.combineArrays(roleList, systemRoles);\n         }\n-        throw new NotImplementedException(\n-                \"doGetSharedRoleListOfUserWithID operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Add role with a list of users and permissions provided.\n-     *\n-     * @param roleName\n-     * @param userList\n-     * @throws UserStoreException\n-     */\n-    protected abstract void doAddRole(String roleName, String[] userList, boolean shared) throws UserStoreException;\n+\t\tint index;\n+\t\tindex = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n+\n+\t\t// Check whether we have a secondary UserStoreManager setup.\n+\t\tif (index > 0) {\n+\t\t\t// Using the short-circuit. User name comes with the domain name.\n+\t\t\tString domain = filter.substring(0, index);\n+\n+\t\t\tUserStoreManager secManager = getSecondaryUserStoreManager(domain);\n+\t\t\tif (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain)) {\n+\t\t\t\treturn new String[0];\n+\t\t\t}\n+\t\t\tif (secManager != null) {\n+\t\t\t\t// We have a secondary UserStoreManager registered for this domain.\n+\t\t\t\tfilter = filter.substring(index + 1);\n+\t\t\t\tif (secManager instanceof AbstractUserStoreManager) {\n+\t\t\t\t\tString[] externalRoles = ((AbstractUserStoreManager) secManager)\n+\t\t\t\t\t\t\t.doGetRoleNames(filter, maxItemLimit);\n+\t\t\t\t\treturn UserCoreUtil.combineArrays(roleList, externalRoles);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tthrow new UserStoreException(\"Invalid Domain Name\");\n+\t\t\t}\n+\t\t} else if (index == 0) {\n+\t\t\tString[] externalRoles = doGetRoleNames(filter.substring(index + 1), maxItemLimit);\n+\t\t\treturn UserCoreUtil.combineArrays(roleList, externalRoles);\n+\t\t}\n+\n+\t\tString[] externalRoles = doGetRoleNames(filter, maxItemLimit);\n+\t\troleList = UserCoreUtil.combineArrays(externalRoles, roleList);\n+\n+\t\tString primaryDomain = getMyDomainName();\n+\n+\t\tif (this.getSecondaryUserStoreManager() != null) {\n+\t\t\tfor (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n+\t\t\t\tif (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tUserStoreManager storeManager = entry.getValue();\n+\t\t\t\tif (storeManager instanceof AbstractUserStoreManager) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tString[] secondRoleList = ((AbstractUserStoreManager) storeManager)\n+\t\t\t\t\t\t\t\t.doGetRoleNames(filter, maxItemLimit);\n+\t\t\t\t\t\troleList = UserCoreUtil.combineArrays(roleList, secondRoleList);\n+\t\t\t\t\t} catch (UserStoreException e) {\n+\t\t\t\t\t\t// We can ignore and proceed. Ignore the results from this user store.\n+\t\t\t\t\t\tlog.error(e);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn roleList;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param userName\n+\t * @param claims\n+\t * @param domainName\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprivate Map<String, String> doGetUserClaimValues(String userName, String[] claims,\n+\t\t\tString domainName, String profileName) throws UserStoreException {\n+\n+\t\t// Here the user name should be domain-less.\n+\t\tboolean requireRoles = false;\n+\t\tboolean requireIntRoles = false;\n+\t\tboolean requireExtRoles = false;\n+\t\tString roleClaim = null;\n+\n+        if(profileName == null || profileName.trim().length() == 0){\n+            profileName = UserCoreConstants.DEFAULT_PROFILE;\n+        }\n \n-    /**\n-     * Add role with a list of users and permissions provided.\n-     *\n-     * @param roleName role name.\n-     * @param userList userIDs list.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doAddRoleWithID(String roleName, String[] userList, boolean shared) throws UserStoreException {\n+\t\tSet<String> propertySet = new HashSet<String>();\n+\t\tfor (String claim : claims) {\n \n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doAddRoleWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"doAddRoleWithID operation is not implemented in: \" + this.getClass());\n+\t\t\t// There can be cases some claim values being requested for claims\n+\t\t\t// we don't have.\n+\t\t\tString property = null;\n+\t\t\ttry {\n+\t            property = getClaimAtrribute(claim, userName, domainName);\n+            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n+\t            throw new UserStoreException(e);\n+            }\n+\t\t\tif (property != null\n+\t\t\t\t\t&& (!UserCoreConstants.ROLE_CLAIM.equalsIgnoreCase(claim)\n+\t\t\t\t\t\t\t|| !UserCoreConstants.INT_ROLE_CLAIM.equalsIgnoreCase(claim) ||\n+                               !UserCoreConstants.EXT_ROLE_CLAIM.equalsIgnoreCase(claim))) {\n+\t\t\t\tpropertySet.add(property);\n+\t\t\t}\n+\n+\t\t\tif (UserCoreConstants.ROLE_CLAIM.equalsIgnoreCase(claim)) {\n+\t\t\t\trequireRoles = true;\n+\t\t\t\troleClaim = claim;\n+\t\t\t} else if (UserCoreConstants.INT_ROLE_CLAIM.equalsIgnoreCase(claim)) {\n+\t\t\t\trequireIntRoles = true;\n+\t\t\t\troleClaim = claim;\n+\t\t\t} else if (UserCoreConstants.EXT_ROLE_CLAIM.equalsIgnoreCase(claim)) {\n+\t\t\t\trequireExtRoles = true;\n+\t\t\t\troleClaim = claim;\n+\t\t\t}\n+\t\t}\n+\n+\t\tString[] properties = propertySet.toArray(new String[propertySet.size()]);\n+\t\tMap<String, String> uerProperties = this.getUserPropertyValues(userName, properties,\n+\t\t\t\tprofileName);\n+\n+\t\tList<String> getAgain = new ArrayList<String>();\n+\t\tMap<String, String> finalValues = new HashMap<String, String>();\n+\n+\t\tfor (String claim : claims) {\n+\t\t\tClaimMapping mapping;\n+\t\t\ttry {\n+\t\t\t\tmapping = (ClaimMapping) claimManager.getClaimMapping(claim);\n+\t\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n+\t\t\t\tthrow new UserStoreException(e);\n+\t\t\t}\n+\t\t\tif (mapping != null) {\n+\t\t\t\tString property = null;\n+\n+\t\t\t\tif (domainName != null) {\n+\t\t\t\t\tMap<String, String> attrMap = mapping.getMappedAttributes();\n+\t\t\t\t\tif (attrMap != null) {\n+\t\t\t\t\t\tString attr = null;\n+\t\t\t\t\t\tif ((attr = attrMap.get(domainName.toUpperCase())) != null) {\n+\t\t\t\t\t\t\tproperty = attr;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tproperty = mapping.getMappedAttribute();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tproperty = mapping.getMappedAttribute();\n+\t\t\t\t}\n+\n+\t\t\t\tString value = uerProperties.get(property);\n+\n+\t\t\t\tif (profileName.equals(UserCoreConstants.DEFAULT_PROFILE)) {\n+\t\t\t\t\t// Check whether we have a value for the requested attribute\n+\t\t\t\t\tif (value != null && value.trim().length() > 0) {\n+\t\t\t\t\t\tfinalValues.put(claim, value);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif (value != null && value.trim().length() > 0) {\n+\t\t\t\t\t\tfinalValues.put(claim, value);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (getAgain.size() > 0) {\n+\t\t\t// oh the beautiful recursion\n+\t\t\tMap<String, String> mapClaimValues = this.getUserClaimValues(userName,\n+\t\t\t\t\t(String[]) getAgain.toArray(new String[getAgain.size()]),\n+\t\t\t\t\tprofileName);\n+\n+\t\t\tIterator<Map.Entry<String, String>> ite3 = mapClaimValues.entrySet().iterator();\n+\t\t\twhile (ite3.hasNext()) {\n+\t\t\t\tMap.Entry<String, String> entry = ite3.next();\n+\t\t\t\tif (entry.getValue() != null) {\n+\t\t\t\t\tfinalValues.put(entry.getKey(), entry.getValue());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// We treat roles claim in special way.\n+\t\tString[] roles = null;\n+\n+\t\tif (requireRoles) {\n+\t\t\troles = getRoleListOfUser(userName);\n+\t\t} else if (requireIntRoles) {\n+\t\t\troles = doGetInternalRoleListOfUser(userName, \"*\");\n+\t\t} else if (requireExtRoles) {\n+\n+\t\t\tList<String> rolesList = new ArrayList<String>();\n+\t\t\tString[] externalRoles = doGetExternalRoleListOfUser(userName, \"*\");\n+\t\t\trolesList.addAll(Arrays.asList(externalRoles));\n+            //if only shared enable\n+            if(isSharedGroupEnabled()){\n+                String[] sharedRoles = doGetSharedRoleListOfUser(userName, null, \"*\");\n+                if (sharedRoles != null) {\n+                    rolesList.addAll(Arrays.asList(sharedRoles));\n+                }\n+            }\n \n-    }\n+\t\t\troles = rolesList.toArray(new String[rolesList.size()]);\n+\t\t}\n+\n+\t\tif (roles != null && roles.length > 0) {\n+\t\t\tString delim = \"\";\n+\t\t\tStringBuffer roleBf = new StringBuffer();\n+\t\t\tfor (String role : roles) {\n+\t\t\t\troleBf.append(delim).append(role);\n+\t\t\t\tdelim = \",\";\n+\t\t\t}\n+\t\t\tfinalValues.put(roleClaim, roleBf.toString());\n+\t\t}\n+\n+\t\treturn finalValues;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @return\n+\t */\n+\tprotected String getEveryOneRoleName() {\n+\t\treturn realmConfig.getEveryOneRoleName();\n+\t}\n+\n+\t/**\n+\t * \n+\t * @return\n+\t */\n+\tprotected String getAdminRoleName() {\n+\t\treturn realmConfig.getAdminRoleName();\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param credential\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected boolean checkUserPasswordValid(Object credential) throws UserStoreException {\n+\n+\t\tif (credential == null) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (!(credential instanceof String)) {\n+\t\t\tthrow new UserStoreException(\"Can handle only string type credentials\");\n+\t\t}\n+\n+\t\tString password = ((String) credential).trim();\n+\n+\t\tif (password.length() < 1) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tString regularExpression = realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX);\n+\t\treturn regularExpression == null || isFormatCorrect(regularExpression, password);\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param userName\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected boolean checkUserNameValid(String userName) throws UserStoreException {\n+\n+\t\tif (userName == null || CarbonConstants.REGISTRY_SYSTEM_USERNAME.equals(userName)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tuserName = userName.trim();\n+\n+\t\tif (userName.length() < 1) {\n+\t\t\treturn false;\n+\t\t}\n \n+        String regularExpression = realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG_EX);\n+        \n+        if (MultitenantUtils.isEmailUserName()) {\n+            regularExpression = realmConfig\n+                    .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_WITH_EMAIL_JS_REG_EX);\n+            if (regularExpression == null) {\n+                regularExpression = UserCoreConstants.RealmConfig.EMAIL_VALIDATION_REGEX;\n+            }\n+        }\n+        \n+        if (regularExpression != null){\n+             regularExpression = regularExpression.trim();\n+        }\n+\n+\t\treturn regularExpression == null || regularExpression.equals(\"\")\n+\t\t\t\t|| isFormatCorrect(regularExpression, userName);\n+\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param roleName\n+\t * @return\n+\t */\n+\tprotected boolean isRoleNameValid(String roleName) {\n+\t\tif (roleName == null) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (roleName.length() < 1) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tString regularExpression = realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n+\t\tif (regularExpression != null) {\n+\t\t\tif (!isFormatCorrect(regularExpression, roleName)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param tenantID\n+\t * @param userName\n+\t * @return\n+\t */\n+\tprotected String[] getRoleListOfUserFromCache(int tenantID, String userName) {\n+\t\tif (userRolesCache != null) {\n+\t\t\treturn userRolesCache.getRolesListOfUser(cacheIdentifier, tenantID, userName);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param tenantID\n+\t */\n+\tprotected void clearUserRolesCacheByTenant(int tenantID) {\n+\t\tif (userRolesCache != null) {\n+\t\t\tuserRolesCache.clearCacheByTenant(tenantID);\n+\t\t}\n+\t\tAuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n+\t\tauthorizationCache.clearCacheByTenant(tenantID);\n+\t}\n \n     /**\n-     * delete the role.\n      *\n-     * @param roleName\n-     * @throws UserStoreException\n-     */\n-    protected abstract void doDeleteRole(String roleName) throws UserStoreException;\n-\n-    /**\n-     * update the role name with the new name\n-     *\n-     * @param roleName\n-     * @param newRoleName\n-     * @throws UserStoreException\n-     */\n-    protected abstract void doUpdateRoleName(String roleName, String newRoleName)\n-            throws UserStoreException;\n-\n-    /**\n-     * This method would returns the role Name actually this must be implemented in interface. As it\n-     * is not good to change the API in point release. This has been added to Abstract class\n-     *\n-     * @param filter\n-     * @param maxItemLimit\n-     * @return\n-     * @throws .UserStoreException\n-     */\n-    protected abstract String[] doGetRoleNames(String filter, int maxItemLimit)\n-            throws UserStoreException;\n-\n-    /**\n-     * @param filter\n-     * @param maxItemLimit\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    protected abstract String[] doListUsers(String filter, int maxItemLimit)\n-            throws UserStoreException;\n-\n-    /**\n-     * Get the user list as for the given filter and max item limit.\n-     *\n-     * @param filter       filter.\n-     * @param maxItemLimit max items limit.\n-     * @return list of users.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n+     * @param userName\n      */\n-    protected List<User> doListUsersWithID(String filter, int maxItemLimit)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doListUsersWithID operation is not implemented in: \" + this.getClass());\n+    protected void clearUserRolesCache(String userName) {\n+        if (userRolesCache != null) {\n+            userRolesCache.clearCacheEntry(cacheIdentifier, tenantId, userName);\n         }\n-        throw new NotImplementedException(\"doListUsersWithID operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public String[] getProfileNamesWithID(String userID) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"getProfileNamesWithID operation is not implemented in: \" + this.getClass());\n+        AuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n+        authorizationCache.clearCacheByUser(tenantId, userName);\n+    }\n+\n+\t/**\n+\t * \n+\t * @param tenantID\n+\t * @param userName\n+\t * @param roleList\n+\t */\n+\tprotected void addToUserRolesCache(int tenantID, String userName, String[] roleList) {\n+\t\tif (userRolesCache != null) {\n+\t\t\tuserRolesCache.addToCache(cacheIdentifier, tenantID, userName, roleList);\n+\t\t\tAuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n+\t\t\tauthorizationCache.clearCacheByTenant(tenantID);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t */\n+\tprotected void initUserRolesCache() {\n+\n+\t\tString userRolesCacheEnabledString = (realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLES_CACHE_ENABLED));\n+\n+\t\tString userCoreCacheIdentifier = realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_CORE_CACHE_IDENTIFIER);\n+\n+\t\tif (userCoreCacheIdentifier != null && userCoreCacheIdentifier.trim().length() > 0) {\n+\t\t\tcacheIdentifier = userCoreCacheIdentifier;\n+\t\t} else {\n+            cacheIdentifier = UserCoreConstants.DEFAULT_CACHE_IDENTIFIER;\n         }\n-        throw new NotImplementedException(\"getProfileNamesWithID operation is not implemented in: \" + this.getClass());\n-    }\n \n-    /**\n-     * Count users with claims.\n-     *\n-     * @param claimURI Claim uri\n-     * @param valueFilter Filter\n-     * @throws UserStoreException UserStoreException\n-     */\n-    public long doCountUsersWithClaims(String claimURI, String valueFilter) throws UserStoreException {\n+\t\tif (userRolesCacheEnabledString != null && !userRolesCacheEnabledString.equals(\"\")) {\n+\t\t\tuserRolesCacheEnabled = Boolean.parseBoolean(userRolesCacheEnabledString);\n+\t\t\tif (log.isDebugEnabled()) {\n+\t\t\t\tlog.debug(\"User Roles Cache is configured to:\" + userRolesCacheEnabledString);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif (log.isDebugEnabled()) {\n+\t\t\t\tlog.info(\"User Roles Cache is not configured. Default value: \"\n+\t\t\t\t\t\t+ userRolesCacheEnabled + \" is taken.\");\n+\t\t\t}\n+\t\t}\n \n-        throw new UserStoreException(\"Operation is not supported\");\n+\t\tif (userRolesCacheEnabled) {\n+            int timeOut = UserCoreConstants.USER_ROLE_CACHE_DEFAULT_TIME_OUT;\n+            String timeOutString = realmConfig.\n+                getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_ROLE_CACHE_TIME_OUT);\n+            if(timeOutString != null){\n+                timeOut = Integer.parseInt(timeOutString);\n+            }\n+\t\t\tuserRolesCache = UserRolesCache.getInstance();\n+            userRolesCache.setTimeOut(timeOut);\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param regularExpression\n+\t * @param attribute\n+\t * @return\n+\t */\n+\tprivate boolean isFormatCorrect(String regularExpression, String attribute) {\n+\t\tPattern p2 = Pattern.compile(regularExpression);\n+\t\tMatcher m2 = p2.matcher(attribute);\n+\t\treturn m2.matches();\n+\t}\n+\n+\t/**\n+\t * This is to replace escape characters in user name at user login if replace escape characters\n+\t * enabled in user-mgt.xml. Some User Stores like ApacheDS stores user names by replacing escape\n+\t * characters. In that case, we have to parse the username accordingly.\n+\t * \n+\t * @param userName\n+\t */\n+\tprotected String replaceEscapeCharacters(String userName) {\n+\t\t\n+\t\tif(log.isDebugEnabled()) {\n+\t\t\tlog.debug(\"Replacing excape characters in \" + userName);\n+\t\t}\n+\t\tString replaceEscapeCharactersAtUserLoginString = realmConfig\n+\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_REPLACE_ESCAPE_CHARACTERS_AT_USER_LOGIN);\n+\n+\t\tif (replaceEscapeCharactersAtUserLoginString != null) {\n+\t\t\treplaceEscapeCharactersAtUserLogin = Boolean\n+\t\t\t\t\t.parseBoolean(replaceEscapeCharactersAtUserLoginString);\n+\t\t\tif (log.isDebugEnabled()) {\n+\t\t\t\tlog.debug(\"Replace escape characters at userlogin is condifured to: \"\n+\t\t\t\t\t\t+ replaceEscapeCharactersAtUserLoginString);\n+\t\t\t}\n+\t\t\tif (replaceEscapeCharactersAtUserLogin) {\n+\t\t\t\t// Currently only '\\' & '\\\\' are identified as escape characters\n+\t\t\t\t// that needs to be\n+\t\t\t\t// replaced.\n+\t\t\t\treturn userName.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\");\n+\t\t\t}\n+\t\t}\n+\t\treturn userName;\n+\t}\n+\n+\t/**\n+\t * TODO: Remove this method. We should not use DTOs\n+\t * \n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tpublic RoleDTO[] getAllSecondaryRoleDTOs() throws UserStoreException {\n+\t\tUserStoreManager secondary = this.getSecondaryUserStoreManager();\n+\t\tList<RoleDTO> roleList = new ArrayList<RoleDTO>();\n+\t\twhile (secondary != null) {\n+\t\t\tString domain = secondary.getRealmConfiguration().getUserStoreProperty(\n+\t\t\t\t\tUserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n+\t\t\tString[] roles = secondary.getRoleNames(true);\n+\t\t\tif (roles != null && roles.length > 0) {\n+\t\t\t\tCollections.addAll(roleList, UserCoreUtil.convertRoleNamesToRoleDTO(roles, domain));\n+\t\t\t}\n+\t\t\tsecondary = secondary.getSecondaryUserStoreManager();\n+\t\t}\n+\t\treturn roleList.toArray(new RoleDTO[roleList.size()]);\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param roleName\n+\t * @param userList\n+\t * @param permissions\n+\t * @throws UserStoreException\n+\t */\n+\tpublic void addSystemRole(String roleName, String[] userList, Permission[] permissions)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tif (!isRoleNameValid(roleName)) {\n+\t\t\tString regEx = realmConfig\n+\t\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n+\t\t\tthrow new UserStoreException(\n+\t\t\t\t\t\"Role name not valid. Role name must be a non null string with following format, \"\n+\t\t\t\t\t\t\t+ regEx);\n+\t\t}\n+\n+\t\tif (systemUserRoleManager.isExistingRole(roleName)) {\n+\t\t\tthrow new UserStoreException(\"Role name: \" + roleName\n+\t\t\t\t\t+ \" in the system. Please pick another role name.\");\n+\t\t}\n+\t\tsystemUserRoleManager.addSystemRole(roleName, userList);\n+\t}\n+\n+\n+\t/**\n+\t * \n+\t * \n+\t * @param roleName\n+\t * @param filter\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected abstract String[] doGetUserListOfRole(String roleName, String filter)\n+\t\t\tthrows UserStoreException;\n+\n+\t/**\n+\t * \n+\t * \n+\t * @param userName\n+\t * @param filter\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tpublic final String[] doGetRoleListOfUser(String userName, String filter)\n+\t\t\tthrows UserStoreException {\n+\n+\t\tString[] roleList;\n+\n+\t\tString[] internalRoles = doGetInternalRoleListOfUser(userName, filter);\n+\n+\t\tString[] modifiedExternalRoleList = new String[0];\n+\n+\t\tif (readGroupsEnabled) {\n+\t\t\tList<String> roles = new ArrayList<String>();\n+\t\t\tString[] externalRoles = doGetExternalRoleListOfUser(userName, \"*\");\n+\t\t\troles.addAll(Arrays.asList(externalRoles));\n+            if(isSharedGroupEnabled()){\n+                String[] sharedRoles = doGetSharedRoleListOfUser(userName, null, \"*\");\n+                if (sharedRoles != null) {\n+                    roles.addAll(Arrays.asList(sharedRoles));\n+                }\n+            }\n+\t\t\tmodifiedExternalRoleList =\n+\t\t\t                           UserCoreUtil.addDomainToNames(roles.toArray(new String[roles.size()]),\n+\t\t\t                                                         getMyDomainName());\n+\t\t}\n+\n+\t\troleList = UserCoreUtil.combine(internalRoles, Arrays.asList(modifiedExternalRoleList));\n+\n+\t\treturn roleList;\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param filter\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tpublic final String[] getHybridRoles(String filter) throws UserStoreException {\n+\t\treturn hybridRoleManager.getHybridRoles(filter);\n+\t}\n+\n+\t/**\n+\t * \n+\t * @param claimList\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tprotected List<String> getMappingAttributeList(List<String> claimList)\n+\t\t\tthrows UserStoreException {\n+\t\tArrayList<String> attributeList = null;\n+\t\tIterator<String> claimIter = null;\n+\n+\t\tattributeList = new ArrayList<String>();\n+\t\tif (claimList == null) {\n+\t\t\treturn attributeList;\n+\t\t}\n+\t\tclaimIter = claimList.iterator();\n+\t\twhile (claimIter.hasNext()) {\n+\t\t\ttry {\n+\t\t\t\tattributeList.add(claimManager.getAttributeName(claimIter.next()));\n+\t\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n+\t\t\t\tthrow new UserStoreException(e);\n+\t\t\t}\n+\t\t}\n+\t\treturn attributeList;\n+\t}\n+\n+    protected  void doInitialSetup() throws UserStoreException {\n+        systemUserRoleManager = new SystemUserRoleManager(dataSource, tenantId);\n+        hybridRoleManager = new HybridRoleManager(dataSource, tenantId, realmConfig, userRealm);\n     }\n-\n-    /*This is to get the display names of users in hybrid role according to the underlying user store, to be shown in UI*/\n-    protected abstract String[] doGetDisplayNamesForInternalRole(String[] userNames)\n-            throws UserStoreException;\n-\n     /**\n-     * To validate username and credential that is given for authentication.\n      *\n-     * @param userName   Name of the user.\n-     * @param credential Credential of the user.\n-     * @return false if the validation fails.\n-     * @throws UserStoreException UserStore Exception.\n+     * @throws UserStoreException\n+     * @return whether this is the initial startup\n      */\n-    private boolean validateUserNameAndCredential(String userName, Object credential) throws UserStoreException {\n-\n-        boolean isValid = true;\n-        if (userName == null || credential == null) {\n-            String message = String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                    \"Authentication failure. Either Username or Password is null\");\n-            handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(), message,\n-                    userName, credential);\n-            log.error(message);\n-            isValid = false;\n-        }\n-        return isValid;\n-    }\n-\n-    private boolean validateUserIDAndCredential(String userID, Object credential) throws UserStoreException {\n-\n-        boolean isValid = true;\n-        if (userID == null || credential == null) {\n-            String message = String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                    \"Authentication failure. Either Username or Password is null\");\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                    message, userID, credential);\n-            log.error(message);\n-            isValid = false;\n-        }\n-        return isValid;\n-    }\n+    protected void doInitialUserAdding() throws UserStoreException {\n \n-    private boolean validateUserNameAndCredential(String claimURI, String claimValue, Object credential) throws UserStoreException {\n+        String systemUser = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME);\n+        String systemRole = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME);\n \n-        boolean isValid = true;\n-        if (claimURI == null || claimValue == null || credential == null) {\n-            String message = String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                    \"Authentication failure. One of the credential element is null.\");\n-            handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(), message,\n-                    claimValue, credential);\n-            log.error(message);\n-            isValid = false;\n+        if (!systemUserRoleManager.isExistingSystemUser(systemUser)) {\n+            systemUserRoleManager.addSystemUser(systemUser,\n+                    UserCoreUtil.getPolicyFriendlyRandomPassword(systemUser), null);\n         }\n-        return isValid;\n-    }\n \n-    private boolean validateUserNameAndCredentials(List<LoginIdentifier> loginIdentifiers, Object credential)\n-            throws UserStoreException {\n-\n-        boolean isValid = true;\n-        for (LoginIdentifier loginIdentifier : loginIdentifiers) {\n-            if (credential == null || loginIdentifier.getLoginKey() == null\n-                    || loginIdentifier.getLoginValue() == null) {\n-                String message = String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                        \"Authentication failure. One of the credential element is null.\");\n-                handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(), message,\n-                        loginIdentifier.getLoginValue(), credential);\n-                log.error(message);\n-                isValid = false;\n-                break;\n-            }\n+        if (!systemUserRoleManager.isExistingRole(systemRole)) {\n+            systemUserRoleManager.addSystemRole(systemRole, new String[]{systemUser});\n         }\n-        return isValid;\n-    }\n-\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final boolean authenticate(final String userName, final Object credential) throws UserStoreException {\n \n-        try {\n-            return AccessController.doPrivileged((PrivilegedExceptionAction<Boolean>)\n-                    () -> {\n-                        if (!validateUserNameAndCredential(userName, credential)) {\n-                            return false;\n-                        }\n-                        int index = userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-                        boolean domainProvided = index > 0;\n-                        return authenticate(userName, credential, domainProvided);\n-                    });\n-        } catch (PrivilegedActionException e) {\n-            if (!(e.getException() instanceof UserStoreException)) {\n-                handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(), e.getMessage()),\n-                        userName, credential);\n-            }\n-            throw (UserStoreException) e.getException();\n+        if (!hybridRoleManager.isExistingRole(UserCoreUtil.removeDomainFromName(realmConfig\n+                .getEveryOneRoleName()))) {\n+            hybridRoleManager.addHybridRole(\n+                    UserCoreUtil.removeDomainFromName(realmConfig.getEveryOneRoleName()), null);\n         }\n     }\n \n-    protected boolean authenticate(final String userName, final Object credential, final boolean domainProvided)\n-            throws UserStoreException {\n \n-        try {\n-            return AccessController.doPrivileged((PrivilegedExceptionAction<Boolean>)\n-                    () -> authenticateInternalIteration(userName, credential, domainProvided));\n-        } catch (PrivilegedActionException e) {\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n \n-    private boolean authenticateInternalIteration(String userName, Object credential, boolean domainProvided)\n-            throws UserStoreException {\n \n-        List<String> userStorePreferenceOrder = new ArrayList<>();\n-        // Check whether user store chain needs to be generated or not.\n-        if (isUserStoreChainNeeded(userStorePreferenceOrder)) {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"User store chain generation is needed hence generating the user store chain using the user\" +\n-                        \" store preference order: \" + userStorePreferenceOrder);\n-            }\n-            return generateUserStoreChain(userName, credential, domainProvided, userStorePreferenceOrder);\n-        } else {\n-            // Authenticate the user.\n-            return authenticateInternal(userName, credential, domainProvided);\n-        }\n-    }\n+    protected boolean isInitSetupDone() throws UserStoreException {\n \n-    /**\n-     * This method is responsible for calling the relevant method from error listeners when there is a failure while\n-     * authenticating.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param userName     Name of the user.\n-     * @param credential   Relevant credential provided for authentication.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private void handleOnAuthenticateFailure(String errorCode, String errorMessage, String userName, Object credential)\n-            throws UserStoreException {\n+        boolean isInitialSetUp = false;\n+        String systemUser = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME);\n+        String systemRole = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME);\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onAuthenticateFailure(errorCode, errorMessage, userName, credential, this)) {\n-                return;\n-            }\n+        if (systemUserRoleManager.isExistingSystemUser(systemUser)) {\n+            isInitialSetUp = true;\n         }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant method from error listeners when there is a failure while\n-     * authenticating.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param userID       Name of the user.\n-     * @param credential   Relevant credential provided for authentication.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private void handleOnAuthenticateFailureWithID(String errorCode, String errorMessage, String userID,\n-            Object credential) throws UserStoreException {\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onAuthenticateFailureWithID(errorCode, errorMessage, userID, credential, this)) {\n-                return;\n-            }\n+        if (systemUserRoleManager.isExistingRole(systemRole)) {\n+            isInitialSetUp = true;\n         }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant method from error listeners when there is a failure while\n-     * authenticating.\n-     *\n-     * @param errorCode        Error Code.\n-     * @param errorMessage     Error Message.\n-     * @param loginIdentifiers Login identifiers.\n-     * @param credential       Relevant credential provided for authentication.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private void handleOnAuthenticateFailureWithID(String errorCode, String errorMessage,\n-            List<LoginIdentifier> loginIdentifiers, Object credential) throws UserStoreException {\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onAuthenticateFailureWithID(errorCode, errorMessage, loginIdentifiers, credential, this)) {\n-                return;\n-            }\n-        }\n+        return isInitialSetUp;\n     }\n \n     /**\n-     * This method is responsible for calling the relevant method from error listeners when there is a failure while\n-     * authenticating.\n      *\n-     * @param errorCode              Error Code.\n-     * @param errorMessage           Error Message.\n-     * @param preferredUserNameClaim Preferred username claim.\n-     * @param preferredUserNameValue Preferred username value.\n-     * @param credential             Relevant credential provided for authentication.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private void handleOnAuthenticateFailureWithID(String errorCode, String errorMessage, String preferredUserNameClaim,\n-            String preferredUserNameValue, Object credential) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onAuthenticateFailureWithID(errorCode, errorMessage, preferredUserNameClaim,\n-                            preferredUserNameValue, credential, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @param userName\n-     * @param credential\n-     * @param domainProvided\n-     * @return\n      * @throws UserStoreException\n      */\n-    private boolean authenticateInternal(String userName, Object credential, boolean domainProvided)\n-            throws UserStoreException {\n-\n-        boolean iterative = false;\n-        AbstractUserStoreManager abstractUserStoreManager = this;\n-        if (this instanceof IterativeUserStoreManager) {\n-            iterative = true;\n-            abstractUserStoreManager = ((IterativeUserStoreManager) this).getAbstractUserStoreManager();\n-        }\n-\n-        boolean authenticated = false;\n-\n-        UserStore userStore = abstractUserStoreManager.getUserStore(userName);\n+    protected void addInitialAdminData(boolean addAdmin, boolean initialSetup) throws UserStoreException {\n \n-        if (domainProvided && iterative) {\n-            userName = userStore.getDomainFreeName();\n-            userStore.setRecurssive(false);\n+        if (realmConfig.getAdminRoleName() == null || realmConfig.getAdminUserName() == null) {\n+            log.error(\"Admin user name or role name is not valid. Please provide valid values.\");\n+            throw new UserStoreException(\n+                    \"Admin user name or role name is not valid. Please provide valid values.\");\n         }\n+        String adminUserName = UserCoreUtil.removeDomainFromName(realmConfig.getAdminUserName());\n+        String adminRoleName = UserCoreUtil.removeDomainFromName(realmConfig.getAdminRoleName());\n+        boolean userExist = false;\n+        boolean roleExist = false;\n+        boolean isInternalRole = false;\n \n-        if (userStore.isRecurssive() && userStore.getUserStoreManager() instanceof AbstractUserStoreManager) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager()).authenticate(userStore.getDomainFreeName(),\n-                    credential, domainProvided);\n+        try{\n+        \tif(Boolean.parseBoolean(this.getRealmConfiguration().getUserStoreProperty(\n+        \t\t\tUserCoreConstants.RealmConfig.READ_GROUPS_ENABLED))){\n+            \troleExist = doCheckExistingRole(adminRoleName);\n+        \t}\n+        } catch (Exception e){\n+            //ignore\n         }\n \n-        Secret credentialObj;\n-        try {\n-            credentialObj = Secret.getSecret(credential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), userName, credential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n+        if(!roleExist){\n+            try{\n+                roleExist = hybridRoleManager.isExistingRole(adminRoleName);\n+            } catch (Exception e){\n+                //ignore\n+            }\n+            if(roleExist){\n+                isInternalRole = true;\n+            }\n         }\n \n-        // #################### Domain Name Free Zone Starts Here ################################\n+        try{\n+            userExist = doCheckExistingUser(adminUserName);\n+        } catch (Exception e){\n+            //ignore\n+        }\n \n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                Object credentialArgument;\n-                if (listener instanceof SecretHandleableListener) {\n-                    credentialArgument = credentialObj;\n-                } else {\n-                    credentialArgument = credential;\n+        if (!userExist) {\n+            if (isReadOnly()) {\n+                String message = \"Admin user can not be created in primary user store. \" +\n+                        \"User store is read only. \" +\n+                        \"Please pick a user name which is exist in the primary user store as Admin user\";\n+                if(initialSetup){\n+                    throw new UserStoreException(message);\n+                } else if(log.isDebugEnabled()){\n+                    log.error(message);\n                 }\n-\n-                if (!listener.authenticate(userName, credentialArgument, abstractUserStoreManager)) {\n-                    handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(), userName,\n-                            credentialArgument);\n-                    return false;\n+            } else if(addAdmin){\n+                try {\n+                    this.doAddUser(adminUserName, realmConfig.getAdminPassword(),\n+                            null, null, null, false);\n+                } catch (Exception e){\n+                    String message = \"Admin user has not been created. \" +\n+                            \"Error occurs while creating Admin user in primary user store.\" ;\n+                    if(initialSetup){\n+                        throw new UserStoreException(message, e);\n+                    } else if(log.isDebugEnabled()){\n+                        log.error(message, e);\n+                    }\n+                }\n+            } else {\n+                if(initialSetup){\n+                    String message = \"Admin user can not be created in primary user store. \" +\n+                            \"Add-Admin has been set to false. \" +\n+                            \"Please pick a User name which is exist in the primary user store as Admin user\";\n+                    if(initialSetup){\n+                        throw new UserStoreException(message);\n+                    } else if(log.isDebugEnabled()){\n+                        log.error(message);\n+                    }\n                 }\n             }\n+        }\n+        \n \n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = credentialObj;\n-                    } else {\n-                        credentialArgument = credential;\n+        if (!roleExist) {\n+            if(addAdmin){\n+                if(!isReadOnly() && writeGroupsEnabled){\n+                    try {\n+                        this.doAddRole(adminRoleName, new String[]{adminUserName}, false);\n+                    } catch (org.wso2.carbon.user.api.UserStoreException e) {\n+                        String message = \"Admin role has not been created. \" +\n+                                \"Error occurs while creating Admin role in primary user store.\" ;\n+                        if(initialSetup){\n+                            throw new UserStoreException(message, e);\n+                        } else if(log.isDebugEnabled()){\n+                            log.error(message, e);\n+                        }\n                     }\n-\n-                    if (!listener.doPreAuthenticate(userName, credentialArgument, abstractUserStoreManager)) {\n-                        handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                        UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                credentialArgument);\n-                        return false;\n+                } else {\n+                    // creates internal role\n+                    try{\n+                        hybridRoleManager.addHybridRole(adminRoleName, new String[]{adminUserName});\n+                        isInternalRole = true;\n+                    } catch (Exception e){\n+                        String message = \"Admin role has not been created. \" +\n+                                \"Error occurs while creating Admin role in primary user store.\";\n+                        if(initialSetup){\n+                            throw new UserStoreException(message, e);\n+                        } else if(log.isDebugEnabled()){\n+                            log.error(message, e);\n+                        }\n                     }\n                 }\n-            } catch (UserStoreException ex) {\n-                handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                ex.getMessage()), userName, credential);\n-                throw ex;\n+            } else {\n+                String message = \"Admin role can not be created in primary user store. \" +\n+                        \"Add-Admin has been set to false. \" +\n+                        \"Please pick a Role name which is exist in the primary user store as Admin Role\";\n+                if(initialSetup){\n+                    throw new UserStoreException(message);\n+                } else if(log.isDebugEnabled()){\n+                    log.error(message);\n+                }\n             }\n-            // #################### </Listeners> #####################################################\n+        }\n \n-            int tenantId = abstractUserStoreManager.getTenantId();\n \n-            try {\n-                RealmService realmService = UserCoreUtil.getRealmService();\n-                if (realmService != null) {\n-                    boolean tenantActive = realmService.getTenantManager().isTenantActive(tenantId);\n-\n-                    if (!tenantActive) {\n-                        String errorCode = ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getCode();\n-                        String errorMessage = String\n-                                .format(ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getMessage(), tenantId);\n-                        log.warn(errorCode + \" - \" + errorMessage);\n-                        handleOnAuthenticateFailure(errorCode, errorMessage, userName, credential);\n-                        return false;\n+        if(isInternalRole){\n+            if(!hybridRoleManager.isUserInRole(adminUserName, adminRoleName)){\n+                try{\n+                    hybridRoleManager.updateHybridRoleListOfUser(adminUserName, null,\n+                            new String[] { adminRoleName });\n+                } catch (Exception e){\n+                    String message = \"Admin user has not been assigned to Admin role. \" +\n+                            \"Error while assignment is done\";\n+                    if(initialSetup){\n+                        throw new UserStoreException(message, e);\n+                    } else if(log.isDebugEnabled()){\n+                        log.error(message, e);\n                     }\n                 }\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                e.getMessage()), userName, credential);\n-                throw new UserStoreException(\"Error while trying to check tenant status for Tenant : \" + tenantId, e);\n             }\n-\n-            // We are here due to two reason. Either there is no secondary UserStoreManager or no\n-            // domain name provided with user name.\n-            try {\n-                // Let's authenticate with the primary UserStoreManager.\n-                if (abstractUserStoreManager.isUniqueUserIdEnabled()) {\n-                    String userNameProperty = abstractUserStoreManager.getUsernameProperty();\n-                    AuthenticationResult authenticationResult = abstractUserStoreManager\n-                            .doAuthenticateWithID(userNameProperty, userName, credential, null);\n-                    if (authenticationResult.getAuthenticationStatus()\n-                            == AuthenticationResult.AuthenticationStatus.SUCCESS) {\n-                        authenticated = true;\n+            realmConfig.setAdminRoleName(UserCoreUtil.addInternalDomainName(adminRoleName));\n+        } else if(!isReadOnly() && writeGroupsEnabled){\n+            if(!this.doCheckIsUserInRole(adminUserName, adminRoleName)){\n+                if(addAdmin){\n+                    try {\n+                        this.doUpdateRoleListOfUser(adminUserName, null,\n+                                new String[] { adminRoleName });\n+                    } catch (Exception e){\n+                        String message = \"Admin user has not been assigned to Admin role. \" +\n+                                \"Error while assignment is done\";\n+                        if(initialSetup){\n+                            throw new UserStoreException(message, e);\n+                        } else if(log.isDebugEnabled()){\n+                            log.error(message, e);\n+                        }\n                     }\n                 } else {\n-                    authenticated = abstractUserStoreManager.doAuthenticate(userName, credentialObj);\n-                }\n-            } catch (Exception e) {\n-                handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(), e.getMessage()),\n-                        userName, credential);\n-                // We can ignore and proceed. Ignore the results from this user store.\n-\n-                if (log.isDebugEnabled()) {\n-                  log.debug(\"Error occurred while authenticating user: \" + userName, e);\n-                } else {\n-                  log.error(e);\n+                    String message = \"Admin user can not be assigned to Admin role \" +\n+                            \"Add-Admin has been set to false. Please do the assign it in user store level\";\n+                    if(initialSetup){\n+                        throw new UserStoreException(message);\n+                    } else if(log.isDebugEnabled()){\n+                        log.error(message);\n+                    }\n                 }\n-                authenticated = false;\n             }\n-\n-        } finally {\n-            credentialObj.clear();\n         }\n \n-        if (authenticated) {\n-            // Set domain in thread local variable for subsequent operations\n-            UserCoreUtil.setDomainInThreadLocal(UserCoreUtil.getDomainName(abstractUserStoreManager.realmConfig));\n-        }\n-\n-        // If authentication fails in the previous step and if the user has not specified a\n-        // domain- then we need to execute chained UserStoreManagers recursively.\n-        if (!authenticated && !domainProvided) {\n-            AbstractUserStoreManager userStoreManager;\n-            if (this instanceof IterativeUserStoreManager) {\n-                IterativeUserStoreManager iterativeUserStoreManager = (IterativeUserStoreManager) this;\n-                userStoreManager = iterativeUserStoreManager.nextUserStoreManager();\n-            } else {\n-                userStoreManager = (AbstractUserStoreManager) abstractUserStoreManager.getSecondaryUserStoreManager();\n-            }\n-            if (userStoreManager != null) {\n-                authenticated = userStoreManager.authenticate(userName, credential, domainProvided);\n-            }\n-        }\n+        doInitialUserAdding();\n+    }\n+\t/**\n+\t * \n+\t * @param type\n+\t * @return\n+\t * @throws UserStoreException\n+\t */\n+\tpublic Map<String, Integer> getMaxListCount(String type) throws UserStoreException {\n+\n+\t\tif (!type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)\n+\t\t\t\t&& !type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)) {\n+\t\t\tthrow new UserStoreException(\"Invalid count parameter\");\n+\t\t}\n+\n+\t\tif (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)\n+\t\t\t\t&& maxUserListCount != null) {\n+\t\t\treturn maxUserListCount;\n+\t\t}\n+\n+\t\tif (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)\n+\t\t\t\t&& maxRoleListCount != null) {\n+\t\t\treturn maxRoleListCount;\n+\t\t}\n+\n+\t\tMap<String, Integer> maxListCount = new HashMap<String, Integer>();\n+\t\tfor (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n+\t\t\tUserStoreManager storeManager = entry.getValue();\n+\t\t\tif (storeManager instanceof AbstractUserStoreManager) {\n+\t\t\t\tString maxConfig = storeManager.getRealmConfiguration().getUserStoreProperty(type);\n+\t\t\t\tif (maxConfig == null) {\n+\t\t\t\t\t// set a default value\n+\t\t\t\t\tmaxConfig = MAX_LIST_LENGTH;\n+\t\t\t\t}\n+\t\t\t\tmaxListCount.put(entry.getKey(), Integer.parseInt(maxConfig));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME) == null) {\n+\t\t\tString maxConfig = realmConfig.getUserStoreProperty(type);\n+\t\t\tif (maxConfig == null) {\n+\t\t\t\t// set a default value\n+\t\t\t\tmaxConfig = MAX_LIST_LENGTH;\n+\t\t\t}\n+\t\t\tmaxListCount.put(null, Integer.parseInt(maxConfig));\n+\t\t}\n+\n+\t\tif (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)) {\n+\t\t\tthis.maxUserListCount = maxListCount;\n+\t\t\treturn this.maxUserListCount;\n+\t\t} else if (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)) {\n+\t\t\tthis.maxRoleListCount = maxListCount;\n+\t\t\treturn this.maxRoleListCount;\n+\t\t} else {\n+\t\t\tthrow new UserStoreException(\"Invalid count parameter\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * \n+\t * @return\n+\t */\n+\tprotected String getMyDomainName() {\n+\t\treturn UserCoreUtil.getDomainName(realmConfig);\n+\t}\n \n-        if (!authenticated) {\n-            handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(),\n-                            \"Authentication failed\"), userName, credential);\n+    protected void persistDomain() throws UserStoreException {\n+        String domain = UserCoreUtil.getDomainName(this.realmConfig);\n+        if (domain != null) {\n+            UserCoreUtil.persistDomain(domain, this.tenantId, this.dataSource);\n         }\n+    }\n \n-        try {\n-            // You cannot change authentication decision in post handler to TRUE\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPostAuthenticate(userName, authenticated, abstractUserStoreManager)) {\n-                    handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName, credential);\n-                    return false;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage(),\n-                            ex.getMessage()), userName, credential);\n-            throw ex;\n+    public void deletePersistedDomain(String domain) throws UserStoreException {\n+        if (domain != null) {\n+        \tif(log.isDebugEnabled()) {\n+        \t\tlog.debug(\"Deleting persisted domain \" + domain);\n+        \t}\n+            UserCoreUtil.deletePersistedDomain(domain, this.tenantId, this.dataSource);\n         }\n-\n-        if (log.isDebugEnabled()) {\n-            if (!authenticated) {\n-                log.debug(\"Authentication failure. Wrong username or password is provided.\");\n-            }\n+    }\n+    \n+    public void updatePersistedDomain(String oldDomain, String newDomain) throws UserStoreException {\n+        if (oldDomain != null && newDomain != null) {\n+        \t// Checks for the newDomain exists already\n+        \t// Traverse through realm configuration chain since USM chain doesn't contains the disabled USMs\n+        \tRealmConfiguration realmConfigTmp = this.getRealmConfiguration();\n+        \twhile (realmConfigTmp != null) {\n+        \t\tString domainName = realmConfigTmp.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n+        \t\tif (newDomain.equalsIgnoreCase(domainName)) {\n+        \t\t\tthrow new UserStoreException(\"Cannot update persisted domain name \"+oldDomain+\" into \"+newDomain+\". New domain name already in use\");\n+        \t\t}\n+        \t\trealmConfigTmp = realmConfigTmp.getSecondaryRealmConfig();\n+        \t}\n+        \t\n+        \tif(log.isDebugEnabled()) {\n+        \t\tlog.debug(\"Renaming persisted domain \" + oldDomain + \" to \" + newDomain);\n+        \t}\n+            UserCoreUtil.updatePersistedDomain(oldDomain, newDomain, this.tenantId, this.dataSource);\n         }\n-\n-        return authenticated;\n     }\n \n-    private String getUsernameProperty() throws org.wso2.carbon.user.api.UserStoreException {\n-\n-        String userNameProperty = realmConfig.getUserStoreProperty(LDAPConstants.USER_NAME_ATTRIBUTE);\n-        if (StringUtils.isBlank(userNameProperty)) {\n-             userNameProperty = claimManager\n-                    .getAttributeName(getMyDomainName(), UserCoreClaimConstants.USERNAME_CLAIM_URI);\n-        }\n-        return userNameProperty;\n+\t/**\n+\t * Checks whether the role is a shared role or not\n+\t * \n+\t * @param roleName\n+\t * @param roleNameBase\n+\t * @return\n+\t */\n+\tpublic boolean isSharedRole(String roleName, String roleNameBase) {\n+\n+\t\t// Only checks the shared groups are enabled\n+\t\treturn isSharedGroupEnabled();\n+\t}\t\n+\t\n+\t/**\n+\t * Checks whether the provided role name belongs to the logged in tenant.\n+\t * This check is done using the domain name which is appended at the end of\n+\t * the role name\n+\t * \n+\t * @param roleName\n+\t * @return\n+\t */\n+\tprotected boolean isOwnRole(String roleName) {\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+    public void addRole(String roleName, String[] userList,\n+                        org.wso2.carbon.user.api.Permission[] permissions)\n+                                              throws org.wso2.carbon.user.api.UserStoreException {\n+\t\taddRole(roleName, userList, permissions, false);\n+\t    \n     }\n \n-    /**\n-     * This method calls the relevant methods when there is a failure while trying to get the claim value of a user.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param userName     Name of the user.\n-     * @param claim        Relevant claim.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleGetUserClaimValueFailure(String errorCode, String errorMessage, String userName, String claim,\n-            String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onGetUserClaimValueFailure(errorCode, errorMessage, userName, claim, profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method calls the relevant methods when there is a failure while trying to get the claim value of a user.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param userID       Name of the user.\n-     * @param claim        Relevant claim.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleGetUserClaimValueFailureWithID(String errorCode, String errorMessage, String userID,\n-            String claim, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onGetUserClaimValueFailureWithID(errorCode, errorMessage, userID, claim, profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final String getUserClaimValue(String userName, String claim, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class, String.class, String.class};\n-            Object object = callSecure(\"getUserClaimValue\", new Object[]{userName, claim, profileName}, argTypes);\n-            return (String) object;\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return userStore.getUserStoreManager().getUserClaimValue(userStore.getDomainFreeName(),\n-                    claim, profileName);\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        // If user does not exist, throw an\n-\n-        boolean isUserExist;\n-        String userID = null;\n-        if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-            userID = getUserIDFromUserName(userName);\n-            isUserExist = userID != null;\n-        } else {\n-            isUserExist = doCheckExistingUser(userName);\n-        }\n-\n-        if (!isUserExist) {\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            handleGetUserClaimValueFailure(errorCode, errorMessage, userName, claim, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        Map<String, String> finalValues;\n-        try {\n-            if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                finalValues = doGetUserClaimValuesWithID(userID, new String[]{claim},\n-                        userStore.getDomainName(), profileName);\n-            } else {\n-                finalValues = doGetUserClaimValues(userName, new String[]{claim}, userStore.getDomainName(),\n-                        profileName);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserClaimValueFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userName, claim, profileName);\n-            throw ex;\n-        }\n-\n-        String value = null;\n-\n-        if (finalValues != null) {\n-            value = finalValues.get(claim);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-\n-        List<String> list = new ArrayList<>();\n-        if (value != null) {\n-            list.add(value);\n-        }\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserClaimValue(userName, claim, list, profileName, this)) {\n-                        handleGetUserClaimValueFailure(\n-                                ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_CLAIM_VALUE.getCode(),\n-                                String.format(\n-                                        ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_CLAIM_VALUE.getMessage(),\n-                                        UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName, claim,\n-                                profileName);\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserClaimValueFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userName, claim, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        if (!list.isEmpty()) {\n-            return list.get(0);\n-        }\n-        return value;\n-    }\n-\n-    private boolean isUniqueUserIdEnabledInUserStore(UserStore userStore) {\n-\n-        return isUniqueUserIdEnabled(userStore.getUserStoreManager());\n-    }\n-\n-    /**\n-     * Checks whether groups and roles separation feature enabled.\n-     *\n-     * @return {@code true} if the groups and roles separation feature enabled.\n-     */\n-    public boolean isRoleAndGroupSeparationEnabled() {\n-\n-        return Boolean.parseBoolean(realmConfig.getAuthorizationManagerProperty(\n-                UserCoreConstants.RealmConfig.PROPERTY_GROUP_AND_ROLE_SEPARATION_ENABLED));\n+    public boolean isOthersSharedRole(String roleName) {\n+\t    return false;\n     }\n-\n-    /**\n-     * This method is responsible for calling relevant listener methods when there is a failure while trying to get\n-     * user claim values.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage Relevant error message.\n-     * @param userName     Name of the user.\n-     * @param claims       Claims requested.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by the relevant listeners.\n-     */\n-    private void handleGetUserClaimValuesFailure(String errorCode, String errorMessage, String userName,\n-            String[] claims, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onGetUserClaimValuesFailure(errorCode, errorMessage, userName, claims, profileName, this)) {\n-                return;\n-            }\n+    public void notifyListeners(String domainName) {\n+        for (UserStoreManagerConfigurationListener aListener : listener) {\n+            aListener.propertyChange(domainName);\n         }\n     }\n \n-    /**\n-     * This method is responsible for calling relevant listener methods when there is a failure while trying to get\n-     * user claim values.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage Relevant error message.\n-     * @param userID       ID of the user.\n-     * @param claims       Claims requested.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by the relevant listeners.\n-     */\n-    private void handleGetUserClaimValuesFailureWithID(String errorCode, String errorMessage, String userID,\n-            String[] claims, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onGetUserClaimValuesFailureWithID(errorCode, errorMessage, userID, claims, profileName, this)) {\n-                return;\n-            }\n-        }\n+    public void addChangeListener(UserStoreManagerConfigurationListener newListener) {\n+        listener.add(newListener);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final Claim[] getUserClaimValues(String userName, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String.class};\n-            Object object = callSecure(\"getUserClaimValues\", new Object[]{userName, profileName}, argTypes);\n-            return (Claim[]) object;\n-        }\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private UserStoreManager createSecondaryUserStoreManager(RealmConfiguration realmConfig,\n+                                                    UserRealm realm) throws UserStoreException {\n \n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return userStore.getUserStoreManager().getUserClaimValues(\n-                    userStore.getDomainFreeName(), profileName);\n-        }\n+        // setting global realm configurations such as everyone role, admin role and admin user\n+        realmConfig.setEveryOneRoleName(this.realmConfig.getEveryOneRoleName());\n+        realmConfig.setAdminUserName(this.realmConfig.getAdminUserName());\n+        realmConfig.setAdminRoleName(this.realmConfig.getAdminRoleName());\n \n-        // #################### Domain Name Free Zone Starts Here ################################\n-        // If user does not exist, throw exception\n-        // Property to check whether this user store supports new APIs with unique user id.\n-        boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        String userID = null;\n-        if (isUniqueUserIdEnabled) {\n-            userID = getUserIDFromUserName(userName);\n+        String className = realmConfig.getUserStoreClass();\n+        if (className == null) {\n+            String errmsg = \"Unable to add user store. UserStoreManager class name is null.\";\n+            log.error(errmsg);\n+            throw new UserStoreException(errmsg);\n         }\n \n-        boolean isUserExists;\n-        if (isUniqueUserIdEnabled) {\n-            isUserExists = userID != null;\n-        } else {\n-            isUserExists = doCheckExistingUser(userStore.getDomainFreeName());\n-        }\n+        HashMap<String, Object> properties = new HashMap<String, Object>();\n+        properties.put(UserCoreConstants.DATA_SOURCE, this.dataSource);\n+        properties.put(UserCoreConstants.FIRST_STARTUP_CHECK, false);\n+        \n+        Class[] initClassOpt1 = new Class[]{RealmConfiguration.class, Map.class,\n+                ClaimManager.class, ProfileConfigurationManager.class, UserRealm.class,\n+                Integer.class};\n+        Object[] initObjOpt1 = new Object[]{realmConfig, properties, realm.getClaimManager(), null, realm,\n+                tenantId};\n \n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleGetUserClaimValuesFailure(errorCode, errorMessage, userName, null, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n+\t// These two methods won't be used\n+        Class[] initClassOpt2 = new Class[]{RealmConfiguration.class, Map.class,\n+                ClaimManager.class, ProfileConfigurationManager.class, UserRealm.class};\n+        Object[] initObjOpt2 = new Object[]{realmConfig, properties, realm.getClaimManager(), null, realm};\n \n-        if (profileName == null || profileName.trim().length() == 0) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n+        Class[] initClassOpt3 = new Class[]{RealmConfiguration.class, Map.class};\n+        Object[] initObjOpt3 = new Object[]{realmConfig, properties};\n \n-        String[] claims;\n         try {\n-            claims = claimManager.getAllClaimUris();\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            handleGetUserClaimValuesFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_URI.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_URI.getMessage(), e.getMessage()),\n-                    userName, null, profileName);\n-            throw new UserStoreException(e);\n-        }\n-\n-        Map<String, String> values = this.getUserClaimValues(userName, claims, profileName);\n-        List<Claim> finalValues = new ArrayList<>();\n-        addClaimValues(values, finalValues);\n-\n-        return finalValues.toArray(new Claim[0]);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final Map<String, String> getUserClaimValues(String userName, String[] claims,\n-                                                        String profileName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String[].class, String.class};\n-            Object object = callSecure(\"getUserClaimValues\", new Object[]{userName, claims, profileName}, argTypes);\n-            return (Map<String, String>) object;\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return userStore.getUserStoreManager().getUserClaimValues(\n-                    userStore.getDomainFreeName(), claims, profileName);\n-        }\n-\n-        String userID = null;\n-        boolean isUserExists;\n-\n-        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        if (isUniqueIdEnabled) {\n-            userID = getUserIDFromUserName(userName);\n-            isUserExists = userID != null;\n-        } else{\n-            isUserExists = doCheckExistingUser(userStore.getDomainFreeName());\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleGetUserClaimValuesFailure(errorCode, errorMessage, userName, null, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-        // check for null claim list\n-        if (claims == null) {\n-            claims = new String[0];\n-        }\n+            Class clazz = Class.forName(className);\n+            Constructor constructor = null;\n+            Object newObject = null;\n \n-        Map<String, String> finalValues;\n-        try {\n-            if (isUniqueIdEnabled) {\n-                finalValues = doGetUserClaimValuesWithID(userID, claims, userStore.getDomainName(), profileName);\n-            } else {\n-                finalValues = doGetUserClaimValues(userStore.getDomainFreeName(), claims, userStore.getDomainName(), profileName);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Start initializing class with the first option\");\n             }\n-        } catch (UserStoreException ex) {\n-            handleGetUserClaimValuesFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userName, claims, profileName);\n-            throw ex;\n-        }\n \n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener\n-                            .doPostGetUserClaimValues(userStore.getDomainFreeName(), claims, profileName, finalValues,\n-                                    this)) {\n-                        handleGetUserClaimValuesFailure(\n-                                ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getMessage(),\n-                                        UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName, claims,\n-                                profileName);\n-                        break;\n-                    }\n+            try {\n+                constructor = clazz.getConstructor(initClassOpt1);\n+                newObject = constructor.newInstance(initObjOpt1);\n+                return (UserStoreManager) newObject;\n+            } catch (NoSuchMethodException e) {\n+\t\t// if not found try again.\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Cannont initialize \" + className + \" using the option 1\");\n                 }\n             }\n-        } catch (UserStoreException ex) {\n-            handleGetUserClaimValuesFailure(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userName, claims, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        return finalValues;\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to get the\n-     * user list.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param claim        Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listner methods.\n-     */\n-    private void handleGetUserListFailure(String errorCode, String errorMessage, String claim, String claimValue,\n-            String profileName) throws UserStoreException {\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onGetUserListFailure(errorCode, errorMessage, claim, claimValue, profileName, this)) {\n-                return;\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"End initializing class with the first option\");\n             }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to get the\n-     * user count.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param claim        Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @throws UserStoreException Exception that will be thrown by relevant listner methods.\n-     */\n-    protected void handleGetUserCountFailure(String errorCode, String errorMessage, String claim, String claimValue\n-    ) throws UserStoreException {\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onGetUserCountFailure(errorCode, errorMessage, claim, claimValue, this)) {\n-                return;\n+            try {\n+                constructor = clazz.getConstructor(initClassOpt2);\n+                newObject = constructor.newInstance(initObjOpt2);\n+                return (UserStoreManager) newObject;\n+            } catch (NoSuchMethodException e) {\n+\t\t// if not found try again.\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Cannont initialize \" + className + \" using the option 2\");\n+                }\n             }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to get the\n-     * user list.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param claim        Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private void handleGetUserListFailureWithID(String errorCode, String errorMessage, String claim, String claimValue,\n-            String profileName) throws UserStoreException {\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onGetUserListFailureWithID(errorCode, errorMessage, claim, claimValue, profileName, this)) {\n-                return;\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"End initializing class with the second option\");\n             }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to get the\n-     * user.\n-     *\n-     * @param errorCode       Error Code.\n-     * @param errorMessage    Error Message.\n-     * @param userID          User ID.\n-     * @param requestedClaims Requested Claims.\n-     * @param profileName     Profile Name.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private void handleGetUserFailureWithID(String errorCode, String errorMessage, String userID,\n-            String[] requestedClaims, String profileName) throws UserStoreException {\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onGetUserFailureWithID(errorCode, errorMessage, userID, requestedClaims, profileName, this)) {\n-                return;\n+            try {\n+                constructor = clazz.getConstructor(initClassOpt3);\n+                newObject = constructor.newInstance(initObjOpt3);\n+                return (UserStoreManager) newObject;\n+            } catch (NoSuchMethodException e) {\n+\t\t// cannot initialize in any of the methods. Throw exception.\n+                String message = \"Cannot initialize \" + className + \". Error \" + e.getMessage();\n+                log.error(message);\n+                throw new UserStoreException(message);\n             }\n-        }\n-    }\n \n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to get the\n-     * user list.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param claim        Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @param limit        No of search records.\n-     * @param offset       Start index of the search.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listner methods.\n-     */\n-    private void handleGetUserListFailure(String errorCode, String errorMessage, String claim, String claimValue,\n-            int limit, int offset, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && listener instanceof AbstractUserManagementErrorListener\n-                    && !listener\n-                    .onGetUserListFailure(errorCode, errorMessage, claim, claimValue, limit, offset, profileName,\n-                            this)) {\n-                return;\n-            }\n+        } catch (Throwable e) {\n+            log.error(\"Cannot create \" + className, e);\n+            throw new UserStoreException(e.getMessage() + \"Type \" + e.getClass(), e);\n         }\n+\n     }\n \n     /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to get the\n-     * user list.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param claim        Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @param limit        No of search records.\n-     * @param offset       Start index of the search.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listner methods.\n+     * Adding new User Store Manager to USM chain\n+     * \n+     * @param userStoreRealmConfig\n+     * @param realm \n+     * @throws UserStoreException\n      */\n-    private void handleGetUserListFailureWithID(String errorCode, String errorMessage, String claim, String claimValue,\n-            int limit, int offset, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && listener instanceof AbstractUserManagementErrorListener\n-                    && !((AbstractUserManagementErrorListener) listener)\n-                    .onGetUserListFailureWithID(errorCode, errorMessage, claim, claimValue, limit, offset, profileName,\n-                            this)) {\n-                return;\n-            }\n-        }\n-    }\n+    public void addSecondaryUserStoreManager(RealmConfiguration userStoreRealmConfig,\n+                                                    UserRealm realm) throws UserStoreException {\n+    \t// Creating new UserStoreManager\n+        UserStoreManager manager = createSecondaryUserStoreManager(userStoreRealmConfig, realm);\n \n-    private void handleGetUserListFailure(String errorCode, String errorMassage, Condition condition, String domain,\n-            String profileName, int limit, int offset, String sortBy, String sortOrder) throws UserStoreException {\n+        String domainName = userStoreRealmConfig\n+                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && listener instanceof AbstractUserManagementErrorListener\n-                    && !listener\n-                    .onGetUserListFailure(errorCode, errorMassage, condition, domain, profileName, limit, offset,\n-                            sortBy, sortOrder, this)) {\n-                return;\n-            }\n-        }\n-    }\n+        if (domainName != null) {\n+            if (this.getSecondaryUserStoreManager(domainName) != null) {\n+                String errmsg = \"Could not initialize new user store manager : \"+domainName\n+                        + \" Duplicate domain names not allowed.\";\n+                if(log.isDebugEnabled()) {\n+                \tlog.debug(errmsg);\n+                }\n+                throw new UserStoreException(errmsg);\n+            } else {\n+            \tBoolean isDisabled = false;\n+                if (userStoreRealmConfig\n+                        .getUserStoreProperty(UserCoreConstants.RealmConfig.USER_STORE_DISABLED) != null) {\n+                    isDisabled = Boolean\n+                            .parseBoolean(userStoreRealmConfig\n+                                    .getUserStoreProperty(UserCoreConstants.RealmConfig.USER_STORE_DISABLED));\n+                    if (isDisabled) {\n+                        log.warn(\"Secondary user store disabled with domain \"\n+                                + domainName + \".\");\n+                    }\n+                    else {\n+                    \t// Fulfilled requirements for adding UserStore,\n+                    \t\n+                    \t// Now adding UserStoreManager to end of the UserStoreManager chain\n+                        UserStoreManager tmpUserStoreManager = this;\n+                        while (tmpUserStoreManager.getSecondaryUserStoreManager() != null) {\n+                            tmpUserStoreManager = tmpUserStoreManager\n+                                    .getSecondaryUserStoreManager();\n+                        }\n+                        tmpUserStoreManager.setSecondaryUserStoreManager(manager);\n \n-    private void handleGetUserListFailureWithID(String errorCode, String errorMassage, Condition condition,\n-            String domain, String profileName, int limit, int offset, String sortBy, String sortOrder)\n-            throws UserStoreException {\n+                        // update domainName-USM map to retrieve USM directly by its domain name\n+                        this.addSecondaryUserStoreManager(domainName.toUpperCase(),\n+                                tmpUserStoreManager.getSecondaryUserStoreManager());\n \n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && listener instanceof AbstractUserManagementErrorListener\n-                    && !((AbstractUserManagementErrorListener) listener)\n-                    .onGetUserListFailureWithID(errorCode, errorMassage, condition, domain, profileName, limit, offset,\n-                            sortBy, sortOrder, this)) {\n-                return;\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"UserStoreManager : \" + domainName\n+                                    + \"added to the list\");\n+                        }\n+                    }\n+                }\n             }\n+        } else {\n+            log.warn(\"Could not initialize new user store manager.  \"\n+                    + \"Domain name is not defined\");\n         }\n     }\n \n     /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to get the\n-     * paginated user list.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param claim        Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listner methods.\n+     * Remove given User Store Manager from USM chain\n+     * \n+     * @param userStoreDomainName\n+     * @throws UserStoreException\n      */\n-    private void handleGetPaginatedUserListFailure(String errorCode, String errorMessage, String claim, String\n-            claimValue, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && listener instanceof AbstractUserManagementErrorListener\n-                    && !listener.onGetPaginatedUserListFailure(errorCode, errorMessage, claim, claimValue,\n-                    profileName, this)) {\n+    public void removeSecondaryUserStoreManager(String userStoreDomainName) throws UserStoreException {\n+    \t\n+    \tif(userStoreDomainName == null) {\n+    \t\tthrow new UserStoreException(\"Cannot remove user store. User store domain name is null\");\n+    \t}\n+    \tif(\"\".equals(userStoreDomainName)) {\n+    \t\tthrow new UserStoreException(\"Cannot remove user store. User store domain name is empty\");\n+    \t}  \n+//    \tif(!this.userStoreManagerHolder.containsKey(userStoreDomainName.toUpperCase())) {\n+//    \t\tthrow new UserStoreException(\"Cannot remove user store. User store domain name does not exists\");\n+//    \t}\n+    \t\n+    \tuserStoreDomainName = userStoreDomainName.toUpperCase();\n+    \t\n+    \tboolean isUSMContainsInMap = false;\n+    \tif(this.userStoreManagerHolder.containsKey(userStoreDomainName.toUpperCase())) {\n+    \t\tisUSMContainsInMap = true;\n+        \tthis.userStoreManagerHolder.remove(userStoreDomainName.toUpperCase());\n+        \tif (log.isDebugEnabled()) {\n+                log.debug(\"UserStore: \" + userStoreDomainName+ \" removed from map\");\n+            }\n+    \t}\n+    \t\n+    \tboolean isUSMConatainsInChain = false;\n+        UserStoreManager prevUserStoreManager = this;\n+        while (prevUserStoreManager.getSecondaryUserStoreManager() != null) {\n+            UserStoreManager secondaryUSM =  prevUserStoreManager.getSecondaryUserStoreManager();\n+            if (secondaryUSM.getRealmConfiguration().getUserStoreProperty(UserStoreConfigConstants.DOMAIN_NAME).equalsIgnoreCase(userStoreDomainName)) {\n+            \tisUSMConatainsInChain = true;\n+            \t// Omit deleting user store manager from the chain\n+            \tprevUserStoreManager.setSecondaryUserStoreManager(secondaryUSM.getSecondaryUserStoreManager());\n+                log.info(\"User store: \" + userStoreDomainName + \" of tenant:\" + tenantId + \" is removed from user store chain.\");\n                 return;\n             }\n+            prevUserStoreManager = secondaryUSM;\n+        }\n+        \n+\t    if(!isUSMContainsInMap && isUSMConatainsInChain ) {\n+\t       \tthrow new UserStoreException(\"Removed user store manager : \"+userStoreDomainName+\" didnt exists in userStoreManagerHolder map\");\n+\t    }\n+        else if(isUSMContainsInMap && !isUSMConatainsInChain) {\n+        \tthrow new UserStoreException(\"Removed user store manager : \"+userStoreDomainName+\" didnt exists in user store manager chain\");\n         }\n     }\n \n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to get the\n-     * paginated user list.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param claim        Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listner methods.\n-     */\n-    private void handleGetPaginatedUserListFailureWithID(String errorCode, String errorMessage, String claim,\n-            String claimValue, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && listener instanceof AbstractUserManagementErrorListener\n-                    && !((AbstractUserManagementErrorListener) listener)\n-                    .onGetPaginatedUserListFailureWithID(errorCode, errorMessage, claim, claimValue, profileName,\n-                            this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to list the\n-     * paginated users.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param filter       Username Filter.\n-     * @param limit        No of search results.\n-     * @param offset       Start index of the search.\n-     * @throws UserStoreException Exception that will be thrown by relevant listner methods.\n-     */\n-    private void handleListPaginatedUsersFailure(String errorCode, String errorMessage, String filter, int limit, int\n-            offset) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && listener instanceof AbstractUserManagementErrorListener\n-                    && !listener.onListUsersFailure(errorCode, errorMessage, filter, limit, offset, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to list the\n-     * paginated users.\n-     *\n-     * @param errorCode    Error Code.\n-     * @param errorMessage Error Message.\n-     * @param filter       Username Filter.\n-     * @param limit        No of search results.\n-     * @param offset       Start index of the search.\n-     * @throws UserStoreException Exception that will be thrown by relevant listner methods.\n-     */\n-    private void handleListPaginatedUsersFailureWithID(String errorCode, String errorMessage, String filter, int limit,\n-            int offset) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && listener instanceof AbstractUserManagementErrorListener\n-                    && !((AbstractUserManagementErrorListener) listener)\n-                    .onListUsersFailureWithID(errorCode, errorMessage, filter, limit, offset, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * To call the postGetUserList of relevant listeners.\n-     *\n-     * @param claim            Claim requested.\n-     * @param claimValue       Claim values.\n-     * @param filteredUserList List of filtered users.\n-     * @param isAuditLogOnly   To indicate whether to call only audit log listener.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handlePostGetUserList(String claim, String claimValue, List<String> filteredUserList,\n-            boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserList(claim, claimValue, filteredUserList, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_LIST.getMessage(),\n-                            ex.getMessage()), claim, claimValue, null);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * To call the postGetUserListWithID of relevant listeners.\n-     *\n-     * @param claim            Claim requested.\n-     * @param claimValue       Claim values.\n-     * @param filteredUserList List of filtered users.\n-     * @param isAuditLogOnly   To indicate whether to call only audit log listener.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handlePostGetUserListWithID(String claim, String claimValue, List<User> filteredUserList,\n-            boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserListWithID(claim, claimValue, filteredUserList, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_LIST.getMessage(),\n-                            ex.getMessage()), claim, claimValue, null);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * To call the postGetUserList of relevant listeners.\n-     *\n-     * @param claim            Claim requested.\n-     * @param claimValue       Claim values.\n-     * @param filteredUserList List of filtered users.\n-     * @param limit            No of search results.\n-     * @param offset           Start index of the search.\n-     * @param isAuditLogOnly   To indicate whether to call only audit log listener.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handlePostGetUserList(String claim, String claimValue, List<String> filteredUserList, int limit, int\n-            offset, boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserList(claim, claimValue, filteredUserList, limit, offset, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_LIST.getMessage(),\n-                            ex.getMessage()), claim, claimValue, limit, offset, null);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * To call the postGetUserList of relevant listeners.\n-     *\n-     * @param claim            Claim requested.\n-     * @param claimValue       Claim values.\n-     * @param filteredUserList List of filtered users.\n-     * @param limit            No of search results.\n-     * @param offset           Start index of the search.\n-     * @param isAuditLogOnly   To indicate whether to call only audit log listener.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handlePostGetUserListWithID(String claim, String claimValue, List<User> filteredUserList, int limit,\n-            int offset, boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener\n-                            .doPostGetUserListWithID(claim, claimValue, filteredUserList, limit, offset, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_LIST.getMessage(),\n-                            ex.getMessage()), claim, claimValue, limit, offset, null);\n-            throw ex;\n-        }\n-    }\n-\n-    private void handlePostGetUserList(Condition condition, String domain, String profileName, int limit, int offset,\n-                                       String sortBy, String sortOrder, String[] users, boolean isAuditLogOnly)\n-            throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserList(condition, domain, profileName, limit, offset, sortBy,\n-                            sortOrder, users, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_CONDITIONAL_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_CONDITIONAL_USER_LIST.getMessage(),\n-                            ex.getMessage()), condition, domain, profileName, limit, offset, sortBy, sortOrder);\n-            throw ex;\n-        }\n-    }\n-\n-    private void handlePostGetUserListWithID(Condition condition, String domain, String profileName, int limit,\n-                                             int offset, String sortBy, String sortOrder, List<User> users, boolean isAuditLogOnly)\n-            throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserListWithID(condition, domain, profileName, limit, offset, sortBy,\n-                            sortOrder, users, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_CONDITIONAL_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_CONDITIONAL_USER_LIST.getMessage(),\n-                            ex.getMessage()), condition, domain, profileName, limit, offset, sortBy, sortOrder);\n-            throw ex;\n-        }\n-    }\n-\n-    private void handlePreGetUserList(Condition condition, String domain, String profileName, int limit, int offset,\n-                                      String sortBy, String sortOrder) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent\n-                    .getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPreGetUserList(condition, domain, profileName, limit, offset, sortBy,\n-                            sortOrder, this)) {\n-\n-                        handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET__CONDITIONAL_USER_LIST\n-                                        .getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET__CONDITIONAL_USER_LIST\n-                                                .getMessage(),\n-                                        UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), condition, domain,\n-                                profileName, limit, offset, sortBy, sortOrder);\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET__CONDITIONAL_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET__CONDITIONAL_USER_LIST.getMessage(),\n-                            ex.getMessage()), condition, domain,\n-                    profileName, limit, offset, sortBy, sortOrder);\n-            throw ex;\n-        }\n-    }\n-\n-    private void handlePreGetUserListWithID(Condition condition, String domain, String profileName, int limit,\n-            int offset,\n-            String sortBy, String sortOrder) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent\n-                    .getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPreGetUserListWithID(condition, domain, profileName, limit, offset, sortBy,\n-                            sortOrder, this)) {\n-\n-                        handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET__CONDITIONAL_USER_LIST.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET__CONDITIONAL_USER_LIST.getMessage(),\n-                                        UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), condition, domain,\n-                                profileName, limit, offset, sortBy, sortOrder);\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET__CONDITIONAL_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET__CONDITIONAL_USER_LIST.getMessage(),\n-                            ex.getMessage()), condition, domain,\n-                    profileName, limit, offset, sortBy, sortOrder);\n-            throw ex;\n-        }\n-    }\n-\n-\n-    /**\n-     * To call the postGetPaginatedUserList of relevant listeners.\n-     *\n-     * @param claim            Claim requested.\n-     * @param claimValue       Claim values.\n-     * @param filteredUserList List of filtered users.\n-     * @param isAuditLogOnly   To indicate whether to call only audit log listener.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handlePostGetPaginatedUserList(String claim, String claimValue, List<String> filteredUserList,\n-                                       boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetPaginatedUserList(claim, claimValue, filteredUserList, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetPaginatedUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_PAGINATED_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_PAGINATED_USER_LIST.getMessage(),\n-                            ex.getMessage()), claim, claimValue, null);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * To call the List paginated users of relevant listeners.\n-     *\n-     * @param filter           Username filter.\n-     * @param limit            No of search results.\n-     * @param offset           start index of the search.\n-     * @param filteredUserList List of filtered users.\n-     * @param isAuditLogOnly   To indicate whether to call only audit log listener.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handlePostListPaginatedUsers(String filter, int limit, int offset, List<String> filteredUserList,\n-                                                boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostListUsers(filter, limit, offset, filteredUserList, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleListPaginatedUsersFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_LIST_PAGINATED_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_LIST_PAGINATED_USER.getMessage(),\n-                            ex.getMessage()), filter, limit, offset);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * To call the List paginated users of relevant listeners.\n-     *\n-     * @param filter           Username filter.\n-     * @param limit            No of search results.\n-     * @param offset           start index of the search.\n-     * @param filteredUserList List of filtered users.\n-     * @param isAuditLogOnly   To indicate whether to call only audit log listener.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handlePostListPaginatedUsersWithID(String filter, int limit, int offset, List<User> filteredUserList,\n-            boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    if (isAuditLogOnly && !listener.getClass().getName()\n-                            .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                        continue;\n-                    }\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostListUsersWithID(filter, limit, offset, filteredUserList, this)) {\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleListPaginatedUsersFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_LIST_PAGINATED_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_LIST_PAGINATED_USER.getMessage(),\n-                            ex.getMessage()), filter, limit, offset);\n-            throw ex;\n-        }\n-    }\n-\n-    @Override\n-    public final String[] getUserList(String claim, String claimValue, String profileName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class, String.class };\n-            Object object = callSecure(\"getUserList\", new Object[] { claim, claimValue, profileName }, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        if (claim == null) {\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getCode();\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getMessage(), \"\");\n-            handleGetUserListFailure(errorCode, errorMessage, null, claimValue, profileName);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.toString());\n-        }\n-\n-        if (claimValue == null) {\n-            handleGetUserListFailure(ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.getCode(),\n-                    ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.getMessage(), claim, null, profileName);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.toString());\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Listing users who having value as \" + claimValue + \" for the claim \" + claim);\n-        }\n-\n-        if (!isUniqueUserIdEnabled() && (USERNAME_CLAIM_URI.equalsIgnoreCase(claim) || SCIM_USERNAME_CLAIM_URI\n-                .equalsIgnoreCase(claim) || SCIM2_USERNAME_CLAIM_URI.equalsIgnoreCase(claim))) {\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Switching to list users using username\");\n-            }\n-\n-            String[] filteredUsers = listUsers(claimValue, MAX_ITEM_LIMIT_UNLIMITED);\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Filtered users: \" + Arrays.toString(filteredUsers));\n-            }\n-\n-            return filteredUsers;\n-        }\n-\n-        // Extracting the domain from claimValue.\n-        String extractedDomain = null;\n-        int index;\n-        index = claimValue.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        if (index > 0) {\n-            String[] names = claimValue.split(CarbonConstants.DOMAIN_SEPARATOR);\n-            extractedDomain = names[0].trim();\n-        }\n-\n-        UserStoreManager userManager = this;\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            UserStoreManager secondaryUserStoreManager = getSecondaryUserStoreManager(extractedDomain);\n-            if (secondaryUserStoreManager != null) {\n-                userManager = secondaryUserStoreManager;\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Domain: \" + extractedDomain + \" is passed with the claim and user store manager is loaded\"\n-                            + \" for the given domain name.\");\n-                }\n-            }\n-        }\n-\n-        if (userManager instanceof JDBCUserStoreManager && (SCIM_USERNAME_CLAIM_URI.equalsIgnoreCase(claim)\n-                || SCIM2_USERNAME_CLAIM_URI.equalsIgnoreCase(claim))) {\n-            if (userManager.isExistingUser(claimValue)) {\n-                return new String[] { claimValue };\n-            } else {\n-                return new String[0];\n-            }\n-        }\n-\n-        claimValue = UserCoreUtil.removeDomainFromName(claimValue);\n-\n-        final List<String> filteredUserList = new ArrayList<>();\n-\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    if (listener instanceof AbstractUserOperationEventListener) {\n-                        AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                        if (!newListener.doPreGetUserList(claim, claimValue, filteredUserList, userManager)) {\n-                            handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), claim,\n-                                    claimValue, profileName);\n-                            break;\n-                        }\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                ex.getMessage()), claim, claimValue, profileName);\n-                throw ex;\n-            }\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Pre listener user list: \" + filteredUserList + \" for domain: \" + extractedDomain);\n-        }\n-\n-        // Iterate through user stores and check for users for this claim.\n-        List<User> usersFromUserStore;\n-        List<String> userNamesFromUserStore;\n-        if (isUniqueUserIdEnabled(userManager)) {\n-            usersFromUserStore = doGetUserListWithID(claim, claimValue, profileName, extractedDomain, userManager);\n-            userNamesFromUserStore = usersFromUserStore.stream()\n-                    .map(User::getDomainQualifiedUsername).collect(Collectors.toList());\n-        } else {\n-            userNamesFromUserStore = doGetUserList(claim, claimValue, profileName, extractedDomain, userManager);\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Users from user store: \" + extractedDomain + \" : \" + userNamesFromUserStore);\n-            }\n-        }\n-        filteredUserList.addAll(userNamesFromUserStore);\n-\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            handlePostGetUserList(claim, claimValue, filteredUserList, false);\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Post listener user list: \" + filteredUserList + \" for domain: \" + extractedDomain);\n-        }\n-\n-        Collections.sort(filteredUserList);\n-        return filteredUserList.toArray(new String[0]);\n-    }\n-\n-    private boolean isUniqueUserIdEnabled(UserStoreManager userManager) {\n-\n-        return userManager instanceof AbstractUserStoreManager && ((AbstractUserStoreManager) userManager).isUniqueUserIdEnabled();\n-    }\n-\n-    private List<String> doGetUserList(String claim, String claimValue, String profileName, String extractedDomain,\n-                                       UserStoreManager userManager)\n-        throws UserStoreException {\n-\n-        String property;\n-\n-        // If domain is present, then we search within that domain only.\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-\n-            if (userManager == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"No user store manager found for domain: \" + extractedDomain);\n-                }\n-                return Collections.emptyList();\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Domain found in claim value. Searching only in the \" + extractedDomain + \" for possible \" +\n-                        \"matches\");\n-            }\n-\n-            try {\n-                property = claimManager.getAttributeName(extractedDomain, claim);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                e.getMessage()), claim, claimValue, profileName);\n-                throw new UserStoreException(\n-                        \"Error occurred while retrieving attribute name for domain : \" + extractedDomain + \" and claim \"\n-                                + claim, e);\n-            }\n-            if (property == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Could not find matching property for\\n\" +\n-                            \"claim :\" + claim +\n-                            \"domain :\" + extractedDomain);\n-                }\n-                return Collections.emptyList();\n-            }\n-\n-            if (userManager instanceof AbstractUserStoreManager) {\n-                // Get the user list and return with domain appended.\n-                try {\n-                    AbstractUserStoreManager userStoreManager = (AbstractUserStoreManager) userManager;\n-                    String[] userArray = userStoreManager.getUserListFromProperties(property, claimValue, profileName);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"List of filtered users for: \" + extractedDomain + \" : \" + Arrays.asList(userArray));\n-                    }\n-                    return Arrays.asList(UserCoreUtil.addDomainToNames(userArray, extractedDomain));\n-                } catch (UserStoreException ex) {\n-                    handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(),\n-                                    ex.getMessage()), claim, claimValue, profileName);\n-                    throw ex;\n-                }\n-            } else {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"getUserListFromProperties is not supported by this user store: \" +\n-                            userManager.getClass());\n-                }\n-                return Collections.emptyList();\n-            }\n-        }\n-\n-        // If domain is not given then search all the user stores.\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"No domain name found in claim value. Searching through all user stores for possible matches\");\n-        }\n-\n-        List<String> usersFromAllStoresList = new ArrayList<>();\n-        List<UserStoreManager> userStoreManagers = getUserStoreMangers();\n-\n-        // Iterate through all of available user store managers.\n-        for (UserStoreManager userStoreManager : userStoreManagers) {\n-\n-            // If this is not an instance of Abstract User Store Manger we can ignore the flow since we can't get the\n-            // domain name.\n-            if (!(userStoreManager instanceof AbstractUserStoreManager)) {\n-                continue;\n-            }\n-\n-            // For all the user stores append the domain name to the claim and pass it recursively (Including PRIMARY).\n-            String domainName = ((AbstractUserStoreManager) userStoreManager).getMyDomainName();\n-            String claimValueWithDomain;\n-            if (StringUtils.equalsIgnoreCase(domainName, UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME)) {\n-                claimValueWithDomain = domainName + CarbonConstants.DOMAIN_SEPARATOR + claimValue;\n-            } else {\n-                claimValueWithDomain = UserCoreUtil.addDomainToName(claimValue, domainName);\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Invoking the get user list for domain: \" + domainName + \" for claim: \" + claim +\n-                        \" value: \" + claimValueWithDomain);\n-            }\n-\n-            // Recursively call the getUserList method appending the domain to claim value.\n-            List<String> userList = Arrays.asList(userStoreManager.getUserList(claim,\n-                    claimValueWithDomain, profileName));\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Secondary user list for domain: \" + domainName + \" : \" + userList);\n-            }\n-\n-            usersFromAllStoresList.addAll(userList);\n-        }\n-\n-        // Done with all user store processing. Return the user array if not empty.\n-        return usersFromAllStoresList;\n-    }\n-\n-    @Override\n-    public final List<User> getUserListWithID(String claim, String claimValue, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class, String.class };\n-            Object object = callSecure(\"getUserListWithID\", new Object[] { claim, claimValue, profileName }, argTypes);\n-            return (List<User>) object;\n-        }\n-\n-        if (claim == null) {\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getCode();\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getMessage(), \"\");\n-            handleGetUserListFailureWithID(errorCode, errorMessage, null, claimValue, profileName);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.toString());\n-        }\n-\n-        if (claimValue == null) {\n-            handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.getCode(),\n-                    ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.getMessage(), claim, null, profileName);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.toString());\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Listing users who having value as \" + claimValue + \" for the claim \" + claim);\n-        }\n-\n-        // Extracting the domain from claimValue.\n-        String extractedDomain = null;\n-        int index;\n-        index = claimValue.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        if (index > 0) {\n-            String[] names = claimValue.split(CarbonConstants.DOMAIN_SEPARATOR);\n-            extractedDomain = names[0].trim();\n-        }\n-\n-        UserStoreManager userManager = this;\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            UserStoreManager secondaryUserStoreManager = getSecondaryUserStoreManager(extractedDomain);\n-            if (secondaryUserStoreManager != null) {\n-                userManager = secondaryUserStoreManager;\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Domain: \" + extractedDomain + \" is passed with the claim and user store manager is loaded\"\n-                            + \" for the given domain name.\");\n-                }\n-            }\n-        }\n-\n-        claimValue = UserCoreUtil.removeDomainFromName(claimValue);\n-        final List<User> filteredUserList = new ArrayList<>();\n-\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    if (listener instanceof AbstractUserOperationEventListener) {\n-                        AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                        if (!newListener.doPreGetUserListWithID(claim, claimValue, filteredUserList, userManager)) {\n-                            handleGetUserListFailureWithID(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), claim,\n-                                    claimValue, profileName);\n-                            break;\n-                        }\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                ex.getMessage()), claim, claimValue, profileName);\n-                throw ex;\n-            }\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Pre listener user list: \" + filteredUserList + \" for domain: \" + extractedDomain);\n-        }\n-\n-        // Iterate through user stores and check for users for this claim.\n-        List<User> usersFromUserStore;\n-        if (isUniqueUserIdEnabled(userManager)) {\n-            usersFromUserStore = doGetUserListWithID(claim, claimValue, profileName, extractedDomain, userManager);\n-        } else {\n-            List<String> userNamesFromUserStore = doGetUserList(claim, claimValue, profileName, extractedDomain,\n-                    userManager);\n-            usersFromUserStore = userUniqueIDManger\n-                    .listUsers(userNamesFromUserStore, (AbstractUserStoreManager) userManager);\n-        }\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Users from user store: \" + extractedDomain + \" : \" + usersFromUserStore.stream()\n-                    .map(User::getUsername).collect(Collectors.toList()));\n-        }\n-        filteredUserList.addAll(usersFromUserStore);\n-\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            handlePostGetUserListWithID(claim, claimValue, filteredUserList, false);\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Post listener user list: \" + filteredUserList.stream().map(User::getUsername)\n-                    .collect(Collectors.toList()) + \" for domain: \" + extractedDomain);\n-        }\n-\n-        return filteredUserList;\n-    }\n-\n-    private List<User> doGetUserListWithID(String claim, String claimValue, String profileName, String extractedDomain,\n-            UserStoreManager userManager) throws UserStoreException {\n-\n-        String property;\n-        // If domain is present, then we search within that domain only.\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-\n-            if (userManager == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"No user store manager found for domain: \" + extractedDomain);\n-                }\n-                return Collections.emptyList();\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Domain found in claim value. Searching only in the \" + extractedDomain + \" for possible \"\n-                        + \"matches\");\n-            }\n-\n-            try {\n-                property = claimManager.getAttributeName(extractedDomain, claim);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                e.getMessage()), claim, claimValue, profileName);\n-                throw new UserStoreException(\n-                        \"Error occurred while retrieving attribute name for domain : \" + extractedDomain + \" and claim \"\n-                                + claim, e);\n-            }\n-            if (property == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Could not find matching property for\\n\" + \"claim :\" + claim + \"domain :\"\n-                            + extractedDomain);\n-                }\n-                return Collections.emptyList();\n-            }\n-\n-            if (userManager instanceof AbstractUserStoreManager) {\n-                // Get the user list and return with domain appended.\n-                try {\n-                    AbstractUserStoreManager userStoreManager = (AbstractUserStoreManager) userManager;\n-                    List<String> userIDs = userStoreManager\n-                            .doGetUserListFromPropertiesWithID(property, claimValue, profileName);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"List of filtered users for: \" + extractedDomain + \" : \" + Arrays.asList(userIDs));\n-                    }\n-                    return userStoreManager.getUsersFromIDs(userIDs, null, extractedDomain, profileName);\n-\n-                } catch (UserStoreException ex) {\n-                    handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(),\n-                                    ex.getMessage()), claim, claimValue, profileName);\n-                    throw ex;\n-                }\n-            } else {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"doGetUserListFromPropertiesWithID is not supported by this user store: \" + userManager\n-                            .getClass());\n-                }\n-                return Collections.emptyList();\n-            }\n-        }\n-\n-        // If domain is not given then search all the user stores.\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"No domain name found in claim value. Searching through all user stores for possible matches\");\n-        }\n-\n-        List<User> usersFromAllStoresList = new ArrayList<>();\n-        List<UserStoreManager> userStoreManagers = getUserStoreMangers();\n-\n-        // Iterate through all of available user store managers.\n-        for (UserStoreManager userStoreManager : userStoreManagers) {\n-\n-            // If this is not an instance of Abstract User Store Manger we can ignore the flow since we can't get the\n-            // domain name.\n-            if (!(userStoreManager instanceof AbstractUserStoreManager)) {\n-                continue;\n-            }\n-\n-            // For all the user stores append the domain name to the claim and pass it recursively (Including PRIMARY).\n-            String domainName = ((AbstractUserStoreManager) userStoreManager).getMyDomainName();\n-            String claimValueWithDomain;\n-            if (StringUtils.equalsIgnoreCase(domainName, UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME)) {\n-                claimValueWithDomain = domainName + CarbonConstants.DOMAIN_SEPARATOR + claimValue;\n-            } else {\n-                claimValueWithDomain = UserCoreUtil.addDomainToName(claimValue, domainName);\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Invoking the get user list for domain: \" + domainName + \" for claim: \" + claim + \" value: \"\n-                        + claimValueWithDomain);\n-            }\n-\n-            // Recursively call the getUserList method appending the domain to claim value.\n-            List<User> userList = ((AbstractUserStoreManager) userStoreManager).getUserListWithID(claim,\n-                    claimValueWithDomain, profileName);\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Secondary user list for domain: \" + domainName + \" : \" + userList);\n-            }\n-\n-            usersFromAllStoresList.addAll(userList);\n-        }\n-\n-        // Done with all user store processing. Return the user array if not empty.\n-        return usersFromAllStoresList;\n-    }\n-\n-    private List<String> doGetUserList(String claim, String claimValue, String profileName, int limit, int offset,\n-                                       String extractedDomain, UserStoreManager userManager)\n-            throws UserStoreException {\n-\n-        String property;\n-\n-        // If domain is present, then we search within that domain only.\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-\n-            if (userManager == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"No user store manager found for domain: \" + extractedDomain);\n-                }\n-                return Collections.emptyList();\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Domain found in claim value. Searching only in the \" + extractedDomain + \" for possible \" +\n-                        \"matches\");\n-            }\n-\n-            try {\n-                property = claimManager.getAttributeName(extractedDomain, claim);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                e.getMessage()), claim, claimValue, limit, offset, profileName);\n-                throw new UserStoreException(\n-                        \"Error occurred while retrieving attribute name for domain : \" + extractedDomain + \" and claim \"\n-                                + claim, e);\n-            }\n-            if (property == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Could not find matching property for\\n\" +\n-                            \"claim :\" + claim +\n-                            \"domain :\" + extractedDomain);\n-                }\n-                return Collections.emptyList();\n-            }\n-\n-            if (userManager instanceof AbstractUserStoreManager) {\n-                // Get the user list and return with domain appended.\n-                try {\n-                    AbstractUserStoreManager userStoreManager = (AbstractUserStoreManager) userManager;\n-                    PaginatedSearchResult result = userStoreManager.getUserListFromProperties(property, claimValue,\n-                            profileName, limit, offset);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"List of filtered paginated users for: \" + extractedDomain + \" : \" + Arrays.asList\n-                                (result.getUsers()));\n-                    }\n-                    return Arrays.asList(UserCoreUtil.addDomainToNames(result.getUsers(), extractedDomain));\n-                } catch (UserStoreException ex) {\n-                    handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(),\n-                                    ex.getMessage()), claim, claimValue, limit, offset, profileName);\n-                    throw ex;\n-                }\n-            } else {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"getUserListFromProperties is not supported by this user store: \" +\n-                            userManager.getClass());\n-                }\n-                return Collections.emptyList();\n-            }\n-        }\n-\n-        // If domain is not given then search all the user stores.\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"No domain name found in claim value. Searching through all user stores for possible matches\");\n-        }\n-\n-        List<String> usersFromAllStoresList = new ArrayList<>();\n-        List<UserStoreManager> userStoreManagers = getUserStoreMangers();\n-        int nonPaginatedUserCount = 0;\n-\n-        // Iterate through all of available user store managers.\n-        for (UserStoreManager userStoreManager : userStoreManagers) {\n-\n-            // If this is not an instance of Abstract User Store Manger we can ignore the flow since we can't get the\n-            // domain name.\n-            if (!(userStoreManager instanceof AbstractUserStoreManager)) {\n-                continue;\n-            }\n-\n-            if (limit <= 0) {\n-                return usersFromAllStoresList;\n-            }\n-\n-            // For all the user stores append the domain name to the claim and pass it recursively (Including PRIMARY).\n-            String domainName = ((AbstractUserStoreManager) userStoreManager).getMyDomainName();\n-\n-            try {\n-                property = claimManager.getAttributeName(domainName, claim);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                e.getMessage()), claim, claimValue, limit, offset, profileName);\n-                throw new UserStoreException(\n-                        \"Error occurred while retrieving attribute name for domain : \" + extractedDomain + \" and claim \"\n-                                + claim, e);\n-            }\n-\n-            // Recursively call the getUserList method appending the domain to claim value.\n-            PaginatedSearchResult userList = getUserListFromProperties(property, claimValue, profileName, limit, offset);\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Secondary user list for domain: \" + domainName + \" : \" + userList);\n-            }\n-            limit = limit - userList.getUsers().length;\n-            nonPaginatedUserCount = userList.getSkippedUserCount();\n-\n-            if (userList.getUsers().length > 0) {\n-                offset = 1;\n-            } else {\n-                offset = offset - nonPaginatedUserCount;\n-            }\n-\n-            usersFromAllStoresList.addAll(Arrays.asList(UserCoreUtil.addDomainToNames(userList.getUsers(), domainName)));\n-        }\n-\n-        // Done with all user store processing. Return the user array if not empty.\n-        return usersFromAllStoresList;\n-    }\n-\n-    /**\n-     * Get the list of user store managers available including primary user store manger.\n-     * @return List of user store managers available.\n-     */\n-    private List<UserStoreManager> getUserStoreMangers() {\n-\n-        List<UserStoreManager> userStoreManagers = new ArrayList<>();\n-        UserStoreManager currentUserStoreManager = this;\n-\n-        // Get the list of user store managers(Including PRIMARY). Later we have to iterate through them.\n-        while (currentUserStoreManager != null) {\n-            userStoreManagers.add(currentUserStoreManager);\n-            currentUserStoreManager = currentUserStoreManager.getSecondaryUserStoreManager();\n-        }\n-\n-        return userStoreManagers;\n-    }\n-\n-    /**\n-     * This method calls the relevant listener methods when there is a failure while trying to update credentials.\n-     *\n-     * @param errorCode     Relevant error code.\n-     * @param errorMessage  Error message.\n-     * @param userID        ID of the user.\n-     * @param newCredential New credential.\n-     * @param oldCredential Old credential.\n-     */\n-    private void handleUpdateCredentialFailureWithID(String errorCode, String errorMessage, String userID,\n-            Object newCredential, Object oldCredential) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onUpdateCredentialFailureWithID(errorCode, errorMessage, userID, newCredential, oldCredential,\n-                            this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method calls the relevant listener methods when there is a failure while trying to update credentials.\n-     *\n-     * @param errorCode     Relevant error code.\n-     * @param errorMessage  Error message.\n-     * @param userName      Name of the user.\n-     * @param newCredential New credential.\n-     * @param oldCredential Old credential.\n-     */\n-    private void handleUpdateCredentialFailure(String errorCode, String errorMessage, String userName,\n-            Object newCredential, Object oldCredential) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onUpdateCredentialFailure(errorCode, errorMessage, userName, newCredential, oldCredential, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void updateCredential(String userName, Object newCredential, Object oldCredential)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, Object.class, Object.class};\n-            callSecure(\"updateCredential\", new Object[]{userName, newCredential, oldCredential}, argTypes);\n-            return;\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().updateCredential(userStore.getDomainFreeName(),\n-                    newCredential, oldCredential);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (isReadOnly()) {\n-            handleUpdateCredentialFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, newCredential, oldCredential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        Secret newCredentialObj;\n-        Secret oldCredentialObj;\n-        try {\n-            newCredentialObj = Secret.getSecret(newCredential);\n-            oldCredentialObj = Secret.getSecret(oldCredential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleUpdateCredentialFailure(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), userName, newCredential,\n-                    oldCredential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString());\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            try {\n-                for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                    if (listener instanceof SecretHandleableListener) {\n-                        if (!listener.updateCredential(userName, newCredentialObj, oldCredentialObj, this)) {\n-                            handleUpdateCredentialFailure(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                                    String.format(\n-                                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                    newCredential, oldCredential);\n-                            return;\n-                        }\n-                    } else {\n-                        if (!listener.updateCredential(userName, newCredential, oldCredential, this)) {\n-                            handleUpdateCredentialFailure(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                                    String.format(\n-                                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                    newCredential, oldCredential);\n-                            return;\n-                        }\n-                    }\n-                }\n-\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-\n-                    if (listener instanceof SecretHandleableListener) {\n-                        if (!listener.doPreUpdateCredential(userName, newCredentialObj, oldCredentialObj, this)) {\n-                            handleUpdateCredentialFailure(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                                    String.format(\n-                                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                    newCredential, oldCredential);\n-                            return;\n-                        }\n-                    } else {\n-                        if (!listener.doPreUpdateCredential(userName, newCredential, oldCredential, this)) {\n-                            handleUpdateCredentialFailure(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                                    String.format(\n-                                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                    newCredential, oldCredential);\n-                            return;\n-                        }\n-                    }\n-                }\n-            } catch (UserStoreException e) {\n-                handleUpdateCredentialFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                e.getMessage()), userName, newCredential, oldCredential);\n-                throw e;\n-            }\n-            // #################### </Listeners> #####################################################\n-\n-            // This user name here is domain-less.\n-            // We directly authenticate user against the selected UserStoreManager.\n-\n-            // Property to check whether this user store supports new APIs with unique user id.\n-            boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-            String userID = null;\n-            if (isUniqueUserIdEnabled) {\n-                userID = getUserIDFromUserName(userName);\n-            }\n-\n-            boolean isAuth;\n-            if (isUniqueUserIdEnabled) {\n-                String preferredUserNameProperty = getUsernameProperty();\n-                isAuth = this.doAuthenticateWithID(preferredUserNameProperty, userName, oldCredentialObj, null)\n-                        .getAuthenticationStatus() == AuthenticationResult.AuthenticationStatus.SUCCESS;\n-            } else {\n-                isAuth = this.doAuthenticate(userName, oldCredentialObj);\n-            }\n-\n-            if (isAuth) {\n-                if (!checkUserPasswordValid(newCredential)) {\n-                    String errorMsg = realmConfig.getUserStoreProperty(PROPERTY_PASSWORD_ERROR_MSG);\n-\n-                    if (errorMsg != null) {\n-                        String errorMessage = String\n-                                .format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                        errorMsg);\n-                        String errorCode = ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode();\n-                        handleUpdateCredentialFailure(errorCode, errorMessage, userName, newCredential, oldCredential);\n-                        throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-                    }\n-\n-                    String errorMessage = String.format(ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getMessage(),\n-                            realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX));\n-                    String errorCode = ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getCode();\n-                    handleUpdateCredentialFailure(errorCode, errorMessage, userName, newCredential, oldCredential);\n-                    throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-                }\n-\n-                try {\n-                    if (isUniqueUserIdEnabled) {\n-                        this.doUpdateCredentialWithID(userID, newCredential, oldCredential);\n-                    } else {\n-                        this.doUpdateCredential(userName, newCredentialObj, oldCredentialObj);\n-                    }\n-                } catch (UserStoreException ex) {\n-                    handleUpdateCredentialFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_CREDENTIAL.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_CREDENTIAL.getMessage(),\n-                                    ex.getMessage()), userName, newCredential, oldCredential);\n-                    throw ex;\n-                }\n-\n-                // #################### <Listeners> ##################################################\n-                try {\n-                    for (UserOperationEventListener listener : UMListenerServiceComponent\n-                            .getUserOperationEventListeners()) {\n-                        if (listener instanceof SecretHandleableListener) {\n-                            if (!listener.doPostUpdateCredential(userName, newCredentialObj, this)) {\n-                                handleUpdateCredentialFailure(\n-                                        ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL.getCode(),\n-                                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL\n-                                                .getMessage(), \"Post update credential tasks failed\"), userName,\n-                                        newCredentialObj, oldCredentialObj);\n-                                return;\n-                            }\n-                        } else {\n-                            if (!listener.doPostUpdateCredential(userName, newCredential, this)) {\n-                                handleUpdateCredentialFailure(\n-                                        ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL.getCode(),\n-                                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL\n-                                                .getMessage(), \"Post update credential tasks failed\"), userName,\n-                                        newCredential, oldCredential);\n-                                return;\n-                            }\n-                        }\n-                    }\n-                } catch (UserStoreException ex) {\n-                    handleUpdateCredentialFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL.getMessage(),\n-                                    ex.getMessage()), userName, newCredential, oldCredential);\n-                    throw ex;\n-                }\n-                // #################### </Listeners> ##################################################\n-            } else {\n-                handleUpdateCredentialFailure(ErrorMessages.ERROR_CODE_OLD_CREDENTIAL_DOES_NOT_MATCH.getCode(),\n-                        ErrorMessages.ERROR_CODE_OLD_CREDENTIAL_DOES_NOT_MATCH.getMessage(), userName, newCredential,\n-                        oldCredential);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_OLD_CREDENTIAL_DOES_NOT_MATCH.toString());\n-            }\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            throw new UserStoreException(e.getMessage(), e);\n-        } finally {\n-            newCredentialObj.clear();\n-            oldCredentialObj.clear();\n-        }\n-    }\n-\n-    /**\n-     * Handles the failure while there is a failure while update of credentials is done by the admin.\n-     *\n-     * @param errorCode     Relevant error code.\n-     * @param errorMessage  Error message.\n-     * @param userName      Name of the user.\n-     * @param newCredential New credential.\n-     * @throws UserStoreException Exception that could be thrown by the listeners.\n-     */\n-    private void handleUpdateCredentialByAdminFailure(String errorCode, String errorMessage, String userName,\n-            Object newCredential) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onUpdateCredentialByAdminFailure(errorCode, errorMessage, userName, newCredential, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Handles the failure while there is a failure while update of credentials is done by the admin.\n-     *\n-     * @param errorCode     Relevant error code.\n-     * @param errorMessage  Error message.\n-     * @param userID        ID of the user.\n-     * @param newCredential New credential.\n-     * @throws UserStoreException Exception that could be thrown by the listeners.\n-     */\n-    private void handleUpdateCredentialByAdminFailureWithID(String errorCode, String errorMessage, String userID,\n-            Object newCredential) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onUpdateCredentialByAdminFailureWithID(errorCode, errorMessage, userID, newCredential, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void updateCredentialByAdmin(String userName, Object newCredential)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, Object.class};\n-            callSecure(\"updateCredentialByAdmin\", new Object[]{userName, newCredential}, argTypes);\n-            return;\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().updateCredentialByAdmin(userStore.getDomainFreeName(),\n-                    newCredential);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (isReadOnly()) {\n-            handleUpdateCredentialByAdminFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, newCredential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        Secret newCredentialObj;\n-        try {\n-            newCredentialObj = Secret.getSecret(newCredential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleUpdateCredentialByAdminFailure(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage() + \" \" + e.getMessage(), userName,\n-                    newCredential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-        }\n-\n-        try {\n-            try {\n-                // #################### <Listeners> #####################################################\n-                for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = newCredentialObj;\n-                    } else {\n-                        credentialArgument = newCredential;\n-                    }\n-\n-                    if (!listener.updateCredentialByAdmin(userName, credentialArgument, this)) {\n-                        handleUpdateCredentialByAdminFailure(\n-                                ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN\n-                                        .getMessage(), UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE),\n-                                userName, credentialArgument);\n-                        return;\n-                    }\n-                }\n-\n-                // using string buffers to allow the password to be changed by listener\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-\n-                    if (listener instanceof SecretHandleableListener) {\n-                        if (!listener.doPreUpdateCredentialByAdmin(userName, newCredentialObj, this)) {\n-                            handleUpdateCredentialByAdminFailure(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN\n-                                            .getMessage(), UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE),\n-                                    userName, newCredentialObj);\n-                            return;\n-                        }\n-                    } else {\n-                        // using string buffers to allow the password to be changed by listener\n-                        StringBuffer credBuff = null;\n-                        if (newCredential == null) { // a default password will be set\n-                            credBuff = new StringBuffer();\n-                        } else if (newCredential instanceof String) {\n-                            credBuff = new StringBuffer((String) newCredential);\n-                        }\n-\n-                        if (credBuff != null) {\n-                            if (!listener.doPreUpdateCredentialByAdmin(userName, credBuff, this)) {\n-                                handleUpdateCredentialByAdminFailure(\n-                                        ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                                        String.format(\n-                                                ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN\n-                                                        .getMessage(),\n-                                                UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                        credBuff);\n-                                return;\n-                            }\n-                            // reading the modified value\n-                            newCredential = credBuff.toString();\n-                            newCredentialObj.clear();\n-                            try {\n-                                newCredentialObj = Secret.getSecret(newCredential);\n-                            } catch (UnsupportedSecretTypeException e) {\n-                                handleUpdateCredentialByAdminFailure(\n-                                        ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                                        ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage() + \" \" + e\n-                                                .getMessage(), userName, newCredential);\n-                                throw new UserStoreException(\n-                                        ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-                            }\n-                        }\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleUpdateCredentialByAdminFailure(\n-                        ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getMessage(),\n-                                ex.getMessage()), userName, newCredential);\n-                throw ex;\n-            }\n-            // #################### </Listeners> #####################################################\n-\n-            if (!checkUserPasswordValid(newCredential)) {\n-                String errorMsg = realmConfig.getUserStoreProperty(PROPERTY_PASSWORD_ERROR_MSG);\n-\n-                if (errorMsg != null) {\n-                    String errorCode = ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode();\n-                    String errorMessage = String\n-                            .format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getMessage(),\n-                                    errorMsg);\n-                    handleUpdateCredentialByAdminFailure(errorCode, errorMessage, userName, newCredential);\n-                    throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-                }\n-\n-                String errorCode = ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getCode();\n-                String errorMessage = String.format(ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getMessage(),\n-                        realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX));\n-                handleUpdateCredentialByAdminFailure(errorCode, errorMessage, userName, newCredential);\n-                throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-            }\n-\n-            // Property to check whether this user store supports new APIs with unique user id.\n-            boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-            String userID = null;\n-            if (isUniqueUserIdEnabled) {\n-                userID = getUserIDFromUserName(userName);\n-            }\n-\n-            boolean isUserExists;\n-            if (isUniqueUserIdEnabled) {\n-                isUserExists = userID != null;\n-            } else {\n-                isUserExists = doCheckExistingUser(userStore.getDomainFreeName());\n-            }\n-\n-            if (!isUserExists) {\n-                String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                        realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-                String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-                handleUpdateCredentialByAdminFailure(errorCode, errorMessage, userName, newCredential);\n-                throw new UserStoreException(errorCode + \"-\" + errorMessage);\n-            }\n-\n-            try {\n-                if (isUniqueUserIdEnabled) {\n-                    doUpdateCredentialByAdminWithID(userID, newCredentialObj);\n-                } else {\n-                    doUpdateCredentialByAdmin(userName, newCredentialObj);\n-                }\n-            } catch (UserStoreException ex) {\n-                handleUpdateCredentialByAdminFailure(\n-                        ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_CREDENTIAL_BY_ADMIN.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_CREDENTIAL_BY_ADMIN.getMessage(),\n-                                ex.getMessage()), userName, newCredentialObj);\n-                throw ex;\n-            }\n-\n-            // #################### <Listeners> #####################################################\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = newCredentialObj;\n-                    } else {\n-                        credentialArgument = newCredential;\n-                    }\n-\n-                    if (!listener.doPostUpdateCredentialByAdmin(userName, credentialArgument, this)) {\n-                        handleUpdateCredentialByAdminFailure(\n-                                ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL_BY_ADMIN\n-                                        .getMessage(), UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE),\n-                                userName, newCredential);\n-                        return;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleUpdateCredentialByAdminFailure(\n-                        ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL_BY_ADMIN.getCode(), String.format(\n-                                ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL_BY_ADMIN.getMessage(),\n-                                ex.getMessage()), userName, newCredential);\n-                throw ex;\n-            }\n-        } finally {\n-            newCredentialObj.clear();\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    /**\n-     * Get the attribute for the provided claim uri and identifier.\n-     *\n-     * @param claimURI\n-     * @param identifier user name or role.\n-     * @param domainName TODO\n-     * @return claim attribute value. NULL if attribute is not defined for the\n-     * claim uri\n-     * @throws org.wso2.carbon.user.api.UserStoreException\n-     */\n-    protected String getClaimAtrribute(String claimURI, String identifier, String domainName)\n-            throws org.wso2.carbon.user.api.UserStoreException {\n-        domainName =\n-                (domainName == null || domainName.isEmpty())\n-                        ? (identifier.indexOf(UserCoreConstants.DOMAIN_SEPARATOR) > -1\n-                        ? identifier.split(UserCoreConstants.DOMAIN_SEPARATOR)[0]\n-                        : realmConfig.getUserStoreProperty(UserStoreConfigConstants.DOMAIN_NAME))\n-                        : domainName;\n-        String attributeName = null;\n-        if (domainName != null) {\n-            attributeName = claimManager.getAttributeName(domainName, claimURI);\n-        }\n-        if (attributeName == null || attributeName.isEmpty()) {\n-            attributeName = claimManager.getAttributeName(UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME, claimURI);\n-        }\n-\n-        if (attributeName == null) {\n-            if (UserCoreConstants.PROFILE_CONFIGURATION.equals(claimURI)) {\n-                attributeName = claimURI;\n-            } else if (DISAPLAY_NAME_CLAIM.equals(claimURI)) {\n-                attributeName = this.realmConfig.getUserStoreProperty(LDAPConstants.DISPLAY_NAME_ATTRIBUTE);\n-            } else {\n-                throw new UserStoreException(\"Mapped attribute cannot be found for claim : \" + claimURI + \" in user \" +\n-                        \"store : \" + getMyDomainName());\n-            }\n-        }\n-\n-        return attributeName;\n-    }\n-\n-    /**\n-     * This method handles the follow up actions when there is a failure while deleting a user.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage Relevant error message.\n-     * @param userName     Name of the user.\n-     * @throws UserStoreException User Store Exception that could be thrown while doing follow-up actions.\n-     */\n-    private void handleDeleteUserFailure(String errorCode, String errorMessage, String userName)\n-            throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener.onDeleteUserFailure(errorCode, errorMessage, userName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method handles the follow up actions when there is a failure while deleting a user.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage Relevant error message.\n-     * @param userID       ID of the user.\n-     * @throws UserStoreException User Store Exception that could be thrown while doing follow-up actions.\n-     */\n-    private void handleDeleteUserFailureWithID(String errorCode, String errorMessage, String userID)\n-            throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onDeleteUserFailureWithID(errorCode, errorMessage, userID, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void deleteUser(String userName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class};\n-            callSecure(\"deleteUser\", new Object[]{userName}, argTypes);\n-            return;\n-        }\n-\n-        String loggedInUser = CarbonContext.getThreadLocalCarbonContext().getUsername();\n-        if (loggedInUser != null) {\n-            loggedInUser = UserCoreUtil.addDomainToName(loggedInUser, UserCoreUtil.getDomainFromThreadLocal());\n-            if ((loggedInUser.indexOf(UserCoreConstants.DOMAIN_SEPARATOR)) < 0) {\n-                loggedInUser = UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME +\n-                        CarbonConstants.DOMAIN_SEPARATOR + loggedInUser;\n-            }\n-        }\n-\n-        String deletingUser = UserCoreUtil.addDomainToName(userName, getMyDomainName());\n-        if ((deletingUser.indexOf(UserCoreConstants.DOMAIN_SEPARATOR)) < 0) {\n-            deletingUser = UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME +\n-                    CarbonConstants.DOMAIN_SEPARATOR + deletingUser;\n-        }\n-\n-        if (loggedInUser != null && loggedInUser.equals(deletingUser)) {\n-            log.debug(\"User \" + loggedInUser + \" tried to delete him/her self\");\n-            handleDeleteUserFailure(ErrorMessages.ERROR_CODE_DELETE_LOGGED_IN_USER.getCode(),\n-                    ErrorMessages.ERROR_CODE_DELETE_LOGGED_IN_USER.getMessage(), userName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_DELETE_LOGGED_IN_USER.toString());\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().deleteUser(userStore.getDomainFreeName());\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (UserCoreUtil.isPrimaryAdminUser(userName, realmConfig)) {\n-            handleDeleteUserFailure(ErrorMessages.ERROR_CODE_DELETE_ADMIN_USER.getCode(),\n-                    ErrorMessages.ERROR_CODE_DELETE_ADMIN_USER.getMessage(), userName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_DELETE_ADMIN_USER.toString());\n-        }\n-\n-        if (UserCoreUtil.isRegistryAnnonymousUser(userName)) {\n-            handleDeleteUserFailure(ErrorMessages.ERROR_CODE_DELETE_ANONYMOUS_USER.getCode(),\n-                    ErrorMessages.ERROR_CODE_DELETE_ANONYMOUS_USER.getMessage(), userName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_DELETE_ANONYMOUS_USER.toString());\n-        }\n-\n-        if (isReadOnly()) {\n-            handleDeleteUserFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                if (!listener.deleteUser(userName, this)) {\n-                    handleDeleteUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName);\n-                    return;\n-                }\n-            }\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPreDeleteUser(userName, this)) {\n-                    handleDeleteUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName);\n-\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleDeleteUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getMessage(), e.getMessage()),\n-                    userName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        // Property to check whether this user store supports new APIs with unique user id.\n-        boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        String userID = null;\n-        boolean isUserExists;\n-        if (isUniqueUserIdEnabled) {\n-            userID = getUserIDFromUserName(userName);\n-            isUserExists = userID != null;\n-        } else {\n-            isUserExists = doCheckExistingUser(userName);\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleDeleteUserFailure(errorCode, errorMessage, userName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // Remove users from internal role mapping\n-        try {\n-\n-            clearUserIDResolverCache(userID, userName, userStore);\n-            if (isUniqueUserIdEnabled) {\n-                hybridRoleManager.deleteUser(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n-                doDeleteUserWithID(userID);\n-            } else {\n-                hybridRoleManager.deleteUser(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n-                doDeleteUser(userName);\n-            }\n-        } catch (UserStoreException e) {\n-            handleDeleteUserFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER.getMessage(), e.getMessage()),\n-                    userName);\n-            throw e;\n-        }\n-\n-        // Needs to clear roles cache upon deletion of a user\n-        clearUserRolesCache(userName);\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPostDeleteUser(userName, this)) {\n-                    handleDeleteUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER.getMessage(), ex.getMessage()),\n-                    userName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    /**\n-     * This is method is to call the relevant listeners when there is a failure while setting user claim value.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param userName     Name of the user.\n-     * @param claimURI     Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException UserStore Exception that would be thrown within the listeners.\n-     */\n-    private void handleSetUserClaimValueFailure(String errorCode, String errorMessage, String userName, String claimURI,\n-            String claimValue, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onSetUserClaimValueFailure(errorCode, errorMessage, userName, claimURI, claimValue, profileName,\n-                            this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This is method is to call the relevant listeners when there is a failure while setting user claim value.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param userID       ID of the user.\n-     * @param claimURI     Claim URI.\n-     * @param claimValue   Claim Value.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException UserStore Exception that would be thrown within the listeners.\n-     */\n-    private void handleSetUserClaimValueFailureWithID(String errorCode, String errorMessage, String userID,\n-            String claimURI, String claimValue, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onSetUserClaimValueFailureWithID(errorCode, errorMessage, userID, claimURI, claimValue,\n-                            profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void setUserClaimValue(String userName, String claimURI, String claimValue,\n-                                        String profileName) throws UserStoreException {\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().setUserClaimValue(userStore.getDomainFreeName(),\n-                    claimURI, claimValue, profileName);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        // Property to check whether this user store supports new APIs with unique user id.\n-        boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        String userID = null;\n-        if (isUniqueUserIdEnabled) {\n-            userID = getUserIDFromUserName(userName);\n-        }\n-\n-        boolean isUserExists;\n-        if (isUniqueUserIdEnabled) {\n-            isUserExists = userID != null;\n-        } else {\n-            isUserExists = doCheckExistingUser(userName);\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleSetUserClaimValueFailure(errorCode, errorMessage, userName, claimURI, claimValue, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPreSetUserClaimValue(userName, claimURI, claimValue, profileName, this)) {\n-                    handleSetUserClaimValueFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName, claimURI,\n-                            claimValue, profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValueFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUE.getMessage(),\n-                            e.getMessage()), userName, claimURI, claimValue, profileName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        // Check userstore is readonly or not.\n-        if (isReadOnly()) {\n-            handleSetUserClaimValueFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, claimURI, claimValue,\n-                    profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        try {\n-            if (isUniqueUserIdEnabled) {\n-                doSetUserClaimValueWithID(userID, claimURI, claimValue, profileName);\n-            } else {\n-                doSetUserClaimValue(userName, claimURI, claimValue, profileName);\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValueFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUE.getMessage(),\n-                            e.getMessage()), userName, claimURI, claimValue, profileName);\n-            throw e;\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPostSetUserClaimValue(userName, this)) {\n-                    handleSetUserClaimValueFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUE.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName, claimURI,\n-                            claimValue, profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValueFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUE.getMessage(),\n-                            e.getMessage()), userName, claimURI, claimValue, profileName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    /**\n-     * This method is responsible for calling relevant methods when there is a failure while setting user claim values.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param userName     Name of the user.\n-     * @param claims       Relevant claims.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleSetUserClaimValuesFailure(String errorCode, String errorMessage, String userName,\n-            Map<String, String> claims, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onSetUserClaimValuesFailure(errorCode, errorMessage, userName, claims, profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling relevant methods when there is a failure while setting user claim values.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param userName     Name of the user.\n-     * @param claims       Relevant claims.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleSetUserClaimValuesFailureWithID(String errorCode, String errorMessage, String userName,\n-            Map<String, String> claims, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onSetUserClaimValuesFailureWithID(errorCode, errorMessage, userName, claims, profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void setUserClaimValues(String userName, Map<String, String> claims,\n-                                         String profileName) throws UserStoreException {\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().setUserClaimValues(userStore.getDomainFreeName(),\n-                    claims, profileName);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        // Property to check whether this user store supports new APIs with unique user id.\n-        boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        String userID = null;\n-        if (isUniqueUserIdEnabled) {\n-            userID = getUserIDFromUserName(userName);\n-        }\n-\n-        boolean isUserExists;\n-        if (isUniqueUserIdEnabled) {\n-            isUserExists = userID != null;\n-        } else {\n-            isUserExists = doCheckExistingUser(userName);\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleSetUserClaimValuesFailure(errorCode, errorMessage, userName, claims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-        if (claims == null) {\n-            claims = new HashMap<>();\n-        }\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPreSetUserClaimValues(userName, claims, profileName, this)) {\n-                    handleSetUserClaimValuesFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userName, claims, profileName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        //If user store is readonly this method should not get invoked with non empty claim set.\n-\n-        if (isReadOnly() && !claims.isEmpty()) {\n-            handleSetUserClaimValuesFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, claims, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        // set claim values if user store is not read only.\n-\n-        try {\n-            if (!isReadOnly()) {\n-                if (isUniqueUserIdEnabled) {\n-                    doSetUserClaimValuesWithID(userID, claims, profileName);\n-                } else {\n-                    doSetUserClaimValues(userName, claims, profileName);\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userName, claims, profileName);\n-            throw e;\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPostSetUserClaimValues(userName, claims, profileName, this)) {\n-                    handleSetUserClaimValuesFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userName, claims, profileName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    /**\n-     * To handle the listener events when there is a failure while trying to delete the user  claim value.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage error message\n-     * @param userName     Name of the user.\n-     * @param claimURI     Claim URI\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will thrown from listeners.\n-     */\n-    private void handleDeleteUserClaimValueFailure(String errorCode, String errorMessage, String userName,\n-            String claimURI, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onDeleteUserClaimValueFailure(errorCode, errorMessage, userName, claimURI, profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * To handle the listener events when there is a failure while trying to delete the user  claim value.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage error message.\n-     * @param userID       ID of the user.\n-     * @param claimURI     Claim URI.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException Exception that will thrown from listeners.\n-     */\n-    private void handleDeleteUserClaimValueFailureWithID(String errorCode, String errorMessage, String userID,\n-            String claimURI, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onDeleteUserClaimValueFailureWithID(errorCode, errorMessage, userID, claimURI, profileName,\n-                            this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void deleteUserClaimValue(String userName, String claimURI, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String.class, String.class};\n-            callSecure(\"deleteUserClaimValue\", new Object[]{userName, claimURI, profileName}, argTypes);\n-            return;\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().deleteUserClaimValue(userStore.getDomainFreeName(),\n-                    claimURI, profileName);\n-            return;\n-        }\n-\n-        if (isReadOnly()) {\n-            handleDeleteUserClaimValueFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, claimURI, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        // Property to check whether this user store supports new APIs with unique user id.\n-        boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        String userID = null;\n-        boolean isUserExists;\n-        if (isUniqueUserIdEnabled) {\n-            userID = getUserIDFromUserName(userName);\n-            isUserExists = userID != null;\n-        } else {\n-            isUserExists = doCheckExistingUser(userName);\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleDeleteUserClaimValueFailure(errorCode, errorMessage, userName, claimURI, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPreDeleteUserClaimValue(userName, claimURI, profileName, this)) {\n-                    handleDeleteUserClaimValueFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUE.getCode(), String.format(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName, claimURI,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-            // #################### </Listeners> #####################################################\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValueFailure(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userName, claimURI, profileName);\n-            throw ex;\n-        }\n-\n-        try {\n-            if (isUniqueUserIdEnabled) {\n-                doDeleteUserClaimValueWithID(userID, claimURI, profileName);\n-            } else {\n-                doDeleteUserClaimValue(userName, claimURI, profileName);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValueFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userName, claimURI, profileName);\n-            throw ex;\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPostDeleteUserClaimValue(userName, this)) {\n-                    handleDeleteUserClaimValueFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUE.getCode(), String.format(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUE.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName, claimURI,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValueFailure(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userName, claimURI, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-    }\n-\n-    /**\n-     * This method handles a failure when trying to delete user claim values.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message\n-     * @param userName     Name of the user.\n-     * @param claims       Claims\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException User Store Exception that will be thrown from the relevant listeners.\n-     */\n-    private void handleDeleteUserClaimValuesFailure(String errorCode, String errorMessage, String userName,\n-            String[] claims, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onDeleteUserClaimValuesFailure(errorCode, errorMessage, userName, claims, profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method handles a failure when trying to delete user claim values.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message\n-     * @param userID       ID of the user.\n-     * @param claims       Claims.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException User Store Exception that will be thrown from the relevant listeners.\n-     */\n-    private void handleDeleteUserClaimValuesFailureWithID(String errorCode, String errorMessage, String userID,\n-            String[] claims, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onDeleteUserClaimValuesFailure(errorCode, errorMessage, userID, claims, profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void deleteUserClaimValues(String userName, String[] claims, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String[].class, String.class };\n-            callSecure(\"deleteUserClaimValues\", new Object[] { userName, claims, profileName }, argTypes);\n-            return;\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().deleteUserClaimValues(userStore.getDomainFreeName(), claims, profileName);\n-            return;\n-        }\n-\n-        if (isReadOnly()) {\n-            handleDeleteUserClaimValuesFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, claims, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        // Property to check whether this user store supports new APIs with unique user id.\n-        boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        String userID = null;\n-        boolean isUserExists;\n-        if (isUniqueUserIdEnabled) {\n-            userID = getUserIDFromUserName(userName);\n-            isUserExists = userID != null;\n-        } else {\n-            isUserExists = doCheckExistingUser(userName);\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userName,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleDeleteUserClaimValuesFailure(errorCode, errorMessage, userName, claims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        if (claims == null) {\n-            claims = new String[0];\n-        }\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPreDeleteUserClaimValues(userName, claims, profileName, this)) {\n-                    handleDeleteUserClaimValuesFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUES.getCode(), String.format(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-            // #################### </Listeners> #####################################################\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValuesFailure(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userName, claims, profileName);\n-            throw ex;\n-        }\n-\n-        try {\n-            if (isUniqueUserIdEnabled) {\n-                doDeleteUserClaimValuesWithID(userID, claims, profileName);\n-            } else {\n-                doDeleteUserClaimValues(userName, claims, profileName);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValuesFailure(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userName, claims, profileName);\n-            throw ex;\n-        }\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPostDeleteUserClaimValues(userName, this)) {\n-                    handleDeleteUserClaimValuesFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUES.getCode(),\n-                            String.format(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValuesFailure(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userName, claims, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public void addUser(String userName, Object credential, String[] roleList,\n-                        Map<String, String> claims, String profileName) throws UserStoreException {\n-\n-        this.addUser(userName, credential, roleList, claims, profileName, false);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void addUser(String userName, Object credential, String[] roleList,\n-                              Map<String, String> claims, String profileName, boolean requirePasswordChange)\n-            throws UserStoreException {\n-\n-        // We have to make sure this call is going through the Java Security Manager.\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class, Object.class, String[].class, Map.class, String.class,\n-                    boolean.class};\n-            callSecure(\"addUser\", new Object[]{userName, credential, roleList, claims, profileName,\n-                    requirePasswordChange}, argTypes);\n-            return;\n-        }\n-\n-        User user = null;\n-        // If we don't have a username, we cannot proceed.\n-        if (StringUtils.isEmpty(userName)) {\n-            String regEx = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig\n-                    .PROPERTY_USER_NAME_JAVA_REG_EX);\n-            // Inorder to support both UsernameJavaRegEx and UserNameJavaRegEx.\n-            if (StringUtils.isEmpty(regEx) || StringUtils.isEmpty(regEx.trim())) {\n-                regEx = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG);\n-            }\n-            String message = String.format(ErrorMessages.ERROR_CODE_INVALID_USER_NAME.getMessage(), null, regEx);\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_USER_NAME.getCode();\n-            handleAddUserFailure(errorCode, message, null, credential, roleList, claims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + message);\n-        }\n-\n-        // If the username claims presents, the value should be equal to the username attribute.\n-        if (claims != null && claims.containsKey(USERNAME_CLAIM_URI) &&\n-                !claims.get(USERNAME_CLAIM_URI).equals(userName)) {\n-            // If not we cannot continue.\n-            throw new UserStoreException(\"Username and the username claim value should be same.\");\n-        }\n-\n-        // Get the user store that this user should be added from the domain name that is appended to the username.\n-        UserStore userStore = getUserStore(userName);\n-        boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager()\n-                    .addUser(userStore.getDomainFreeName(), credential, roleList, claims, profileName,\n-                            requirePasswordChange);\n-            return;\n-        }\n-\n-        // Convert the credential (Password) to a Secret.\n-        Secret credentialObj;\n-        try {\n-            credentialObj = Secret.getSecret(credential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleAddUserFailure(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), userName, credential, roleList,\n-                    claims, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-        }\n-\n-        try {\n-            if (userStore.isSystemStore()) {\n-                systemUserRoleManager.addSystemUser(userName, credentialObj, roleList);\n-                return;\n-            }\n-\n-            // #################### Domain Name Free Zone Starts Here ################################\n-\n-            // First check whether this user store is a readonly one. If so we cannot continue.\n-            if (isReadOnly()) {\n-                handleAddUserFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                        ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, credential, roleList,\n-                        claims, profileName);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-            }\n-\n-            // This happens only once during first startup - adding administrator user/role.\n-            if (userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-                userName = userStore.getDomainFreeName();\n-                roleList = UserCoreUtil.removeDomainFromNames(roleList);\n-            }\n-            if (roleList == null) {\n-                roleList = new String[0];\n-            }\n-            if (claims == null) {\n-                claims = new HashMap<>();\n-            }\n-\n-            // #################### <Pre-Listeners> #####################################################\n-            try {\n-                // First we are going to call all the registered User Store Manager Listeners.\n-                for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = credentialObj;\n-                    } else {\n-                        credentialArgument = credential;\n-                    }\n-\n-                    // Call the listener, and if it returns false, then it is an error scenario.\n-                    if (!listener.addUser(userName, credentialArgument, roleList, claims, profileName, this)) {\n-                        handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                        UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName, credential,\n-                                roleList, claims, profileName);\n-                        return;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(), ex.getMessage()),\n-                        userName, credential, roleList, claims, profileName);\n-                throw ex;\n-            }\n-\n-            // Then call all the registered User Operation Event Listeners.\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                // This is to call all new listeners. All listeners should support the Secret object as the credential\n-                // for security reasons.\n-                if (listener instanceof SecretHandleableListener) {\n-                    try {\n-                        // Call pre add user listener.\n-                        if (!listener.doPreAddUser(userName, credentialObj, roleList, claims, profileName, this)) {\n-                            handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                    credential, roleList, claims, profileName);\n-                            return;\n-                        }\n-                    } catch (UserStoreException ex) {\n-                        String message = String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                ex.getMessage());\n-                        handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(), message,\n-                                userName, credential, roleList, claims, profileName);\n-                        throw ex;\n-                    }\n-                } else {\n-                    // This is to support the legacy listeners which does not know how to handle the Secret object as\n-                    // the credentials.\n-\n-                    // String buffers are used to let the listeners to modify the password.\n-                    StringBuffer credBuff = null;\n-                    if (credential == null) {\n-                        // No credentials passed. A default password will be set.\n-                        credBuff = new StringBuffer();\n-                    } else if (credential instanceof String) {\n-                        credBuff = new StringBuffer((String) credential);\n-                    }\n-\n-                    // If the credential is not null and not an instance of \"String\".\n-                    if (credBuff == null) {\n-                        continue;\n-                    }\n-\n-                    try {\n-                        // Call pre add user listener.\n-                        if (!listener.doPreAddUser(userName, credBuff, roleList, claims, profileName, this)) {\n-                            handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                    credential, roleList, claims, profileName);\n-                            return;\n-                        }\n-                    } catch (UserStoreException e) {\n-                        handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                        e.getMessage()), userName, credential, roleList, claims, profileName);\n-                        throw e;\n-                    }\n-                    // Reading the modified value and update the credential object (Secret) with the new values.\n-                    credential = credBuff.toString();\n-                    credentialObj.clear();\n-                    try {\n-                        credentialObj = Secret.getSecret(credential);\n-                    } catch (UnsupportedSecretTypeException e) {\n-                        handleAddUserFailure(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                                ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), userName,\n-                                credential, roleList, claims, profileName);\n-                        throw new UserStoreException(\n-                                ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-                    }\n-                }\n-            }\n-\n-            // #################### </Pre-Listeners> #####################################################\n-\n-            // Validate the username against provided regular expressions.\n-            if (!checkUserNameValid(userStore.getDomainFreeName())) {\n-                String regEx = realmConfig\n-                        .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG_EX);\n-                // Inorder to support both UsernameJavaRegEx and UserNameJavaRegEx.\n-                if (StringUtils.isEmpty(regEx) || StringUtils.isEmpty(regEx.trim())) {\n-                    regEx = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG);\n-                }\n-                String message = String\n-                        .format(ErrorMessages.ERROR_CODE_INVALID_USER_NAME.getMessage(), userStore.getDomainFreeName(),\n-                                regEx);\n-                String errorCode = ErrorMessages.ERROR_CODE_INVALID_USER_NAME.getCode();\n-                handleAddUserFailure(errorCode, message, userName, credential, roleList, claims, profileName);\n-                throw new UserStoreException(errorCode + \" - \" + message);\n-            }\n-\n-            // Validate the password against provided regular expressions.\n-            if (!checkUserPasswordValid(credentialObj)) {\n-                String regEx = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX);\n-                String message = String.format(ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getMessage(), regEx);\n-                String errorCode = ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getCode();\n-                handleAddUserFailure(errorCode, message, userName, credential, roleList, claims, profileName);\n-                throw new UserStoreException(errorCode + \" - \" + message);\n-            }\n-\n-            boolean isExistingUser;\n-            if (isUniqueUserIdEnabled) {\n-                isExistingUser = getUserIDFromUserName(userName) != null;\n-            } else {\n-                isExistingUser = doCheckExistingUser(userName);\n-            }\n-            // Property to check whether this user store supports new APIs with unique user id.\n-            if (isExistingUser) {\n-                String message = String.format(ErrorMessages.ERROR_CODE_USER_ALREADY_EXISTS.getMessage(), userName);\n-                String errorCode = ErrorMessages.ERROR_CODE_USER_ALREADY_EXISTS.getCode();\n-                handleAddUserFailure(errorCode, message, userName, credential, roleList, claims, profileName);\n-                throw new UserStoreException(errorCode + \" - \" + message);\n-            }\n-\n-            // Categorize roles according to the internal and external roles.\n-            List<String> internalRoles = new ArrayList<>();\n-            List<String> externalRoles = new ArrayList<>();\n-            filterRoles(roleList, internalRoles, externalRoles);\n-\n-            // Check existence of internal roles.\n-            for (String internalRole : internalRoles) {\n-                if (!hybridRoleManager.isExistingRole(internalRole)) {\n-                    String message = String\n-                            .format(ErrorMessages.ERROR_CODE_INTERNAL_ROLE_NOT_EXISTS.getMessage(), internalRole);\n-                    String errorCode = ErrorMessages.ERROR_CODE_INTERNAL_ROLE_NOT_EXISTS.getCode();\n-                    handleAddUserFailure(errorCode, message, userName, credential, roleList, claims, profileName);\n-                    throw new UserStoreException(errorCode + \" - \" + message);\n-                }\n-            }\n-\n-            // Check existence of external roles.\n-            for (String externalRole : externalRoles) {\n-                if (!doCheckExistingRole(externalRole)) {\n-                    String message = String\n-                            .format(ErrorMessages.ERROR_CODE_EXTERNAL_ROLE_NOT_EXISTS.getMessage(), externalRole);\n-                    String errorCode = ErrorMessages.ERROR_CODE_EXTERNAL_ROLE_NOT_EXISTS.getCode();\n-                    handleAddUserFailure(errorCode, message, userName, credential, roleList, claims, profileName);\n-                    throw new UserStoreException(errorCode + \" - \" + message);\n-                }\n-            }\n-\n-            // Check for the existence of the claims.\n-            for (Map.Entry<String, String> entry : claims.entrySet()) {\n-                ClaimMapping claimMapping;\n-                try {\n-                    claimMapping = (ClaimMapping) claimManager.getClaimMapping(entry.getKey());\n-                } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                    String errorMessage = String\n-                            .format(ErrorMessages.ERROR_CODE_UNABLE_TO_FETCH_CLAIM_MAPPING.getMessage(),\n-                                    \"persisting user attributes.\");\n-                    String errorCode = ErrorMessages.ERROR_CODE_UNABLE_TO_FETCH_CLAIM_MAPPING.getCode();\n-                    handleAddUserFailure(errorCode, errorMessage, userName, credential, roleList, claims,\n-                            profileName);\n-                    throw new UserStoreException(errorCode + \" - \" + errorMessage, e);\n-                }\n-                if (claimMapping == null) {\n-                    String errorMessage = String\n-                            .format(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getMessage(), entry.getKey());\n-                    String errorCode = ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getCode();\n-                    handleAddUserFailure(errorCode, errorMessage, userName, credential, roleList, claims,\n-                            profileName);\n-                    throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-                }\n-            }\n-\n-            // Call the do add user method of the underlying user store to add the user.\n-            try {\n-                // If this is an user store that that supports the APIs with unique user ID, then we can call the new\n-                // APIs. However, we don't need the returned values as this API does not require those values.\n-                // Ex. Generated unique id.\n-                if (isUniqueUserIdEnabled) {\n-                    // Ignore the return value as we don't need it.\n-                    user = doAddUserWithID(userName, credential, externalRoles.toArray(new String[0]), claims,\n-                            profileName, requirePasswordChange);\n-                } else {\n-                    // Call the old API since this user store does not support the unique user id related APIs.\n-                    doAddUser(userName, credentialObj, externalRoles.toArray(new String[0]), claims, profileName,\n-                            requirePasswordChange);\n-                }\n-            } catch (UserStoreException ex) {\n-                handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_ADDING_USER.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_ADDING_USER.getMessage(), ex.getMessage()),\n-                        userName, credential, roleList, claims, profileName);\n-                throw ex;\n-            }\n-\n-            if (internalRoles.size() > 0) {\n-                hybridRoleManager.updateHybridRoleListOfUser(userName, null, internalRoles.toArray(new String[0]));\n-            }\n-\n-            // #################### <Post-Listeners> #####################################################\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = credentialObj;\n-                    } else {\n-                        credentialArgument = credential;\n-                    }\n-\n-                    if (!listener.doPostAddUser(userName, credentialArgument, roleList, claims, profileName, this)) {\n-                        handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_USER.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_USER.getMessage(),\n-                                        UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                credential, roleList, claims, profileName);\n-                        return;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_USER.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_USER.getMessage(),\n-                                ex.getMessage()), userName, credential, roleList, claims, profileName);\n-                throw ex;\n-            }\n-            // #################### </Post-Listeners> #####################################################\n-        } finally {\n-            credentialObj.clear();\n-        }\n-\n-        // Clean the role cache since it contains old role information.\n-        clearUserRolesCache(userName);\n-    }\n-\n-    /**\n-     * Checks whether this user store supports new user unique id feature.\n-     * @return True if this user store supports unique user id feature.\n-     */\n-    public boolean isUniqueUserIdEnabled() {\n-\n-        return Boolean.parseBoolean(realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_ID_ENABLED));\n-    }\n-\n-    /**\n-     * To handle the erroneous scenario in add user flow.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage Relevant error message.\n-     * @param userName     Name of the user.\n-     * @param credential   Credential\n-     * @param roleList     List of roles.\n-     * @param claims       Claims\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException UserStore Exception that could be thrown during the execution.\n-     */\n-    private void handleAddUserFailure(String errorCode, String errorMessage, String userName, Object credential,\n-            String[] roleList, Map<String, String> claims, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onAddUserFailure(errorCode, errorMessage, userName, credential, roleList, claims, profileName,\n-                            this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * To handle the erroneous scenario in add user flow.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage Relevant error message.\n-     * @param userName     Name of the user.\n-     * @param credential   Credential\n-     * @param roleList     List of roles.\n-     * @param claims       Claims.\n-     * @param profileName  Name of the profile.\n-     * @throws UserStoreException UserStore Exception that could be thrown during the execution.\n-     */\n-    private void handleAddUserFailureWithID(String errorCode, String errorMessage, String userName, Object credential,\n-            String[] roleList, Map<String, String> claims, String profileName) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onAddUserFailureWithID(errorCode, errorMessage, userName, credential, roleList, claims,\n-                            profileName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    public final void updateUserListOfRole(final String roleName, final String[] deletedUsers, final String[] newUsers)\n-            throws UserStoreException {\n-        try {\n-            AccessController.doPrivileged((PrivilegedExceptionAction<String>) () -> {\n-                updateUserListOfRoleInternal(roleName, deletedUsers, newUsers);\n-                return null;\n-            });\n-        } catch (PrivilegedActionException e) {\n-            if (!(e.getException() instanceof UserStoreException)) {\n-                handleUpdateUserListOfRoleFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_OF_USER.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_OF_USER.getMessage(),\n-                                e.getMessage()), roleName, deletedUsers, newUsers);\n-            }\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    /**\n-     * This method calls the relevant listeners that handle failure during update user list of a role.\n-     *\n-     * @param errorCode    Relevant error code.\n-     * @param errorMessage Relevant error message.\n-     * @param roleName     Name of the role.\n-     * @param deletedUsers Removed users from a particular role.\n-     * @param newUsers     Added users from a particular role.\n-     * @throws UserStoreException Exception that will be thrown from the relevant listeners.\n-     */\n-    private void handleUpdateUserListOfRoleFailure(String errorCode, String errorMessage, String roleName,\n-            String deletedUsers[], String[] newUsers) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onUpdateUserListOfRoleFailure(errorCode, errorMessage, roleName, deletedUsers, newUsers, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method calls the relevant listeners that handle failure during update user list of a role.\n-     *\n-     * @param errorCode      Relevant error code.\n-     * @param errorMessage   Relevant error message.\n-     * @param roleName       Name of the role.\n-     * @param deletedUserIDs Removed users from a particular role.\n-     * @param newUserIDs     Added users from a particular role.\n-     * @throws UserStoreException Exception that will be thrown from the relevant listeners.\n-     */\n-    private void handleUpdateUserListOfRoleFailureWithID(String errorCode, String errorMessage, String roleName,\n-            String[] deletedUserIDs, String[] newUserIDs) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onUpdateUserListOfRoleFailureWithID(errorCode, errorMessage, roleName, deletedUserIDs, newUserIDs,\n-                            this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    private final void updateUserListOfRoleInternal(String roleName, String[] deletedUsers, String[] newUsers)\n-            throws UserStoreException {\n-\n-        String primaryDomain = getMyDomainName();\n-        if (primaryDomain != null) {\n-            primaryDomain += CarbonConstants.DOMAIN_SEPARATOR;\n-        }\n-\n-        if (deletedUsers != null && deletedUsers.length > 0) {\n-            Arrays.sort(deletedUsers);\n-            // Updating the user list of a role belong to the primary domain.\n-            if (UserCoreUtil.isPrimaryAdminRole(roleName, realmConfig)) {\n-                for (int i = 0; i < deletedUsers.length; i++) {\n-                    if (deletedUsers[i].equalsIgnoreCase(realmConfig.getAdminUserName()) || (primaryDomain\n-                            + deletedUsers[i]).equalsIgnoreCase(realmConfig.getAdminUserName())) {\n-                        handleUpdateUserListOfRoleFailure(\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.getCode(),\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.getMessage(), roleName,\n-                                deletedUsers, newUsers);\n-                        throw new UserStoreException(\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.toString());\n-                    }\n-\n-                }\n-            }\n-        }\n-\n-        UserStore userStore = getUserStore(roleName);\n-\n-        if (userStore.isHybridRole()) {\n-            // Check whether someone is trying to update Everyone role.\n-            if (UserCoreUtil.isEveryoneRole(roleName, realmConfig)) {\n-                handleUpdateUserListOfRoleFailure(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getCode(),\n-                        ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getMessage(), roleName, deletedUsers,\n-                        newUsers);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.toString());\n-            }\n-\n-            if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(userStore.getDomainName())) {\n-                hybridRoleManager.updateUserListOfHybridRole(userStore.getDomainFreeName(), deletedUsers, newUsers);\n-                handleDoPostUpdateUserListOfRole(roleName, deletedUsers, newUsers, true);\n-            } else {\n-                hybridRoleManager.updateUserListOfHybridRole(userStore.getDomainAwareName(), deletedUsers, newUsers);\n-                handleDoPostUpdateUserListOfRole(roleName, deletedUsers, newUsers, true);\n-            }\n-            clearUserRolesCacheByTenant(this.tenantId);\n-            return;\n-        }\n-\n-        if (userStore.isSystemStore()) {\n-            systemUserRoleManager.updateUserListOfSystemRole(userStore.getDomainFreeName(),\n-                    UserCoreUtil.removeDomainFromNames(deletedUsers),\n-                    UserCoreUtil.removeDomainFromNames(newUsers));\n-            handleDoPostUpdateUserListOfRole(roleName, deletedUsers, newUsers, true);\n-            return;\n-        }\n-\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().updateUserListOfRole(userStore.getDomainFreeName(),\n-                    UserCoreUtil.removeDomainFromNames(deletedUsers),\n-                    UserCoreUtil.removeDomainFromNames(newUsers));\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        if (deletedUsers == null) {\n-            deletedUsers = new String[0];\n-        }\n-        if (newUsers == null) {\n-            newUsers = new String[0];\n-        }\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPreUpdateUserListOfRole(roleName, deletedUsers, newUsers, this)) {\n-                    handleUpdateUserListOfRoleFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_UPDATE_USERS_OF_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_UPDATE_USERS_OF_ROLE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), roleName, deletedUsers,\n-                            newUsers);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateUserListOfRoleFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_UPDATE_USERS_OF_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_UPDATE_USERS_OF_ROLE.getMessage(),\n-                            ex.getMessage()), roleName, deletedUsers, newUsers);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        if (deletedUsers.length > 0 || newUsers != null && newUsers.length > 0) {\n-            if (!isReadOnly() && writeGroupsEnabled) {\n-                try {\n-                    if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                        List<String> newUserIds = getUserIDsFromUserNames(Arrays.asList(newUsers));\n-                        List<String> deletedUserIds = getUserIDsFromUserNames(Arrays.asList(deletedUsers));\n-                        doUpdateUserListOfRoleWithID(userStore.getDomainFreeName(),\n-                                UserCoreUtil.removeDomainFromNames(deletedUserIds.toArray(new String[0])),\n-                                UserCoreUtil.removeDomainFromNames(newUserIds.toArray(new String[0])));\n-                    } else {\n-                        doUpdateUserListOfRole(userStore.getDomainFreeName(),\n-                                UserCoreUtil.removeDomainFromNames(deletedUsers),\n-                                UserCoreUtil.removeDomainFromNames(newUsers));\n-                    }\n-                } catch (UserStoreException ex) {\n-                    handleUpdateUserListOfRoleFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_UPDATE_USERS_OF_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_UPDATE_USERS_OF_ROLE.getMessage(),\n-                                    ex.getMessage()), roleName, deletedUsers, newUsers);\n-                    throw ex;\n-                }\n-            } else {\n-                handleUpdateUserListOfRoleFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                        ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), roleName, deletedUsers, newUsers);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-            }\n-        }\n-\n-        // need to clear user roles cache upon roles update\n-        clearUserRolesCacheByTenant(this.tenantId);\n-\n-        // Call relevant listeners after updating user list of role.\n-        handleDoPostUpdateUserListOfRole(roleName, deletedUsers, newUsers, false);\n-    }\n-\n-    /**\n-     * This method is responsible for calling the listeners after updating user list of role.\n-     *\n-     * @param roleName       Name of the role.\n-     * @param deletedUsers   Removed users\n-     * @param newUsers       Added users.\n-     * @param isAuditLogOnly Indicate whether to call only the audit log listener.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleDoPostUpdateUserListOfRole(String roleName, String[] deletedUsers, String[] newUsers,\n-            boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName()\n-                        .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-                if (!listener.doPostUpdateUserListOfRole(roleName, deletedUsers, newUsers, this)) {\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateUserListOfRoleFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_UPDATE_USERS_OF_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_UPDATE_USERS_OF_ROLE.getMessage(),\n-                            ex.getMessage()), roleName, deletedUsers, newUsers);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the listeners after updating user list of role.\n-     *\n-     * @param roleName       Name of the role.\n-     * @param deletedUserIDs Removed users.\n-     * @param newUserIDs     Added users.\n-     * @param isAuditLogOnly Indicate whether to call only the audit log listener.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleDoPostUpdateUserListOfRoleWithID(String roleName, String[] deletedUserIDs, String[] newUserIDs,\n-            boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName()\n-                        .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPostUpdateUserListOfRoleWithID(roleName, deletedUserIDs, newUserIDs, this)) {\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateUserListOfRoleFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_UPDATE_USERS_OF_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_UPDATE_USERS_OF_ROLE.getMessage(),\n-                            ex.getMessage()), roleName, deletedUserIDs, newUserIDs);\n-            throw ex;\n-        }\n-    }\n-\n-    public final void updateRoleListOfUser(final String username, final String[] deletedRoles, final String[] newRoles)\n-            throws UserStoreException {\n-        try {\n-            AccessController.doPrivileged((PrivilegedExceptionAction<String>) () -> {\n-                updateRoleListOfUserInternal(username, deletedRoles, newRoles);\n-                return null;\n-            });\n-        } catch (PrivilegedActionException e) {\n-            if (!(e.getException() instanceof UserStoreException)) {\n-                handleUpdateRoleListOfUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_UPDATE_USERS_OF_ROLE.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_UPDATE_USERS_OF_ROLE.getMessage(),\n-                                e.getMessage()), username, deletedRoles, newRoles);\n-            }\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the methods of listeners after a failure while trying to update role\n-     * list of users.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param userName     User Name\n-     * @param deletedRoles Removed roles\n-     * @param newRoles     Assigned roles\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleUpdateRoleListOfUserFailure(String errorCode, String errorMessage, String userName,\n-            String[] deletedRoles, String[] newRoles) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onUpdateRoleListOfUserFailure(errorCode, errorMessage, userName, deletedRoles, newRoles, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the methods of listeners after a failure while trying to update role\n-     * list of users.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param userID       User ID.\n-     * @param deletedRoles Removed roles.\n-     * @param newRoles     Assigned roles.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleUpdateRoleListOfUserFailureWithID(String errorCode, String errorMessage, String userID,\n-            String[] deletedRoles, String[] newRoles) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((AbstractUserManagementErrorListener) listener)\n-                    .onUpdateRoleListOfUserFailureWithID(errorCode, errorMessage, userID, deletedRoles, newRoles,\n-                            this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    private final void updateRoleListOfUserInternal(String userName, String[] deletedRoles, String[] newRoles)\n-            throws UserStoreException {\n-\n-        String primaryDomain = realmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-        if (primaryDomain != null) {\n-            primaryDomain += CarbonConstants.DOMAIN_SEPARATOR;\n-        }\n-\n-        if (deletedRoles != null && deletedRoles.length > 0) {\n-            Arrays.sort(deletedRoles);\n-            if (UserCoreUtil.isPrimaryAdminUser(userName, realmConfig)) {\n-                for (int i = 0; i < deletedRoles.length; i++) {\n-                    if (deletedRoles[i].equalsIgnoreCase(realmConfig.getAdminRoleName()) || (primaryDomain\n-                            + deletedRoles[i]).equalsIgnoreCase(realmConfig.getAdminRoleName())) {\n-                        handleUpdateRoleListOfUserFailure(\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.getCode(),\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.getMessage(), userName,\n-                                deletedRoles, newRoles);\n-                        throw new UserStoreException(\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.toString());\n-                    }\n-                }\n-            }\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().updateRoleListOfUser(userStore.getDomainFreeName(),\n-                    UserCoreUtil.removeDomainFromNames(deletedRoles),\n-                    UserCoreUtil.removeDomainFromNames(newRoles));\n-            return;\n-        }\n-\n-        if (userStore.isSystemStore()) {\n-            systemUserRoleManager.updateSystemRoleListOfUser(userStore.getDomainFreeName(),\n-                    UserCoreUtil.removeDomainFromNames(deletedRoles),\n-                    UserCoreUtil.removeDomainFromNames(newRoles));\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        if (deletedRoles == null) {\n-            deletedRoles = new String[0];\n-        }\n-        if (newRoles == null) {\n-            newRoles = new String[0];\n-        }\n-        // This happens only once during first startup - adding administrator user/role.\n-        if (userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-            userName = userStore.getDomainFreeName();\n-            deletedRoles = UserCoreUtil.removeDomainFromNames(deletedRoles);\n-            newRoles = UserCoreUtil.removeDomainFromNames(newRoles);\n-        }\n-\n-        List<String> internalRoleDel = new ArrayList<String>();\n-        List<String> internalRoleNew = new ArrayList<String>();\n-\n-        List<String> roleDel = new ArrayList<String>();\n-        List<String> roleNew = new ArrayList<String>();\n-\n-        if (deletedRoles != null && deletedRoles.length > 0) {\n-            for (String deleteRole : deletedRoles) {\n-                if (UserCoreUtil.isEveryoneRole(deleteRole, realmConfig)) {\n-                    handleUpdateRoleListOfUserFailure(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getCode(),\n-                            ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getMessage(), userName, deletedRoles,\n-                            newRoles);\n-                    throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.toString());\n-                }\n-                String domain = null;\n-                int index1 = deleteRole.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-                if (index1 > 0) {\n-                    domain = deleteRole.substring(0, index1);\n-                }\n-                processDeletedRoles(internalRoleDel, roleDel, deleteRole, domain);\n-            }\n-            deletedRoles = roleDel.toArray(new String[roleDel.size()]);\n-        }\n-\n-        if (newRoles != null && newRoles.length > 0) {\n-            for (String newRole : newRoles) {\n-                if (UserCoreUtil.isEveryoneRole(newRole, realmConfig)) {\n-                    handleUpdateRoleListOfUserFailure(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getCode(),\n-                            ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getMessage(), userName, deletedRoles,\n-                            newRoles);\n-                    throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.toString());\n-                }\n-                String domain = null;\n-                int index2 = newRole.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-                if (index2 > 0) {\n-                    domain = newRole.substring(0, index2);\n-                }\n-\n-                processNewRoles(internalRoleNew, roleNew, newRole, domain);\n-            }\n-            newRoles = roleNew.toArray(new String[roleNew.size()]);\n-        }\n-\n-        if (internalRoleDel.size() > 0 || internalRoleNew.size() > 0) {\n-            hybridRoleManager.updateHybridRoleListOfUser(userStore.getDomainFreeName(),\n-                    internalRoleDel.toArray(new String[internalRoleDel.size()]),\n-                    internalRoleNew.toArray(new String[internalRoleNew.size()]));\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPreUpdateRoleListOfUser(userName, deletedRoles, newRoles, this)) {\n-                    handleUpdateRoleListOfUserFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_OF_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_OF_USER.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName, deletedRoles,\n-                            newRoles);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateRoleListOfUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_OF_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_OF_USER.getMessage(),\n-                            ex.getMessage()), userName, deletedRoles, newRoles);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        if ((deletedRoles != null && deletedRoles.length > 0) || (newRoles != null && newRoles.length > 0)) {\n-            if (!isReadOnly() && writeGroupsEnabled) {\n-                try {\n-                    // Property to check whether this user store supports new APIs with unique user id.\n-                    boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-                    if (isUniqueUserIdEnabled) {\n-                        String userID = getUserIDFromUserName(userName);\n-                        doUpdateRoleListOfUserWithID(userID, deletedRoles, newRoles);\n-                    } else {\n-                        doUpdateRoleListOfUser(userName, deletedRoles, newRoles);\n-                    }\n-                } catch (UserStoreException ex) {\n-                    handleUpdateRoleListOfUserFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_OF_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_OF_USER.getMessage(),\n-                                    ex.getMessage()), userName, deletedRoles, newRoles);\n-                    throw ex;\n-                }\n-            } else {\n-                handleUpdateRoleListOfUserFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                        ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, deletedRoles, newRoles);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-            }\n-        }\n-\n-        clearUserRolesCache(userName);\n-\n-        // Call the relevant listeners after updating the role list of user.\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!listener.doPostUpdateRoleListOfUser(userName, deletedRoles, newRoles, this)) {\n-                    handleUpdateRoleListOfUserFailure(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_OF_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_OF_USER.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName, deletedRoles,\n-                            newRoles);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateRoleListOfUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_OF_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_OF_USER.getMessage(),\n-                            ex.getMessage()), userName, deletedRoles, newRoles);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling the relevant methods when there is a failure while trying to update the\n-     * role name.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message\n-     * @param roleName     Role Name\n-     * @param newRoleName  New Role Name\n-     * @throws UserStoreException Exception that will be thrown by relevant methods in listener.\n-     */\n-    private void handleUpdateRoleNameFailure(String errorCode, String errorMessage, String roleName, String newRoleName)\n-            throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onUpdateRoleNameFailure(errorCode, errorMessage, roleName, newRoleName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling post update role name methods in listeners.\n-     *\n-     * @param roleName       Name of the role.\n-     * @param newRoleName    New role name\n-     * @param isAuditLogOnly to indicate whether to call only the audit log listener.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handlePostUpdateRoleName(String roleName, String newRoleName, boolean isAuditLogOnly)\n-            throws UserStoreException {\n-\n-        try {\n-            boolean internalRole = isAnInternalRole(roleName);\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName()\n-                        .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-\n-                boolean success = false;\n-                if (internalRole && listener instanceof AbstractUserOperationEventListener) {\n-                    success = ((AbstractUserOperationEventListener) listener).doPostUpdateInternalRoleName(roleName,\n-                            newRoleName, this);\n-                } else if (internalRole && !(listener instanceof AbstractUserOperationEventListener)) {\n-                    success = true;\n-                } else if (!internalRole) {\n-                    success = listener.doPostUpdateRoleName(roleName, newRoleName, this);\n-                }\n-\n-                if (!success) {\n-                    handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_NAME.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_NAME.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), roleName, newRoleName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_NAME.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_NAME.getMessage(),\n-                            ex.getMessage()), roleName, newRoleName);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling pre update role name methods in listeners.\n-     *\n-     * @param roleName       Name of the internal role.\n-     * @param newRoleName    New internal role name\n-     * @param isAuditLogOnly to indicate whether to call only the audit log listener.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private boolean handlePreUpdateRoleName(String roleName, String newRoleName, boolean isAuditLogOnly)\n-            throws UserStoreException {\n-\n-        try {\n-            boolean internalRole = isAnInternalRole(roleName);\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName()\n-                        .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-\n-                boolean success = false;\n-                if (internalRole && listener instanceof AbstractUserOperationEventListener) {\n-                    success = ((AbstractUserOperationEventListener) listener).doPreUpdateInternalRoleName(roleName,\n-                            newRoleName, this);\n-                }\n-                if (internalRole && !(listener instanceof AbstractUserOperationEventListener)) {\n-                    success = true;\n-                } else if (!internalRole) {\n-                    success = listener.doPreUpdateRoleName(roleName, newRoleName, this);\n-                }\n-\n-                if (!success) {\n-                    handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_NAME.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_NAME.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), roleName, newRoleName);\n-                    return false;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_NAME.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_NAME.getMessage(),\n-                            ex.getMessage()), roleName, newRoleName);\n-            throw ex;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void updateRoleName(String roleName, String newRoleName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String.class};\n-            callSecure(\"updateRoleName\", new Object[]{roleName, newRoleName}, argTypes);\n-            return;\n-        }\n-\n-        if (UserCoreUtil.isPrimaryAdminRole(newRoleName, realmConfig)) {\n-            handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_ADMIN_ROLE.getCode(),\n-                    ErrorMessages.ERROR_CODE_CANNOT_UPDATE_ADMIN_ROLE.getMessage(), roleName, newRoleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_ADMIN_ROLE.toString());\n-        }\n-\n-        if (UserCoreUtil.isEveryoneRole(newRoleName, realmConfig)) {\n-            handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getCode(),\n-                    ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getMessage(), roleName, newRoleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.toString());\n-        }\n-\n-        UserStore userStore = getUserStoreOfRoles(roleName);\n-        UserStore userStoreNew = getUserStore(newRoleName);\n-\n-        if (!UserCoreUtil.canRoleBeRenamed(userStore, userStoreNew, realmConfig)) {\n-            handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_CANNOT_RENAME_ROLE.getCode(),\n-                    ErrorMessages.ERROR_CODE_CANNOT_RENAME_ROLE.getMessage(), roleName, newRoleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_RENAME_ROLE.toString());\n-        }\n-\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager()\n-                    .updateRoleName(userStore.getDomainFreeName(), userStoreNew.getDomainFreeName());\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (userStore.isHybridRole()) {\n-            //Invoke pre listeners.\n-            if (!handlePreUpdateRoleName(roleName, newRoleName, false)) {\n-                return;\n-            }\n-            if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(userStore.getDomainName())) {\n-                hybridRoleManager.updateHybridRoleName(userStore.getDomainFreeName(),\n-                        userStoreNew.getDomainFreeName());\n-            } else {\n-                hybridRoleManager.updateHybridRoleName(userStore.getDomainAwareName(),\n-                        userStoreNew.getDomainAwareName());\n-            }\n-\n-            // This is a special case. We need to pass roles with domains.\n-            userRealm.getAuthorizationManager().resetPermissionOnUpdateRole(\n-                    userStore.getDomainAwareName(), userStoreNew.getDomainAwareName());\n-\n-            // To make sure to maintain the back-ward compatibility, only audit log listener will be called.\n-            handlePostUpdateRoleName(roleName, newRoleName, false);\n-            // Need to update user role cache upon update of role names\n-            clearUserRolesCacheByTenant(this.tenantId);\n-            return;\n-        }\n-\n-        if (!isRoleNameValid(roleName)) {\n-            String regEx = realmConfig\n-                    .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n-            String errorMessage = String\n-                    .format(ErrorMessages.ERROR_CODE_INVALID_ROLE_NAME.getMessage(), roleName, regEx);\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_ROLE_NAME.getCode();\n-            handleUpdateRoleNameFailure(errorCode, errorMessage, roleName, newRoleName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        if (isExistingRole(newRoleName)) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_ROLE_ALREADY_EXISTS.getMessage(), newRoleName);\n-            String errorCode = ErrorMessages.ERROR_CODE_ROLE_ALREADY_EXISTS.getCode();\n-            handleUpdateRoleNameFailure(errorCode, errorMessage, roleName, newRoleName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        if (!handlePreUpdateRoleName(roleName, newRoleName, false)) {\n-            return;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        if (!isReadOnly() && writeGroupsEnabled) {\n-            try {\n-                doUpdateRoleName(userStore.getDomainFreeName(), userStoreNew.getDomainFreeName());\n-            } catch (UserStoreException ex) {\n-                handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_NAME.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_NAME.getMessage(),\n-                                ex.getMessage()), roleName, newRoleName);\n-            }\n-        } else {\n-            handleUpdateRoleNameFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), roleName, newRoleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        // This is a special case. We need to pass domain aware name.\n-        userRealm.getAuthorizationManager().resetPermissionOnUpdateRole(\n-                userStore.getDomainAwareName(), userStoreNew.getDomainAwareName());\n-\n-        // need to update user role cache upon update of role names\n-        clearUserRolesCacheByTenant(tenantId);\n-\n-        // #################### <Listeners> #####################################################\n-        handlePostUpdateRoleName(roleName, newRoleName, false);\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-\n-    @Override\n-    public boolean isExistingRole(String roleName, boolean shared) throws org.wso2.carbon.user.api.UserStoreException {\n-        if (shared) {\n-            return isExistingShareRole(roleName);\n-        } else {\n-            return isExistingRole(roleName);\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public boolean isExistingRole(String roleName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class};\n-            Object object = callSecure(\"isExistingRole\", new Object[]{roleName}, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        UserStore userStore = getUserStoreOfRoles(roleName);\n-\n-        if (userStore.isRecurssive()) {\n-            return userStore.getUserStoreManager().isExistingRole(userStore.getDomainFreeName());\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (userStore.isSystemStore()) {\n-            return systemUserRoleManager.isExistingRole(userStore.getDomainFreeName());\n-        }\n-\n-        if (userStore.isHybridRole()) {\n-            boolean exist;\n-\n-            if (!UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(userStore.getDomainName())) {\n-                exist = hybridRoleManager.isExistingRole(userStore.getDomainAwareName());\n-            } else {\n-                exist = hybridRoleManager.isExistingRole(userStore.getDomainFreeName());\n-            }\n-\n-            return exist;\n-        }\n-\n-        // This happens only once during first startup - adding administrator user/role.\n-        roleName = userStore.getDomainFreeName();\n-\n-        // you can not check existence of shared role using this method.\n-        if (isSharedGroupEnabled() && roleName.contains(UserCoreConstants.TENANT_DOMAIN_COMBINER)) {\n-            return false;\n-        }\n-\n-        boolean isExisting = doCheckExistingRole(roleName);\n-\n-        if (!isExisting && (isReadOnly() || !readGroupsEnabled)) {\n-            isExisting = hybridRoleManager.isExistingRole(roleName);\n-        }\n-\n-        if (!isExisting) {\n-            if (systemUserRoleManager.isExistingRole(roleName)) {\n-                isExisting = true;\n-            }\n-        }\n-\n-        return isExisting;\n-    }\n-\n-//////////////////////////////////// Shared role APIs start //////////////////////////////////////////\n-\n-    /**\n-     * TODO move to API\n-     *\n-     * @param roleName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public boolean isExistingShareRole(String roleName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class};\n-            Object object = callSecure(\"isExistingShareRole\", new Object[]{roleName}, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        UserStoreManager manager = getUserStoreWithSharedRoles();\n-\n-        if (manager == null) {\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        return ((AbstractUserStoreManager) manager).doCheckExistingRole(roleName);\n-    }\n-\n-    /**\n-     * TODO  move to API\n-     *\n-     * @param roleName\n-     * @param deletedUsers\n-     * @param newUsers\n-     * @throws UserStoreException\n-     */\n-    public void updateUsersOfSharedRole(String roleName,\n-                                        String[] deletedUsers, String[] newUsers) throws UserStoreException {\n-\n-        UserStoreManager manager = getUserStoreWithSharedRoles();\n-\n-        if (manager == null) {\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-        if (isUniqueUserIdEnabled(manager)) {\n-            ((AbstractUserStoreManager) manager).doUpdateUserListOfRoleWithID(roleName,\n-                    getUserIDsFromUserNames(Arrays.asList(deletedUsers)).toArray(new String[0]),\n-                    getUserIDsFromUserNames(Arrays.asList(newUsers)).toArray(new String[0]));\n-        } else {\n-            ((AbstractUserStoreManager) manager).doUpdateUserListOfRole(roleName, deletedUsers, newUsers);\n-        }\n-    }\n-\n-    /**\n-     * TODO move to API\n-     *\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public String[] getSharedRolesOfUser(String userName, String tenantDomain, String filter)\n-            throws UserStoreException {\n-\n-        UserStore userStore = getUserStore(userName);\n-        UserStoreManager manager = userStore.getUserStoreManager();\n-\n-        if (!((AbstractUserStoreManager) manager).isSharedGroupEnabled()) {\n-            throw new UserStoreException(\"Share Groups are not supported by user store\");\n-        }\n-        String[] sharedRoles;\n-        if (((AbstractUserStoreManager) manager).isUniqueUserIdEnabled()) {\n-            sharedRoles = ((AbstractUserStoreManager) manager).\n-                    doGetSharedRoleListOfUserWithID(getUserIDFromUserName(userStore.getDomainFreeName()), tenantDomain,\n-                            filter);\n-        } else {\n-            sharedRoles = ((AbstractUserStoreManager) manager).\n-                    doGetSharedRoleListOfUser(userStore.getDomainFreeName(), tenantDomain, filter);\n-        }\n-        return UserCoreUtil.removeDomainFromNames(sharedRoles);\n-    }\n-\n-    /**\n-     * TODO move to API\n-     *\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public String[] getUsersOfSharedRole(String roleName, String filter) throws UserStoreException {\n-\n-        UserStoreManager manager = getUserStoreWithSharedRoles();\n-\n-        if (manager == null) {\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        if (isUniqueUserIdEnabled(manager)) {\n-            List<User> users = ((AbstractUserStoreManager) manager).doGetUserListOfRoleWithID(roleName, filter);\n-            return users.stream().map(User::getDomainQualifiedUsername).toArray(String[]::new);\n-        } else {\n-            String[] users = ((AbstractUserStoreManager) manager).doGetUserListOfRole(roleName, filter);\n-            return UserCoreUtil.removeDomainFromNames(users);\n-        }\n-    }\n-\n-    /**\n-     * TODO move to API\n-     *\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public String[] getSharedRoleNames(String tenantDomain, String filter,\n-                                       int maxItemLimit) throws UserStoreException {\n-\n-\n-        UserStoreManager manager = getUserStoreWithSharedRoles();\n-\n-        if (manager == null) {\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        String[] sharedRoles = null;\n-        try {\n-            sharedRoles = ((AbstractUserStoreManager) manager).\n-                    doGetSharedRoleNames(tenantDomain, filter, maxItemLimit);\n-        } catch (UserStoreException e) {\n-            throw new UserStoreException(\"Error while retrieving shared roles\", e);\n-        }\n-        return UserCoreUtil.removeDomainFromNames(sharedRoles);\n-    }\n-\n-\n-    /**\n-     * TODO move to API\n-     *\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public String[] getSharedRoleNames(String filter, int maxItemLimit) throws UserStoreException {\n-\n-        UserStoreManager manager = getUserStoreWithSharedRoles();\n-\n-        if (manager == null) {\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        String[] sharedRoles = null;\n-        try {\n-            sharedRoles = ((AbstractUserStoreManager) manager).\n-                    doGetSharedRoleNames(null, filter, maxItemLimit);\n-        } catch (UserStoreException e) {\n-            throw new UserStoreException(\"Error while retrieving shared roles\", e);\n-        }\n-        return UserCoreUtil.removeDomainFromNames(sharedRoles);\n-    }\n-\n-\n-    public void addInternalRole(String roleName, String[] userList,\n-                                org.wso2.carbon.user.api.Permission[] permission) throws UserStoreException {\n-        doAddInternalRole(roleName, userList, permission);\n-    }\n-\n-    private UserStoreManager getUserStoreWithSharedRoles() throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{};\n-            Object object = callSecure(\"getUserStoreWithSharedRoles\", new Object[]{}, argTypes);\n-            return (UserStoreManager) object;\n-        }\n-\n-        UserStoreManager sharedRoleManager = null;\n-\n-        if (isSharedGroupEnabled()) {\n-            return this;\n-        }\n-\n-        for (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-            UserStoreManager manager = entry.getValue();\n-            if (manager != null && ((AbstractUserStoreManager) manager).isSharedGroupEnabled()) {\n-                if (sharedRoleManager != null) {\n-                    throw new UserStoreException(\"There can not be more than one user store that support\" +\n-                            \"shared groups\");\n-                }\n-                sharedRoleManager = manager;\n-            }\n-        }\n-\n-        return sharedRoleManager;\n-    }\n-\n-    /**\n-     * TODO move to API\n-     *\n-     * @param userName\n-     * @param roleName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public boolean isUserInRole(String userName, String roleName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String.class};\n-            Object object = callSecure(\"isUserInRole\", new Object[]{userName, roleName}, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        if (roleName == null || roleName.trim().length() == 0 || userName == null ||\n-                userName.trim().length() == 0) {\n-            return false;\n-        }\n-\n-        // anonymous user is always assigned to  anonymous role\n-        if (CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME.equalsIgnoreCase(roleName) &&\n-                CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userName)) {\n-            return true;\n-        }\n-\n-        if (!CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userName) &&\n-                realmConfig.getEveryOneRoleName().equalsIgnoreCase(roleName) &&\n-                !systemUserRoleManager.isExistingSystemUser(UserCoreUtil.\n-                        removeDomainFromName(userName))) {\n-            return true;\n-        }\n-\n-\n-        String[] roles = null;\n-\n-        roles = getRoleListOfUserFromCache(tenantId, userName);\n-        if (roles != null && roles.length > 0) {\n-            if (UserCoreUtil.isContain(roleName, roles)) {\n-                return true;\n-            }\n-        }\n-\n-        // TODO create new cache for this method\n-        String modifiedUserName = UserCoreConstants.IS_USER_IN_ROLE_CACHE_IDENTIFIER + userName;\n-        roles = getRoleListOfUserFromCache(tenantId, modifiedUserName);\n-        if (roles != null && roles.length > 0) {\n-            if (UserCoreUtil.isContain(roleName, roles)) {\n-                return true;\n-            }\n-        }\n-\n-        if (UserCoreConstants.INTERNAL_DOMAIN.\n-                equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName))\n-                || APPLICATION_DOMAIN.equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName)) ||\n-                WORKFLOW_DOMAIN.equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName))) {\n-\n-            String[] internalRoles = doGetInternalRoleListOfUser(userName, roleName);\n-            if (UserCoreUtil.isContain(roleName, internalRoles)) {\n-                addToIsUserHasRole(modifiedUserName, roleName, roles);\n-                return true;\n-            }\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()\n-                && (userStore.getUserStoreManager() instanceof AbstractUserStoreManager)) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager()).isUserInRole(\n-                    userStore.getDomainFreeName(), roleName);\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (userStore.isSystemStore()) {\n-            return systemUserRoleManager.isUserInRole(userStore.getDomainFreeName(),\n-                    UserCoreUtil.removeDomainFromName(roleName));\n-        }\n-        // admin user is always assigned to admin role if it is in primary user store\n-        if (realmConfig.isPrimary() && roleName.equalsIgnoreCase(realmConfig.getAdminRoleName()) &&\n-                userName.equalsIgnoreCase(realmConfig.getAdminUserName())) {\n-            return true;\n-        }\n-\n-        String roleDomainName = UserCoreUtil.extractDomainFromName(roleName);\n-\n-        String roleDomainNameForForest = realmConfig.\n-                getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_GROUP_SEARCH_DOMAINS);\n-        if (roleDomainNameForForest != null && roleDomainNameForForest.trim().length() > 0) {\n-            String[] values = roleDomainNameForForest.split(\"#\");\n-            for (String value : values) {\n-                if (value != null && !value.trim().equalsIgnoreCase(roleDomainName)) {\n-                    return false;\n-                }\n-            }\n-        } else if (!userStore.getDomainName().equalsIgnoreCase(roleDomainName) && !(UserCoreConstants.INTERNAL_DOMAIN.\n-                equalsIgnoreCase(roleDomainName) || APPLICATION_DOMAIN.equalsIgnoreCase(roleDomainName)\n-                || WORKFLOW_DOMAIN.equalsIgnoreCase(roleDomainName))) {\n-            return false;\n-        }\n-\n-        boolean success = false;\n-        if (readGroupsEnabled) {\n-            if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                success = doCheckIsUserInRoleWithID(getUserIDFromUserName(userName),\n-                        UserCoreUtil.removeDomainFromName(roleName));\n-            } else {\n-                success = doCheckIsUserInRole(userStore.getDomainFreeName(),\n-                        UserCoreUtil.removeDomainFromName(roleName));\n-            }\n-\n-            if (isRoleAndGroupSeparationEnabled()) {\n-                String[] rolesList;\n-                if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                    rolesList = doGetExternalRoleListOfUserWithID(getUserIDFromUserName(userName), \"*\");\n-                } else {\n-                    rolesList = doGetExternalRoleListOfUser(userName, \"*\");\n-                }\n-\n-                Map<String, List<String>> rolesOfGroups = getHybridRoleListOfGroups(Arrays.asList(rolesList),\n-                        userStore.getDomainName());\n-                Set<String> roleListOfGroups = getUniqueSet(rolesOfGroups);\n-                if (roleListOfGroups.stream().anyMatch(roleName::equalsIgnoreCase)) {\n-                    success = true;\n-                }\n-            }\n-        }\n-\n-        // add to cache\n-        if (success) {\n-            addToIsUserHasRole(modifiedUserName, roleName, roles);\n-        }\n-        return success;\n-    }\n-\n-    /**\n-     * @param userName\n-     * @param roleName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public abstract boolean doCheckIsUserInRole(String userName, String roleName) throws UserStoreException;\n-\n-    /**\n-     * @param userID   user ID.\n-     * @param roleName role name.\n-     * @return true if user uis in the given role.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    public boolean doCheckIsUserInRoleWithID(String userID, String roleName) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doCheckIsUserInRoleWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"doCheckIsUserInRoleWithID operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    /**\n-     * Helper method\n-     *\n-     * @param userName\n-     * @param roleName\n-     * @param currentRoles\n-     */\n-    private void addToIsUserHasRole(String userName, String roleName, String[] currentRoles) {\n-        List<String> roles;\n-        if (currentRoles != null) {\n-            roles = new ArrayList<>(Arrays.asList(currentRoles));\n-        } else {\n-            roles = new ArrayList<>();\n-        }\n-        roles.add(roleName);\n-        addToUserRolesCache(tenantId, userName, roles.toArray(new String[0]));\n-    }\n-\n-//////////////////////////////////// Shared role APIs finish //////////////////////////////////////////\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public boolean isExistingUser(String userName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class};\n-            Object object = callSecure(\"isExistingUser\", new Object[]{userName}, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        if (UserCoreUtil.isRegistrySystemUser(userName)) {\n-            return true;\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return userStore.getUserStoreManager().isExistingUser(userStore.getDomainFreeName());\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (userStore.isSystemStore()) {\n-            return systemUserRoleManager.isExistingSystemUser(userStore.getDomainFreeName());\n-        }\n-\n-        if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-            return doCheckExistingUser(userStore.getDomainFreeName());\n-        } else {\n-            return getUserIDFromUserName(userName) != null;\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final String[] listUsers(String filter, int maxItemLimit) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class, int.class};\n-            Object object = callSecure(\"listUsers\", new Object[]{filter, maxItemLimit}, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        int index;\n-        index = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        String[] userList;\n-\n-        // Check whether we have a secondary UserStoreManager setup.\n-        if (index > 0) {\n-            // Using the short-circuit. User name comes with the domain name.\n-            String domain = filter.substring(0, index);\n-\n-            UserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-            if (secManager != null) {\n-                // We have a secondary UserStoreManager registered for this domain.\n-                filter = filter.substring(index + 1);\n-                if (secManager instanceof AbstractUserStoreManager) {\n-                    if (!((AbstractUserStoreManager) secManager).isUniqueUserIdEnabled()) {\n-                        userList = ((AbstractUserStoreManager) secManager).doListUsers(filter, maxItemLimit);\n-                    } else {\n-                        userList = ((AbstractUserStoreManager) secManager).doListUsersWithID(filter, maxItemLimit)\n-                                .stream()\n-                                .map(User::getDomainQualifiedUsername)\n-                                .toArray(String[]::new);\n-                    }\n-                    handlePostGetUserList(null, null, new ArrayList<>(Arrays.asList(userList)), true);\n-                    return userList;\n-                } else {\n-                    userList = secManager.listUsers(filter, maxItemLimit);\n-                    handlePostGetUserList(null, null, new ArrayList<>(Arrays.asList(userList)), true);\n-                    return userList;\n-                }\n-            }\n-        } else if (index == 0) {\n-            if (!isUniqueUserIdEnabled()) {\n-                userList = doListUsers(filter.substring(1), maxItemLimit);\n-            } else {\n-                userList = doListUsersWithID(filter.substring(1), maxItemLimit)\n-                        .stream()\n-                        .map(User::getDomainQualifiedUsername)\n-                        .toArray(String[]::new);\n-            }\n-            handlePostGetUserList(null, null, new ArrayList<>(Arrays.asList(userList)), true);\n-            return userList;\n-        }\n-\n-        try {\n-            if (!isUniqueUserIdEnabled()) {\n-                userList = doListUsers(filter, maxItemLimit);\n-            } else {\n-                userList = doListUsersWithID(filter, maxItemLimit)\n-                        .stream()\n-                        .map(User::getDomainQualifiedUsername)\n-                        .toArray(String[]::new);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(), ex.getMessage()),\n-                    null, null, null);\n-            throw ex;\n-        }\n-\n-        String primaryDomain = realmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\n-        if (this.getSecondaryUserStoreManager() != null) {\n-            for (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-                if (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n-                    continue;\n-                }\n-                UserStoreManager storeManager = entry.getValue();\n-                if (storeManager instanceof AbstractUserStoreManager) {\n-                    try {\n-                        String[] secondUserList;\n-                        if (!((AbstractUserStoreManager) storeManager).isUniqueUserIdEnabled()) {\n-                            secondUserList = ((AbstractUserStoreManager) storeManager)\n-                                    .doListUsers(filter, maxItemLimit);\n-                        } else {\n-                            secondUserList = ((AbstractUserStoreManager) storeManager)\n-                                    .doListUsersWithID(filter, maxItemLimit)\n-                                    .stream()\n-                                    .map(User::getDomainQualifiedUsername)\n-                                    .toArray(String[]::new);\n-                        }\n-                        userList = UserCoreUtil.combineArrays(userList, secondUserList);\n-                    } catch (UserStoreException ex) {\n-                        handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(),\n-                                        ex.getMessage()), null, null, null);\n-\n-                        // We can ignore and proceed. Ignore the results from this user store.\n-                        log.error(ex);\n-                    }\n-                } else {\n-                    String[] secondUserList = storeManager.listUsers(filter, maxItemLimit);\n-                    userList = UserCoreUtil.combineArrays(userList, secondUserList);\n-                }\n-            }\n-        }\n-\n-        handlePostGetUserList(null, null, new ArrayList<>(Arrays.asList(userList)), true);\n-        return userList;\n-    }\n-\n-    /**\n-     * Count roles in user stores\n-     *\n-     * @param filter The string to filter out roles\n-     * @return countRoles\n-     * @throws UserStoreException UserStoreException\n-     */\n-    public long countRoles(String filter) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class};\n-            Object object = callSecure(\"countRoles\", new Object[]{filter}, argTypes);\n-            return (long) object;\n-        }\n-\n-        int index;\n-        index = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-\n-        // Check whether we have a secondary UserStoreManager setup.\n-        if (index > 0) {\n-            String domain = filter.substring(0, index);\n-            if (isInternalRole(domain)) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Internal domain is provided. Thus calling the hybrid role manager to get the \" +\n-                            \"internal role count.\");\n-                }\n-                return this.hybridRoleManager.countHybridRoles(filter);\n-            }\n-            filter = filter.substring(index + 1);\n-            UserStoreManager secondaryUserStoreManager = getSecondaryUserStoreManager(domain);\n-            if (secondaryUserStoreManager != null) {\n-                // We have a secondary UserStoreManager registered for this domain.\n-                if (secondaryUserStoreManager instanceof AbstractUserStoreManager) {\n-                    return ((AbstractUserStoreManager) secondaryUserStoreManager).doCountRoles(filter);\n-                } else {\n-                    throw new UserStoreException(\"User store not supported\");\n-                }\n-            }\n-        } else if (index == 0) {\n-            return doCountRoles(filter.substring(1));\n-        }\n-        return doCountRoles(filter);\n-    }\n-\n-    /**\n-     * Count Claims in user stores\n-     *\n-     * @return claim count value\n-     * @throws UserStoreException\n-     */\n-    public final long countUsersWithClaims(String claimURI, String valueFilter) throws UserStoreException {\n-\n-        return doCountUsersWithClaims(claimURI, valueFilter);\n-    }\n-\n-    /**\n-     * This is to call the relevant post methods in listeners after successful retrieval of user list of a role.\n-     *\n-     * @param roleName Name of the role.\n-     * @param userList List of users.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handleDoPostGetUserListOfRoleWithID(String roleName, List<User> userList) throws UserStoreException {\n-\n-        for (UserOperationEventListener userOperationEventListener : UMListenerServiceComponent\n-                .getUserOperationEventListeners()) {\n-            if (userOperationEventListener instanceof AbstractUserOperationEventListener) {\n-                if (!((AbstractUserOperationEventListener) userOperationEventListener)\n-                        .doPostGetUserListOfRoleWithID(roleName, userList, this)) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This is to call the relevant post methods in listeners after successful retrieval of user list of a role.\n-     *\n-     * @param roleName Name of the role.\n-     * @param userList List of users.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handleDoPostGetUserListOfRole(String roleName, String[] userList) throws UserStoreException {\n-\n-        for (UserOperationEventListener userOperationEventListener : UMListenerServiceComponent\n-                .getUserOperationEventListeners()) {\n-            if (userOperationEventListener instanceof AbstractUserOperationEventListener) {\n-                if (!((AbstractUserOperationEventListener) userOperationEventListener)\n-                        .doPostGetUserListOfRole(roleName, userList, this)) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final String[] getUserListOfRole(String roleName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class};\n-            Object object = callSecure(\"getUserListOfRole\", new Object[]{roleName}, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        return getUserListOfRole(roleName, QUERY_FILTER_STRING_ANY, QUERY_MAX_ITEM_LIMIT_ANY);\n-    }\n-\n-    /**\n-     * Retrieves a list of user names belongs to the given role and matches the given string filter.\n-     *\n-     * @param roleName Name of the role.\n-     * @param filter The string to filter out names of users belong to the given role.\n-     * @param maxItemLimit Maximum number of users returned.\n-     * @return User name list.\n-     * @throws UserStoreException\n-     */\n-    public final String[] getUserListOfRole(String roleName, String filter, int maxItemLimit) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String.class, int.class};\n-            Object object = callSecure(\"getUserListOfRole\", new Object[]{roleName, filter, maxItemLimit}, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        String[] userNames = new String[0];\n-\n-        // If role does not exit, just return\n-        if (!isExistingRole(roleName)) {\n-            handleDoPostGetUserListOfRole(roleName, userNames);\n-            return userNames;\n-        }\n-\n-        UserStore userStore = getUserStoreOfRoles(roleName);\n-\n-        if (userStore.isRecurssive()) {\n-            UserStoreManager resolvedUserStoreManager = userStore.getUserStoreManager();\n-            if (resolvedUserStoreManager instanceof AbstractUserStoreManager) {\n-                return ((AbstractUserStoreManager) resolvedUserStoreManager)\n-                        .getUserListOfRole(userStore.getDomainFreeName(), filter, maxItemLimit);\n-            } else {\n-                return resolvedUserStoreManager.getUserListOfRole(userStore.getDomainFreeName());\n-            }\n-        }\n-\n-\n-        // #################### Domain Name Free Zone Starts Here\n-        // ################################\n-\n-        if (userStore.isSystemStore()) {\n-            String[] userList = systemUserRoleManager.getUserListOfSystemRole(userStore.getDomainFreeName());\n-            handleDoPostGetUserListOfRole(roleName, userList);\n-            return userList;\n-        }\n-\n-        String[] userNamesInHybrid;\n-        if (userStore.isHybridRole()) {\n-            if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(userStore.getDomainName())) {\n-                userNamesInHybrid = hybridRoleManager.getUserListOfHybridRole(userStore.getDomainFreeName());\n-            } else {\n-                userNamesInHybrid = hybridRoleManager.getUserListOfHybridRole(userStore.getDomainAwareName());\n-            }\n-\n-            // Get the users of associated groups of the role.\n-            if (isRoleAndGroupSeparationEnabled()) {\n-                Set<String> userListOfGroups = new HashSet<>();\n-                String[] groupsOfRole;\n-                if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(userStore.getDomainName())) {\n-                    groupsOfRole = hybridRoleManager.getGroupListOfHybridRole(userStore.getDomainFreeName());\n-                } else {\n-                    groupsOfRole = hybridRoleManager.getGroupListOfHybridRole(userStore.getDomainAwareName());\n-                }\n-                for (String group : groupsOfRole) {\n-                    userListOfGroups.addAll(Arrays.asList(getUserListOfRole(group, filter, maxItemLimit)));\n-                }\n-                userNamesInHybrid = UserCoreUtil.combine(userNamesInHybrid, new ArrayList<>(userListOfGroups));\n-            }\n-\n-            // remove domain\n-            List<String> finalNameList = new ArrayList<>();\n-            String displayNameAttribute = this.realmConfig.getUserStoreProperty(LDAPConstants.DISPLAY_NAME_ATTRIBUTE);\n-\n-            if (userNamesInHybrid != null && userNamesInHybrid.length > 0) {\n-                if (displayNameAttribute != null && displayNameAttribute.trim().length() > 0) {\n-                    for (String userName : userNamesInHybrid) {\n-                        String domainName = UserCoreUtil.extractDomainFromName(userName);\n-                        if (domainName == null || domainName.trim().length() == 0) {\n-                            finalNameList.add(userName);\n-                        }\n-                        UserStoreManager userManager = userStoreManagerHolder.get(domainName);\n-                        userName = UserCoreUtil.removeDomainFromName(userName);\n-                        if (userManager != null) {\n-                            String[] displayNames = null;\n-                            if (userManager instanceof AbstractUserStoreManager) {\n-                                // get displayNames\n-                                displayNames = ((AbstractUserStoreManager) userManager)\n-                                        .doGetDisplayNamesForInternalRole(new String[] { userName });\n-                            } else {\n-                                displayNames = userManager.getRoleNames();\n-                            }\n-\n-                            for (String displayName : displayNames) {\n-                                // if domain names are not added by above method, add it\n-                                // here\n-                                String nameWithDomain = UserCoreUtil.addDomainToName(displayName, domainName);\n-                                finalNameList.add(nameWithDomain);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    handleDoPostGetUserListOfRole(roleName, userNamesInHybrid);\n-                    return userNamesInHybrid;\n-                }\n-            }\n-            String[] userList = finalNameList.toArray(new String[0]);\n-            handleDoPostGetUserListOfRole(roleName, userList);\n-            return userList;\n-        }\n-\n-        if (readGroupsEnabled) {\n-            if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                List<User> users = doGetUserListOfRoleWithID(roleName, filter, maxItemLimit);\n-                userNames = users.stream().map(User::getDomainQualifiedUsername).toArray(String[]::new);\n-            } else {\n-                userNames = doGetUserListOfRole(roleName, filter, maxItemLimit);\n-            }\n-            handleDoPostGetUserListOfRole(roleName, userNames);\n-        }\n-        return userNames;\n-\n-    }\n-\n-    public String[] getRoleListOfUser(String userName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class};\n-            Object object = callSecure(\"getRoleListOfUser\", new Object[]{userName}, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        String[] roleNames;\n-        String userID;\n-\n-        // anonymous user is only assigned to  anonymous role\n-        if (CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userName)) {\n-            return new String[]{CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME};\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return userStore.getUserStoreManager().getRoleListOfUser(userStore.getDomainFreeName());\n-        }\n-\n-        roleNames = getRoleListOfUserFromCache(this.tenantId, userName);\n-\n-        if (roleNames != null && roleNames.length > 0) {\n-            return roleNames;\n-        }\n-\n-        if (userStore.isSystemStore()) {\n-            return systemUserRoleManager.getSystemRoleListOfUser(userStore.getDomainFreeName());\n-        }\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-            userID = getUserIDFromUserName(userName);\n-            if (userID == null) {\n-                // According to implementation, getRoleListOfUser method would return everyone role name for all users.\n-                return new String[]{realmConfig.getEveryOneRoleName()};\n-            }\n-            roleNames = doGetRoleListOfUserWithID(userID, \"*\").toArray(new String[0]);\n-        } else {\n-            roleNames = doGetRoleListOfUser(userName, \"*\");\n-        }\n-        return roleNames;\n-    }\n-\n-    /**\n-     * Getter method for claim manager property specifically to be used in the implementations of\n-     * UserOperationEventListener implementations\n-     *\n-     * @return\n-     */\n-    public ClaimManager getClaimManager() {\n-        return claimManager;\n-    }\n-\n-    /**\n-     * This method is responsible for calling relevant listener methods when there is a failure while trying to add\n-     * role.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param roleName     Name of the role.\n-     * @param userList     List of users to be assigned to the role.\n-     * @param permissions  Permissions of the role role.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleAddRoleFailure(String errorCode, String errorMessage, String roleName, String[] userList,\n-            org.wso2.carbon.user.api.Permission[] permissions) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener\n-                    .onAddRoleFailure(errorCode, errorMessage, roleName, userList, permissions, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling relevant listener methods when there is a failure while trying to add\n-     * role.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param roleName     Name of the role.\n-     * @param userIDList     List of users to be assigned to the role.\n-     * @param permissions  Permissions of the role role.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handleAddRoleFailureWithID(String errorCode, String errorMessage, String roleName,\n-                                            String[] userIDList,  org.wso2.carbon.user.api.Permission[]\n-                                                    permissions) throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !((UniqueIDUserManagementErrorEventListener) listener)\n-                    .onAddRoleFailureWithID(errorCode, errorMessage, roleName, userIDList, permissions, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling relevant postAddRole listener methods after successfully adding role.\n-     *\n-     * @param roleName       Name of the role.\n-     * @param userList       List of users.\n-     * @param permissions    Permissions that are assigned to the role.\n-     * @param isAuditLogOnly To indicate whether to only call the relevant audit logger.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handlePostAddRole(String roleName, String[] userList, org.wso2.carbon.user.api.Permission[]\n-            permissions, boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            boolean internalRole = isAnInternalRole(roleName);\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName().endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-\n-                boolean success = false;\n-                if (internalRole && listener instanceof AbstractUserOperationEventListener) {\n-                    success = ((AbstractUserOperationEventListener) listener).doPostAddInternalRole(roleName,\n-                            userList, permissions, this);\n-                } else if (internalRole && !(listener instanceof AbstractUserOperationEventListener)) {\n-                    success = true;\n-                } else if (!internalRole) {\n-                    success = listener.doPostAddRole(roleName, userList, permissions, this);\n-                }\n-\n-                if (!success) {\n-                    handleAddRoleFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_ROLE.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), roleName, userList,\n-                            permissions);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleAddRoleFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_ROLE.getMessage(), ex.getMessage()),\n-                    roleName, userList, permissions);\n-            throw ex;\n-        }\n-    }\n-\n-    private boolean handlePreAddRole(String roleName, String[] userList, org.wso2.carbon.user.api.Permission[]\n-            permissions, boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            boolean internalRole = isAnInternalRole(roleName);\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName().endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-\n-                boolean success = false;\n-                if (internalRole && listener instanceof AbstractUserOperationEventListener) {\n-                    success = ((AbstractUserOperationEventListener) listener).doPreAddInternalRole(roleName,\n-                            userList, permissions, this);\n-                } else if (internalRole && !(listener instanceof AbstractUserOperationEventListener)) {\n-                    success = true;\n-                } else if (!internalRole) {\n-                    success = listener.doPreAddRole(roleName, userList, permissions, this);\n-                }\n-\n-                if (!success) {\n-                    handleAddRoleFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_ROLE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), roleName, userList,\n-                            permissions);\n-                    return false;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleAddRoleFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_ROLE.getMessage(), ex.getMessage()),\n-                    roleName, userList, permissions);\n-            throw ex;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     *\n-     */\n-    public void addRole(String roleName, String[] userList, org.wso2.carbon.user.api.Permission[] permissions,\n-                        boolean isSharedRole) throws org.wso2.carbon.user.api.UserStoreException {\n-\n-        if (StringUtils.isEmpty(roleName)) {\n-            handleAddRoleFailure(ErrorMessages.ERROR_CODE_CANNOT_ADD_EMPTY_ROLE.getCode(),\n-                    ErrorMessages.ERROR_CODE_CANNOT_ADD_EMPTY_ROLE.getMessage(), roleName, userList, permissions);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_ADD_EMPTY_ROLE.toString());\n-        }\n-\n-        if (userList == null) {\n-            userList = new String[0];\n-        }\n-\n-        UserStore userStore = getUserStoreOfRoles(roleName);\n-\n-        if (isSharedRole && !isSharedGroupEnabled()) {\n-            handleAddRoleFailure(ErrorMessages.ERROR_CODE_SHARED_ROLE_NOT_SUPPORTED.getCode(),\n-                    ErrorMessages.ERROR_CODE_SHARED_ROLE_NOT_SUPPORTED.getMessage(), roleName, userList, permissions);\n-            throw new org.wso2.carbon.user.api.UserStoreException(\n-                    ErrorMessages.ERROR_CODE_SHARED_ROLE_NOT_SUPPORTED.toString());\n-        }\n-\n-        if (userStore.isHybridRole()) {\n-            //Invoke Pre listeners for hybrid roles.\n-            if (!handlePreAddRole(roleName, userList, permissions, false)) {\n-                return;\n-            }\n-\n-            doAddInternalRole(roleName, userList, permissions);\n-\n-            // Calling only the audit logger, to maintain the back-ward compatibility\n-            handlePostAddRole(roleName, userList, permissions, false);\n-            return;\n-        }\n-\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().addRole(userStore.getDomainFreeName(),\n-                    UserCoreUtil.removeDomainFromNames(userList), permissions, isSharedRole);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        if (permissions == null) {\n-            permissions = new org.wso2.carbon.user.api.Permission[0];\n-        }\n-        // This happens only once during first startup - adding administrator user/role.\n-        if (roleName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-            roleName = userStore.getDomainFreeName();\n-            userList = UserCoreUtil.removeDomainFromNames(userList);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        if (!handlePreAddRole(roleName, userList, permissions, false)) {\n-            return;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        // Check for validations\n-        if (isReadOnly()) {\n-            handleAddRoleFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), roleName, userList, permissions);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        if (!isRoleNameValid(roleName)) {\n-            String regEx = realmConfig\n-                    .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n-            String errorMessage = String\n-                    .format(ErrorMessages.ERROR_CODE_INVALID_ROLE_NAME.getMessage(), roleName, regEx);\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_ROLE_NAME.getCode();\n-            handleAddRoleFailure(errorCode, errorMessage, roleName, userList, permissions);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        if (doCheckExistingRole(roleName)) {\n-            handleRoleAlreadyExistException(roleName, userList, permissions);\n-        }\n-\n-        String roleWithDomain = null;\n-        if (writeGroupsEnabled) {\n-            try {\n-                // add role in to actual user store\n-                if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                    doAddRole(roleName, userList, isSharedRole);\n-                } else {\n-                    List<String> userIDs = getUserIDsFromUserNames(Arrays.asList(userList));\n-                    doAddRoleWithID(roleName, userIDs.toArray(new String[0]), isSharedRole);\n-                }\n-                roleWithDomain = UserCoreUtil.addDomainToName(roleName, getMyDomainName());\n-            } catch (UserStoreException ex) {\n-                handleAddRoleFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_ADDING_ROLE.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_ADDING_ROLE.getMessage(), ex.getMessage()),\n-                        roleName, userList, permissions);\n-                throw ex;\n-            }\n-        } else {\n-            handleAddRoleFailure(ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.getCode(),\n-                    ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.getMessage(), roleName, userList, permissions);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.toString());\n-        }\n-\n-        // add permission in to the the permission store\n-        if (permissions != null) {\n-            for (org.wso2.carbon.user.api.Permission permission : permissions) {\n-                String resourceId = permission.getResourceId();\n-                String action = permission.getAction();\n-                if (resourceId == null || resourceId.trim().length() == 0) {\n-                    continue;\n-                }\n-\n-                if (action == null || action.trim().length() == 0) {\n-                    // default action value // TODO\n-                    action = \"read\";\n-                }\n-                // This is a special case. We need to pass domain aware name.\n-                userRealm.getAuthorizationManager().authorizeRole(roleWithDomain, resourceId,\n-                        action);\n-            }\n-        }\n-\n-        // if existing users are added to role, need to update user role cache\n-        if ((userList != null) && (userList.length > 0)) {\n-            clearUserRolesCacheByTenant(tenantId);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        handlePostAddRole(roleName, userList, permissions, false);\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    /**\n-     * TODO move to API\n-     *\n-     * @return\n-     */\n-    public boolean isSharedGroupEnabled() {\n-        String value = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.SHARED_GROUPS_ENABLED);\n-        try {\n-            return realmConfig.isPrimary() && !isReadOnly() && TRUE_VALUE.equalsIgnoreCase(value);\n-        } catch (UserStoreException e) {\n-            log.error(e);\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Removes the shared roles relevant to the provided tenant domain\n-     *\n-     * @param sharedRoles\n-     * @param tenantDomain\n-     */\n-    protected void filterSharedRoles(List<String> sharedRoles, String tenantDomain) {\n-        if (tenantDomain != null) {\n-            for (Iterator<String> i = sharedRoles.iterator(); i.hasNext(); ) {\n-                String role = i.next();\n-                if (role.indexOf(tenantDomain) > -1) {\n-                    i.remove();\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method calls the relevant methods when there is a failure while trying to delete the role.\n-     *\n-     * @param errorCode    Error code.\n-     * @param errorMessage Error message.\n-     * @param roleName     Name of the roles.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private void handleDeleteRoleFailure(String errorCode, String errorMessage, String roleName)\n-            throws UserStoreException {\n-\n-        for (UserManagementErrorEventListener listener : UMListenerServiceComponent\n-                .getUserManagementErrorEventListeners()) {\n-            if (listener.isEnable() && !listener.onDeleteRoleFailure(errorCode, errorMessage, roleName, this)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling post delete methods of relevant listeners.\n-     *\n-     * @param roleName       Name of the role\n-     * @param isAuditLogOnly To indicate whether to call only the audit logger.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private void handleDoPostDeleteRole(String roleName, boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            boolean internalRole = isAnInternalRole(roleName);\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName()\n-                        .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-\n-                boolean success = false;\n-                if (internalRole && listener instanceof AbstractUserOperationEventListener) {\n-                    success = ((AbstractUserOperationEventListener) listener).doPostDeleteInternalRole(roleName, this);\n-                } else if (internalRole && !(listener instanceof AbstractUserOperationEventListener)) {\n-                    success = true;\n-                } else if (!internalRole) {\n-                    success = listener.doPostDeleteRole(roleName, this);\n-                }\n-\n-                if (!success) {\n-                    handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_ROLE.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), roleName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_ROLE.getMessage(), ex.getMessage()),\n-                    roleName);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * This method is responsible for calling pre delete methods of relevant listeners.\n-     *\n-     * @param roleName       Name of the role\n-     * @param isAuditLogOnly To indicate whether to call only the audit logger.\n-     * @throws UserStoreException Exception that will be thrown by relevant listener methods.\n-     */\n-    private boolean handleDoPreDeleteRole(String roleName, boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            boolean internalRole = isAnInternalRole(roleName);\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName()\n-                        .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-\n-                boolean success = false;\n-                if (internalRole && listener instanceof AbstractUserOperationEventListener) {\n-                    success = ((AbstractUserOperationEventListener) listener).doPreDeleteInternalRole(roleName, this);\n-                } else if (internalRole && !(listener instanceof AbstractUserOperationEventListener)) {\n-                    success = true;\n-                } else if (!internalRole) {\n-                    success = listener.doPreDeleteRole(roleName, this);\n-                }\n-\n-                if (!success) {\n-                    handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_ROLE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), roleName);\n-                    return false;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_ROLE.getMessage(), ex.getMessage()),\n-                    roleName);\n-            throw ex;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Delete the role with the given role name\n-     *\n-     * @param roleName The role name\n-     * @throws org.wso2.carbon.user.core.UserStoreException\n-     */\n-    public final void deleteRole(String roleName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class};\n-            callSecure(\"deleteRole\", new Object[]{roleName}, argTypes);\n-            return;\n-        }\n-\n-        if (UserCoreUtil.isPrimaryAdminRole(roleName, realmConfig)) {\n-            handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_CANNOT_DELETE_ADMIN_ROLE.getCode(),\n-                    ErrorMessages.ERROR_CODE_CANNOT_DELETE_ADMIN_ROLE.getMessage(), roleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_DELETE_ADMIN_ROLE.toString());\n-        }\n-        if (UserCoreUtil.isEveryoneRole(roleName, realmConfig)) {\n-            handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_CANNOT_DELETE_EVERYONE_ROLE.getCode(),\n-                    ErrorMessages.ERROR_CODE_CANNOT_DELETE_EVERYONE_ROLE.getMessage(), roleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_DELETE_EVERYONE_ROLE.toString());\n-        }\n-\n-        UserStore userStore = getUserStoreOfRoles(roleName);\n-        if (userStore.isRecurssive()) {\n-            userStore.getUserStoreManager().deleteRole(userStore.getDomainFreeName());\n-            return;\n-        }\n-\n-        String roleWithDomain = UserCoreUtil.addDomainToName(roleName, getMyDomainName());\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (userStore.isHybridRole()) {\n-            // Invoke pre listeners.\n-            if (!handleDoPreDeleteRole(roleName, false)) {\n-                return;\n-            }\n-            try {\n-                if (APPLICATION_DOMAIN.equalsIgnoreCase(userStore.getDomainName()) || WORKFLOW_DOMAIN\n-                        .equalsIgnoreCase(userStore.getDomainName())) {\n-                    hybridRoleManager.deleteHybridRole(roleName);\n-                } else {\n-                    hybridRoleManager.deleteHybridRole(userStore.getDomainFreeName());\n-                }\n-            } catch (UserStoreException ex) {\n-                handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETE_ROLE.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETE_ROLE.getMessage(), ex.getMessage()),\n-                        roleName);\n-                throw ex;\n-            }\n-            handleDoPostDeleteRole(roleName, false);\n-            clearUserRolesCacheByTenant(tenantId);\n-            return;\n-        }\n-\n-        if (!doCheckExistingRole(roleName)) {\n-            handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_CANNOT_DELETE_NON_EXISTING_ROLE.getCode(),\n-                    ErrorMessages.ERROR_CODE_CANNOT_DELETE_NON_EXISTING_ROLE.getMessage(), roleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_DELETE_NON_EXISTING_ROLE.toString());\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        if (!handleDoPreDeleteRole(roleName, false)) {\n-            return;\n-        }\n-        // #################### </Listeners> #####################################################\n-        if (isReadOnly()) {\n-            handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), roleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        if (!writeGroupsEnabled) {\n-            handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.getCode(),\n-                    ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.getMessage(), roleName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.toString());\n-        }\n-        try {\n-            doDeleteRole(roleName);\n-        } catch (UserStoreException ex) {\n-            handleDeleteRoleFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETE_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETE_ROLE.getMessage(), ex.getMessage()),\n-                    roleName);\n-            throw ex;\n-        }\n-\n-        // clear role authorization\n-        userRealm.getAuthorizationManager().clearRoleAuthorization(roleWithDomain);\n-\n-        // clear cache\n-        clearUserRolesCacheByTenant(tenantId);\n-\n-        // Call relevant listeners after deleting the role.\n-        handleDoPostDeleteRole(roleName, false);\n-\n-    }\n-\n-    /**\n-     * Method to get the password expiration time.\n-     *\n-     * @param userName the user name.\n-     * @return the password expiration time.\n-     * @throws UserStoreException throw if the operation failed.\n-     */\n-    @Override\n-    public Date getPasswordExpirationTime(String userName) throws UserStoreException {\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return userStore.getUserStoreManager().getPasswordExpirationTime(userStore.getDomainFreeName());\n-        }\n-\n-        if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-            String userIDFromUserName = getUserIDFromUserName(userName);\n-            if (userIDFromUserName == null) {\n-                throw new UserStoreException(\"No UserId found for user:\" + userName);\n-            }\n-            return doGetPasswordExpirationTimeWithID(getUserIDFromUserName(userName));\n-        } else {\n-            return doGetPasswordExpirationTime(userName);\n-        }\n-    }\n-\n-    protected Date doGetPasswordExpirationTime(String userName) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetPasswordExpirationTime operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"doGetPasswordExpirationTime operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    protected Date doGetPasswordExpirationTimeWithID(String userName) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetPasswordExpirationTimeWithId operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"doGetPasswordExpirationTimeWithId operation is not implemented in: \" + this.getClass());\n-    }\n-\n-\n-    private UserStore getUserStore(final String user) throws UserStoreException {\n-\n-        try {\n-            return AccessController\n-                    .doPrivileged((PrivilegedExceptionAction<UserStore>) () -> getUserStoreInternal(user));\n-        } catch (PrivilegedActionException e) {\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    protected UserStore getUserStoreWithID(final String userID) throws UserStoreException {\n-\n-        try {\n-            return AccessController\n-                    .doPrivileged((PrivilegedExceptionAction<UserStore>) () -> getUserStoreInternalWithId(userID));\n-        } catch (PrivilegedActionException e) {\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    private UserStore getUserStoreOfRoles(final String role) throws UserStoreException {\n-\n-        return getUserStore(role);\n-    }\n-\n-    /**\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    private UserStore getUserStoreInternal(String user) throws UserStoreException {\n-\n-        int index;\n-        UserStore userStore = new UserStore();\n-        if (user == null) {\n-            userStore.setUserStoreManager(this);\n-            userStore.setRecurssive(false);\n-            userStore.setDomainName(getMyDomainName());\n-            return userStore;\n-        }\n-        index = user.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        String domainFreeName = null;\n-\n-        // Check whether we have a secondary UserStoreManager setup.\n-        if (index > 0) {\n-            // Using the short-circuit. User name comes with the domain name.\n-            String domain = user.substring(0, index);\n-            UserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-            if (secManager == null) {\n-                secManager = getSecondaryUserStore(domain);\n-            }\n-            domainFreeName = user.substring(index + 1);\n-\n-            if (secManager != null) {\n-                userStore.setUserStoreManager(secManager);\n-                userStore.setDomainAwareName(user);\n-                userStore.setDomainFreeName(domainFreeName);\n-                userStore.setDomainName(domain);\n-                userStore.setRecurssive(true);\n-                return userStore;\n-            } else {\n-                if (!domain.equalsIgnoreCase(getMyDomainName())) {\n-                    if ((UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain)\n-                            || APPLICATION_DOMAIN.equalsIgnoreCase(domain) || WORKFLOW_DOMAIN.equalsIgnoreCase(domain))) {\n-                        userStore.setHybridRole(true);\n-                    } else if (SYSTEM_DOMAIN_NAME.equalsIgnoreCase(domain)) {\n-                        userStore.setSystemStore(true);\n-                    } else {\n-                        throw new UserStoreException(\"Invalid Domain Name\");\n-                    }\n-                }\n-\n-                userStore.setDomainAwareName(user);\n-                userStore.setDomainFreeName(domainFreeName);\n-                userStore.setDomainName(domain);\n-                userStore.setRecurssive(false);\n-                userStore.setUserStoreManager(this);\n-                return userStore;\n-            }\n-        }\n-\n-        String domain = getMyDomainName();\n-        userStore.setUserStoreManager(this);\n-        if (index > 0) {\n-            userStore.setDomainAwareName(user);\n-            userStore.setDomainFreeName(domainFreeName);\n-        } else {\n-            userStore.setDomainAwareName(domain + CarbonConstants.DOMAIN_SEPARATOR + user);\n-            userStore.setDomainFreeName(user);\n-        }\n-        userStore.setRecurssive(false);\n-        userStore.setDomainName(domain);\n-\n-        return userStore;\n-    }\n-\n-    private UserStore getUserStoreInternalWithId(String userId) throws UserStoreException {\n-\n-        // If the user id is null, we set current user store manger as the selected one and return.\n-        UserStore userStore = new UserStore();\n-        if (userId == null) {\n-            userStore.setUserStoreManager(this);\n-            userStore.setRecurssive(false);\n-            userStore.setDomainName(getMyDomainName());\n-            return userStore;\n-        }\n-\n-        // First we have to check whether this user store is already resolved and we have it either in the cache or\n-        // in our local database. If so we can use that.\n-        String domainName = userUniqueIDDomainResolver.getDomainForUserId(userId, tenantId);\n-\n-        // If we don't have the domain name in our side, then we have to iterate through each user store and find\n-        // where is this user id from and mark it as the user store domain.\n-        if (domainName == null) {\n-            // Iterate through each registered user stores.\n-            for (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-                if (entry.getValue() instanceof AbstractUserStoreManager) {\n-                    // If there is a user for the give user id, then that is the correct domain.\n-                    AbstractUserStoreManager abstractUserStoreManager = (AbstractUserStoreManager) entry.getValue();\n-                    if (abstractUserStoreManager.isUniqueUserIdEnabled()) {\n-                        if (abstractUserStoreManager.doGetUserNameFromUserIDWithID(userId) != null) {\n-                            // If we found a domain name for the give user id, update the domain resolver with the name.\n-                            domainName = entry.getKey();\n-                            userUniqueIDDomainResolver.setDomainForUserId(userId, domainName, tenantId);\n-                            break;\n-                        }\n-                    } else {\n-                        // This is happening when the user store is not supporting uniqueID.\n-                        try {\n-                            if (abstractUserStoreManager.getUserListFromProperties(claimManager.getAttributeName(entry\n-                                    .getKey(), UserCoreClaimConstants.USER_ID_CLAIM_URI), userId, null).length > 0) {\n-                                domainName = entry.getKey();\n-                                userUniqueIDDomainResolver.setDomainForUserId(userId, domainName, tenantId);\n-                                break;\n-                            }\n-                        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                                handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(),\n-                                                e.getMessage()), UserCoreClaimConstants.USER_ID_CLAIM_URI, userId,\n-                                        null);\n-                                throw new UserStoreException(\"Unable retrieve users from getUserListFromProperties \" +\n-                                        \"method from the user store: \" + entry.getKey() + \".\", e);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Okay we didn't find the domain from there either. So this should either the PRIMARY domain or an invalid\n-        // user id. So set the current user store manager domain as the domain name.\n-        if (domainName == null || domainName.equals(getMyDomainName())) {\n-            String domain = getMyDomainName();\n-            userStore.setUserStoreManager(this);\n-            userStore.setDomainAwareUserId(UserCoreUtil.addDomainToName(userId, domainName));\n-            userStore.setDomainFreeUserId(userId);\n-            userStore.setRecurssive(false);\n-            userStore.setDomainName(domain);\n-            return userStore;\n-        }\n-\n-        UserStoreManager secManager = getSecondaryUserStoreManager(domainName);\n-        if (secManager == null) {\n-            secManager = getSecondaryUserStore(domainName);\n-        }\n-        if (secManager != null) {\n-            userStore.setUserStoreManager(secManager);\n-            userStore.setDomainAwareUserId(UserCoreUtil.addDomainToName(userId, domainName));\n-            userStore.setDomainFreeUserId(userId);\n-            userStore.setDomainName(domainName);\n-            userStore.setRecurssive(true);\n-            return userStore;\n-        } else {\n-            if (!domainName.equalsIgnoreCase(getMyDomainName())) {\n-                if ((UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domainName)\n-                        || APPLICATION_DOMAIN.equalsIgnoreCase(domainName)\n-                        || WORKFLOW_DOMAIN.equalsIgnoreCase(domainName))) {\n-                    userStore.setHybridRole(true);\n-                } else if (SYSTEM_DOMAIN_NAME.equalsIgnoreCase(domainName)) {\n-                    userStore.setSystemStore(true);\n-                } else {\n-                    throw new UserStoreException(\"Invalid Domain Name\");\n-                }\n-            }\n-\n-            userStore.setDomainAwareUserId(UserCoreUtil.addDomainToName(userId, domainName));\n-            userStore.setDomainFreeUserId(userId);\n-            userStore.setDomainName(domainName);\n-            userStore.setRecurssive(false);\n-            userStore.setUserStoreManager(this);\n-            return userStore;\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final UserStoreManager getSecondaryUserStoreManager() {\n-        return secondaryUserStoreManager;\n-    }\n-\n-    /**\n-     *\n-     */\n-    public final void setSecondaryUserStoreManager(UserStoreManager secondaryUserStoreManager) {\n-        this.secondaryUserStoreManager = secondaryUserStoreManager;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final UserStoreManager getSecondaryUserStoreManager(String userDomain) {\n-        if (userDomain == null) {\n-            return null;\n-        }\n-        return userStoreManagerHolder.get(userDomain.toUpperCase());\n-    }\n-\n-    private UserStoreManager getSecondaryUserStore(String userDomain) throws UserStoreException {\n-\n-        org.wso2.carbon.user.api.UserStoreManager userStoreManager;\n-        try {\n-            RealmService realmService = UserStoreMgtDSComponent.getRealmService();\n-            if (realmService == null) {\n-                return null;\n-            }\n-            userStoreManager = realmService.getTenantUserRealm(tenantId).getUserStoreManager();\n-            return ((AbstractUserStoreManager) userStoreManager).getSecondaryUserStoreManager(userDomain);\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            throw new UserStoreException(e.getMessage(), e);\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final void addSecondaryUserStoreManager(String userDomain,\n-                                                   UserStoreManager userStoreManager) {\n-        if (userDomain != null) {\n-            userStoreManagerHolder.put(userDomain.toUpperCase(), userStoreManager);\n-        }\n-    }\n-\n-    public final void clearAllSecondaryUserStores() {\n-        userStoreManagerHolder.clear();\n-\n-        if (getMyDomainName() != null) {\n-            userStoreManagerHolder.put(getMyDomainName().toUpperCase(), this);\n-        }\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final String[] getAllSecondaryRoles() throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{};\n-            Object object = callSecure(\"getAllSecondaryRoles\", new Object[]{}, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        UserStoreManager secondary = this.getSecondaryUserStoreManager();\n-        List<String> roleList = new ArrayList<String>();\n-        while (secondary != null) {\n-            String[] roles = secondary.getRoleNames(true);\n-            if (roles != null && roles.length > 0) {\n-                Collections.addAll(roleList, roles);\n-            }\n-            secondary = secondary.getSecondaryUserStoreManager();\n-        }\n-        return roleList.toArray(new String[roleList.size()]);\n-    }\n-\n-    /**\n-     * @return\n-     */\n-    public boolean isSCIMEnabled() {\n-\n-        return true;\n-    }\n-\n-    /**\n-     * {@inheritDoc}                  doAddInternalRole\n-     */\n-    public final String[] getHybridRoles() throws UserStoreException {\n-        return hybridRoleManager.getHybridRoles(\"*\");\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final String[] getRoleNames() throws UserStoreException {\n-        return getRoleNames(false);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    public final String[] getRoleNames(boolean noHybridRoles) throws UserStoreException {\n-        return getRoleNames(\"*\", MAX_ITEM_LIMIT_UNLIMITED, noHybridRoles, true, true);\n-    }\n-\n-    /**\n-     * Add internal roles for the given users.\n-     *\n-     * @param roleName\n-     * @param userList\n-     * @param permissions\n-     * @throws UserStoreException\n-     */\n-    protected void doAddInternalRole(String roleName, String[] userList,\n-                                     org.wso2.carbon.user.api.Permission[] permissions)\n-            throws UserStoreException {\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        String domainModeratedRoleName = removeDomainIfNotApplicationRole(roleName);\n-        if (hybridRoleManager.isExistingRole(domainModeratedRoleName)) {\n-            handleRoleAlreadyExistException(domainModeratedRoleName, userList, permissions);\n-        }\n-        createHybridRole(domainModeratedRoleName, userList, permissions);\n-\n-        if (permissions != null) {\n-            for (org.wso2.carbon.user.api.Permission permission : permissions) {\n-                String resourceId = permission.getResourceId();\n-                String action = permission.getAction();\n-                // This is a special case. We need to pass domain aware name.\n-                userRealm.getAuthorizationManager().authorizeRole(\n-                        UserCoreUtil.addInternalDomainName(roleName), resourceId, action);\n-            }\n-        }\n-\n-        if ((userList != null) && (userList.length > 0)) {\n-            clearUserRolesCacheByTenant(this.tenantId);\n-        }\n-    }\n-\n-    /**\n-     * This method handles role already exists exception.\n-     *\n-     * @param roleName    Name of teh role.\n-     * @param userList    list of users.\n-     * @param permissions Relevant permissions added for new role.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handleRoleAlreadyExistException(String roleName, String[] userList,\n-            org.wso2.carbon.user.api.Permission[] permissions) throws UserStoreException {\n-\n-        String errorCode = ErrorMessages.ERROR_CODE_ROLE_ALREADY_EXISTS.getCode();\n-        String errorMessage = String.format(ErrorMessages.ERROR_CODE_ROLE_ALREADY_EXISTS.getMessage(), roleName);\n-        handleAddRoleFailure(errorCode, errorMessage, roleName, userList, permissions);\n-        throw new UserStoreException(errorCode + \" - \" + errorMessage, errorCode, null);\n-    }\n-\n-    /**\n-     * This method handles role already exists exception.\n-     *\n-     * @param roleName    Name of teh role.\n-     * @param userIDList    list of users.\n-     * @param permissions Relevant permissions added for new role.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    private void handleRoleAlreadyExistExceptionWithID(String roleName, String[] userIDList,\n-                                                       org.wso2.carbon.user.api.Permission[] permissions)\n-            throws UserStoreException {\n-\n-        String errorCode = ErrorMessages.ERROR_CODE_ROLE_ALREADY_EXISTS.getCode();\n-        String errorMessage = String.format(ErrorMessages.ERROR_CODE_ROLE_ALREADY_EXISTS.getMessage(), roleName);\n-        handleAddRoleFailureWithID(errorCode, errorMessage, roleName, userIDList, permissions);\n-        throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-    }\n-\n-    /**\n-     * Returns the set of shared roles which applicable for the logged in tenant\n-     *\n-     * @param tenantDomain tenant domain of the shared roles. If this is null,\n-     *                     returns all shared roles of available tenant domains\n-     * @param filter\n-     * @param maxItemLimit\n-     * @return\n-     */\n-    protected abstract String[] doGetSharedRoleNames(String tenantDomain, String filter,\n-                                                     int maxItemLimit) throws UserStoreException;\n-\n-    /**\n-     * TODO This method would returns the role Name actually this must be implemented in interface.\n-     * As it is not good to change the API in point release. This has been added to Abstract class\n-     *\n-     * @param filter\n-     * @param maxItemLimit\n-     * @param noInternalRoles\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public final String[] getRoleNames(String filter, int maxItemLimit, boolean noInternalRoles,\n-                                       boolean noSystemRole, boolean noSharedRoles)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, int.class, boolean.class, boolean.class, boolean.class};\n-            Object object = callSecure(\"getRoleNames\", new Object[]{filter, maxItemLimit, noInternalRoles,\n-                    noSystemRole, noSharedRoles}, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        String[] roleList = new String[0];\n-\n-        if (!noInternalRoles && (filter.toLowerCase().startsWith(APPLICATION_DOMAIN.toLowerCase()))) {\n-            roleList = hybridRoleManager.getHybridRoles(filter);\n-        } else if (!noInternalRoles && !isAnInternalRole(filter) && !filter\n-                .contains(UserCoreConstants.DOMAIN_SEPARATOR)) {\n-            // When domain name is not present in the filter value.\n-            if (filter == \"*\") {\n-                roleList = hybridRoleManager.getHybridRoles(filter);\n-            } else {\n-                // Since Application domain roles are stored in db with the \"Application/\" prefix, when domain is not\n-                // present in the filter, need to append the \"Application/\" before sending for db query.\n-                String[] applicationDomainRoleArray = hybridRoleManager\n-                        .getHybridRoles(APPLICATION_DOMAIN + UserCoreConstants.DOMAIN_SEPARATOR + filter);\n-                String[] internalDomainRoleArray = hybridRoleManager.getHybridRoles(filter);\n-                List<String> internalOnlyList = new ArrayList<>();\n-                // When filtering with sw, ew and co there is a possibility of returning results belonging to\n-                // Application domain.\n-                for (String filteredRole : internalDomainRoleArray) {\n-                    if (filteredRole != null && !filteredRole.matches(\"Application/(.*)\")) {\n-                        // Create Internal domain only list.\n-                        internalOnlyList.add(filteredRole);\n-                    }\n-                }\n-                roleList = UserCoreUtil.combineArrays(applicationDomainRoleArray,\n-                        internalOnlyList.toArray(new String[internalOnlyList.size()]));\n-            }\n-        } else if (!noInternalRoles) {\n-            roleList = hybridRoleManager.getHybridRoles(UserCoreUtil.removeDomainFromName(filter));\n-        }\n-\n-        if (!noSystemRole) {\n-            String[] systemRoles = systemUserRoleManager.getSystemRoles();\n-            roleList = UserCoreUtil.combineArrays(roleList, systemRoles);\n-        }\n-\n-        int index;\n-        index = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-\n-        // Check whether we have a secondary UserStoreManager setup.\n-        if (index > 0) {\n-            // Using the short-circuit. User name comes with the domain name.\n-            String domain = filter.substring(0, index);\n-\n-            UserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-            if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain)\n-                    || APPLICATION_DOMAIN.equalsIgnoreCase(domain) || WORKFLOW_DOMAIN.equalsIgnoreCase(domain)) {\n-                return roleList;\n-            }\n-            if (secManager != null) {\n-                // We have a secondary UserStoreManager registered for this domain.\n-                filter = filter.substring(index + 1);\n-                if (secManager instanceof AbstractUserStoreManager) {\n-                    if (readGroupsEnabled) {\n-                        String[] externalRoles = ((AbstractUserStoreManager) secManager)\n-                                .doGetRoleNames(filter, maxItemLimit);\n-                        return UserCoreUtil.combineArrays(roleList, externalRoles);\n-                    }\n-                } else {\n-                    String[] externalRoles = secManager.getRoleNames();\n-                    return UserCoreUtil.combineArrays(roleList, externalRoles);\n-                }\n-            } else {\n-                throw new UserStoreException(\"Invalid Domain Name\");\n-            }\n-        } else if (index == 0) {\n-            if (readGroupsEnabled) {\n-                String[] externalRoles = doGetRoleNames(filter.substring(index + 1), maxItemLimit);\n-                return UserCoreUtil.combineArrays(roleList, externalRoles);\n-            }\n-        }\n-\n-        if (readGroupsEnabled) {\n-            String[] externalRoles = doGetRoleNames(filter, maxItemLimit);\n-            roleList = UserCoreUtil.combineArrays(externalRoles, roleList);\n-        }\n-\n-        String primaryDomain = getMyDomainName();\n-\n-        if (this.getSecondaryUserStoreManager() != null) {\n-            for (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-                if (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n-                    continue;\n-                }\n-                UserStoreManager storeManager = entry.getValue();\n-                if (storeManager instanceof AbstractUserStoreManager) {\n-                    try {\n-                        if (readGroupsEnabled) {\n-                            String[] secondRoleList = ((AbstractUserStoreManager) storeManager)\n-                                    .doGetRoleNames(filter, maxItemLimit);\n-                            roleList = UserCoreUtil.combineArrays(roleList, secondRoleList);\n-                        }\n-                    } catch (UserStoreException e) {\n-                        // We can ignore and proceed. Ignore the results from this user store.\n-                        log.error(e);\n-                    }\n-                } else {\n-                    roleList = UserCoreUtil.combineArrays(roleList, storeManager.getRoleNames());\n-                }\n-            }\n-        }\n-        return roleList;\n-    }\n-\n-    /**\n-     * @param userName\n-     * @param claims\n-     * @param domainName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    private Map<String, String> doGetUserClaimValues(String userName, String[] claims,\n-            String domainName, String profileName) throws UserStoreException {\n-\n-        // Here the user name should be domain-less.\n-        boolean requireRoles = false;\n-        boolean requireIntRoles = false;\n-        boolean requireExtRoles = false;\n-        String roleClaim = null;\n-\n-        if (profileName == null || profileName.trim().length() == 0) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n-\n-        Set<String> propertySet = new HashSet<String>();\n-        for (String claim : claims) {\n-\n-            // There can be cases some claim values being requested for claims\n-            // we don't have.\n-            String property = null;\n-            try {\n-                property = getClaimAtrribute(claim, userName, domainName);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-            if (property != null\n-                    && (!UserCoreConstants.ROLE_CLAIM.equalsIgnoreCase(claim)\n-                    || !UserCoreConstants.INT_ROLE_CLAIM.equalsIgnoreCase(claim) ||\n-                    !UserCoreConstants.EXT_ROLE_CLAIM.equalsIgnoreCase(claim))) {\n-                propertySet.add(property);\n-            }\n-\n-            if (UserCoreConstants.ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-                requireRoles = true;\n-                roleClaim = claim;\n-            } else if (UserCoreConstants.INT_ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-                requireIntRoles = true;\n-                roleClaim = claim;\n-            } else if (UserCoreConstants.EXT_ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-                requireExtRoles = true;\n-                roleClaim = claim;\n-            }\n-        }\n-\n-        String[] properties = propertySet.toArray(new String[propertySet.size()]);\n-        Map<String, String> userPropertyValues = this.getUserPropertyValues(userName, properties,\n-                profileName);\n-\n-        processAttributesAfterRetrieval(userName, userPropertyValues, profileName);\n-\n-        List<String> getAgain = new ArrayList<>();\n-        Map<String, String> finalValues = new HashMap<>();\n-\n-        boolean isOverrideUsernameClaimEnabled = false;\n-        if (!isUniqueUserIdEnabled()) {\n-            isOverrideUsernameClaimEnabled = Boolean\n-                    .parseBoolean(realmConfig.getIsOverrideUsernameClaimFromInternalUsername());\n-        }\n-\n-        for (String claim : claims) {\n-            ClaimMapping mapping;\n-            try {\n-                mapping = (ClaimMapping) claimManager.getClaimMapping(claim);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-            String property = null;\n-            String value = null;\n-            if (mapping != null) {\n-                if (domainName != null) {\n-                    Map<String, String> attrMap = mapping.getMappedAttributes();\n-                    if (attrMap != null) {\n-                        String attr = null;\n-                        if ((attr = attrMap.get(domainName.toUpperCase())) != null) {\n-                            property = attr;\n-                        } else {\n-                            property = mapping.getMappedAttribute();\n-                        }\n-                    }\n-                } else {\n-                    property = mapping.getMappedAttribute();\n-                }\n-\n-                value = userPropertyValues.get(property);\n-\n-                if (isOverrideUsernameClaimEnabled && USERNAME_CLAIM_URI.equals(mapping.getClaim()\n-                        .getClaimUri())) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"The username claim value is overridden by the username :\" + userName);\n-                    }\n-                    value = userName;\n-                }\n-                if (value != null && value.trim().length() > 0) {\n-                    finalValues.put(claim, value);\n-                }\n-\n-            } else {\n-                if (property == null && claim.equals(DISAPLAY_NAME_CLAIM)) {\n-                    property = this.realmConfig.getUserStoreProperty(LDAPConstants.DISPLAY_NAME_ATTRIBUTE);\n-                }\n-\n-                value = userPropertyValues.get(property);\n-                if (value != null && value.trim().length() > 0) {\n-                    finalValues.put(claim, value);\n-                }\n-            }\n-        }\n-\n-        if (getAgain.size() > 0) {\n-            // oh the beautiful recursion\n-            Map<String, String> mapClaimValues = this.getUserClaimValues(userName,\n-                    (String[]) getAgain.toArray(new String[getAgain.size()]),\n-                    profileName);\n-\n-            Iterator<Map.Entry<String, String>> ite3 = mapClaimValues.entrySet().iterator();\n-            while (ite3.hasNext()) {\n-                Map.Entry<String, String> entry = ite3.next();\n-                if (entry.getValue() != null) {\n-                    finalValues.put(entry.getKey(), entry.getValue());\n-                }\n-            }\n-        }\n-\n-        // We treat roles claim in special way.\n-        String[] roles = null;\n-\n-        if (requireRoles) {\n-            roles = getRoleListOfUser(userName);\n-        } else if (requireIntRoles) {\n-            roles = doGetInternalRoleListOfUser(userName, \"*\");\n-        } else if (requireExtRoles) {\n-\n-            List<String> rolesList = new ArrayList<String>();\n-            String[] externalRoles = doGetExternalRoleListOfUser(userName, \"*\");\n-            rolesList.addAll(Arrays.asList(externalRoles));\n-            //if only shared enable\n-            if (isSharedGroupEnabled()) {\n-                String[] sharedRoles = doGetSharedRoleListOfUser(userName, null, \"*\");\n-                if (sharedRoles != null) {\n-                    rolesList.addAll(Arrays.asList(sharedRoles));\n-                }\n-            }\n-\n-            roles = rolesList.toArray(new String[rolesList.size()]);\n-        }\n-\n-        if (roles != null && roles.length > 0) {\n-            String userAttributeSeparator = \",\";\n-            String claimSeparator = realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR);\n-            if (claimSeparator != null && !claimSeparator.trim().isEmpty()) {\n-                userAttributeSeparator = claimSeparator;\n-            }\n-            String delim = \"\";\n-            StringBuffer roleBf = new StringBuffer();\n-            for (String role : roles) {\n-                roleBf.append(delim).append(role);\n-                delim = userAttributeSeparator;\n-            }\n-            finalValues.put(roleClaim, roleBf.toString());\n-        }\n-\n-        return finalValues;\n-    }\n-\n-    /**\n-     * Handles the processing of any special user store attribute values after retrieval.\n-     *\n-     * @param userName       Username of the user.\n-     * @param userAttributes Un-processed map (user store attribute name -> attribute value) of user store.\n-     * @param profileName    Profile name of the user.\n-     */\n-    protected void processAttributesAfterRetrieval(String userName, Map<String, String> userAttributes,\n-                                                   String profileName) {\n-        // Not implemented for AbstractUserStoreManager, may have implementations at subclasses.\n-    }\n-\n-    /**\n-     * Handles the processing of any special user store attribute values before update.\n-     *\n-     * @param userName       Username of the user.\n-     * @param userAttributes Un-processed map (user store attribute name -> attribute value) of user store.\n-     * @param profileName    Profile name of the user.\n-     */\n-    protected void processAttributesBeforeUpdate(String userName, Map<String, ? extends Object> userAttributes,\n-                                                 String profileName) {\n-        // Not implemented for AbstractUserStoreManager, may have implementations at subclasses.\n-    }\n-\n-    /**\n-     * Handles the processing of any special user store attribute values after retrieval.\n-     *\n-     * @param userID         User ID of the user.\n-     * @param userAttributes Un-processed map (user store attribute name -> attribute value) of user store.\n-     * @param profileName    Profile name of the user.\n-     */\n-    protected void processAttributesAfterRetrievalWithID(String userID, Map<String, String> userAttributes,\n-                                                         String profileName) {\n-        // Not implemented for AbstractUserStoreManager, may have implementations at subclasses.\n-    }\n-\n-    /**\n-     * Handles the processing of any special user store attribute values before update.\n-     *\n-     * @param userID         User ID of the user.\n-     * @param userAttributes Un-processed map (user store attribute name -> attribute value) of user store.\n-     * @param profileName    Profile name of the user.\n-     */\n-    protected void processAttributesBeforeUpdateWithID(String userID, Map<String, ? extends Object> userAttributes,\n-                                                       String profileName) {\n-        // Not implemented for AbstractUserStoreManager, may have implementations at subclasses.\n-    }\n-\n-    /**\n-     * @return\n-     */\n-    protected String getEveryOneRoleName() {\n-        return realmConfig.getEveryOneRoleName();\n-    }\n-\n-    /**\n-     * @return\n-     */\n-    protected String getAdminRoleName() {\n-        return realmConfig.getAdminRoleName();\n-    }\n-\n-    /**\n-     * @param credential\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    protected boolean checkUserPasswordValid(Object credential) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{Object.class};\n-            Object object = callSecure(\"checkUserPasswordValid\", new Object[]{credential}, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        if (credential == null) {\n-            return false;\n-        }\n-\n-        Secret credentialObj;\n-        try {\n-            credentialObj = Secret.getSecret(credential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            throw new UserStoreException(\"Unsupported credential type\", e);\n-        }\n-\n-        try {\n-            if (credentialObj.getChars().length < 1) {\n-                return false;\n-            }\n-\n-            String regularExpression =\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX);\n-            if (regularExpression != null) {\n-                if (isFormatCorrect(regularExpression, credentialObj.getChars())) {\n-                    return true;\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Submitted password does not match with the regex \" + regularExpression);\n-                    }\n-                    return false;\n-                }\n-            }\n-            return true;\n-        } finally {\n-            credentialObj.clear();\n-        }\n-\n-    }\n-\n-    /**\n-     * Validate credential object.\n-     *\n-     * @param credential credentials object to be validated\n-     * @return is valid credentials object\n-     * @throws UserStoreException\n-     */\n-    protected boolean isValidCredentials(Object credential) throws UserStoreException {\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { Object.class };\n-            Object object = callSecure(\"isValidCredentials\", new Object[] { credential }, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        if (credential == null) {\n-            return false;\n-        }\n-\n-        Secret credentialObj;\n-        try {\n-            credentialObj = Secret.getSecret(credential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            throw new UserStoreException(\"Unsupported credential type\", e);\n-        }\n-\n-        return credentialObj.getChars().length >= 1;\n-    }\n-\n-    /**\n-     * @param userName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    protected boolean checkUserNameValid(String userName) throws UserStoreException {\n-\n-        if (isValidUserName(userName)) {\n-            String regularExpression = realmConfig\n-                    .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG_EX);\n-            //Inorder to support both UsernameJavaRegEx and UserNameJavaRegEx.\n-            if (StringUtils.isEmpty(regularExpression) || StringUtils.isEmpty(regularExpression.trim())) {\n-                regularExpression = realmConfig\n-                        .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG);\n-            }\n-\n-            if (MultitenantUtils.isEmailUserName()) {\n-                regularExpression = realmConfig\n-                        .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_WITH_EMAIL_JS_REG_EX);\n-\n-                if (StringUtils.isEmpty(regularExpression) || StringUtils.isEmpty(regularExpression.trim())) {\n-                    regularExpression = realmConfig\n-                            .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG_EX);\n-                }\n-\n-                //Inorder to support both UsernameJavaRegEx and UserNameJavaRegEx.\n-                if (StringUtils.isEmpty(regularExpression) || StringUtils.isEmpty(regularExpression.trim())) {\n-                    regularExpression = realmConfig\n-                            .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG);\n-                }\n-\n-                if (StringUtils.isEmpty(regularExpression) || StringUtils.isEmpty(regularExpression.trim())) {\n-                    regularExpression = UserCoreConstants.RealmConfig.EMAIL_VALIDATION_REGEX;\n-                }\n-            }\n-\n-            if (regularExpression != null) {\n-                regularExpression = regularExpression.trim();\n-            }\n-\n-            if (StringUtils.isNotEmpty(regularExpression)) {\n-                if (isFormatCorrect(regularExpression, userName)) {\n-                    return true;\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Username \" + userName + \" does not match with the regex \" + regularExpression);\n-                    }\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Validate username. It should be non-null, non-blank value which should not equal to REGISTRY_SYSTEM_USERNAME.\n-     *\n-     * @param userName username to be validated\n-     * @return is username valid\n-     * @throws UserStoreException when checking the call is secure or not\n-     */\n-    protected boolean isValidUserName(String userName) throws UserStoreException {\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class };\n-            Object object = callSecure(\"isValidUserName\", new Object[] { userName }, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        if (userName == null || CarbonConstants.REGISTRY_SYSTEM_USERNAME.equals(userName)) {\n-            return false;\n-        }\n-\n-        String leadingOrTrailingSpaceAllowedInUserName = realmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.LEADING_OR_TRAILING_SPACE_ALLOWED_IN_USERNAME);\n-        if (StringUtils.isEmpty(leadingOrTrailingSpaceAllowedInUserName)) {\n-            // Keeping old behavior for backward-compatibility.\n-            userName = userName.trim();\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"'LeadingOrTrailingSpaceAllowedInUserName' property is set to : \"\n-                        + leadingOrTrailingSpaceAllowedInUserName + \". Hence username trimming will be skipped during \"\n-                        + \"validation for the username: \" + userName);\n-            }\n-        }\n-\n-        return !userName.isEmpty();\n-    }\n-\n-    /**\n-     * @param roleName\n-     * @return\n-     */\n-    protected boolean isRoleNameValid(String roleName) {\n-        if (roleName == null) {\n-            return false;\n-        }\n-\n-        if (roleName.length() < 1) {\n-            return false;\n-        }\n-\n-        String regularExpression = realmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n-        if (regularExpression != null) {\n-            if (!isFormatCorrect(regularExpression, roleName)) {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    protected String[] getRoleListOfUserFromCache(int tenantID, String userName) {\n-\n-        if (userRolesCache != null) {\n-            String usernameWithDomain = UserCoreUtil.addDomainToName(userName, getMyDomainName());\n-            return userRolesCache.getRolesListOfUser(cacheIdentifier, tenantID, usernameWithDomain);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * @param tenantID\n-     */\n-    protected void clearUserRolesCacheByTenant(int tenantID) {\n-        if (userRolesCache != null) {\n-            userRolesCache.clearCacheByTenant(tenantID);\n-        }\n-        AuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n-        authorizationCache.clearCacheByTenant(tenantID);\n-    }\n-\n-    /**\n-     * @param tenantID\n-     * @param userName\n-     * @param roleList\n-     */\n-    protected void addToUserRolesCache(int tenantID, String userName, String[] roleList) {\n-\n-        if (userRolesCache != null) {\n-            String usernameWithDomain = UserCoreUtil.addDomainToName(userName, getMyDomainName());\n-            String[] rolesWithDomain = UserCoreUtil.addDomainToNames(roleList, getMyDomainName());\n-            userRolesCache.addToCache(cacheIdentifier, tenantID, usernameWithDomain, rolesWithDomain);\n-            AuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n-            authorizationCache.clearCacheByTenant(tenantID);\n-        }\n-    }\n-\n-    protected void clearUserRolesCache(String userIdentifier) {\n-\n-        String usernameWithDomain = UserCoreUtil.addDomainToName(userIdentifier, getMyDomainName());\n-        if (userRolesCache != null) {\n-            userRolesCache.clearCacheEntry(cacheIdentifier, tenantId, usernameWithDomain);\n-        }\n-        AuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n-        authorizationCache.clearCacheByUser(tenantId, usernameWithDomain);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    protected void initUserRolesCache() {\n-\n-        String userRolesCacheEnabledString = (realmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLES_CACHE_ENABLED));\n-\n-        String userCoreCacheIdentifier = realmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_CORE_CACHE_IDENTIFIER);\n-\n-        if (userCoreCacheIdentifier != null && userCoreCacheIdentifier.trim().length() > 0) {\n-            cacheIdentifier = userCoreCacheIdentifier;\n-        } else {\n-            cacheIdentifier = UserCoreConstants.DEFAULT_CACHE_IDENTIFIER;\n-        }\n-\n-        if (userRolesCacheEnabledString != null && !userRolesCacheEnabledString.equals(\"\")) {\n-            userRolesCacheEnabled = Boolean.parseBoolean(userRolesCacheEnabledString);\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"User Roles Cache is configured to:\" + userRolesCacheEnabledString);\n-            }\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.info(\"User Roles Cache is not configured. Default value: \"\n-                        + userRolesCacheEnabled + \" is taken.\");\n-            }\n-        }\n-\n-        if (userRolesCacheEnabled) {\n-            int timeOut = UserCoreConstants.USER_ROLE_CACHE_DEFAULT_TIME_OUT;\n-            String timeOutString = realmConfig.\n-                    getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_ROLE_CACHE_TIME_OUT);\n-            if (timeOutString != null) {\n-                timeOut = Integer.parseInt(timeOutString);\n-            }\n-            userRolesCache = UserRolesCache.getInstance();\n-            userRolesCache.setTimeOut(timeOut);\n-        }\n-\n-    }\n-\n-    /**\n-     * @param regularExpression\n-     * @param attribute\n-     * @return\n-     */\n-    private boolean isFormatCorrect(String regularExpression, String attribute) {\n-        Pattern p2 = Pattern.compile(regularExpression);\n-        Matcher m2 = p2.matcher(attribute);\n-        return m2.matches();\n-    }\n-\n-    private boolean isFormatCorrect(String regularExpression, char[] attribute) {\n-\n-        boolean matches;\n-        CharBuffer charBuffer = CharBuffer.wrap(attribute);\n-\n-        Pattern p2 = Pattern.compile(regularExpression);\n-        Matcher m2 = p2.matcher(charBuffer);\n-        matches = m2.matches();\n-\n-        return matches;\n-    }\n-\n-    /**\n-     * This is to replace escape characters in user name at user login if replace escape characters\n-     * enabled in user-mgt.xml. Some User Stores like ApacheDS stores user names by replacing escape\n-     * characters. In that case, we have to parse the username accordingly.\n-     *\n-     * @param userName\n-     */\n-    protected String replaceEscapeCharacters(String userName) {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Replacing escape characters in \" + userName);\n-        }\n-        String replaceEscapeCharactersAtUserLoginString = realmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_REPLACE_ESCAPE_CHARACTERS_AT_USER_LOGIN);\n-\n-        if (replaceEscapeCharactersAtUserLoginString != null) {\n-            replaceEscapeCharactersAtUserLogin = Boolean\n-                    .parseBoolean(replaceEscapeCharactersAtUserLoginString);\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Replace escape characters at userlogin is configured to: \"\n-                        + replaceEscapeCharactersAtUserLoginString);\n-            }\n-            if (replaceEscapeCharactersAtUserLogin) {\n-                // Currently only '\\' & '\\\\' are identified as escape characters\n-                // that needs to be\n-                // replaced.\n-                return userName.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\");\n-            }\n-        }\n-        return userName;\n-    }\n-\n-    /**\n-     * TODO: Remove this method. We should not use DTOs\n-     *\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public RoleDTO[] getAllSecondaryRoleDTOs() throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{};\n-            Object object = callSecure(\"getAllSecondaryRoleDTOs\", new Object[]{}, argTypes);\n-            return (RoleDTO[]) object;\n-        }\n-\n-        UserStoreManager secondary = this.getSecondaryUserStoreManager();\n-        List<RoleDTO> roleList = new ArrayList<RoleDTO>();\n-        while (secondary != null) {\n-            String domain = secondary.getRealmConfiguration().getUserStoreProperty(\n-                    UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-            String[] roles = secondary.getRoleNames(true);\n-            if (roles != null && roles.length > 0) {\n-                Collections.addAll(roleList, UserCoreUtil.convertRoleNamesToRoleDTO(roles, domain));\n-            }\n-            secondary = secondary.getSecondaryUserStoreManager();\n-        }\n-        return roleList.toArray(new RoleDTO[roleList.size()]);\n-    }\n-\n-    /**\n-     * @param roleName\n-     * @param userList\n-     * @param permissions\n-     * @throws UserStoreException\n-     */\n-    public void addSystemRole(String roleName, String[] userList, Permission[] permissions)\n-            throws UserStoreException {\n-\n-        if (!isRoleNameValid(roleName)) {\n-            String regEx = realmConfig\n-                    .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_ROLE_NAME.getCode();\n-            String errorMessage = String\n-                    .format(ErrorMessages.ERROR_CODE_INVALID_ROLE_NAME.getMessage(), roleName, regEx);\n-            handleAddRoleFailure(errorCode, errorMessage, roleName, userList, permissions);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-        createSystemRole(roleName, userList, permissions);\n-    }\n-\n-\n-    /**\n-     * @param roleName\n-     * @param filter\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    protected abstract String[] doGetUserListOfRole(String roleName, String filter)\n-            throws UserStoreException;\n-\n-    /**\n-     * Return the list of users belong to the given role for the given filter and max item limit.\n-     *\n-     * @param roleName Name of the role.\n-     * @param filter String filter value.\n-     * @param maxItemLimit Maximum number of users in the returned array. A negative value return all users and zero\n-     *                     returns zero users.\n-     * @return An array of users.\n-     * @throws UserStoreException\n-     */\n-    protected String[] doGetUserListOfRole(String roleName, String filter, int maxItemLimit)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Using the default implementation of retrieving users in the role: \" + roleName + \" only with \" +\n-                    \"the filter: \" + filter + \". The provided value: \" + maxItemLimit + \" for the maximum limit \" +\n-                    \"of returning users is ignored\");\n-        }\n-        return doGetUserListOfRole(roleName, filter);\n-    }\n-\n-    /**\n-     * Return the list of users belong to the given role for the given filter.\n-     *\n-     * @param roleName role name.\n-     * @param filter   filter.\n-     * @return user list of the given role.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected List<User> doGetUserListOfRoleWithID(String roleName, String filter) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetUserListOfRoleWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"doGetUserListOfRoleWithID operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    /**\n-     * Return the list of users belong to the given role for the given filter.\n-     *\n-     * @param roleName     role name.\n-     * @param filter       filter.\n-     * @param maxItemLimit Maximum number of users in the returned array. A negative value return all users and zero\n-     *                     returns zero users.\n-     * @return user list of the given role.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected List<User> doGetUserListOfRoleWithID(String roleName, String filter, int maxItemLimit)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Using the default implementation of retrieving users in the role: \" + roleName + \" only with \"\n-                    + \"the filter: \" + filter + \". The provided value: \" + maxItemLimit + \" for the maximum limit \"\n-                    + \"of returning users is ignored\");\n-        }\n-        return doGetUserListOfRoleWithID(roleName, filter);\n-    }\n-\n-    /**\n-     * This will return the roles list of given user ID.\n-     *\n-     * @param userID user ID.\n-     * @param filter filter.\n-     * @return user list of the given role.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    public List<String> doGetRoleListOfUserWithID(String userID, String filter) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class };\n-            Object object = callSecure(\"doGetRoleListOfUserWithID\", new Object[] { userID, filter }, argTypes);\n-            return (List<String>) object;\n-        }\n-\n-        String username = getUserNameFromUserID(userID);\n-        if (username != null) {\n-            String[] roleListOfUserFromCache = getRoleListOfUserFromCache(this.tenantId, username);\n-            if (roleListOfUserFromCache != null) {\n-                List<String> roleList = Arrays.asList(roleListOfUserFromCache);\n-                if (!roleList.isEmpty()) {\n-                    return roleList;\n-                }\n-            }\n-        }\n-\n-        return getUserRolesWithID(userID, filter);\n-    }\n-\n-    private List<String> getUserRolesWithID(String userID, String filter) throws UserStoreException {\n-\n-        List<String> internalRoles = doGetInternalRoleListOfUserWithID(userID, filter);\n-        Set<String> modifiedInternalRoles = new HashSet<>();\n-        String[] modifiedExternalRoleList = new String[0];\n-\n-        if (readGroupsEnabled && doCheckExistingUserWithID(userID)) {\n-            List<String> roles = new ArrayList<>();\n-            String[] externalRoles = doGetExternalRoleListOfUserWithID(userID, \"*\");\n-            roles.addAll(Arrays.asList(externalRoles));\n-            if (isSharedGroupEnabled()) {\n-                String[] sharedRoles = doGetSharedRoleListOfUserWithID(userID, null, \"*\");\n-                if (sharedRoles != null) {\n-                    roles.addAll(Arrays.asList(sharedRoles));\n-                }\n-            }\n-            modifiedExternalRoleList = UserCoreUtil.addDomainToNames(roles.toArray(new String[0]), getMyDomainName());\n-\n-            // Get the associated internal roles of the groups.\n-            if (isRoleAndGroupSeparationEnabled()) {\n-                Set<String> rolesOfGroups = getUniqueSet(getHybridRoleListOfGroups(roles, getMyDomainName()));\n-                modifiedInternalRoles.addAll(rolesOfGroups);\n-            }\n-        }\n-        modifiedInternalRoles.addAll(internalRoles);\n-        String[] roleList = UserCoreUtil.combine(modifiedExternalRoleList, new ArrayList<>(modifiedInternalRoles));\n-\n-        for (UserOperationEventListener userOperationEventListener : UMListenerServiceComponent\n-                .getUserOperationEventListeners()) {\n-            if (userOperationEventListener instanceof AbstractUserOperationEventListener) {\n-                if (!((AbstractUserOperationEventListener) userOperationEventListener)\n-                        .doPostGetRoleListOfUserWithID(userID, filter, roleList, this)) {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // Add to user role cache uisng username.\n-        String username = getUserNameFromUserID(userID);\n-        if (username != null) {\n-            addToUserRolesCache(this.tenantId, username, roleList);\n-        }\n-        return Arrays.asList(roleList);\n-    }\n-\n-    /**\n-     * This will return the roles list of given user name.\n-     *\n-     * @param userName user name.\n-     * @param filter   filter.\n-     * @return user list of the given role.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    public final String[] doGetRoleListOfUser(String userName, String filter) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class };\n-            Object object = callSecure(\"doGetRoleListOfUser\", new Object[] { userName, filter }, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        String[] roleList = getRoleListOfUserFromCache(this.tenantId, userName);\n-        if (roleList != null && roleList.length > 0) {\n-            return roleList;\n-        }\n-\n-        return getUserRoles(userName, filter);\n-    }\n-\n-    private String[] getUserRoles(String username, String filter) throws UserStoreException {\n-\n-        String[] internalRoles = doGetInternalRoleListOfUser(username, filter);\n-        String[] modifiedExternalRoleList = new String[0];\n-\n-        if (readGroupsEnabled && doCheckExistingUser(username)) {\n-            String[] externalRoles = doGetExternalRoleListOfUser(username, \"*\");\n-            List<String> roles = Arrays.asList(externalRoles);\n-            if (isSharedGroupEnabled()) {\n-                String[] sharedRoles = doGetSharedRoleListOfUser(username, null, \"*\");\n-                if (sharedRoles != null) {\n-                    roles.addAll(Arrays.asList(sharedRoles));\n-                }\n-            }\n-            modifiedExternalRoleList = UserCoreUtil\n-                    .addDomainToNames(roles.toArray(new String[0]), getMyDomainName());\n-\n-            // Get the associated internal roles of the groups.\n-            if (isRoleAndGroupSeparationEnabled()) {\n-                Set<String> rolesOfGroups = getUniqueSet(getHybridRoleListOfGroups(roles, getMyDomainName()));\n-                internalRoles = UserCoreUtil.combine(internalRoles, new ArrayList<>(rolesOfGroups));\n-            }\n-        }\n-\n-        String[] roleList = UserCoreUtil.combine(internalRoles, Arrays.asList(modifiedExternalRoleList));\n-\n-        for (UserOperationEventListener userOperationEventListener : UMListenerServiceComponent\n-                .getUserOperationEventListeners()) {\n-            if (userOperationEventListener instanceof AbstractUserOperationEventListener) {\n-                if (!((AbstractUserOperationEventListener) userOperationEventListener)\n-                        .doPostGetRoleListOfUser(username, filter, roleList, this)) {\n-                    break;\n-                }\n-            }\n-        }\n-        addToUserRolesCache(this.tenantId, username, roleList);\n-        return roleList;\n-    }\n-\n-    /**\n-     * Retrieve the list of users directly from the database,\n-     * without using the cache.\n-     * @param username username of the user\n-     * @param filter filter to be used when searching for roles\n-     * @return the list of roles which the specified users belongs to\n-     * @throws UserStoreException\n-     */\n-    public final String[] getRoleListOfUserFromDatabase(String username, String filter)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String.class};\n-            Object object = callSecure(\"getRoleListOfUserFromDatabase\", new Object[]{username, filter}, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        if (isUniqueUserIdEnabledInUserStore(getUserStore(username))) {\n-            String userID = getUserIDFromUserName(username);\n-            if (userID == null) {\n-                // According to implementation, getRoleListOfUser method would return everyone role name for all users.\n-                return new String[]{realmConfig.getEveryOneRoleName()};\n-            }\n-            return getUserRolesWithID(userID, filter).toArray(new String[0]);\n-        } else {\n-            return getUserRoles(username, filter);\n-        }\n-    }\n-\n-\n-    /**\n-     * @param filter\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public final String[] getHybridRoles(String filter) throws UserStoreException {\n-        return hybridRoleManager.getHybridRoles(filter);\n-    }\n-\n-    /**\n-     * @param claimList\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    protected List<String> getMappingAttributeList(List<String> claimList)\n-            throws UserStoreException {\n-        ArrayList<String> attributeList = null;\n-        Iterator<String> claimIter = null;\n-\n-        attributeList = new ArrayList<String>();\n-        if (claimList == null) {\n-            return attributeList;\n-        }\n-        claimIter = claimList.iterator();\n-        while (claimIter.hasNext()) {\n-            try {\n-                attributeList.add(claimManager.getAttributeName(getMyDomainName(), claimIter.next()));\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-        }\n-        return attributeList;\n-    }\n-\n-    protected void doInitialSetup() throws UserStoreException {\n-        systemUserRoleManager = new SystemUserRoleManager(dataSource, tenantId);\n-        hybridRoleManager = new HybridRoleManager(dataSource, tenantId, realmConfig, userRealm);\n-        userUniqueIDDomainResolver = new UserUniqueIDDomainResolver(dataSource);\n-    }\n-\n-    /**\n-     * @return whether this is the initial startup\n-     * @throws UserStoreException\n-     */\n-    protected void doInitialUserAdding() throws UserStoreException {\n-\n-        String systemUser = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME);\n-        String systemRole = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME);\n-\n-        if (!systemUserRoleManager.isExistingSystemUser(systemUser)) {\n-            try {\n-                systemUserRoleManager.addSystemUser(systemUser,\n-                        UserCoreUtil.getPolicyFriendlyRandomPassword(systemUser), null);\n-            } catch (UserStoreException e) {\n-                if (ERROR_CODE_DUPLICATE_WHILE_ADDING_A_SYSTEM_USER.getCode().equals(e.getErrorCode())) {\n-                    log.warn(String.format(\"System User :%s has already added. Hence, continue without adding the \" +\n-                                    \"user.\", systemUser));\n-                } else {\n-                    throw e;\n-                }\n-            }\n-\n-        }\n-\n-        if (!systemUserRoleManager.isExistingRole(systemRole)) {\n-            try {\n-                systemUserRoleManager.addSystemRole(systemRole, new String[]{systemUser});\n-            } catch (UserStoreException e) {\n-                if (ERROR_CODE_DUPLICATE_WHILE_ADDING_A_SYSTEM_ROLE.getCode().equals(e.getErrorCode())) {\n-                    log.warn(String.format(\"System Role :%s is already added. Hence, continue without adding the \" +\n-                                    \"role.\", systemRole), e);\n-                } else {\n-                    throw e;\n-                }\n-            }\n-        }\n-\n-        if (!hybridRoleManager.isExistingRole(UserCoreUtil.removeDomainFromName(realmConfig\n-                .getEveryOneRoleName()))) {\n-            try {\n-                hybridRoleManager.addHybridRole(\n-                        UserCoreUtil.removeDomainFromName(realmConfig.getEveryOneRoleName()), null);\n-            } catch (UserStoreException e) {\n-                if (ERROR_CODE_DUPLICATE_WHILE_ADDING_A_HYBRID_ROLE.getCode().equals(e.getErrorCode())) {\n-                    log.warn(String.format(\"Hybrid Role :%s is already added. Hence, continue without adding the \" +\n-                            \"role.\", systemRole));\n-                } else {\n-                    throw e;\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    protected boolean isInitSetupDone() throws UserStoreException {\n-\n-        boolean isInitialSetUp = false;\n-        String systemUser = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME);\n-        String systemRole = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME);\n-\n-        if (systemUserRoleManager.isExistingSystemUser(systemUser)) {\n-            isInitialSetUp = true;\n-        }\n-\n-        if (systemUserRoleManager.isExistingRole(systemRole)) {\n-            isInitialSetUp = true;\n-        }\n-\n-        return isInitialSetUp;\n-    }\n-\n-    /**\n-     * @throws UserStoreException\n-     */\n-    protected void addInitialAdminData(boolean addAdmin, boolean initialSetup) throws UserStoreException {\n-\n-        if (realmConfig.getAdminRoleName() == null || realmConfig.getAdminUserName() == null) {\n-            log.error(\"Admin user name or role name is not valid. Please provide valid values.\");\n-            throw new UserStoreException(\n-                    \"Admin user name or role name is not valid. Please provide valid values.\");\n-        }\n-        String adminUserName = UserCoreUtil.removeDomainFromName(realmConfig.getAdminUserName());\n-        String adminRoleName = UserCoreUtil.removeDomainFromName(realmConfig.getAdminRoleName());\n-        boolean userExist = false;\n-        boolean roleExist = false;\n-        boolean isInternalRole = false;\n-        String adminUserID = null;\n-        User user = null;\n-\n-        try {\n-            if (!isRoleAndGroupSeparationEnabled() && Boolean.parseBoolean(this.getRealmConfiguration()\n-                    .getUserStoreProperty(UserCoreConstants.RealmConfig.READ_GROUPS_ENABLED))) {\n-                roleExist = doCheckExistingRole(adminRoleName);\n-            }\n-        } catch (Exception e) {\n-            //ignore\n-        }\n-\n-        if (!roleExist) {\n-            try {\n-                roleExist = hybridRoleManager.isExistingRole(adminRoleName);\n-            } catch (Exception e) {\n-                //ignore\n-            }\n-            if (roleExist) {\n-                isInternalRole = true;\n-            }\n-        }\n-\n-        try {\n-            if (isUniqueUserIdEnabled()) {\n-                userExist = doCheckExistingUserNameWithIDImpl(adminUserName);\n-                if (userExist) {\n-                    String userIDFromUserName = getUserIDFromUserName(adminUserName);\n-                    String userIDAttribute = realmConfig.getUserStoreProperty(LDAPConstants.USER_ID_ATTRIBUTE);\n-                    String userID = getUniqueUserID();\n-                    if (StringUtils.isEmpty(userIDFromUserName) && !this.isReadOnly()) {\n-                        doSetUserAttribute(adminUserName, userIDAttribute, userID, null);\n-                    }\n-                }\n-            } else {\n-                userExist = doCheckExistingUser(adminUserName);\n-            }\n-        } catch (Exception e) {\n-            //ignore\n-        }\n-\n-        if (!userExist) {\n-            if (isReadOnly()) {\n-                String message = \"Admin user can not be created in primary user store. \" +\n-                        \"User store is read only. \" +\n-                        \"Please pick a user name which is exist in the primary user store as Admin user\";\n-                if (initialSetup) {\n-                    throw new UserStoreException(message);\n-                } else if (log.isDebugEnabled()) {\n-                    log.error(message);\n-                }\n-            } else if (addAdmin) {\n-                try {\n-                    if (isUniqueUserIdEnabled()) {\n-                        // Ignore the return value as we don't need it.\n-                        user = doAddUserWithID(adminUserName, realmConfig.getAdminPassword(), null, null, null, false);\n-                    } else {\n-                        // Call the old API since this user store does not support the unique user id related APIs.\n-                        this.doAddUser(adminUserName, realmConfig.getAdminPassword(), null, null, null, false);\n-                    }\n-                } catch (Exception e) {\n-                    String message = \"Admin user has not been created. \" +\n-                            \"Error occurs while creating Admin user in primary user store.\";\n-                    if (initialSetup) {\n-                        if (e instanceof UserStoreException && ERROR_CODE_DUPLICATE_WHILE_ADDING_A_USER.getCode\n-                                ().equals(((UserStoreException) e).getErrorCode())) {\n-                            log.warn(String.format(\"Admin User :%s is already added. Hence, continue without adding\" +\n-                                    \" the user.\", adminUserName));\n-                        } else {\n-                            throw new UserStoreException(message, e);\n-                        }\n-                    } else if (log.isDebugEnabled()) {\n-                        log.error(message, e);\n-                    }\n-                }\n-            } else {\n-                if (initialSetup) {\n-                    String message = \"Admin user can not be created in primary user store. \" +\n-                            \"Add-Admin has been set to false. \" +\n-                            \"Please pick a User name which is exist in the primary user store as Admin user\";\n-                    if (initialSetup) {\n-                        throw new UserStoreException(message);\n-                    } else if (log.isDebugEnabled()) {\n-                        log.error(message);\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (isUniqueUserIdEnabled()) {\n-            if (user != null && user.getUserID() != null) {\n-                adminUserID = user.getUserID();\n-            } else {\n-                adminUserID = getUserIDFromUserName(adminUserName);\n-            }\n-        }\n-\n-        if (!roleExist) {\n-            if (addAdmin) {\n-                if (!isRoleAndGroupSeparationEnabled() && !isReadOnly() && writeGroupsEnabled) {\n-                    try {\n-                        if (isUniqueUserIdEnabled()) {\n-                            this.doAddRoleWithID(adminRoleName, new String[] { adminUserID }, false);\n-                        } else {\n-                            this.doAddRole(adminRoleName, new String[] { adminUserName }, false);\n-                        }\n-                    } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                        String message = \"Admin role has not been created. \" +\n-                                \"Error occurs while creating Admin role in primary user store.\";\n-                        if (initialSetup) {\n-                            if (ERROR_CODE_DUPLICATE_WHILE_ADDING_ROLE.getCode().equals(((UserStoreException) e)\n-                                    .getErrorCode())) {\n-                                log.warn(String.format(\"Admin Role :%s is already added. Hence, continue without \" +\n-                                        \"adding the role.\", adminRoleName));\n-                            } else {\n-                                throw new UserStoreException(message, e);\n-                            }\n-                        } else if (log.isDebugEnabled()) {\n-                            log.error(message, e);\n-                        }\n-                    }\n-                } else {\n-                    // Creates internal role.\n-                    try {\n-                        if (isUniqueUserIdEnabled()) {\n-                            hybridRoleManager.addHybridRole(adminRoleName, new String[] { adminUserName });\n-                        } else {\n-                            hybridRoleManager.addHybridRole(adminRoleName, new String[] { adminUserName });\n-                        }\n-                        isInternalRole = true;\n-\n-                        if (isRoleAndGroupSeparationEnabled()) {\n-                            // Create a new admin group with the same role name if not exist.\n-                            boolean groupExist = false;\n-                            if (Boolean.parseBoolean(this.getRealmConfiguration()\n-                                    .getUserStoreProperty(UserCoreConstants.RealmConfig.READ_GROUPS_ENABLED))) {\n-                                groupExist = doCheckExistingRole(adminRoleName);\n-                            }\n-                            if (!groupExist && !isReadOnly() && writeGroupsEnabled) {\n-                                if (isUniqueUserIdEnabled()) {\n-                                    this.doAddRoleWithID(adminRoleName, new String[] { adminUserID }, false);\n-                                } else {\n-                                    this.doAddRole(adminRoleName, new String[] { adminUserName }, false);\n-                                }\n-                                groupExist = true;\n-                            }\n-                            // Assign the admin group to the admin role.\n-                            if (groupExist) {\n-                                this.updateGroupListOfHybridRole(adminRoleName, null, new String[] { adminRoleName });\n-                            }\n-                        }\n-                    } catch (Exception e) {\n-                        String message = \"Admin role has not been created. \" +\n-                                \"Error occurs while creating Admin role in primary user store.\";\n-                        if (initialSetup) {\n-                            if (ERROR_CODE_DUPLICATE_WHILE_ADDING_A_HYBRID_ROLE.getCode().equals(((UserStoreException) e)\n-                                    .getErrorCode())) {\n-                                log.warn(String.format(\"Hybrid Admin Role :%s is already added. Hence, continue \" +\n-                                        \"without adding the hybrid role.\", adminRoleName));\n-                            } else {\n-                                throw new UserStoreException(message, e);\n-                            }\n-                        } else if (log.isDebugEnabled()) {\n-                            log.error(message, e);\n-                        }\n-                    }\n-                }\n-            } else {\n-                String message = \"Admin role can not be created in primary user store. \" +\n-                        \"Add-Admin has been set to false. \" +\n-                        \"Please pick a Role name which is exist in the primary user store as Admin Role\";\n-                if (initialSetup) {\n-                    throw new UserStoreException(message);\n-                } else if (log.isDebugEnabled()) {\n-                    log.error(message);\n-                }\n-            }\n-        }\n-\n-        if (isInternalRole) {\n-\n-            if (isUniqueUserIdEnabled()) {\n-                updateHybridRoleListOfUserInternal(initialSetup, adminRoleName, adminUserName);\n-            } else {\n-                updateHybridRoleListOfUserInternal(initialSetup, adminRoleName, adminUserName);\n-            }\n-            realmConfig.setAdminRoleName(UserCoreUtil.addInternalDomainName(adminRoleName));\n-        } else if (!isReadOnly() && writeGroupsEnabled) {\n-\n-            boolean doCheckIsUserInRole;\n-            if (isUniqueUserIdEnabled()) {\n-                doCheckIsUserInRole = this.doCheckIsUserInRoleWithID(adminUserID, adminRoleName);\n-            } else {\n-                doCheckIsUserInRole = this.doCheckIsUserInRole(adminUserName, adminRoleName);\n-            }\n-            if (!doCheckIsUserInRole) {\n-                if (addAdmin) {\n-                    try {\n-                        if (isUniqueUserIdEnabled()) {\n-                            this.doUpdateRoleListOfUserWithID(adminUserID, null, new String[] { adminRoleName });\n-                        } else {\n-                            this.doUpdateRoleListOfUser(adminUserName, null, new String[] { adminRoleName });\n-                        }\n-                    } catch (Exception e) {\n-                        String message = \"Admin user has not been assigned to Admin role. \" +\n-                                \"Error while assignment is done\";\n-                        if (initialSetup) {\n-                            throw new UserStoreException(message, e);\n-                        } else if (log.isDebugEnabled()) {\n-                            log.error(message, e);\n-                        }\n-                    }\n-                } else {\n-                    String message = \"Admin user can not be assigned to Admin role \" +\n-                            \"Add-Admin has been set to false. Please do the assign it in user store level\";\n-                    if (initialSetup) {\n-                        throw new UserStoreException(message);\n-                    } else if (log.isDebugEnabled()) {\n-                        log.error(message);\n-                    }\n-                }\n-            }\n-        }\n-\n-        doInitialUserAdding();\n-    }\n-\n-    private void updateHybridRoleListOfUserInternal(boolean initialSetup, String adminRoleName, String adminUserID)\n-            throws UserStoreException {\n-\n-        if (!hybridRoleManager.isUserInRole(adminUserID, adminRoleName)) {\n-            try {\n-                hybridRoleManager.updateHybridRoleListOfUser(adminUserID, null, new String[] { adminRoleName });\n-            } catch (Exception e) {\n-                String message = \"Admin user has not been assigned to Admin role. \" + \"Error while assignment is done\";\n-                if (initialSetup) {\n-                    throw new UserStoreException(message, e);\n-                } else if (log.isDebugEnabled()) {\n-                    log.error(message, e);\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * @param type\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public Map<String, Integer> getMaxListCount(String type) throws UserStoreException {\n-\n-        if (!type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)\n-                && !type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)) {\n-            throw new UserStoreException(\"Invalid count parameter\");\n-        }\n-\n-        if (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)\n-                && maxUserListCount != null) {\n-            return maxUserListCount;\n-        }\n-\n-        if (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)\n-                && maxRoleListCount != null) {\n-            return maxRoleListCount;\n-        }\n-\n-        Map<String, Integer> maxListCount = new HashMap<String, Integer>();\n-        for (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-            UserStoreManager storeManager = entry.getValue();\n-            String maxConfig = storeManager.getRealmConfiguration().getUserStoreProperty(type);\n-\n-            if (maxConfig == null) {\n-                // set a default value\n-                maxConfig = MAX_LIST_LENGTH;\n-            }\n-            maxListCount.put(entry.getKey(), Integer.parseInt(maxConfig));\n-        }\n-\n-        if (realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME) == null) {\n-            String maxConfig = realmConfig.getUserStoreProperty(type);\n-            if (maxConfig == null) {\n-                // set a default value\n-                maxConfig = MAX_LIST_LENGTH;\n-            }\n-            maxListCount.put(null, Integer.parseInt(maxConfig));\n-        }\n-\n-        if (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)) {\n-            this.maxUserListCount = maxListCount;\n-            return this.maxUserListCount;\n-        } else if (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)) {\n-            this.maxRoleListCount = maxListCount;\n-            return this.maxRoleListCount;\n-        } else {\n-            throw new UserStoreException(\"Invalid count parameter\");\n-        }\n-    }\n-\n-    /**\n-     * @return\n-     */\n-    protected String getMyDomainName() {\n-        return UserCoreUtil.getDomainName(realmConfig);\n-    }\n-\n-    protected void persistDomain() throws UserStoreException {\n-        String domain = UserCoreUtil.getDomainName(this.realmConfig);\n-        if (domain != null) {\n-            UserCoreUtil.persistDomain(domain, this.tenantId, this.dataSource);\n-        }\n-    }\n-\n-    public void deletePersistedDomain(String domain) throws UserStoreException {\n-        if (domain != null) {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Deleting persisted domain \" + domain);\n-            }\n-            UserCoreUtil.deletePersistedDomain(domain, this.tenantId, this.dataSource);\n-        }\n-    }\n-\n-    public void updatePersistedDomain(String oldDomain, String newDomain) throws UserStoreException {\n-        if (oldDomain != null && newDomain != null) {\n-            // Checks for the newDomain exists already\n-            // Traverse through realm configuration chain since USM chain doesn't contains the disabled USMs\n-            RealmConfiguration realmConfigTmp = this.getRealmConfiguration();\n-            while (realmConfigTmp != null) {\n-                String domainName = realmConfigTmp.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-                if (newDomain.equalsIgnoreCase(domainName)) {\n-                    throw new UserStoreException(\"Cannot update persisted domain name \" + oldDomain + \" into \" + newDomain + \". New domain name already in use\");\n-                }\n-                realmConfigTmp = realmConfigTmp.getSecondaryRealmConfig();\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Renaming persisted domain \" + oldDomain + \" to \" + newDomain);\n-            }\n-            UserCoreUtil.updatePersistedDomain(oldDomain, newDomain, this.tenantId, this.dataSource);\n-\n-        }\n-    }\n-\n-    /**\n-     * Checks whether the role is a shared role or not\n-     *\n-     * @param roleName\n-     * @param roleNameBase\n-     * @return\n-     */\n-    public boolean isSharedRole(String roleName, String roleNameBase) {\n-\n-        // Only checks the shared groups are enabled\n-        return isSharedGroupEnabled();\n-    }\n-\n-    /**\n-     * Checks whether the provided role name belongs to the logged in tenant.\n-     * This check is done using the domain name which is appended at the end of\n-     * the role name\n-     *\n-     * @param roleName\n-     * @return\n-     */\n-    protected boolean isOwnRole(String roleName) {\n-        return true;\n-    }\n-\n-    @Override\n-    public void addRole(String roleName, String[] userList,\n-                        org.wso2.carbon.user.api.Permission[] permissions)\n-            throws org.wso2.carbon.user.api.UserStoreException {\n-        addRole(roleName, userList, permissions, false);\n-    }\n-\n-    public boolean isOthersSharedRole(String roleName) {\n-        return false;\n-    }\n-\n-    public void notifyListeners(String domainName) {\n-        for (UserStoreManagerConfigurationListener aListener : listener) {\n-            aListener.propertyChange(domainName);\n-        }\n-    }\n-\n-    public void addChangeListener(UserStoreManagerConfigurationListener newListener) {\n-        listener.add(newListener);\n-    }\n-\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    private UserStoreManager createSecondaryUserStoreManager(RealmConfiguration realmConfig,\n-                                                             UserRealm realm) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{RealmConfiguration.class, UserRealm.class};\n-            Object object = callSecure(\"createSecondaryUserStoreManager\", new Object[]{realmConfig, realm}, argTypes);\n-            return (UserStoreManager) object;\n-        }\n-\n-        // setting global realm configurations such as everyone role, admin role and admin user\n-        realmConfig.setEveryOneRoleName(this.realmConfig.getEveryOneRoleName());\n-        realmConfig.setAdminUserName(this.realmConfig.getAdminUserName());\n-        realmConfig.setAdminRoleName(this.realmConfig.getAdminRoleName());\n-\n-        String className = realmConfig.getUserStoreClass();\n-        if (className == null) {\n-            String errmsg = \"Unable to add user store. UserStoreManager class name is null.\";\n-            log.error(errmsg);\n-            throw new UserStoreException(errmsg);\n-        }\n-\n-        HashMap<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(UserCoreConstants.DATA_SOURCE, this.dataSource);\n-        properties.put(UserCoreConstants.FIRST_STARTUP_CHECK, false);\n-\n-        Class[] initClassOpt1 = new Class[]{RealmConfiguration.class, Map.class,\n-                ClaimManager.class, ProfileConfigurationManager.class, UserRealm.class,\n-                Integer.class};\n-        Object[] initObjOpt1 = new Object[]{realmConfig, properties, realm.getClaimManager(), null, realm,\n-                tenantId};\n-\n-        // These two methods won't be used\n-        Class[] initClassOpt2 = new Class[]{RealmConfiguration.class, Map.class,\n-                ClaimManager.class, ProfileConfigurationManager.class, UserRealm.class};\n-        Object[] initObjOpt2 = new Object[]{realmConfig, properties, realm.getClaimManager(), null, realm};\n-\n-        Class[] initClassOpt3 = new Class[]{RealmConfiguration.class, Map.class};\n-        Object[] initObjOpt3 = new Object[]{realmConfig, properties};\n-\n-        try {\n-            Class clazz = Class.forName(className);\n-            Constructor constructor = null;\n-            Object newObject = null;\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Start initializing class with the first option\");\n-            }\n-\n-            try {\n-                constructor = clazz.getConstructor(initClassOpt1);\n-                newObject = constructor.newInstance(initObjOpt1);\n-                return (UserStoreManager) newObject;\n-            } catch (NoSuchMethodException e) {\n-                // if not found try again.\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Cannont initialize \" + className + \" using the option 1\");\n-                }\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"End initializing class with the first option\");\n-            }\n-\n-            try {\n-                constructor = clazz.getConstructor(initClassOpt2);\n-                newObject = constructor.newInstance(initObjOpt2);\n-                return (UserStoreManager) newObject;\n-            } catch (NoSuchMethodException e) {\n-                // if not found try again.\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Cannot initialize \" + className + \" using the option 2\");\n-                }\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"End initializing class with the second option\");\n-            }\n-\n-            try {\n-                constructor = clazz.getConstructor(initClassOpt3);\n-                newObject = constructor.newInstance(initObjOpt3);\n-                return (UserStoreManager) newObject;\n-            } catch (NoSuchMethodException e) {\n-                // cannot initialize in any of the methods. Throw exception.\n-                String message = \"Cannot initialize \" + className + \". Error \" + e.getMessage();\n-                log.error(message);\n-                throw new UserStoreException(message);\n-            }\n-\n-        } catch (Throwable e) {\n-            log.error(\"Cannot create \" + className, e);\n-            throw new UserStoreException(e.getMessage() + \"Type \" + e.getClass(), e);\n-        }\n-\n-    }\n-\n-    /**\n-     * Adding new User Store Manager to USM chain\n-     *\n-     * @param userStoreRealmConfig\n-     * @param realm\n-     * @throws UserStoreException\n-     */\n-    public void addSecondaryUserStoreManager(RealmConfiguration userStoreRealmConfig,\n-                                             UserRealm realm) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{RealmConfiguration.class, UserRealm.class};\n-            callSecure(\"addSecondaryUserStoreManager\", new Object[]{userStoreRealmConfig, realm}, argTypes);\n-            return;\n-        }\n-\n-        boolean isDisabled = Boolean.parseBoolean(userStoreRealmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.USER_STORE_DISABLED));\n-\n-        String domainName = userStoreRealmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\n-        if (isDisabled) {\n-            log.warn(\"Secondary user store disabled with domain \" + domainName + \".\");\n-        } else {\n-            // Creating new UserStoreManager\n-            UserStoreManager manager = createSecondaryUserStoreManager(userStoreRealmConfig, realm);\n-\n-            if (domainName != null) {\n-                if (this.getSecondaryUserStoreManager(domainName) != null) {\n-                    String errmsg = \"Could not initialize new user store manager : \" + domainName\n-                            + \" Duplicate domain names not allowed.\";\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(errmsg);\n-                    }\n-                    throw new UserStoreException(errmsg);\n-                } else {\n-                    // Fulfilled requirements for adding UserStore,\n-\n-                    // Now adding UserStoreManager to end of the UserStoreManager chain\n-                    UserStoreManager tmpUserStoreManager = this;\n-                    while (tmpUserStoreManager.getSecondaryUserStoreManager() != null) {\n-                        tmpUserStoreManager = tmpUserStoreManager.getSecondaryUserStoreManager();\n-                    }\n-                    tmpUserStoreManager.setSecondaryUserStoreManager(manager);\n-\n-                    // update domainName-USM map to retrieve USM directly by its domain name\n-                    this.addSecondaryUserStoreManager(domainName.toUpperCase(), tmpUserStoreManager.getSecondaryUserStoreManager());\n-\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"UserStoreManager : \" + domainName + \"added to the list\");\n-                    }\n-                }\n-            } else {\n-                log.warn(\"Could not initialize new user store manager.  \"\n-                        + \"Domain name is not defined\");\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public Map<String, List<String>> getRoleListOfUsers(String[] userNames) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String[].class };\n-            Object object = callSecure(\"getRoleListOfUsers\", new Object[] { userNames }, argTypes);\n-            return (Map<String, List<String>>) object;\n-        }\n-\n-        Map<String, List<String>> allRoleNames = new HashMap<>();\n-        Map<String, List<String>> domainFreeUsers = getDomainFreeUsers(userNames);\n-\n-        for (Map.Entry<String, List<String>> entry : domainFreeUsers.entrySet()) {\n-            UserStoreManager secondaryUserStoreManager = getSecondaryUserStoreManager(entry.getKey());\n-            if (secondaryUserStoreManager instanceof AbstractUserStoreManager) {\n-                if (((AbstractUserStoreManager) secondaryUserStoreManager).isUniqueUserIdEnabled()) {\n-                    Map<String, List<String>> userRoles = ((AbstractUserStoreManager) secondaryUserStoreManager)\n-                            .doGetRoleListOfUsersWithID(getUserIDsFromUserNames(entry.getValue()), entry.getKey());\n-                    userRoles.forEach((key, value) -> {\n-                        try {\n-                            allRoleNames.put(getUserNameFromUserID(key), value);\n-                        } catch (UserStoreException ignored) {\n-                            // Ignore\n-                        }\n-                    });\n-                } else {\n-                    Map<String, List<String>> roleNames = ((AbstractUserStoreManager) secondaryUserStoreManager)\n-                            .doGetRoleListOfUsers(entry.getValue(), entry.getKey());\n-                    allRoleNames.putAll(roleNames);\n-                }\n-            }\n-        }\n-\n-        for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-            if (listener instanceof AbstractUserOperationEventListener) {\n-                AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                if (!newListener.doPostGetRoleListOfUsers(userNames, allRoleNames)) {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-            if (listener instanceof AbstractUserOperationEventListener) {\n-                AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                if (!newListener.doPostGetRoleListOfUsers(userNames, allRoleNames, this)) {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return allRoleNames;\n-    }\n-\n-    public Map<String, List<String>> doGetRoleListOfUsers(List<String> userNames, String domainName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { List.class, String.class };\n-            Object object = callSecure(\"doGetRoleListOfUsers\", new Object[] { userNames, domainName }, argTypes);\n-            return (Map<String, List<String>>) object;\n-        }\n-\n-        Map<String, List<String>> internalRoles = doGetInternalRoleListOfUsers(userNames, domainName);\n-\n-        Map<String, List<String>> externalRoles = new HashMap<>();\n-        if (readGroupsEnabled) {\n-            externalRoles = doGetExternalRoleListOfUsers(userNames);\n-        }\n-\n-        Map<String, List<String>> combinedRoles = new HashMap<>();\n-        if (!internalRoles.isEmpty() && !externalRoles.isEmpty()) {\n-            for (String userName : userNames) {\n-                List<String> roles = new ArrayList<>();\n-                if (internalRoles.get(userName) != null) {\n-                    roles.addAll(internalRoles.get(userName));\n-                }\n-                if (externalRoles.get(userName) != null) {\n-                    List<String> domainQualifiedRoleNames = getNamesWithDomain(externalRoles.get(userName), domainName);\n-                    roles.addAll(domainQualifiedRoleNames);\n-                }\n-                if (!roles.isEmpty()) {\n-                    combinedRoles.put(userName, roles);\n-                }\n-            }\n-        } else if (!internalRoles.isEmpty()) {\n-            combinedRoles = internalRoles;\n-        } else if (!externalRoles.isEmpty()) {\n-            combinedRoles = externalRoles;\n-        }\n-\n-        return combinedRoles;\n-    }\n-\n-    protected Map<String, List<String>> doGetExternalRoleListOfUsers(List<String> userNames) throws UserStoreException {\n-\n-        Map<String, List<String>> externalRoleListOfUsers = new HashMap<>();\n-        for (String userName : userNames) {\n-            String[] externalRoles = doGetExternalRoleListOfUser(userName, null);\n-            if (!ArrayUtils.isEmpty(externalRoles)) {\n-                externalRoleListOfUsers.put(userName, Arrays.asList(externalRoles));\n-            }\n-        }\n-        return externalRoleListOfUsers;\n-    }\n-\n-    protected Map<String, List<String>> doGetExternalRoleListOfUsersWithID(List<String> userIDs) throws UserStoreException {\n-\n-        Map<String, List<String>> externalRoleListOfUsers = new HashMap<>();\n-        for (String userID : userIDs) {\n-            String[] externalRoles = doGetExternalRoleListOfUserWithID(userID, null);\n-            if (!ArrayUtils.isEmpty(externalRoles)) {\n-                externalRoleListOfUsers.put(userID, Arrays.asList(externalRoles));\n-            }\n-        }\n-        return externalRoleListOfUsers;\n-    }\n-\n-    @Override\n-    public UserClaimSearchEntry[] getUsersClaimValues(String[] userNames, String[] claims, String profileName) throws\n-            UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String[].class, String[].class, String.class};\n-            Object object = callSecure(\"getUsersClaimValues\", new Object[]{userNames, claims, profileName},\n-                    argTypes);\n-            return (UserClaimSearchEntry[]) object;\n-        }\n-\n-        if (StringUtils.isEmpty(profileName)) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n-\n-        if (claims == null) {\n-            claims = new String[0];\n-        }\n-\n-        UserClaimSearchEntry[] allUsers = new UserClaimSearchEntry[0];\n-        Map<String, List<String>> domainFreeUsers = getDomainFreeUsers(userNames);\n-\n-        for (Map.Entry<String, List<String>> entry : domainFreeUsers.entrySet()) {\n-            UserStoreManager secondaryUserStoreManager = getSecondaryUserStoreManager(entry.getKey());\n-            if (secondaryUserStoreManager instanceof AbstractUserStoreManager) {\n-                List<String> usersWithDomain = getNamesWithDomain(entry.getValue(), entry.getKey());\n-                if (((AbstractUserStoreManager) secondaryUserStoreManager).isUniqueUserIdEnabled()) {\n-                    List<UniqueIDUserClaimSearchEntry> uniqueIDUserClaimSearchEntries = ((AbstractUserStoreManager)\n-                            secondaryUserStoreManager).doGetUsersClaimValuesWithID(getUserIDsFromUserNames(\n-                            usersWithDomain), Arrays.asList(claims), entry.getKey(), profileName);\n-\n-                    List<UserClaimSearchEntry> userClaimSearchEntries = getUserClaimSearchEntries(\n-                            uniqueIDUserClaimSearchEntries);\n-                    allUsers = (UserClaimSearchEntry[]) ArrayUtils\n-                            .addAll(userClaimSearchEntries.toArray(new UserClaimSearchEntry[0]), allUsers);\n-                } else {\n-                    UserClaimSearchEntry[] users = ((AbstractUserStoreManager) secondaryUserStoreManager)\n-                            .doGetUsersClaimValues(entry.getValue(), claims, entry.getKey(), profileName);\n-                    allUsers = (UserClaimSearchEntry[]) ArrayUtils.addAll(users, allUsers);\n-                }\n-\n-            }\n-        }\n-\n-        for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-            if (listener instanceof AbstractUserOperationEventListener) {\n-                AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                if (!newListener.doPostGetUsersClaimValues(userNames, claims, profileName, allUsers)) {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-            if (listener instanceof AbstractUserOperationEventListener) {\n-                AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                if (!newListener.doPostGetUsersClaimValues(userNames, claims, profileName, allUsers, this)) {\n-                    break;\n-                }\n-            }\n-        }\n-        return allUsers;\n-    }\n-\n-    public List<UserClaimSearchEntry> getUserClaimSearchEntries(\n-            List<UniqueIDUserClaimSearchEntry> uniqueIDUserClaimSearchEntries) {\n-\n-        List<UserClaimSearchEntry> userClaimSearchEntries = new ArrayList<>();\n-        for (UniqueIDUserClaimSearchEntry uniqueIDUserClaimSearchEntry : uniqueIDUserClaimSearchEntries) {\n-            userClaimSearchEntries.add(uniqueIDUserClaimSearchEntry.getUserClaimSearchEntry());\n-        }\n-        return userClaimSearchEntries;\n-    }\n-\n-    public UserClaimSearchEntry[] doGetUsersClaimValues(List<String> users, String[] claims, String domainName,\n-            String profileName) throws UserStoreException {\n-\n-        Set<String> propertySet = new HashSet<>();\n-        Map<String, String> claimToAttributeMap = new HashMap<>();\n-        List<UserClaimSearchEntry> userClaimSearchEntryList = new ArrayList<>();\n-        for (String claim : claims) {\n-            String property;\n-            try {\n-                property = getClaimAtrribute(claim, null, domainName);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-            propertySet.add(property);\n-            claimToAttributeMap.put(claim, property);\n-        }\n-\n-        String[] properties = propertySet.toArray(new String[0]);\n-        Map<String, Map<String, String>> userProperties = this.getUsersPropertyValues(users, properties, profileName);\n-\n-        for (Map.Entry<String, Map<String, String>> entry : userProperties.entrySet()) {\n-            UserClaimSearchEntry userClaimSearchEntry = new UserClaimSearchEntry();\n-            userClaimSearchEntry.setUserName(UserCoreUtil.addDomainToName(entry.getKey(), domainName));\n-            Map<String, String> userClaims = new HashMap<>();\n-\n-            for (String claim : claims) {\n-                for (Map.Entry<String, String> userAttribute : entry.getValue().entrySet()) {\n-                    if (claimToAttributeMap.get(claim) != null && claimToAttributeMap.get(claim)\n-                            .equals(userAttribute.getKey())) {\n-                        userClaims.put(claim, userAttribute.getValue());\n-                    }\n-                }\n-            }\n-            userClaimSearchEntry.setClaims(userClaims);\n-            userClaimSearchEntryList.add(userClaimSearchEntry);\n-\n-        }\n-\n-        return userClaimSearchEntryList.toArray(new UserClaimSearchEntry[0]);\n-    }\n-\n-    private Map<String, List<String>> getDomainFreeUsers(String[] userNames) {\n-\n-        Map<String, List<String>> domainAwareUsers = new HashMap<>();\n-        if (ArrayUtils.isNotEmpty(userNames)) {\n-            for (String username : userNames) {\n-                String domainName = UserCoreUtil.extractDomainFromName(username);\n-                if (StringUtils.isEmpty(domainName)) {\n-                    domainName = UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME;\n-                }\n-\n-                List<String> users = domainAwareUsers.get(domainName);\n-                if (users == null) {\n-                    users = new ArrayList<>();\n-                    domainAwareUsers.put(domainName.toUpperCase(), users);\n-                }\n-                users.add(UserCoreUtil.removeDomainFromName(username));\n-            }\n-        }\n-\n-        return domainAwareUsers;\n-    }\n-\n-    protected Map<String, Map<String, String>> getUsersPropertyValues(List<String> users, String[] propertyNames,\n-            String profileName) throws UserStoreException {\n-\n-        Map<String, Map<String, String>> usersPropertyValuesMap = new HashMap<>();\n-        for (String userName : users) {\n-            Map<String, String> propertyValuesMap = getUserPropertyValues(userName, propertyNames, profileName);\n-            processAttributesAfterRetrieval(userName, propertyValuesMap, profileName);\n-            if (propertyValuesMap != null && !propertyValuesMap.isEmpty()) {\n-                usersPropertyValuesMap.put(userName, propertyValuesMap);\n-            }\n-        }\n-        return usersPropertyValuesMap;\n-    }\n-\n-    /**\n-     * Remove given User Store Manager from USM chain\n-     *\n-     * @param userStoreDomainName\n-     * @throws UserStoreException\n-     */\n-    public void removeSecondaryUserStoreManager(String userStoreDomainName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class};\n-            callSecure(\"removeSecondaryUserStoreManager\", new Object[]{userStoreDomainName}, argTypes);\n-            return;\n-        }\n-\n-        if (userStoreDomainName == null) {\n-            throw new UserStoreException(\"Cannot remove user store. User store domain name is null\");\n-        }\n-        if (\"\".equals(userStoreDomainName)) {\n-            throw new UserStoreException(\"Cannot remove user store. User store domain name is empty\");\n-        }\n-//    \tif(!this.userStoreManagerHolder.containsKey(userStoreDomainName.toUpperCase())) {\n-//    \t\tthrow new UserStoreException(\"Cannot remove user store. User store domain name does not exists\");\n-//    \t}\n-\n-        userStoreDomainName = userStoreDomainName.toUpperCase();\n-\n-        boolean isUSMContainsInMap = false;\n-        if (this.userStoreManagerHolder.containsKey(userStoreDomainName.toUpperCase())) {\n-            isUSMContainsInMap = true;\n-            this.userStoreManagerHolder.remove(userStoreDomainName.toUpperCase());\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"UserStore: \" + userStoreDomainName + \" removed from map\");\n-            }\n-        }\n-\n-        boolean isUSMConatainsInChain = false;\n-        UserStoreManager prevUserStoreManager = this;\n-        while (prevUserStoreManager.getSecondaryUserStoreManager() != null) {\n-            UserStoreManager secondaryUSM = prevUserStoreManager.getSecondaryUserStoreManager();\n-            if (secondaryUSM.getRealmConfiguration().getUserStoreProperty(UserStoreConfigConstants.DOMAIN_NAME).equalsIgnoreCase(userStoreDomainName)) {\n-                isUSMConatainsInChain = true;\n-                // Omit deleting user store manager from the chain\n-                prevUserStoreManager.setSecondaryUserStoreManager(secondaryUSM.getSecondaryUserStoreManager());\n-                log.info(\"User store: \" + userStoreDomainName + \" of tenant:\" + tenantId + \" is removed from user store chain.\");\n-                return;\n-            }\n-            prevUserStoreManager = secondaryUSM;\n-        }\n-\n-        if (!isUSMContainsInMap && isUSMConatainsInChain) {\n-            throw new UserStoreException(\"Removed user store manager : \" + userStoreDomainName + \" didnt exists in userStoreManagerHolder map\");\n-        } else if (isUSMContainsInMap && !isUSMConatainsInChain) {\n-            throw new UserStoreException(\"Removed user store manager : \" + userStoreDomainName + \" didnt exists in user store manager chain\");\n-        }\n-    }\n-\n-    public HybridRoleManager getInternalRoleManager() {\n-        return hybridRoleManager;\n-    }\n-\n-    @Override\n-    public String[] getUserList(String claim, String claimValue, String profileName, int limit, int offset) throws\n-            UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String.class, String.class, int.class, int.class};\n-            Object object = callSecure(\"getUserList\", new Object[]{claim, claimValue, profileName, limit, offset},\n-                    argTypes);\n-            return (String[]) object;\n-        }\n-\n-        if (claim == null) {\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getCode();\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getMessage(), \"\");\n-            handleGetUserListFailure(errorCode, errorMessage, null, claimValue, limit, offset, profileName);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.toString());\n-        }\n-\n-        if (claimValue == null) {\n-            handleGetUserListFailure(ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.getCode(), ErrorMessages.\n-                    ERROR_CODE_INVALID_CLAIM_VALUE.getMessage(), claim, null, limit, offset, profileName);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.toString());\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Listing and paginate users who having value as \" + claimValue + \" for the claim \" + claim);\n-        }\n-\n-        if (USERNAME_CLAIM_URI.equalsIgnoreCase(claim) || SCIM_USERNAME_CLAIM_URI.equalsIgnoreCase(claim) ||\n-                SCIM2_USERNAME_CLAIM_URI.equalsIgnoreCase(claim)) {\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Switching to paginate users using username\");\n-            }\n-\n-            String[] filteredUsers = listUsers(claimValue, limit, offset);\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Filtered users: \" + Arrays.toString(filteredUsers));\n-            }\n-\n-            return filteredUsers;\n-        }\n-\n-        // Extracting the domain from claimValue.\n-        String extractedDomain = null;\n-        int index;\n-        index = claimValue.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        if (index > 0) {\n-            String names[] = claimValue.split(CarbonConstants.DOMAIN_SEPARATOR);\n-            extractedDomain = names[0].trim();\n-        }\n-\n-        UserStoreManager userManager = this;\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            UserStoreManager secondaryUserStoreManager = getSecondaryUserStoreManager(extractedDomain);\n-            if (secondaryUserStoreManager != null) {\n-                userManager = secondaryUserStoreManager;\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Domain: \" + extractedDomain + \" is passed with the claim and user store manager is loaded\"\n-                            + \" for the given domain name.\");\n-                }\n-            }\n-        }\n-\n-        if (userManager instanceof JDBCUserStoreManager && (SCIM_USERNAME_CLAIM_URI.equalsIgnoreCase(claim) ||\n-                SCIM2_USERNAME_CLAIM_URI.equalsIgnoreCase(claim))) {\n-            if (userManager.isExistingUser(claimValue)) {\n-                return new String[]{claimValue};\n-            } else {\n-                return new String[0];\n-            }\n-        }\n-\n-        claimValue = UserCoreUtil.removeDomainFromName(claimValue);\n-\n-        final List<String> filteredUserList = new ArrayList<>();\n-\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    if (listener instanceof AbstractUserOperationEventListener) {\n-                        AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                        if (!newListener.doPreGetUserList(claim, claimValue, limit, offset, filteredUserList, userManager)) {\n-                            handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), claim,\n-                                    claimValue, limit, offset, profileName);\n-                            break;\n-                        }\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                ex.getMessage()), claim, claimValue, limit, offset, profileName);\n-                throw ex;\n-            }\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Pre listener user list: \" + filteredUserList + \" for domain: \" + extractedDomain);\n-        }\n-\n-        List<String> userNamesFromUserStore;\n-        if (isUniqueUserIdEnabled(userManager)) {\n-            List<User> usersFromUserStore = doGetUserListWithID(claim, claimValue, profileName, limit,\n-                    offset, extractedDomain, userManager);\n-            userNamesFromUserStore = usersFromUserStore.stream()\n-                    .map(User::getDomainQualifiedUsername).collect(Collectors.toList());\n-        } else {\n-            userNamesFromUserStore = doGetUserList(claim, claimValue, profileName, limit,\n-                    offset, extractedDomain, userManager);\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Users from user store: \" + extractedDomain + \" : \" + userNamesFromUserStore);\n-            }\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Users from user store: \" + extractedDomain + \" : \" + userNamesFromUserStore);\n-        }\n-        filteredUserList.addAll(userNamesFromUserStore);\n-\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            handlePostGetUserList(claim, claimValue, filteredUserList, limit, offset, false);\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Post listener user list pagination: \" + filteredUserList + \" for domain: \" + extractedDomain);\n-        }\n-\n-        return filteredUserList.toArray(new String[0]);\n-    }\n-\n-    /**\n-     * Get the user count with claim value as a filter.\n-     *\n-     * @param claimUri  claim uri\n-     * @param filter filter or filter value with domain name (PRIMARY/* or *)\n-     * @return usersCountInUserStore\n-     * @throws UserStoreException UserStoreException\n-     */\n-    public long getUserCountWithClaims(String claimUri, String filter) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, String.class};\n-            Object object = callSecure(\"getUserCountWithClaims\", new Object[]{claimUri,filter}, argTypes);\n-            return (long) object;\n-        }\n-\n-        if (claimUri == null) {\n-            String errorCode = ErrorMessages.ERROR_CODE_NULL_CLAIM_URI.getCode();\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NULL_CLAIM_URI.getMessage());\n-            handleGetUserCountFailure(errorCode, errorMessage, null, filter);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_NULL_CLAIM_URI.toString());\n-        }\n-\n-        if (filter == null) {\n-            handleGetUserCountFailure(ErrorMessages.ERROR_CODE_DOMAIN_VALUE_WITH_FILTER_EMPTY.getCode(),\n-                    ErrorMessages.ERROR_CODE_DOMAIN_VALUE_WITH_FILTER_EMPTY.getMessage(), claimUri, null);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_DOMAIN_VALUE_WITH_FILTER_EMPTY.toString());\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Count users who having filter and domain \" + filter + \" for the claim \" + claimUri);\n-        }\n-\n-        String extractedDomain = null;\n-        int index;\n-        index = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        if (index > 0) {\n-            String names[] = filter.split(CarbonConstants.DOMAIN_SEPARATOR);\n-            extractedDomain = names[0].trim();\n-        }\n-\n-        if (StringUtils.isEmpty(extractedDomain)) {\n-            extractedDomain = UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME;\n-        }\n-        UserStoreManager userManager = getSecondaryUserStoreManager(extractedDomain);\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Domain: \" + extractedDomain + \" is passed with the claim and user store manager is loaded\"\n-                    + \" for the given domain name.\");\n-        }\n-\n-        String filterValue = UserCoreUtil.removeDomainFromName(filter);\n-        return getCountUsers(claimUri, filterValue, userManager);\n-    }\n-\n-    @Override\n-    public String[] getUserList(Condition condition, String domain, String profileName, int limit, int offset, String sortBy, String\n-            sortOrder) throws UserStoreException {\n-\n-        validateCondition(condition);\n-        if (StringUtils.isNotEmpty(sortBy) && StringUtils.isNotEmpty(sortOrder)) {\n-            throw new UserStoreException(\"Sorting is not supported.\");\n-        }\n-\n-        if (StringUtils.isEmpty(domain)) {\n-            domain = UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME;\n-        }\n-\n-        if (StringUtils.isEmpty(profileName)) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n-\n-        handlePreGetUserList(condition, domain, profileName, limit, offset, sortBy, sortOrder);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Pre listener get conditional  user list for domain: \" + domain);\n-        }\n-\n-        String[] filteredUsers = new String[0];\n-        UserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-        if (secManager != null) {\n-            if (secManager instanceof AbstractUserStoreManager) {\n-                if (((AbstractUserStoreManager) secManager).isUniqueUserIdEnabled()) {\n-                    UniqueIDPaginatedSearchResult users = ((AbstractUserStoreManager) secManager).doGetUserListWithID(condition,\n-                            profileName, limit, offset, sortBy, sortOrder);\n-                    filteredUsers = users.getUsers().stream().map(User::getUsername).toArray(String[]::new);\n-                } else {\n-                    PaginatedSearchResult users = ((AbstractUserStoreManager) secManager).doGetUserList(condition,\n-                            profileName, limit, offset, sortBy, sortOrder);\n-                    filteredUsers = users.getUsers();\n-                }\n-            }\n-        }\n-\n-        handlePostGetUserList(condition, domain, profileName, limit, offset, sortBy, sortOrder, filteredUsers, false);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"post listener get conditional  user list for domain: \" + domain);\n-        }\n-        return filteredUsers;\n-    }\n-\n-    protected PaginatedSearchResult doGetUserList(Condition condition, String profileName, int limit, int offset,\n-                                                  String sortBy, String sortOrder) throws UserStoreException {\n-\n-        return new PaginatedSearchResult();\n-    }\n-\n-    protected UniqueIDPaginatedSearchResult doGetUserListWithID(Condition condition, String profileName, int limit,\n-            int offset, String sortBy, String sortOrder) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetUserListWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"doGetUserListWithID operation is not implemented in: \" + this.getClass());\n-    }\n-\n-\n-    @Override\n-    public String[] listUsers(String filter, int limit, int offset) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[]{String.class, int.class, int.class};\n-            Object object = callSecure(\"listUsers\", new Object[]{filter, limit, offset}, argTypes);\n-            return (String[]) object;\n-        }\n-\n-        int index = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        PaginatedSearchResult userList;\n-        String[] users = new String[0];\n-\n-        if (offset <= 0) {\n-            offset = 1;\n-        }\n-\n-        if (index > 0) {\n-            String domain = filter.substring(0, index);\n-\n-            UserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-            if (secManager != null) {\n-                // Secondary UserStoreManager registered for this domain.\n-                filter = filter.substring(index + 1);\n-                if (secManager instanceof AbstractUserStoreManager) {\n-                    if (!((AbstractUserStoreManager) secManager).isUniqueUserIdEnabled()) {\n-                        userList = ((AbstractUserStoreManager) secManager).doListUsers(filter, limit, offset);\n-                    } else {\n-                        userList = ((AbstractUserStoreManager) secManager).doListUsersWithID(filter, limit, offset)\n-                                .getPaginatedSearchResult();\n-                    }\n-                    handlePostListPaginatedUsers(filter, limit, offset, new ArrayList<>(Arrays.asList(userList.getUsers())),\n-                            true);\n-                    return userList.getUsers();\n-                }\n-            }\n-        } else if (index == 0) {\n-            if (!isUniqueUserIdEnabled()) {\n-                userList = doListUsers(filter.substring(1), limit, offset);\n-            } else {\n-                userList = doListUsersWithID(filter.substring(1), limit, offset).getPaginatedSearchResult();\n-            }\n-            handlePostListPaginatedUsers(filter, limit, offset, new ArrayList<>(Arrays.asList(userList.getUsers())),\n-                    true);\n-            return userList.getUsers();\n-        }\n-\n-        try {\n-            if (!isUniqueUserIdEnabled()) {\n-                userList = doListUsers(filter, limit, offset);\n-            } else {\n-                userList = doListUsersWithID(filter, limit, offset).getPaginatedSearchResult();\n-            }\n-            users = UserCoreUtil.combineArrays(users, userList.getUsers());\n-            limit = limit - users.length;\n-        } catch (UserStoreException ex) {\n-            handleGetPaginatedUserListFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_LISTING_PAGINATED_USERS.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_LISTING_PAGINATED_USERS.getMessage(),\n-                            ex.getMessage()), null, null, null);\n-            throw ex;\n-        }\n-\n-        String primaryDomain = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\n-        int nonPaginatedUserCount = userList.getSkippedUserCount();\n-        if (this.getSecondaryUserStoreManager() != null) {\n-            for (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-                if (limit <= 0) {\n-                    return users;\n-                }\n-                if (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n-                    continue;\n-                }\n-                UserStoreManager storeManager = entry.getValue();\n-                if (storeManager instanceof AbstractUserStoreManager) {\n-                    try {\n-                        if (userList.getUsers().length > 0) {\n-                            offset = 1;\n-                        } else {\n-                            offset = offset - nonPaginatedUserCount;\n-                        }\n-\n-                        PaginatedSearchResult secondUserList;\n-                        if (!((AbstractUserStoreManager) storeManager).isUniqueUserIdEnabled()) {\n-                          secondUserList  = ((AbstractUserStoreManager) storeManager)\n-                                    .doListUsers(filter, limit, offset);\n-                        } else {\n-                            secondUserList  = ((AbstractUserStoreManager) storeManager)\n-                                    .doListUsersWithID(filter, limit, offset).getPaginatedSearchResult();\n-                        }\n-                        nonPaginatedUserCount = secondUserList.getSkippedUserCount();\n-                        users = UserCoreUtil.combineArrays(users, secondUserList.getUsers());\n-                        limit = limit - users.length;\n-                    } catch (UserStoreException ex) {\n-                        handleGetPaginatedUserListFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_LISTING_PAGINATED_USERS\n-                                        .getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_LISTING_PAGINATED_USERS.getMessage(),\n-                                        ex.getMessage()), null, null, null);\n-                        // We can ignore and proceed. Ignore the results from this user store.\n-                        log.error(ex);\n-                    }\n-                }\n-            }\n-        }\n-\n-        handlePostListPaginatedUsers(filter, limit, offset, new ArrayList<>(Arrays.asList(users)), true);\n-        return users;\n-    }\n-\n-    protected PaginatedSearchResult doListUsers(String filter, int limit, int offset)\n-            throws UserStoreException{\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Operation is not implemented in: \" + this.getClass());\n-        }\n-        return new PaginatedSearchResult();\n-    }\n-\n-    protected UniqueIDPaginatedSearchResult doListUsersWithID(String filter, int limit, int offset)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doListUsersWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"doListUsersWithID operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    /**\n-     * Get the count of Roles having a matching user name for the filter.\n-     *\n-     * @param filter the filter for the user name. Use '*' to have all.\n-     * @throws  UserStoreException UserStoreException\n-     */\n-    protected long doCountRoles(String filter) throws UserStoreException{\n-\n-        throw new UserStoreException(\"Operation is not supported\");\n-    }\n-\n-    protected PaginatedSearchResult getUserListFromProperties(String property, String value, String profileName, int\n-            limit, int offset) throws UserStoreException {\n-\n-        return new PaginatedSearchResult();\n-    }\n-\n-    protected UniqueIDPaginatedSearchResult doGetUserListFromPropertiesWithID(String property, String value, String profileName,\n-            int limit, int offset) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetUserListFromPropertiesWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"doGetUserListFromPropertiesWithID operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    private void validateCondition(Condition condition) throws UserStoreException {\n-\n-        if (condition instanceof ExpressionCondition) {\n-            if (isNotSupportedExpressionOperation(condition)) {\n-                throw new UserStoreException(\"Unsupported expression operation: \" + condition.getOperation());\n-            }\n-        } else if (condition instanceof OperationalCondition) {\n-            Condition leftCondition = ((OperationalCondition) condition).getLeftCondition();\n-            validateCondition(leftCondition);\n-            Condition rightCondition = ((OperationalCondition) condition).getRightCondition();\n-            String operation = condition.getOperation();\n-            if (!OperationalOperation.AND.toString().equals(operation)) {\n-                throw new UserStoreException(\"Unsupported Conditional operation: \" + condition.getOperation());\n-            }\n-            validateCondition(rightCondition);\n-        }\n-    }\n-\n-    private boolean isNotSupportedExpressionOperation(Condition condition) {\n-\n-        return !(ExpressionOperation.EQ.toString().equals(condition.getOperation()) ||\n-                ExpressionOperation.CO.toString().equals(condition.getOperation()) ||\n-                ExpressionOperation.SW.toString().equals(condition.getOperation()) ||\n-                ExpressionOperation.EW.toString().equals(condition.getOperation()));\n-    }\n-\n-    private boolean isAnInternalRole(String roleName) {\n-\n-        return roleName.toLowerCase().startsWith(APPLICATION_DOMAIN.toLowerCase()) || roleName.toLowerCase()\n-                .startsWith(UserCoreConstants.INTERNAL_DOMAIN.toLowerCase()) || roleName.toLowerCase()\n-                .startsWith(WORKFLOW_DOMAIN.toLowerCase());\n-    }\n-\n-    private List<String> getUserStorePreferenceOrder() throws UserStoreException {\n-\n-        UserMgtContext userMgtContext = UserCoreUtil.getUserMgtContextFromThreadLocal();\n-        if (userMgtContext != null) {\n-            // Retrieve the relevant supplier to generate the user store preference order.\n-            UserStorePreferenceOrderSupplier<List<String>> userStorePreferenceSupplier = userMgtContext.\n-                    getUserStorePreferenceOrderSupplier();\n-            if (userStorePreferenceSupplier != null) {\n-                // Generate the user store preference order.\n-                List<String> userStorePreferenceOrder = userStorePreferenceSupplier.get();\n-                if (userStorePreferenceOrder != null) {\n-                    return userStorePreferenceOrder;\n-                }\n-            }\n-        }\n-        return Collections.emptyList();\n-    }\n-\n-    private boolean hasUserStorePreferenceChainGenerated() throws UserStoreException {\n-\n-        return this instanceof IterativeUserStoreManager;\n-    }\n-\n-    private boolean isUserStoreChainNeeded(List<String> userStorePreferenceOrder) throws UserStoreException {\n-\n-        if (this instanceof IterativeUserStoreManager) {\n-            return false;\n-        }\n-        userStorePreferenceOrder.addAll(getUserStorePreferenceOrder());\n-        return CollectionUtils.isNotEmpty(userStorePreferenceOrder) && !hasUserStorePreferenceChainGenerated();\n-    }\n-\n-    private boolean generateUserStoreChain(String userName, Object credential, boolean domainProvided,\n-                                           List<String> userStorePreferenceOrder) throws UserStoreException {\n-\n-        // If domain name is provided, directly authenticate using the corresponding user store.\n-        if (domainProvided) {\n-            String providedDomainName = this.getUserStore(userName).getDomainName();\n-            // Check whether provided domain is in the preference list.\n-            if (!userStorePreferenceOrder.contains(providedDomainName)) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Authentication failure. Invalid username or password is provided.\");\n-                }\n-                handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(),\n-                                \"Authentication failed\"), userName, credential);\n-                throw new UserStoreException(\"Authentication failed. Invalid username or password.\");\n-            }\n-            UserStoreManager userStoreManager = this.getSecondaryUserStoreManager(providedDomainName);\n-            if (!(userStoreManager instanceof AbstractUserStoreManager)) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"UserStoreManager is not an instance of AbstractUserStoreManager. Hence \" +\n-                            \"authenticate the user through all the available user store list.\");\n-                }\n-                return authenticateInternal(userName, credential, true);\n-            }\n-            IterativeUserStoreManager iterativeUserStoreManager = new IterativeUserStoreManager(\n-                    (AbstractUserStoreManager) userStoreManager);\n-            return iterativeUserStoreManager.authenticate(userName, credential);\n-        }\n-        // If domain is not provided, generate a user store chain.\n-        IterativeUserStoreManager initialUserStoreManager = null;\n-        IterativeUserStoreManager prevUserStoreManager = null;\n-        for (String domainName : userStorePreferenceOrder) {\n-            UserStoreManager userStoreManager = this.getSecondaryUserStoreManager(domainName);\n-            // If the user store manager is instance of AbstractUserStoreManager then generate a user store chain using\n-            // IterativeUserStoreManager.\n-            if (userStoreManager instanceof AbstractUserStoreManager) {\n-                if (initialUserStoreManager == null) {\n-                    prevUserStoreManager = new IterativeUserStoreManager((AbstractUserStoreManager) userStoreManager);\n-                    initialUserStoreManager = prevUserStoreManager;\n-                } else {\n-                    IterativeUserStoreManager currentUserStoreManager = new IterativeUserStoreManager(\n-                            (AbstractUserStoreManager) userStoreManager);\n-                    prevUserStoreManager.setNextUserStoreManager(currentUserStoreManager);\n-                    prevUserStoreManager = currentUserStoreManager;\n-                }\n-            } else {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"UserStoreManager is not an instance of AbstractUserStoreManager hence authenticate the\" +\n-                            \" user through all the available user store list.\");\n-                }\n-                return authenticateInternal(userName, credential, domainProvided);\n-            }\n-        }\n-        // Authenticate using the initial user store from the user store preference list.\n-        return initialUserStoreManager.authenticate(userName, credential);\n-    }\n-\n-    private long getCountUsers(String claimUri, String filterValue, UserStoreManager userManager)\n-            throws UserStoreException {\n-\n-        if (userManager instanceof AbstractUserStoreManager) {\n-\n-            return ((AbstractUserStoreManager) userManager).countUsersWithClaims(claimUri, filterValue);\n-\n-        } else {\n-            String msg = \"Get user count is not supported by this user store: \";\n-            if (log.isDebugEnabled()) {\n-                log.debug(msg + userManager.getClass());\n-            }\n-            throw new UserStoreException(msg + userManager.getClass());\n-        }\n-    }\n-\n-    private boolean isInternalRole(String domain) {\n-\n-        return domain.equals(\"Internal\") || domain.equals(\"Application\");\n-    }\n-\n-    private String removeDomainIfNotApplicationRole(String roleName) {\n-\n-        String formattedRoleName;\n-        if (roleName.contains(UserCoreConstants.DOMAIN_SEPARATOR)\n-                && roleName.toLowerCase().startsWith(APPLICATION_DOMAIN.toLowerCase())) {\n-            formattedRoleName = roleName;\n-        } else {\n-            formattedRoleName = UserCoreUtil.removeDomainFromName(roleName);\n-        }\n-        return formattedRoleName;\n-    }\n-\n-    private void createHybridRole(String roleName, String[] userList, org.wso2.carbon.user.api.Permission[] permissions)\n-            throws UserStoreException {\n-\n-        // It is possible that the adding role could already exists at the table. But if concurrent requests were made,\n-        // it is possible that the adding role does not exists at this moment, but it still could exists at the\n-        // moment when DB query is called.\n-        try {\n-            hybridRoleManager.addHybridRole(roleName, userList);\n-        } catch (UserStoreException e) {\n-            // In case of a unique constraint violation.\n-            if (ERROR_CODE_ROLE_ALREADY_EXISTS.getCode().equals(e.getErrorCode())) {\n-                handleRoleAlreadyExistException(roleName, userList, permissions);\n-            }\n-            // Otherwise, the error is propagated.\n-            throw e;\n-        }\n-    }\n-\n-    private void createSystemRole(String roleName, String[] userList, Permission[] permissions) throws UserStoreException {\n-\n-        if (systemUserRoleManager.isExistingRole(roleName)) {\n-            handleRoleAlreadyExistException(roleName, userList, permissions);\n-        }\n-\n-        // It is possible that the adding role could already exists at the table. But if concurrent requests were made,\n-        // it is possible that the adding role does not exists at this moment, but it still could exists at the\n-        // moment when DB query is called.\n-        try {\n-            systemUserRoleManager.addSystemRole(roleName, userList);\n-        } catch (UserStoreException e) {\n-            if (ERROR_CODE_DUPLICATE_WHILE_ADDING_A_SYSTEM_ROLE.getCode().contains(e.getErrorCode())) {\n-                // A unique constraint violation due to already existing role.\n-                handleRoleAlreadyExistException(roleName, userList, permissions);\n-            }\n-            throw e;\n-        }\n-    }\n-\n-    @Override\n-    public final AuthenticationResult authenticateWithID(final List<LoginIdentifier> loginIdentifiers,\n-            final String domain, final Object credential) throws UserStoreException {\n-\n-        try {\n-            return AccessController.doPrivileged((PrivilegedExceptionAction<AuthenticationResult>) () -> {\n-                if (!validateUserNameAndCredentials(loginIdentifiers, credential)) {\n-                    AuthenticationResult authenticationResult = new AuthenticationResult(\n-                            AuthenticationResult.AuthenticationStatus.FAIL);\n-                    authenticationResult.setFailureReason(new FailureReason(\"Invalid Credentials\"));\n-                    return authenticationResult;\n-                }\n-\n-                List<String> userStorePreferenceOrder = new ArrayList<>();\n-                // Check whether user store chain needs to be generated or not.\n-                if (isUserStoreChainNeeded(userStorePreferenceOrder)) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"User store chain generation is needed hence generating the user store chain using \"\n-                                + \"the user\" + \" store preference order: \" + userStorePreferenceOrder);\n-                    }\n-                    return generateUserStoreChainWithID(loginIdentifiers, domain, credential, userStorePreferenceOrder);\n-                } else {\n-                    // Authenticate the user.\n-                    return authenticateInternalWithID(loginIdentifiers, domain, credential);\n-                }\n-\n-            });\n-        } catch (PrivilegedActionException e) {\n-            if (!(e.getException() instanceof UserStoreException)) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(), e.getMessage()),\n-                        loginIdentifiers, credential);\n-            }\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    private AuthenticationResult generateUserStoreChainWithID(List<LoginIdentifier> loginIdentifiers, String domain,\n-            Object credential, List<String> userStorePreferenceOrder) throws UserStoreException {\n-\n-        IterativeUserStoreManager initialUserStoreManager = null;\n-        IterativeUserStoreManager prevUserStoreManager = null;\n-        for (String domainName : userStorePreferenceOrder) {\n-            UserStoreManager userStoreManager = this.getSecondaryUserStoreManager(domainName);\n-            // If the user store manager is instance of AbstractUserStoreManager then generate a user store chain using\n-            // IterativeUserStoreManager.\n-            if (userStoreManager instanceof AbstractUserStoreManager) {\n-                if (initialUserStoreManager == null) {\n-                    prevUserStoreManager = new IterativeUserStoreManager((AbstractUserStoreManager) userStoreManager);\n-                    initialUserStoreManager = prevUserStoreManager;\n-                } else {\n-                    IterativeUserStoreManager currentUserStoreManager = new IterativeUserStoreManager(\n-                            (AbstractUserStoreManager) userStoreManager);\n-                    prevUserStoreManager.setNextUserStoreManager(currentUserStoreManager);\n-                    prevUserStoreManager = currentUserStoreManager;\n-                }\n-            } else {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"UserStoreManager is not an instance of AbstractUserStoreManager hence authenticate the\"\n-                            + \" user through all the available user store list.\");\n-                }\n-                return authenticateInternalWithID(loginIdentifiers, domain, credential);\n-            }\n-        }\n-        // Authenticate using the initial user store from the user store preference list.\n-        return initialUserStoreManager.authenticateWithID(loginIdentifiers, domain, credential);\n-    }\n-\n-    private AuthenticationResult authenticateInternalWithID(List<LoginIdentifier> loginIdentifiers, String domain,\n-            Object credential) throws UserStoreException {\n-\n-        AbstractUserStoreManager abstractUserStoreManager = this;\n-        if (this instanceof IterativeUserStoreManager) {\n-            abstractUserStoreManager = ((IterativeUserStoreManager) this).getAbstractUserStoreManager();\n-        }\n-        boolean authenticated = false;\n-        AuthenticationResult authenticationResult = new AuthenticationResult(\n-                AuthenticationResult.AuthenticationStatus.FAIL);\n-\n-        Secret credentialObj;\n-        try {\n-            credentialObj = Secret.getSecret(credential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), loginIdentifiers, credential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-        }\n-\n-        try {\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = credentialObj;\n-                    } else {\n-                        credentialArgument = credential;\n-                    }\n-\n-                    if (!((AbstractUserOperationEventListener) listener)\n-                            .doPreAuthenticateWithID(loginIdentifiers, credentialArgument, abstractUserStoreManager)) {\n-                        handleOnAuthenticateFailureWithID(\n-                                ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                        UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), loginIdentifiers,\n-                                credentialArgument);\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(new FailureReason(\n-                                ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage()));\n-                        return authenticationResult;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                ex.getMessage()), loginIdentifiers, credential);\n-                throw ex;\n-            }\n-\n-            int tenantId = abstractUserStoreManager.getTenantId();\n-\n-            try {\n-\n-                for (LoginIdentifier loginIdentifier : loginIdentifiers) {\n-                    if (loginIdentifier.getLoginIdentifierType()\n-                            .equals(LoginIdentifier.LoginIdentifierType.CLAIM_URI)) {\n-                        String mappedAttribute = claimManager\n-                                .getAttributeName(getMyDomainName(), loginIdentifier.getLoginKey());\n-                        if (mappedAttribute != null) {\n-                            loginIdentifier.setLoginIdentifierType(LoginIdentifier.LoginIdentifierType.ATTRIBUTE);\n-                            loginIdentifier.setLoginKey(mappedAttribute);\n-                        }\n-                    }\n-                }\n-\n-                RealmService realmService = UserCoreUtil.getRealmService();\n-                if (realmService != null) {\n-                    boolean tenantActive = realmService.getTenantManager().isTenantActive(tenantId);\n-\n-                    if (!tenantActive) {\n-                        String errorCode = ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getCode();\n-                        String errorMessage = String\n-                                .format(ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getMessage(), tenantId);\n-                        log.warn(errorCode + \" - \" + errorMessage);\n-                        handleOnAuthenticateFailureWithID(errorCode, errorMessage, loginIdentifiers, credential);\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(new FailureReason(\"Inactive Tenant: \" + tenantId));\n-                        return authenticationResult;\n-                    }\n-                }\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                e.getMessage()), loginIdentifiers, credential);\n-                throw new UserStoreException(\"Error while trying to check tenant status for Tenant : \" + tenantId, e);\n-            }\n-\n-            if (StringUtils.isNotEmpty(domain)) {\n-                UserStoreManager secUserStoreManager = abstractUserStoreManager.getSecondaryUserStoreManager(domain);\n-                if (isUniqueUserIdEnabled(secUserStoreManager)) {\n-                    authenticationResult = ((AbstractUserStoreManager) secUserStoreManager)\n-                            .doAuthenticateWithID(loginIdentifiers, credential);\n-                } else {\n-                    String userName = getUsernameByClaims(loginIdentifiers);\n-                    String userID = userUniqueIDManger.getUniqueId(userName, this);\n-                    boolean status = ((AbstractUserStoreManager) secUserStoreManager)\n-                            .doAuthenticate(userName, credential);\n-                    if (status) {\n-                        User user = getUser(userID, userName);\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.SUCCESS);\n-                        authenticationResult.setAuthenticatedUser(user);\n-                    } else {\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(new FailureReason(\"Authentication failed.\"));\n-                    }\n-                }\n-\n-                if (authenticationResult.getAuthenticationStatus()\n-                        == AuthenticationResult.AuthenticationStatus.SUCCESS) {\n-                    authenticated = true;\n-                }\n-                if (authenticated) {\n-                    // Set domain in thread local variable for subsequent operations\n-                    UserCoreUtil.setDomainInThreadLocal(domain);\n-                }\n-            } else {\n-                // Domain is not provided. Try to authenticate with the current user store manager.\n-                if (abstractUserStoreManager.isUniqueUserIdEnabled()) {\n-                    authenticationResult = abstractUserStoreManager.doAuthenticateWithID(loginIdentifiers, credential);\n-                } else {\n-                    String userName = getUsernameByClaims(loginIdentifiers);\n-                    String userID = userUniqueIDManger.getUniqueId(userName, abstractUserStoreManager);\n-                    boolean status = abstractUserStoreManager.doAuthenticate(userName, credential);\n-                    if (status) {\n-                        User user = getUser(userID, userName);\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.SUCCESS);\n-                        authenticationResult.setAuthenticatedUser(user);\n-                    } else {\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(new FailureReason(\"Authentication failed.\"));\n-                    }\n-                }\n-\n-                if (authenticationResult.getAuthenticationStatus()\n-                        == AuthenticationResult.AuthenticationStatus.SUCCESS) {\n-                    authenticated = true;\n-                }\n-                if (authenticated) {\n-                    // Set domain in thread local variable for subsequent operations\n-                    UserCoreUtil\n-                            .setDomainInThreadLocal(UserCoreUtil.getDomainName(abstractUserStoreManager.realmConfig));\n-                }\n-            }\n-        } finally {\n-            credentialObj.clear();\n-        }\n-\n-        // If authentication fails in the previous step and if the user has not specified a\n-        // domain- then we need to execute chained UserStoreManagers recursively.\n-        if (!authenticated && StringUtils.isEmpty(domain)) {\n-            AbstractUserStoreManager userStoreManager;\n-            if (this instanceof IterativeUserStoreManager) {\n-                IterativeUserStoreManager iterativeUserStoreManager = (IterativeUserStoreManager) this;\n-                userStoreManager = iterativeUserStoreManager.nextUserStoreManager();\n-            } else {\n-                userStoreManager = (AbstractUserStoreManager) abstractUserStoreManager.getSecondaryUserStoreManager();\n-            }\n-            if (userStoreManager != null) {\n-                authenticationResult = userStoreManager.authenticateWithID(loginIdentifiers, null, credential);\n-                if (authenticationResult.getAuthenticationStatus()\n-                        == AuthenticationResult.AuthenticationStatus.SUCCESS) {\n-                    authenticated = true;\n-                }\n-            }\n-        }\n-\n-        if (!authenticated) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(),\n-                            \"Authentication failed\"), loginIdentifiers, credential);\n-        }\n-\n-        try {\n-            // You cannot change authentication decision in post handler to TRUE\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPostAuthenticateWithID(loginIdentifiers, authenticationResult, abstractUserStoreManager)) {\n-                    handleOnAuthenticateFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), loginIdentifiers,\n-                            credential);\n-\n-                    authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                    authenticationResult.setFailureReason(\n-                            new FailureReason(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage()));\n-                    return authenticationResult;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage(),\n-                            ex.getMessage()), loginIdentifiers, credential);\n-            throw ex;\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            if (!authenticated) {\n-                log.debug(\"Authentication failure. Wrong userID or password is provided.\");\n-            }\n-        }\n-\n-        return authenticationResult;\n-    }\n-\n-    public String getUsernameByClaims(List<LoginIdentifier> loginIdentifiers) throws UserStoreException {\n-\n-        if (loginIdentifiers.isEmpty()) {\n-            return null;\n-        }\n-\n-        for (LoginIdentifier loginIdentifier : loginIdentifiers) {\n-            if (loginIdentifier.getLoginIdentifierType()\n-                    .equals(LoginIdentifier.LoginIdentifierType.CLAIM_URI)) {\n-                String mappedAttribute;\n-                try {\n-                    mappedAttribute = claimManager.getAttributeName(getMyDomainName(), loginIdentifier.getLoginKey());\n-                } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                    throw new UserStoreException(e);\n-                }\n-                if (mappedAttribute != null) {\n-                    loginIdentifier.setLoginIdentifierType(LoginIdentifier.LoginIdentifierType.ATTRIBUTE);\n-                    loginIdentifier.setLoginKey(mappedAttribute);\n-                }\n-            }\n-        }\n-\n-        String userName = null;\n-        String[] resultedUserList = null;\n-        // Need to populate the claim email as the first element in the\n-        // passed array.\n-        for (LoginIdentifier loginIdentifier : loginIdentifiers) {\n-\n-            String attribute = loginIdentifier.getLoginKey();\n-            String attributeValue = loginIdentifier.getLoginValue();\n-\n-            if (attribute != null && attributeValue != null) {\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Searching users for \" + attribute + \" with the value :\" + attributeValue);\n-                }\n-                String[] matchedUserList = getUserListFromProperties(attribute, attributeValue, null);\n-\n-                if (!ArrayUtils.isEmpty(matchedUserList)) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Matched userList : \" + Arrays.toString(matchedUserList));\n-                    }\n-                    // If more than one user find the first matching user list. Hence need to define unique claims\n-                    if (resultedUserList != null) {\n-                        List<String> users = new ArrayList<>();\n-                        for (String user : resultedUserList) {\n-                            for (String matchedUser : matchedUserList) {\n-                                if (user.equals(matchedUser)) {\n-                                    users.add(matchedUser);\n-                                }\n-                            }\n-                        }\n-                        if (users.size() > 0) {\n-                            resultedUserList = new String[users.size()];\n-                            users.toArray(resultedUserList);\n-                            if (log.isDebugEnabled()) {\n-                                log.debug(\"Current matching temporary userlist :\" + Arrays.toString(resultedUserList));\n-                            }\n-                        } else {\n-                            if (log.isDebugEnabled()) {\n-                                log.debug(\"There are no users for \" + attribute + \" with the value : \" + attributeValue\n-                                        + \" in the previously filtered user list\");\n-                            }\n-                            return null;\n-                        }\n-                    } else {\n-                        resultedUserList = matchedUserList;\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\"Current matching temporary userlist :\" + Arrays.toString(resultedUserList));\n-                        }\n-                    }\n-\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\n-                                \"There are no matching users for \" + attribute + \" with the value : \" + attributeValue);\n-                    }\n-                    return null;\n-                }\n-            }\n-        }\n-\n-        if (resultedUserList.length == 1) {\n-            userName = resultedUserList[0];\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"There are more than one user in the result set : \" + Arrays.toString(resultedUserList));\n-            }\n-        }\n-        return userName;\n-    }\n-\n-    @Override\n-    public final AuthenticationResult authenticateWithID(final String preferredUserNameClaim,\n-            final String preferredUserNameValue, final Object credential, final String profileName)\n-            throws UserStoreException {\n-\n-        try {\n-            return AccessController.doPrivileged((PrivilegedExceptionAction<AuthenticationResult>) () -> {\n-                if (!validateUserNameAndCredential(preferredUserNameClaim, preferredUserNameValue, credential)) {\n-                    AuthenticationResult authenticationResult = new AuthenticationResult(\n-                            AuthenticationResult.AuthenticationStatus.FAIL);\n-                    authenticationResult.setFailureReason(new FailureReason(\"Invalid Credentials\"));\n-                    return authenticationResult;\n-                }\n-                int index = preferredUserNameValue.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-                boolean domainProvided = index > 0;\n-                return authenticateWithID(preferredUserNameClaim, preferredUserNameValue, credential, profileName,\n-                        domainProvided);\n-            });\n-        } catch (PrivilegedActionException e) {\n-            if (!(e.getException() instanceof UserStoreException)) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(), e.getMessage()),\n-                        preferredUserNameClaim, preferredUserNameValue, credential);\n-            }\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    /**\n-     * Given the preferred user name and a credential object, the method will validate whether the user can be\n-     * authenticated.\n-     *\n-     * @param preferredUserNameClaim The preferred user name claim.\n-     * @param preferredUserNameValue The preferred user name value.\n-     * @param credential             The credential of a user.\n-     * @param profileName            profile name.\n-     * @param domainProvided         Whether the domain is provided.\n-     * @return authenticated user.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected AuthenticationResult authenticateWithID(final String preferredUserNameClaim,\n-                                                      final String preferredUserNameValue,\n-                                                      final Object credential, final String profileName,\n-                                                      final boolean domainProvided) throws UserStoreException {\n-\n-        try {\n-            return AccessController.doPrivileged(\n-                    (PrivilegedExceptionAction<AuthenticationResult>) ()\n-                            -> authenticateInternalIterationWithID(preferredUserNameClaim,\n-                            preferredUserNameValue, credential, profileName, domainProvided));\n-        } catch (PrivilegedActionException e) {\n-            throw (UserStoreException) e.getException();\n-        }\n-\n-    }\n-\n-    private AuthenticationResult authenticateInternalIterationWithID(String preferredUserNameClaim,\n-                                                                     String preferredUserNameValue,\n-                                                                     Object credential, String profileName,\n-                                                                     boolean domainProvided) throws UserStoreException {\n-\n-        List<String> userStorePreferenceOrder = new ArrayList<>();\n-        // Check whether user store chain needs to be generated or not.\n-        if (isUserStoreChainNeeded(userStorePreferenceOrder)) {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"User store chain generation is needed hence generating the user store chain using the user\"\n-                        + \" store preference order: \" + userStorePreferenceOrder);\n-            }\n-            return generateUserStoreChainWithID(preferredUserNameClaim, preferredUserNameValue, credential, profileName,\n-                    domainProvided, userStorePreferenceOrder);\n-        } else {\n-            // Authenticate the user.\n-            return authenticateInternalWithID(preferredUserNameClaim, preferredUserNameValue, credential, profileName,\n-                    domainProvided);\n-        }\n-    }\n-\n-    private AuthenticationResult generateUserStoreChainWithID(String preferredUserNameClaim,\n-            String preferredUserNameValue, Object credential, String profileName, boolean domainProvided,\n-            List<String> userStorePreferenceOrder) throws UserStoreException {\n-\n-        // If domain name is provided, directly authenticate using the corresponding user store.\n-        if (domainProvided) {\n-            String providedDomainName = this.getUserStore(preferredUserNameValue).getDomainName();\n-            // Check whether provided domain is in the preference list.\n-            if (!userStorePreferenceOrder.contains(providedDomainName)) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Authentication failure. Invalid username or password is provided.\");\n-                }\n-                handleOnAuthenticateFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(),\n-                                \"Authentication failed\"), preferredUserNameValue, credential);\n-                throw new UserStoreException(\"Authentication failed. Invalid username or password.\");\n-            }\n-            UserStoreManager userStoreManager = this.getSecondaryUserStoreManager(providedDomainName);\n-            if (!(userStoreManager instanceof AbstractUserStoreManager)) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"UserStoreManager is not an instance of AbstractUserStoreManager. Hence \" +\n-                            \"authenticate the user through all the available user store list.\");\n-                }\n-                return authenticateInternalWithID(preferredUserNameClaim, preferredUserNameValue, credential,\n-                        profileName, domainProvided);\n-            }\n-            IterativeUserStoreManager iterativeUserStoreManager = new IterativeUserStoreManager(\n-                    (AbstractUserStoreManager) userStoreManager);\n-            return iterativeUserStoreManager.\n-                    authenticateWithID(preferredUserNameClaim, preferredUserNameValue, credential, profileName);\n-        }\n-        // If domain is not provided, generate a user store chain.\n-        IterativeUserStoreManager initialUserStoreManager = null;\n-        IterativeUserStoreManager prevUserStoreManager = null;\n-        for (String domainName : userStorePreferenceOrder) {\n-            UserStoreManager userStoreManager = this.getSecondaryUserStoreManager(domainName);\n-            // If the user store manager is instance of AbstractUserStoreManager then generate a user store chain using\n-            // IterativeUserStoreManager.\n-            if (userStoreManager instanceof AbstractUserStoreManager) {\n-                if (initialUserStoreManager == null) {\n-                    prevUserStoreManager = new IterativeUserStoreManager((AbstractUserStoreManager) userStoreManager);\n-                    initialUserStoreManager = prevUserStoreManager;\n-                } else {\n-                    IterativeUserStoreManager currentUserStoreManager = new IterativeUserStoreManager(\n-                            (AbstractUserStoreManager) userStoreManager);\n-                    prevUserStoreManager.setNextUserStoreManager(currentUserStoreManager);\n-                    prevUserStoreManager = currentUserStoreManager;\n-                }\n-            } else {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"UserStoreManager is not an instance of AbstractUserStoreManager hence authenticate the\"\n-                            + \" user through all the available user store list.\");\n-                }\n-                return authenticateInternalWithID(preferredUserNameClaim, preferredUserNameValue, credential,\n-                        profileName, domainProvided);\n-            }\n-        }\n-        // Authenticate using the initial user store from the user store preference list.\n-        return initialUserStoreManager\n-                .authenticateWithID(preferredUserNameClaim, preferredUserNameValue, credential, profileName);\n-    }\n-\n-    private AuthenticationResult authenticateInternalWithID(String preferredUserNameClaim,\n-            String preferredUserNameValue, Object credential, String profileName, boolean domainProvided)\n-            throws UserStoreException {\n-\n-        AbstractUserStoreManager abstractUserStoreManager = this;\n-        if (this instanceof IterativeUserStoreManager) {\n-            abstractUserStoreManager = ((IterativeUserStoreManager) this).getAbstractUserStoreManager();\n-        }\n-\n-        boolean authenticated = false;\n-        AuthenticationResult authenticationResult = new AuthenticationResult(\n-                AuthenticationResult.AuthenticationStatus.FAIL);\n-\n-        UserStore userStore = abstractUserStoreManager.getUserStore(preferredUserNameValue);\n-        if (userStore.isRecurssive() && userStore.getUserStoreManager() instanceof AbstractUserStoreManager) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .authenticateWithID(preferredUserNameClaim, userStore.getDomainFreeName(), credential, profileName);\n-        }\n-\n-        Secret credentialObj;\n-        try {\n-            credentialObj = Secret.getSecret(credential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), preferredUserNameClaim,\n-                    preferredUserNameValue, credential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                Object credentialArgument;\n-                if (listener instanceof SecretHandleableListener) {\n-                    credentialArgument = credentialObj;\n-                } else {\n-                    credentialArgument = credential;\n-                }\n-\n-                if (!((AbstractUserStoreManagerListener) listener)\n-                        .authenticateWithID(preferredUserNameClaim, preferredUserNameValue, credentialArgument,\n-                                abstractUserStoreManager)) {\n-                    handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(), preferredUserNameClaim,\n-                            preferredUserNameValue, credentialArgument);\n-\n-                    authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                    authenticationResult.setFailureReason(\n-                            new FailureReason(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage()));\n-                    return authenticationResult;\n-                }\n-            }\n-\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = credentialObj;\n-                    } else {\n-                        credentialArgument = credential;\n-                    }\n-\n-                    if (!((AbstractUserOperationEventListener) listener)\n-                            .doPreAuthenticateWithID(preferredUserNameClaim, preferredUserNameValue, credentialArgument,\n-                                    abstractUserStoreManager)) {\n-                        handleOnAuthenticateFailureWithID(\n-                                ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                        UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE),\n-                                preferredUserNameClaim, preferredUserNameValue, credentialArgument);\n-\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(new FailureReason(\n-                                ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage()));\n-                        return authenticationResult;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                ex.getMessage()), preferredUserNameClaim, preferredUserNameValue, credential);\n-                throw ex;\n-            }\n-            // #################### </Listeners> #####################################################\n-\n-            int tenantId = abstractUserStoreManager.getTenantId();\n-\n-            try {\n-                RealmService realmService = UserCoreUtil.getRealmService();\n-                if (realmService != null) {\n-                    boolean tenantActive = realmService.getTenantManager().isTenantActive(tenantId);\n-\n-                    if (!tenantActive) {\n-                        String errorCode = ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getCode();\n-                        String errorMessage = String\n-                                .format(ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getMessage(), tenantId);\n-                        log.warn(errorCode + \" - \" + errorMessage);\n-                        handleOnAuthenticateFailureWithID(errorCode, errorMessage, preferredUserNameClaim,\n-                                preferredUserNameValue, credential);\n-\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(\n-                                new FailureReason(ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getMessage()));\n-                        return authenticationResult;\n-                    }\n-                }\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                e.getMessage()), preferredUserNameClaim, preferredUserNameValue, credential);\n-                throw new UserStoreException(\"Error while trying to check tenant status for Tenant : \" + tenantId, e);\n-            }\n-\n-            // We are here due to two reason. Either there is no secondary UserStoreManager or no\n-            // domain name provided with user name.\n-\n-            try {\n-                String preferredUserNameProperty = claimManager\n-                        .getAttributeName(getMyDomainName(), preferredUserNameClaim);\n-                // Let's authenticate with the primary UserStoreManager.\n-\n-                if (abstractUserStoreManager.isUniqueUserIdEnabled()) {\n-                    authenticationResult = abstractUserStoreManager\n-                            .doAuthenticateWithID(preferredUserNameProperty, preferredUserNameValue, credentialObj,\n-                                    profileName);\n-                } else {\n-                    List<String> users = doGetUserList(preferredUserNameClaim, preferredUserNameValue, profileName,\n-                            abstractUserStoreManager.getMyDomainName(), abstractUserStoreManager);\n-                    if (users.size() != 1) {\n-                        String message = \"Users count matching to claim: \" + preferredUserNameClaim + \" and value: \"\n-                                + preferredUserNameValue + \" is: \" + users.size();\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(new FailureReason(message));\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(message);\n-                        }\n-                    } else {\n-                        boolean status = abstractUserStoreManager.doAuthenticate(users.get(0), credentialObj);\n-                        authenticationResult = new AuthenticationResult(status ?\n-                                AuthenticationResult.AuthenticationStatus.SUCCESS :\n-                                AuthenticationResult.AuthenticationStatus.FAIL);\n-                        if (status) {\n-                            String userID = userUniqueIDManger.getUniqueId(users.get(0), this);\n-                            User user = userUniqueIDManger.getUser(userID, this);\n-                            authenticationResult.setAuthenticatedUser(user);\n-                        } else {\n-                            authenticationResult.setFailureReason(new FailureReason(\"Invalid credentials.\"));\n-                        }\n-                    }\n-                }\n-                if (authenticationResult.getAuthenticationStatus()\n-                        == AuthenticationResult.AuthenticationStatus.SUCCESS) {\n-                    authenticated = true;\n-                }\n-            } catch (Exception e) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(), e.getMessage()),\n-                        preferredUserNameClaim, preferredUserNameValue, credential);\n-                // We can ignore and proceed. Ignore the results from this user store.\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Error occurred while authenticating user: \" + preferredUserNameValue, e);\n-                } else {\n-                    log.error(e);\n-                }\n-                authenticated = false;\n-            }\n-\n-        } finally {\n-            credentialObj.clear();\n-        }\n-\n-        if (authenticated) {\n-            // Set domain in thread local variable for subsequent operations\n-            UserCoreUtil.setDomainInThreadLocal(UserCoreUtil.getDomainName(abstractUserStoreManager.realmConfig));\n-        }\n-\n-        // If authentication fails in the previous step and if the user has not specified a\n-        // domain- then we need to execute chained UserStoreManagers recursively.\n-        if (!authenticated && !domainProvided) {\n-            AbstractUserStoreManager userStoreManager;\n-            if (this instanceof IterativeUserStoreManager) {\n-                IterativeUserStoreManager iterativeUserStoreManager = (IterativeUserStoreManager) this;\n-                userStoreManager = iterativeUserStoreManager.nextUserStoreManager();\n-            } else {\n-                userStoreManager = (AbstractUserStoreManager) abstractUserStoreManager.getSecondaryUserStoreManager();\n-            }\n-            if (userStoreManager != null) {\n-                authenticationResult = userStoreManager\n-                        .authenticateWithID(preferredUserNameClaim, preferredUserNameValue, credential, profileName,\n-                                domainProvided);\n-            }\n-        }\n-\n-        if (!authenticated) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(),\n-                            \"Authentication failed\"), preferredUserNameClaim, preferredUserNameValue, credential);\n-        }\n-\n-        try {\n-            // You cannot change authentication decision in post handler to TRUE\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPostAuthenticateWithID(preferredUserNameClaim, preferredUserNameValue, authenticationResult,\n-                                abstractUserStoreManager)) {\n-                    handleOnAuthenticateFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), preferredUserNameClaim,\n-                            preferredUserNameValue, credential);\n-                    authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                    authenticationResult.setFailureReason(\n-                            new FailureReason(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage()));\n-                    return authenticationResult;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage(),\n-                            ex.getMessage()), preferredUserNameClaim, preferredUserNameValue, credential);\n-            throw ex;\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            if (!authenticated) {\n-                log.debug(\"Authentication failure. Wrong username or password is provided.\");\n-            }\n-        }\n-        return authenticationResult;\n-    }\n-\n-    @Override\n-    public final AuthenticationResult authenticateWithID(final String userID, final Object credential)\n-            throws UserStoreException {\n-\n-        try {\n-            return AccessController.doPrivileged((PrivilegedExceptionAction<AuthenticationResult>) () -> {\n-                if (!validateUserIDAndCredential(userID, credential)) {\n-                    AuthenticationResult authenticationResult = new AuthenticationResult(\n-                            AuthenticationResult.AuthenticationStatus.FAIL);\n-                    authenticationResult.setFailureReason(new FailureReason(\"Invalid Credentials\"));\n-                    return authenticationResult;\n-                }\n-\n-                List<String> userStorePreferenceOrder = new ArrayList<>();\n-                // Check whether user store chain needs to be generated or not.\n-                if (isUserStoreChainNeeded(userStorePreferenceOrder)) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\n-                                \"User store chain generation is needed hence generating the user store chain using \"\n-                                        + \"the user\"\n-                                        + \" store preference order: \" + userStorePreferenceOrder);\n-                    }\n-                    return generateUserStoreChainWithID(userID, credential, userStorePreferenceOrder);\n-                } else {\n-                    // Authenticate the user.\n-                    return authenticateInternalWithID(userID, credential);\n-                }\n-\n-            });\n-        } catch (PrivilegedActionException e) {\n-            if (!(e.getException() instanceof UserStoreException)) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(), e.getMessage()),\n-                        userID, credential);\n-            }\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    private AuthenticationResult generateUserStoreChainWithID(String userID, Object credential,\n-            List<String> userStorePreferenceOrder) throws UserStoreException {\n-\n-        IterativeUserStoreManager initialUserStoreManager = null;\n-        IterativeUserStoreManager prevUserStoreManager = null;\n-        for (String domainName : userStorePreferenceOrder) {\n-            UserStoreManager userStoreManager = this.getSecondaryUserStoreManager(domainName);\n-            // If the user store manager is instance of AbstractUserStoreManager then generate a user store chain using\n-            // IterativeUserStoreManager.\n-            if (userStoreManager instanceof AbstractUserStoreManager) {\n-                if (initialUserStoreManager == null) {\n-                    prevUserStoreManager = new IterativeUserStoreManager((AbstractUserStoreManager) userStoreManager);\n-                    initialUserStoreManager = prevUserStoreManager;\n-                } else {\n-                    IterativeUserStoreManager currentUserStoreManager = new IterativeUserStoreManager(\n-                            (AbstractUserStoreManager) userStoreManager);\n-                    prevUserStoreManager.setNextUserStoreManager(currentUserStoreManager);\n-                    prevUserStoreManager = currentUserStoreManager;\n-                }\n-            } else {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"UserStoreManager is not an instance of AbstractUserStoreManager hence authenticate the\"\n-                            + \" user through all the available user store list.\");\n-                }\n-                return authenticateInternalWithID(userID, credential);\n-            }\n-        }\n-        // Authenticate using the initial user store from the user store preference list.\n-        return initialUserStoreManager.authenticateWithID(userID, credential);\n-    }\n-\n-    private AuthenticationResult authenticateInternalWithID(String userID, Object credential)\n-            throws UserStoreException {\n-\n-        UserStore userStoreWithID = getUserStoreWithID(userID);\n-        AbstractUserStoreManager abstractUserStoreManager = (AbstractUserStoreManager) userStoreWithID.getUserStoreManager();\n-\n-        if (userStoreWithID.getUserStoreManager() instanceof IterativeUserStoreManager) {\n-            abstractUserStoreManager = ((IterativeUserStoreManager) userStoreWithID.getUserStoreManager()).getAbstractUserStoreManager();\n-        }\n-        boolean authenticated = false;\n-        AuthenticationResult authenticationResult = new AuthenticationResult(\n-                AuthenticationResult.AuthenticationStatus.FAIL);\n-\n-        Secret credentialObj;\n-        try {\n-            credentialObj = Secret.getSecret(credential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), userID, credential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-        }\n-\n-        try {\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = credentialObj;\n-                    } else {\n-                        credentialArgument = credential;\n-                    }\n-\n-                    if (!((AbstractUserOperationEventListener) listener)\n-                            .doPreAuthenticateWithID(userID, credentialArgument, abstractUserStoreManager)) {\n-                        handleOnAuthenticateFailureWithID(\n-                                ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                        UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID,\n-                                credentialArgument);\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(new FailureReason(\n-                                ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage()));\n-                        return authenticationResult;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                ex.getMessage()), userID, credential);\n-                throw ex;\n-            }\n-\n-            int tenantId = abstractUserStoreManager.getTenantId();\n-\n-            try {\n-                RealmService realmService = UserCoreUtil.getRealmService();\n-                if (realmService != null) {\n-                    boolean tenantActive = realmService.getTenantManager().isTenantActive(tenantId);\n-\n-                    if (!tenantActive) {\n-                        String errorCode = ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getCode();\n-                        String errorMessage = String\n-                                .format(ErrorMessages.ERROR_CODE_TENANT_DEACTIVATED.getMessage(), tenantId);\n-                        log.warn(errorCode + \" - \" + errorMessage);\n-                        handleOnAuthenticateFailureWithID(errorCode, errorMessage, userID, credential);\n-                        authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                        authenticationResult.setFailureReason(new FailureReason(\"Inactive Tenant: \" + tenantId));\n-                        return authenticationResult;\n-                    }\n-                }\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_AUTHENTICATION.getMessage(),\n-                                e.getMessage()), userID, credential);\n-                throw new UserStoreException(\"Error while trying to check tenant status for Tenant : \" + tenantId, e);\n-            }\n-\n-            if (isUniqueUserIdEnabled(abstractUserStoreManager)) {\n-                authenticationResult = ((AbstractUserStoreManager) abstractUserStoreManager)\n-                        .doAuthenticateWithID(userID, credential);\n-            } else {\n-                User user = userUniqueIDManger\n-                        .getUser(userID, (AbstractUserStoreManager) abstractUserStoreManager);\n-                boolean status = ((AbstractUserStoreManager) abstractUserStoreManager)\n-                        .doAuthenticate(user.getUsername(), credential);\n-                if (status) {\n-                    authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.SUCCESS);\n-                    authenticationResult.setAuthenticatedUser(user);\n-                } else {\n-                    authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                    authenticationResult\n-                            .setFailureReason(new FailureReason(\"Authentication failed for userID: \" + userID));\n-                }\n-            }\n-\n-            if (authenticationResult.getAuthenticationStatus()\n-                    == AuthenticationResult.AuthenticationStatus.SUCCESS) {\n-                authenticated = true;\n-            }\n-            if (authenticated) {\n-                // Set domain in thread local variable for subsequent operations\n-                UserCoreUtil.setDomainInThreadLocal(userStoreWithID.getDomainName());\n-            }\n-        } finally {\n-            credentialObj.clear();\n-        }\n-\n-        if (!authenticated) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_AUTHENTICATION.getMessage(),\n-                            \"Authentication failed\"), userID, credential);\n-        }\n-\n-        try {\n-            // You cannot change authentication decision in post handler to TRUE\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPostAuthenticateWithID(userID, authenticationResult, abstractUserStoreManager)) {\n-                    handleOnAuthenticateFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, credential);\n-\n-                    authenticationResult.setAuthenticationStatus(AuthenticationResult.AuthenticationStatus.FAIL);\n-                    authenticationResult.setFailureReason(\n-                            new FailureReason(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage()));\n-                    return authenticationResult;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleOnAuthenticateFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_POST_AUTHENTICATION.getMessage(),\n-                            ex.getMessage()), userID, credential);\n-            throw ex;\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            if (!authenticated) {\n-                log.debug(\"Authentication failure. Wrong userID or password is provided.\");\n-            }\n-        }\n-\n-        return authenticationResult;\n-    }\n-\n-    @Override\n-    public final List<User> listUsersWithID(String filter, int maxItemLimit) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, int.class };\n-            Object object = callSecure(\"listUsersWithID\", new Object[] { filter, maxItemLimit }, argTypes);\n-            return (List<User>) object;\n-        }\n-\n-        int index;\n-        index = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        List<User> userList;\n-\n-        // Check whether we have a secondary UserStoreManager setup.\n-        if (index > 0) {\n-            // Using the short-circuit. User name comes with the domain name.\n-            String domain = filter.substring(0, index);\n-\n-            UserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-            if (secManager != null) {\n-                // We have a secondary UserStoreManager registered for this domain.\n-                filter = filter.substring(index + 1);\n-                if (secManager instanceof AbstractUserStoreManager) {\n-                    // If unique id feature is not enabled, we have to call the legacy methods.\n-                    if (!isUniqueUserIdEnabled(secManager)) {\n-                        userList = userUniqueIDManger.listUsers(doListUsers(filter, maxItemLimit), this);\n-                    } else {\n-                        userList = ((AbstractUserStoreManager) secManager)\n-                                .doListUsersWithID(filter, maxItemLimit);\n-                    }\n-                    handlePostGetUserListWithID(null, null, userList, true);\n-                    return userList;\n-                }\n-            }\n-        } else if (index == 0) {\n-            if (!isUniqueUserIdEnabled()) {\n-                userList = userUniqueIDManger.listUsers(doListUsers(filter.substring(1), maxItemLimit), this);\n-            } else {\n-                userList = listUsersWithID(filter.substring(1), maxItemLimit);\n-            }\n-\n-            handlePostGetUserListWithID(null, null, userList, true);\n-            return userList;\n-        }\n-\n-        try {\n-            if (!isUniqueUserIdEnabled()) {\n-                userList = userUniqueIDManger.listUsers(doListUsers(filter, maxItemLimit), this);\n-            } else {\n-                userList = doListUsersWithID(filter, maxItemLimit);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(), ex.getMessage()),\n-                    null, null, null);\n-            throw ex;\n-        }\n-\n-        String primaryDomain = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\n-        if (this.getSecondaryUserStoreManager() != null) {\n-            for (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-                if (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n-                    continue;\n-                }\n-                UserStoreManager storeManager = entry.getValue();\n-                if (storeManager instanceof AbstractUserStoreManager) {\n-                    try {\n-                        List<User> secondUserList;\n-                        if (!isUniqueUserIdEnabled(storeManager)) {\n-                            secondUserList = userUniqueIDManger.listUsers(((AbstractUserStoreManager) storeManager)\n-                                    .doListUsers(filter, maxItemLimit), this);\n-                        } else {\n-                            secondUserList = ((AbstractUserStoreManager) storeManager)\n-                                    .doListUsersWithID(filter, maxItemLimit);\n-                        }\n-                        userList.addAll(secondUserList);\n-                    } catch (UserStoreException ex) {\n-                        handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(),\n-                                        ex.getMessage()), null, null, null);\n-\n-                        // We can ignore and proceed. Ignore the results from this user store.\n-                        log.error(ex);\n-                    }\n-                } else {\n-                    List<User> secondUserList = ((UniqueIDUserStoreManager) storeManager)\n-                            .listUsersWithID(filter, maxItemLimit);\n-                    userList.addAll(secondUserList);\n-                }\n-            }\n-        }\n-\n-        handlePostGetUserListWithID(null, null, userList, true);\n-        return userList;\n-    }\n-\n-    @Override\n-    public User updateUserName(String userID, String newUserName) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"updateUserName operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"updateUserName operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public User getUserWithID(String userID, String[] requestedClaims, String profileName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[] { String.class, String[].class, String.class };\n-            Object object = callSecure(\"getUserWithID\", new Object[] { userID, requestedClaims, profileName },\n-                    argTypes);\n-            return (User) object;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .getUserWithID(userStore.getDomainFreeUserId(), requestedClaims, profileName);\n-        }\n-\n-        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        User user = null;\n-        boolean isUserExists;\n-        if (isUniqueIdEnabled) {\n-            isUserExists = doCheckExistingUserWithID(userID);\n-        } else {\n-            user = userUniqueIDManger.getUser(userID, this);\n-            isUserExists = user != null;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleGetUserFailureWithID(errorCode, errorMessage, userID, requestedClaims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage, errorCode);\n-        }\n-        // check for null claim list\n-        if (requestedClaims == null) {\n-            requestedClaims = new String[0];\n-        }\n-\n-        try {\n-            // If unique id feature is not enabled, we have to call the legacy methods.\n-            if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                if (user == null) {\n-                    user = userUniqueIDManger.getUser(userID, this);\n-                }\n-            } else {\n-                user = getUserFromID(userID, requestedClaims, userStore.getDomainName(), profileName);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userID, requestedClaims, profileName);\n-            throw ex;\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserWithID(userID, requestedClaims, profileName, user, this)) {\n-                        handleGetUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getMessage(),\n-                                        UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID,\n-                                requestedClaims, profileName);\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userID, requestedClaims, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        return user;\n-    }\n-\n-    @Override\n-    public boolean isExistingUserWithID(String userID) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class };\n-            Object object = callSecure(\"isExistingUserWithID\", new Object[] { userID }, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        if (UserCoreUtil.isRegistrySystemUser(userID)) {\n-            return true;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .isExistingUserWithID(userStore.getDomainFreeUserId());\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (userStore.isSystemStore()) {\n-            return systemUserRoleManager.isExistingSystemUser(userID);\n-        }\n-\n-        // If unique id feature is not enabled, we have to call the legacy methods.\n-        if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-            User user = userUniqueIDManger.getUser(userID, this);\n-            if (user == null) {\n-                return false;\n-            }\n-            return doCheckExistingUser(user.getUsername());\n-        } else {\n-            return doCheckExistingUserWithID(userID);\n-        }\n-    }\n-\n-    @Override\n-    public List<String> getRoleListOfUserWithID(String userID) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class };\n-            Object object = callSecure(\"getRoleListOfUserWithID\", new Object[] { userID }, argTypes);\n-            return (List<String>) object;\n-        }\n-\n-        List<String> roleNames;\n-\n-        // anonymous user is only assigned to  anonymous role\n-        if (CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userID)) {\n-            return new ArrayList<String>(){{ add(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME); }};\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .getRoleListOfUserWithID(userStore.getDomainFreeUserId());\n-        }\n-\n-        // Check whether roles exist in cache\n-        String userName = this.getUserNameFromUserID(userID);\n-        if (StringUtils.isNotEmpty(userName)) {\n-            String[] roleListOfUserFromCache = getRoleListOfUserFromCache(this.tenantId, userName);\n-            if (roleListOfUserFromCache != null) {\n-                roleNames = Arrays.asList(roleListOfUserFromCache);\n-                if (roleNames.size() > 0) {\n-                    return roleNames;\n-                }\n-            }\n-        }\n-\n-        if (userStore.isSystemStore()) {\n-            return Arrays.asList(systemUserRoleManager.getSystemRoleListOfUser(userStore.getDomainFreeUserId()));\n-        }\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        // If unique id feature is not enabled, we have to call the legacy methods.\n-        if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-            if (StringUtils.isEmpty(userName)) {\n-                return Arrays.asList(realmConfig.getEveryOneRoleName());\n-            }\n-            return Arrays.asList(doGetRoleListOfUser(userName, \"*\"));\n-        } else {\n-            return doGetRoleListOfUserWithID(userID, \"*\");\n-        }\n-    }\n-\n-    @Override\n-    public final List<User> getUserListOfRoleWithID(String roleName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class };\n-            Object object = callSecure(\"getUserListOfRoleWithID\", new Object[] { roleName }, argTypes);\n-            return (List<User>) object;\n-        }\n-\n-        return getUserListOfRoleWithID(roleName, QUERY_FILTER_STRING_ANY, QUERY_MAX_ITEM_LIMIT_ANY);\n-    }\n-\n-    @Override\n-    public final List<User> getUserListOfRoleWithID(String roleName, String filter, int maxItemLimit)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class, int.class };\n-            Object object = callSecure(\"getUserListOfRoleWithID\", new Object[] { roleName, filter, maxItemLimit },\n-                    argTypes);\n-            return (List<User>) object;\n-        }\n-\n-        List<User> users = new ArrayList<>();\n-\n-        // If role does not exit, just return\n-        if (!isExistingRole(roleName)) {\n-            handleDoPostGetUserListOfRoleWithID(roleName, users);\n-            return users;\n-        }\n-\n-        UserStore userStore = getUserStoreOfRoles(roleName);\n-\n-        if (userStore.isRecurssive()) {\n-            UserStoreManager resolvedUserStoreManager = userStore.getUserStoreManager();\n-            if (resolvedUserStoreManager instanceof AbstractUserStoreManager) {\n-                return ((AbstractUserStoreManager) resolvedUserStoreManager)\n-                        .getUserListOfRoleWithID(userStore.getDomainFreeName(), filter, maxItemLimit);\n-            } else {\n-                return ((UniqueIDUserStoreManager) resolvedUserStoreManager)\n-                        .getUserListOfRoleWithID(userStore.getDomainFreeName());\n-            }\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here\n-        // ################################\n-\n-        if (userStore.isSystemStore()) {\n-            String[] userArray = systemUserRoleManager.getUserListOfSystemRole(userStore.getDomainFreeName());\n-            List<User> userList = UserCoreUtil.getUserList(userArray);\n-            handleDoPostGetUserListOfRoleWithID(roleName, userList);\n-            return userList;\n-        }\n-\n-        String[] userNamesInHybrid;\n-        if (userStore.isHybridRole()) {\n-            if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(userStore.getDomainName())) {\n-                userNamesInHybrid = hybridRoleManager.getUserListOfHybridRole(userStore.getDomainFreeName());\n-            } else {\n-                userNamesInHybrid = hybridRoleManager.getUserListOfHybridRole(userStore.getDomainAwareName());\n-            }\n-\n-            // Get the users of associated groups of the role.\n-            if (isRoleAndGroupSeparationEnabled()) {\n-                Set<String> userListOfGroups = new HashSet<>();\n-                String[] groupsOfRole;\n-                if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(userStore.getDomainName())) {\n-                    groupsOfRole = hybridRoleManager.getGroupListOfHybridRole(userStore.getDomainFreeName());\n-                } else {\n-                    groupsOfRole = hybridRoleManager.getGroupListOfHybridRole(userStore.getDomainAwareName());\n-                }\n-                for (String group : groupsOfRole) {\n-                    userListOfGroups.addAll(Arrays.asList(getUserListOfRole(group, filter, maxItemLimit)));\n-                }\n-                userNamesInHybrid = UserCoreUtil.combine(userNamesInHybrid, new ArrayList<>(userListOfGroups));\n-            }\n-\n-            // remove domain\n-            List<String> finalNameList = new ArrayList<>();\n-            String displayNameAttribute = this.realmConfig.getUserStoreProperty(LDAPConstants.DISPLAY_NAME_ATTRIBUTE);\n-\n-            if (userNamesInHybrid != null && userNamesInHybrid.length > 0) {\n-                if (displayNameAttribute != null && displayNameAttribute.trim().length() > 0) {\n-                    for (String userName : userNamesInHybrid) {\n-                        String domainName = UserCoreUtil.extractDomainFromName(userName);\n-                        if (domainName == null || domainName.trim().length() == 0) {\n-                            finalNameList.add(userName);\n-                        }\n-                        UserStoreManager userManager = userStoreManagerHolder.get(domainName);\n-                        userName = UserCoreUtil.removeDomainFromName(userName);\n-                        if (userManager != null) {\n-                            String[] displayNames;\n-                            if (userManager instanceof AbstractUserStoreManager) {\n-                                // get displayNames\n-                                displayNames = ((AbstractUserStoreManager) userManager)\n-                                        .doGetDisplayNamesForInternalRole(new String[] { userName });\n-                            } else {\n-                                displayNames = userManager.getRoleNames();\n-                            }\n-\n-                            for (String displayName : displayNames) {\n-                                // if domain names are not added by above method, add it\n-                                // here\n-                                String nameWithDomain = UserCoreUtil.addDomainToName(displayName, domainName);\n-                                finalNameList.add(nameWithDomain);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    List<User> usersInHybrid = userUniqueIDManger.listUsers(userNamesInHybrid, this);\n-                    handleDoPostGetUserListOfRoleWithID(roleName, usersInHybrid);\n-                    return usersInHybrid;\n-                }\n-            }\n-            List<User> usersList = userUniqueIDManger.listUsers(finalNameList, this);\n-            handleDoPostGetUserListOfRoleWithID(roleName, usersList);\n-            return usersList;\n-        }\n-        if (readGroupsEnabled) {\n-            // If unique id feature is not enabled, we have to call the legacy methods.\n-            if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                users = userUniqueIDManger.listUsers(doGetUserListOfRole(roleName, filter, maxItemLimit), this);\n-            } else {\n-                users = doGetUserListOfRoleWithID(roleName, filter, maxItemLimit);\n-            }\n-            handleDoPostGetUserListOfRoleWithID(roleName, users);\n-        }\n-        return users;\n-    }\n-\n-    @Override\n-    public final String getUserClaimValueWithID(String userID, String claim, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class, String.class };\n-            Object object = callSecure(\"getUserClaimValueWithID\", new Object[] { userID, claim, profileName },\n-                    argTypes);\n-            return (String) object;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .getUserClaimValueWithID(userStore.getDomainFreeUserId(), claim, profileName);\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        boolean isUserExists;\n-        User user = null;\n-        if (isUniqueIdEnabled) {\n-            isUserExists = doCheckExistingUserWithID(userID);\n-        } else{\n-            user = userUniqueIDManger.getUser(userID, this);\n-            isUserExists = user != null;\n-        }\n-\n-        if (!isUserExists) {\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            handleGetUserClaimValueFailureWithID(errorCode, errorMessage, userID, claim, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        Map<String, String> finalValues;\n-        try {\n-            // If unique id feature is not enabled, we have to call the legacy methods.\n-            if (!isUniqueIdEnabled) {\n-                finalValues = doGetUserClaimValues(user.getUsername(), new String[]{claim},\n-                        userStore.getDomainName(), profileName);\n-            } else {\n-                finalValues = doGetUserClaimValuesWithID(userID, new String[]{claim}, userStore.getDomainName(),\n-                        profileName);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserClaimValueFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userID, claim, profileName);\n-            throw ex;\n-        }\n-\n-        String value = null;\n-\n-        if (finalValues != null) {\n-            value = finalValues.get(claim);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-\n-        List<String> list = new ArrayList<>();\n-        if (value != null) {\n-            list.add(value);\n-        }\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserClaimValueWithID(userID, claim, list, profileName, this)) {\n-                        handleGetUserClaimValueFailureWithID(\n-                                ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_CLAIM_VALUE.getCode(),\n-                                String.format(\n-                                        ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_CLAIM_VALUE.getMessage(),\n-                                        UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, claim,\n-                                profileName);\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserClaimValueFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_GET_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userID, claim, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        if (!list.isEmpty()) {\n-            return list.get(0);\n-        }\n-        return value;\n-    }\n-\n-    @Override\n-    public final Map<String, String> getUserClaimValuesWithID(String userID, String[] claims, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String[].class, String.class };\n-            Object object = callSecure(\"getUserClaimValuesWithID\", new Object[] { userID, claims, profileName },\n-                    argTypes);\n-            return (Map<String, String>) object;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .getUserClaimValuesWithID(userStore.getDomainFreeUserId(), claims, profileName);\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        boolean isUserExists;\n-        User user = null;\n-        if (isUniqueIdEnabled) {\n-            isUserExists = doCheckExistingUserWithID(userID);\n-        } else{\n-            user = userUniqueIDManger.getUser(userID, this);\n-            isUserExists = user != null;\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleGetUserClaimValuesFailureWithID(errorCode, errorMessage, userID, claims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // check for null claim list\n-        if (claims == null) {\n-            claims = new String[0];\n-        }\n-\n-        Map<String, String> finalValues;\n-        try {\n-            // If unique id feature is not enabled, we have to call the legacy methods.\n-            if (!isUniqueIdEnabled) {\n-                finalValues = doGetUserClaimValues(user.getUsername(), claims, userStore.getDomainName(),\n-                        profileName);\n-            } else {\n-                finalValues = doGetUserClaimValuesWithID(userID, claims, userStore.getDomainName(), profileName);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userID, claims, profileName);\n-            throw ex;\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (listener instanceof AbstractUserOperationEventListener) {\n-                    AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                    if (!newListener.doPostGetUserClaimValuesWithID(userStore.getDomainFreeUserId(), claims, profileName,\n-                            finalValues, this)) {\n-                        handleGetUserClaimValuesFailureWithID(\n-                                ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getMessage(),\n-                                        UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, claims,\n-                                profileName);\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleGetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_IN_POST_GET_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userID, claims, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        return finalValues;\n-    }\n-\n-    @Override\n-    public final List<Claim> getUserClaimValuesWithID(String userID, String profileName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class };\n-            Object object = callSecure(\"getUserClaimValuesWithID\", new Object[] { userID, profileName }, argTypes);\n-            return (List<Claim>) object;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .getUserClaimValuesWithID(userStore.getDomainFreeUserId(), profileName);\n-        }\n-\n-        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        boolean isUserExists;\n-        if (isUniqueIdEnabled) {\n-            isUserExists = doCheckExistingUserWithID(userID);\n-        } else {\n-            String userNameFromUserID = doGetUserNameFromUserID(userID);\n-            isUserExists = userNameFromUserID != null;\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleGetUserClaimValuesFailureWithID(errorCode, errorMessage, userID, null, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // If unique id feature is not enabled, we have to call the legacy methods.\n-        if (!isUniqueIdEnabled) {\n-            User user = userUniqueIDManger.getUser(userID, this);\n-            return Arrays.asList(getUserClaimValues(user.getDomainQualifiedUsername(), profileName));\n-        }\n-\n-        if (StringUtils.isEmpty(profileName)) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n-\n-        String[] claims;\n-        try {\n-            claims = claimManager.getAllClaimUris();\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            handleGetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_URI.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_CLAIM_URI.getMessage(), e.getMessage()),\n-                    userID, null, profileName);\n-            throw new UserStoreException(e);\n-        }\n-\n-        Map<String, String> values = doGetUserClaimValuesWithID(userID, claims, userStore.getDomainName(), profileName);\n-        List<Claim> finalValues = new ArrayList<>();\n-        addClaimValues(values, finalValues);\n-\n-        return finalValues;\n-    }\n-\n-    protected Map<String, String> doGetUserClaimValuesWithID(String userID, String[] claims, String domainName,\n-            String profileName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String[].class, String.class, String.class };\n-            Object object = callSecure(\"doGetUserClaimValuesWithID\", new Object[] {\n-                    userID, claims, domainName, profileName\n-            }, argTypes);\n-            return (Map<String, String>) object;\n-        }\n-\n-        if (ArrayUtils.isEmpty(claims)) {\n-            return new HashMap<>();\n-        }\n-\n-        // Here the user name should be domain-less.\n-        boolean requireRoles = false;\n-        boolean requireIntRoles = false;\n-        boolean requireExtRoles = false;\n-        String roleClaim = null;\n-\n-        if (StringUtils.isEmpty(profileName)) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n-\n-        Set<String> propertySet = new HashSet<>();\n-        for (String claim : claims) {\n-\n-            // There can be cases some claim values being requested for claims\n-            // we don't have.\n-            String property;\n-            try {\n-                property = getClaimAtrribute(claim, userID, domainName);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-            if (property != null && (!UserCoreConstants.ROLE_CLAIM.equalsIgnoreCase(claim)\n-                    || !UserCoreConstants.INT_ROLE_CLAIM.equalsIgnoreCase(claim) || !UserCoreConstants.EXT_ROLE_CLAIM\n-                    .equalsIgnoreCase(claim))) {\n-                propertySet.add(property);\n-            }\n-\n-            if (UserCoreConstants.ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-                requireRoles = true;\n-                roleClaim = claim;\n-            } else if (UserCoreConstants.INT_ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-                requireIntRoles = true;\n-                roleClaim = claim;\n-            } else if (UserCoreConstants.EXT_ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-                requireExtRoles = true;\n-                roleClaim = claim;\n-            }\n-        }\n-\n-        String[] properties = propertySet.toArray(new String[0]);\n-        Map<String, String> userPropertyValues = this.getUserPropertyValuesWithID(userID, properties, profileName);\n-        processAttributesAfterRetrievalWithID(userID, userPropertyValues, profileName);\n-\n-        List<String> getAgain = new ArrayList<>();\n-        Map<String, String> finalValues = new HashMap<>();\n-\n-        for (String claim : claims) {\n-            ClaimMapping mapping;\n-            try {\n-                mapping = (ClaimMapping) claimManager.getClaimMapping(claim);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-            String property = null;\n-            String value;\n-            if (mapping != null) {\n-                if (domainName != null) {\n-                    Map<String, String> attrMap = mapping.getMappedAttributes();\n-                    if (attrMap != null) {\n-                        String attr;\n-                        if ((attr = attrMap.get(domainName.toUpperCase())) != null) {\n-                            property = attr;\n-                        } else {\n-                            property = mapping.getMappedAttribute();\n-                        }\n-                    }\n-                } else {\n-                    property = mapping.getMappedAttribute();\n-                }\n-\n-                value = userPropertyValues.get(property);\n-                if (value != null && value.trim().length() > 0) {\n-                    finalValues.put(claim, value);\n-                }\n-\n-            } else {\n-                if (property == null && claim.equals(DISAPLAY_NAME_CLAIM)) {\n-                    property = this.realmConfig.getUserStoreProperty(LDAPConstants.DISPLAY_NAME_ATTRIBUTE);\n-                }\n-\n-                value = userPropertyValues.get(property);\n-                if (value != null && value.trim().length() > 0) {\n-                    finalValues.put(claim, value);\n-                }\n-            }\n-        }\n-\n-        if (getAgain.size() > 0) {\n-            // oh the beautiful recursion\n-            Map<String, String> mapClaimValues = this\n-                    .getUserClaimValuesWithID(userID, getAgain.toArray(new String[0]), profileName);\n-\n-            Iterator<Map.Entry<String, String>> ite3 = mapClaimValues.entrySet().iterator();\n-            while (ite3.hasNext()) {\n-                Map.Entry<String, String> entry = ite3.next();\n-                if (entry.getValue() != null) {\n-                    finalValues.put(entry.getKey(), entry.getValue());\n-                }\n-            }\n-        }\n-\n-        // We treat roles claim in special way.\n-        List<String> roles = null;\n-\n-        if (requireRoles) {\n-            roles = getRoleListOfUserWithID(userID);\n-        } else if (requireIntRoles) {\n-            roles = doGetInternalRoleListOfUserWithID(userID, \"*\");\n-        } else if (requireExtRoles) {\n-\n-            List<String> rolesList = new ArrayList<>();\n-            String[] externalRoles = doGetExternalRoleListOfUserWithID(userID, \"*\");\n-            rolesList.addAll(Arrays.asList(externalRoles));\n-            //if only shared enable\n-            if (isSharedGroupEnabled()) {\n-                String[] sharedRoles = doGetSharedRoleListOfUserWithID(userID, null, \"*\");\n-                if (sharedRoles != null) {\n-                    rolesList.addAll(Arrays.asList(sharedRoles));\n-                }\n-            }\n-\n-            roles = rolesList;\n-        }\n-\n-        if (roles != null && roles.size() > 0) {\n-            String userAttributeSeparator = \",\";\n-            String claimSeparator = realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR);\n-            if (claimSeparator != null && !claimSeparator.trim().isEmpty()) {\n-                userAttributeSeparator = claimSeparator;\n-            }\n-            String delim = \"\";\n-            StringBuffer roleBf = new StringBuffer();\n-            for (String role : roles) {\n-                roleBf.append(delim).append(role);\n-                delim = userAttributeSeparator;\n-            }\n-            finalValues.put(roleClaim, roleBf.toString());\n-        }\n-\n-        return finalValues;\n-    }\n-\n-    private User getUserFromID(String userID, String[] requestedClaims, String domainName, String profileName)\n-            throws UserStoreException {\n-\n-        User user = getUser(userID, null);\n-        if (ArrayUtils.isNotEmpty(requestedClaims)) {\n-            Map<String, String> claimValues = doGetUserClaimValuesWithID(userID, requestedClaims, domainName, profileName);\n-            user.setAttributes(claimValues);\n-        }\n-        return user;\n-    }\n-\n-    private void addClaimValues(Map<String, String> values, List<Claim> finalValues) throws UserStoreException {\n-\n-        for (Map.Entry<String, String> entry : values.entrySet()) {\n-            Claim claim = new Claim();\n-            claim.setValue(entry.getValue());\n-            claim.setClaimUri(entry.getKey());\n-            String displayTag;\n-            try {\n-                displayTag = claimManager.getClaim(entry.getKey()).getDisplayTag();\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-            claim.setDisplayTag(displayTag);\n-            finalValues.add(claim);\n-        }\n-    }\n-\n-    @Override\n-    public final void updateCredentialWithID(String userID, Object newCredential, Object oldCredential)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class, Object.class, Object.class};\n-            callSecure(\"updateCredentialWithID\", new Object[] { userID, newCredential, oldCredential }, argTypes);\n-            return;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .updateCredentialWithID(userStore.getDomainFreeUserId(), newCredential, oldCredential);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (isReadOnly()) {\n-            handleUpdateCredentialFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, newCredential, oldCredential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        Secret newCredentialObj;\n-        Secret oldCredentialObj;\n-        try {\n-            newCredentialObj = Secret.getSecret(newCredential);\n-            oldCredentialObj = Secret.getSecret(oldCredential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleUpdateCredentialFailureWithID(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), userID, newCredential,\n-                    oldCredential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString());\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            try {\n-                for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                    if (listener instanceof SecretHandleableListener) {\n-                        if (!listener.updateCredential(userID, newCredentialObj, oldCredentialObj, this)) {\n-                            handleUpdateCredentialFailureWithID(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                                    String.format(\n-                                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID,\n-                                    newCredential, oldCredential);\n-                            return;\n-                        }\n-                    } else {\n-                        if (!listener.updateCredential(userID, newCredential, oldCredential, this)) {\n-                            handleUpdateCredentialFailureWithID(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                                    String.format(\n-                                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID,\n-                                    newCredential, oldCredential);\n-                            return;\n-                        }\n-                    }\n-                }\n-\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-\n-                    if (listener instanceof SecretHandleableListener) {\n-                        if (!listener.doPreUpdateCredential(userID, newCredentialObj, oldCredentialObj, this)) {\n-                            handleUpdateCredentialFailureWithID(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                                    String.format(\n-                                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID,\n-                                    newCredential, oldCredential);\n-                            return;\n-                        }\n-                    } else {\n-                        if (!listener.doPreUpdateCredential(userID, newCredential, oldCredential, this)) {\n-                            handleUpdateCredentialFailureWithID(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                                    String.format(\n-                                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID,\n-                                    newCredential, oldCredential);\n-                            return;\n-                        }\n-                    }\n-                }\n-            } catch (UserStoreException e) {\n-                handleUpdateCredentialFailureWithID(\n-                        ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                e.getMessage()), userID, newCredential, oldCredential);\n-                throw e;\n-            }\n-            // #################### </Listeners> #####################################################\n-\n-            // This user name here is domain-less.\n-            // We directly authenticate user against the selected UserStoreManager.\n-\n-            AuthenticationResult authenticationResult;\n-            try {\n-                if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                    User user = userUniqueIDManger.getUser(userID, this);\n-                    boolean auth = this.doAuthenticate(user.getUsername(), oldCredentialObj);\n-                    authenticationResult = new AuthenticationResult(auth ?\n-                            AuthenticationResult.AuthenticationStatus.SUCCESS :\n-                            AuthenticationResult.AuthenticationStatus.FAIL);\n-                } else {\n-                    authenticationResult = this.doAuthenticateWithID(userID, oldCredentialObj);\n-                }\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-\n-            if (authenticationResult.getAuthenticationStatus() == AuthenticationResult.AuthenticationStatus.SUCCESS) {\n-                if (!checkUserPasswordValid(newCredential)) {\n-                    String errorMsg = realmConfig.getUserStoreProperty(PROPERTY_PASSWORD_ERROR_MSG);\n-\n-                    if (errorMsg != null) {\n-                        String errorMessage = String\n-                                .format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getMessage(),\n-                                        errorMsg);\n-                        String errorCode = ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL.getCode();\n-                        handleUpdateCredentialFailureWithID(errorCode, errorMessage, userID, newCredential,\n-                                oldCredential);\n-                        throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-                    }\n-\n-                    String errorMessage = String.format(ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getMessage(),\n-                            realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX));\n-                    String errorCode = ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getCode();\n-                    handleUpdateCredentialFailureWithID(errorCode, errorMessage, userID, newCredential, oldCredential);\n-                    throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-                }\n-\n-                try {\n-                    // If unique id feature is not enabled, we have to call the legacy methods.\n-                    if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                        User user = userUniqueIDManger.getUser(userID, this);\n-                        // If we don't have a record for this user, let's try to call directly using the user id.\n-                        if (user == null) {\n-                            updateCredential(userID, newCredential, oldCredential);\n-                        } else {\n-                            updateCredential(user.getUsername(), newCredential, oldCredential);\n-                        }\n-                    } else {\n-                        this.doUpdateCredentialWithID(userID, newCredentialObj, oldCredentialObj);\n-                    }\n-                } catch (UserStoreException ex) {\n-                    handleUpdateCredentialFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_CREDENTIAL.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_CREDENTIAL.getMessage(),\n-                                    ex.getMessage()), userID, newCredential, oldCredential);\n-                    throw ex;\n-                }\n-\n-                // #################### <Listeners> ##################################################\n-                try {\n-                    for (UserOperationEventListener listener : UMListenerServiceComponent\n-                            .getUserOperationEventListeners()) {\n-                        if (listener instanceof SecretHandleableListener) {\n-                            if (!listener.doPostUpdateCredential(userID, newCredentialObj, this)) {\n-                                handleUpdateCredentialFailureWithID(\n-                                        ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL.getCode(),\n-                                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL\n-                                                .getMessage(), \"Post update credential tasks failed\"), userID,\n-                                        newCredentialObj, oldCredentialObj);\n-                                return;\n-                            }\n-                        } else {\n-                            if (!listener.doPostUpdateCredential(userID, newCredential, this)) {\n-                                handleUpdateCredentialFailureWithID(\n-                                        ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL.getCode(),\n-                                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL\n-                                                .getMessage(), \"Post update credential tasks failed\"), userID,\n-                                        newCredential, oldCredential);\n-                                return;\n-                            }\n-                        }\n-                    }\n-                } catch (UserStoreException ex) {\n-                    handleUpdateCredentialFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL.getMessage(),\n-                                    ex.getMessage()), userID, newCredential, oldCredential);\n-                    throw ex;\n-                }\n-                // #################### </Listeners> ##################################################\n-\n-            } else {\n-                handleUpdateCredentialFailureWithID(ErrorMessages.ERROR_CODE_OLD_CREDENTIAL_DOES_NOT_MATCH.getCode(),\n-                        ErrorMessages.ERROR_CODE_OLD_CREDENTIAL_DOES_NOT_MATCH.getMessage(), userID, newCredential,\n-                        oldCredential);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_OLD_CREDENTIAL_DOES_NOT_MATCH.toString());\n-            }\n-        } finally {\n-            newCredentialObj.clear();\n-            oldCredentialObj.clear();\n-        }\n-    }\n-\n-    /**\n-     * Get the user.\n-     *\n-     * @param userID   user ID.\n-     * @param userName user name.\n-     * @return User.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    public User getUser(String userID, String userName) throws UserStoreException {\n-\n-        if (userID == null && userName == null) {\n-            throw new UserStoreException(\"Both userID and UserName cannot be null.\");\n-        }\n-\n-        String domain = getMyDomainName();\n-        if (userID == null) {\n-            userID = getUserIDFromUserName(userName);\n-        }\n-\n-        if (userName == null) {\n-            userName = getUserNameFromUserID(userID);\n-        }\n-        if (userName.contains(UserCoreConstants.DOMAIN_SEPARATOR)) {\n-            domain = UserCoreUtil.extractDomainFromName(userName);\n-            userName = UserCoreUtil.removeDomainFromName(userName);\n-        }\n-        User user = new User(userID, userName, userName);\n-        user.setTenantDomain(getTenantDomain(tenantId));\n-        user.setUserStoreDomain(domain);\n-        return user;\n-    }\n-\n-    /**\n-     * Get the tenant domain.\n-     *\n-     * @return tenant domain.\n-     * @throws UserStoreException User Store Exception.\n-     */\n-    protected String getTenantDomain(int tenantID) throws UserStoreException {\n-\n-        String tenantDomain;\n-        RealmService realmService = UserCoreUtil.getRealmService();\n-        try {\n-            if (realmService != null) {\n-                tenantDomain = realmService.getTenantManager().getDomain(tenantID);\n-            } else {\n-                tenantDomain = CarbonContext.getThreadLocalCarbonContext().getTenantDomain();\n-            }\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            throw new UserStoreException(\"Error occured while getting the tenant domain.\", e);\n-        }\n-        return tenantDomain;\n-    }\n-\n-    /**\n-     * provides the unique user ID of the user.\n-     *\n-     * @return unique user ID.\n-     */\n-    protected String getUniqueUserID() {\n-\n-        return UUID.randomUUID().toString();\n-    }\n-\n-    /**\n-     * Check whether the userID attribute is generated/maintained by the user store itself.\n-     *\n-     * @param userName       User's userName.\n-     * @param userAttributes A map user attribute values.\n-     * @return True if generated, else false.\n-     */\n-    protected boolean isUserIdGeneratedByUserStore(String userName, Map<String, String> userAttributes) {\n-\n-        return false;\n-    }\n-\n-    /**\n-     * provides the unique user ID of the given user.\n-     *\n-     * @param userName username of the user.\n-     * @return user ID of the user.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    public String getUserIDFromUserName(String userName) throws UserStoreException {\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .getUserIDFromUserName(userStore.getDomainFreeName());\n-        }\n-        userName = userStore.getDomainFreeName();\n-        String userID = getFromUserIDCache(userName, userStore);\n-        if (StringUtils.isEmpty(userID)) {\n-            if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                userID = doGetUserIDFromUserNameWithID(userName);\n-                addToUserIDCache(userID, userName, userStore);\n-                addToUserNameCache(userID, userName, userStore);\n-                return userID;\n-            }\n-\n-            Map<String, String> claims = doGetUserClaimValues(userName,\n-                    new String[]{UserCoreClaimConstants.USER_ID_CLAIM_URI},\n-                    userStore.getDomainName(), null);\n-            if (claims != null && claims.size() == 1) {\n-                userID = claims.get(UserCoreClaimConstants.USER_ID_CLAIM_URI);\n-                addToUserIDCache(userID, userName, userStore);\n-                addToUserNameCache(userID, userName, userStore);\n-                return userID;\n-            }\n-        }\n-        return userID;\n-    }\n-\n-    /**\n-     * provides the unique user ID of the given user.\n-     *\n-     * @param userName username of the user.\n-     * @return user ID of the user.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected String doGetUserIDFromUserNameWithID(String userName) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetUserIDFromUserName operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"doGetUserIDFromUserName operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    /**\n-     * Get the user name of the given user ID in the user store.\n-     *\n-     * @param userID userID of the user.\n-     * @return user name.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected String doGetUserNameFromUserID(String userID) throws UserStoreException {\n-\n-        if (isUniqueUserIdEnabled()) {\n-            return doGetUserNameFromUserIDWithID(userID);\n-        }\n-        User user = userUniqueIDManger.getUser(userID, this);\n-        return user.getUsername();\n-    }\n-\n-    /**\n-     * Get the user name of the given user.\n-     *\n-     * @param userID userID of the user.\n-     * @return user name.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    public String getUserNameFromUserID(String userID) throws UserStoreException {\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .getUserNameFromUserID(userStore.getDomainFreeUserId());\n-        }\n-\n-        if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-            return getUserNameFromCurrentUserStore(userID, userStore);\n-        } else {\n-            return userUniqueIDManger.getUser(userID, this).getDomainQualifiedUsername();\n-        }\n-    }\n-\n-    /**\n-     * Get the user name of the given user from a unique user id natively supported user store.\n-     *\n-     * @param userID userID of the user.\n-     * @param userStore user store of the user.\n-     * @return user name.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    private String getUserNameFromCurrentUserStore(String userID, UserStore userStore) throws UserStoreException {\n-\n-        String userName = getFromUserNameCache(userID);\n-        if (StringUtils.isEmpty(userName)) {\n-            userName = doGetUserNameFromUserIDWithID(userID);\n-            addToUserNameCache(userID, userName, userStore);\n-            addToUserIDCache(userID, userName, userStore);\n-        }\n-        return UserCoreUtil.addDomainToName(userName, userStore.getDomainName());\n-    }\n-\n-    private String getFromUserNameCache(String userID) {\n-\n-        return UserIdResolverCache.getInstance().getValueFromCache(userID,\n-                RESOLVE_USER_NAME_FROM_USER_ID_CACHE_NAME, tenantId);\n-    }\n-\n-    private String getFromUserIDCache(String userName, UserStore userStore) {\n-\n-        return UserIdResolverCache.getInstance()\n-                .getValueFromCache(UserCoreUtil.addDomainToName(userName, userStore.getDomainName()),\n-                        RESOLVE_USER_ID_FROM_USER_NAME_CACHE_NAME, tenantId);\n-    }\n-\n-    private void addToUserIDCache(String userID, String userName, UserStore userStore) {\n-\n-        UserIdResolverCache.getInstance()\n-                .addToCache(UserCoreUtil.addDomainToName(userName, userStore.getDomainName()), userID,\n-                        RESOLVE_USER_ID_FROM_USER_NAME_CACHE_NAME, tenantId);\n-    }\n-\n-    private void addToUserNameCache(String userID, String userName, UserStore userStore) {\n-\n-        UserIdResolverCache.getInstance()\n-                .addToCache(userID, UserCoreUtil.addDomainToName(userName, userStore.getDomainName()),\n-                        RESOLVE_USER_NAME_FROM_USER_ID_CACHE_NAME, tenantId);\n-    }\n-\n-    private void clearUserIDResolverCache(String userID, String userName, UserStore userStore) {\n-\n-        UserIdResolverCache.getInstance()\n-                .clearCacheEntry(UserCoreUtil.addDomainToName(userName, userStore.getDomainName()),\n-                        RESOLVE_USER_ID_FROM_USER_NAME_CACHE_NAME, tenantId);\n-        UserIdResolverCache.getInstance().clearCacheEntry(userID, RESOLVE_USER_NAME_FROM_USER_ID_CACHE_NAME, tenantId);\n-        UserIdResolverCache.getInstance()\n-                .clearCacheEntry(UserCoreUtil.addDomainToName(userName, userStore.getDomainName()),\n-                        RESOLVE_USER_UNIQUE_ID_FROM_USER_NAME_CACHE_NAME, SUPER_TENANT_ID);\n-        UserIdResolverCache.getInstance()\n-                .clearCacheEntry(userID, RESOLVE_USER_NAME_FROM_UNIQUE_USER_ID_CACHE_NAME, SUPER_TENANT_ID);\n-    }\n-\n-    /**\n-     * provides the userName of the given user.\n-     *\n-     * @param userID userID of the user.\n-     * @return userName of the user.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    protected String doGetUserNameFromUserIDWithID(String userID) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"doGetUserNameFromUserIDWithID operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"doGetUserNameFromUserIDWithID operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    /**\n-     * provides the unique user IDs of the given users.\n-     *\n-     * @param userIDs userIDs of the users.\n-     * @return list of user IDs.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    public List<String> getUserNamesFromUserIDs(List<String> userIDs) throws UserStoreException {\n-\n-        List<String> userNames = new ArrayList<>();\n-        for (String userID : userIDs) {\n-            userNames.add(getUserNameFromUserID(userID));\n-        }\n-        return userNames;\n-    }\n-\n-    /**\n-     * provides the unique user IDs of the given users.\n-     *\n-     * @param userNames user names of the users.\n-     * @return list of user IDs.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    public List<String> getUserIDsFromUserNames(List<String> userNames) throws UserStoreException {\n-\n-        List<String> userIDs = new ArrayList<>();\n-        for (String userName : userNames) {\n-            String userId = getUserIDFromUserName(userName);\n-            if (userId == null) {\n-                throw new UserStoreException(\"User \" + userName + \" does not exit in the system.\");\n-            }\n-            userIDs.add(userId);\n-        }\n-        return userIDs;\n-    }\n-\n-    /**\n-     * Provide the users list for a given usernames list.\n-     *\n-     * @param userNamesList user names list.\n-     * @return list of users.\n-     * @throws UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    public List<User> getUsersFromUserNames(List<String> userNamesList) throws UserStoreException {\n-\n-        List<User> usersList = new ArrayList<>();\n-        for (String userName : userNamesList) {\n-            String userID = getUserIDFromUserName(userName);\n-            User user = new User(userID, userName, userName);\n-            usersList.add(user);\n-        }\n-        return usersList;\n-    }\n-\n-    /**\n-     * provides the unique user ID of the given user.\n-     *\n-     * @param claimURI    Claim naURIme.\n-     * @param claimValue  Claim value.\n-     * @param profileName Profile name.\n-     * @return user ID.\n-     * @throws UserStoreException UserStoreException Thrown by the underlying UserStoreManager.\n-     */\n-    public String getUserIDFromProperties(String claimURI, String claimValue, String profileName)\n-            throws UserStoreException {\n-\n-        String domain = this.getMyDomainName();\n-        if (isUniqueUserIdEnabled()) {\n-            List<User> users = doGetUserListWithID(claimURI, claimValue, profileName, domain, this);\n-            if (users.isEmpty()) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"No userID found for the claim: \" + claimURI + \", value: \" + claimValue + \", in domain:\"\n-                            + \" \" + getMyDomainName());\n-                }\n-                return null;\n-            } else if (users.size() > 1) {\n-                throw new UserStoreException(\n-                        \"Invalid scenario. Multiple users cannot be found for the given value: \" + claimValue + \"of \"\n-                                + \"the \" + \"claim: \" + claimURI);\n-            }\n-            return users.get(0).getUserID();\n-        } else {\n-            List<String> userNames = doGetUserList(claimURI, claimValue, profileName, domain, this);\n-            if (userNames.isEmpty()) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"No userID found for the claim: \" + claimURI + \", value: \" + claimValue + \", in domain:\"\n-                            + \" \" + getMyDomainName());\n-                }\n-                return null;\n-            } else if (userNames.size() > 1) {\n-                throw new UserStoreException(\n-                        \"Invalid scenario. Multiple users cannot be found for the given value: \" + claimValue + \"of \"\n-                                + \"the \" + \"claim: \" + claimURI);\n-            }\n-            return userUniqueIDManger.getUniqueId(userNames.get(0), this);\n-        }\n-    }\n-\n-    /**\n-     * Get Users list from userIDs.\n-     *\n-     * @param userIDs     user IDs.\n-     * @param claims      Requested claims.\n-     * @param domainName  Domain name.\n-     * @param profileName Profile name.\n-     * @return User list.\n-     * @throws UserStoreException UserStoreException.\n-     */\n-    protected List<User> getUsersFromIDs(List<String> userIDs, String[] claims, String domainName, String profileName)\n-            throws UserStoreException {\n-\n-        List<User> users = new ArrayList<>();\n-        for (String userID : userIDs) {\n-            users.add(getUserFromID(userID, claims, domainName, profileName));\n-        }\n-        return users;\n-    }\n-\n-\n-    /**\n-     * Get the mapped user store attribute name for the user name.\n-     *\n-     * @return mapped attribute for the user name.\n-     * @throws UserStoreException\n-     */\n-    protected String getUserNameMappedAttribute() throws UserStoreException {\n-\n-        try {\n-            return claimManager.getAttributeName(getMyDomainName(), UserCoreClaimConstants.USERNAME_CLAIM_URI);\n-        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-            throw new UserStoreException(e);\n-        }\n-    }\n-\n-    /**\n-     * Add username as a user claim.\n-     *\n-     * @param userName username.\n-     * @param claims   claims map.\n-     */\n-    protected Map<String, String> addUserNameAttribute(String userName, Map<String, String> claims) {\n-\n-        if (claims == null) {\n-            claims = new HashMap<>();\n-        }\n-        claims.put(UserCoreClaimConstants.USERNAME_CLAIM_URI, userName);\n-        return claims;\n-    }\n-\n-    /**\n-     * Add username as a user claim.\n-     *\n-     * @param userID user ID.\n-     * @param claims claims map.\n-     */\n-    protected Map<String, String> addUserIDAttribute(String userID, Map<String, String> claims) {\n-\n-        if (claims == null) {\n-            claims = new HashMap<>();\n-        }\n-        claims.put(UserCoreClaimConstants.USER_ID_CLAIM_URI, userID);\n-        return claims;\n-    }\n-\n-    @Override\n-    public final void deleteUserWithID(String userID) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class};\n-            callSecure(\"deleteUserWithID\", new Object[] { userID }, argTypes);\n-            return;\n-        }\n-\n-        String loggedInUser = CarbonContext.getThreadLocalCarbonContext().getUsername();\n-        if (loggedInUser != null) {\n-            loggedInUser = UserCoreUtil.addDomainToName(loggedInUser, UserCoreUtil.getDomainFromThreadLocal());\n-            if ((loggedInUser.indexOf(UserCoreConstants.DOMAIN_SEPARATOR)) < 0) {\n-                loggedInUser =\n-                        UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME + CarbonConstants.DOMAIN_SEPARATOR + loggedInUser;\n-            }\n-        }\n-\n-        String deletingUser = UserCoreUtil.addDomainToName(userID, getMyDomainName());\n-        if ((deletingUser.indexOf(UserCoreConstants.DOMAIN_SEPARATOR)) < 0) {\n-            deletingUser =\n-                    UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME + CarbonConstants.DOMAIN_SEPARATOR + deletingUser;\n-        }\n-\n-        if (loggedInUser != null && loggedInUser.equals(deletingUser)) {\n-            log.debug(\"User \" + loggedInUser + \" tried to delete him/her self\");\n-            handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_DELETE_LOGGED_IN_USER.getCode(),\n-                    ErrorMessages.ERROR_CODE_DELETE_LOGGED_IN_USER.getMessage(), userID);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_DELETE_LOGGED_IN_USER.toString());\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .deleteUserWithID(userStore.getDomainFreeUserId());\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (UserCoreUtil.isPrimaryAdminUser(userID, realmConfig)) {\n-            handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_DELETE_ADMIN_USER.getCode(),\n-                    ErrorMessages.ERROR_CODE_DELETE_ADMIN_USER.getMessage(), userID);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_DELETE_ADMIN_USER.toString());\n-        }\n-\n-        if (UserCoreUtil.isRegistryAnnonymousUser(userID)) {\n-            handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_DELETE_ANONYMOUS_USER.getCode(),\n-                    ErrorMessages.ERROR_CODE_DELETE_ANONYMOUS_USER.getMessage(), userID);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_DELETE_ANONYMOUS_USER.toString());\n-        }\n-\n-        if (isReadOnly()) {\n-            handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                if (!((AbstractUserStoreManagerListener) listener).deleteUserWithID(userID, this)) {\n-                    handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID);\n-                    return;\n-                }\n-            }\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener).doPreDeleteUserWithID(userID, this)) {\n-                    handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID);\n-\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER.getMessage(), e.getMessage()),\n-                    userID);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        User user = null;\n-        boolean isUserEixisting;\n-        String userName;\n-        if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-            userName = doGetUserNameFromUserID(userID);\n-            isUserEixisting = userName != null;\n-        } else {\n-            user = userUniqueIDManger.getUser(userID, this);\n-            isUserEixisting = user != null;\n-            userName = user.getUsername();\n-        }\n-\n-        if (!isUserEixisting) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleDeleteUserFailureWithID(errorCode, errorMessage, userID);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        try {\n-\n-            clearUserIDResolverCache(userID, userName, userStore);\n-            // If unique id feature is not enabled, we have to call the legacy methods.\n-            if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                hybridRoleManager.deleteUser(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n-                doDeleteUserWithID(userID);\n-            } else {\n-                hybridRoleManager.deleteUser(user.getDomainQualifiedUsername());\n-                doDeleteUser(userName);\n-            }\n-        } catch (UserStoreException e) {\n-            handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER.getMessage(), e.getMessage()),\n-                    userID);\n-            throw e;\n-        }\n-\n-        // Needs to clear roles cache upon deletion of a user\n-        clearUserRolesCache(userName);\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener).doPostDeleteUserWithID(userID, this)) {\n-                    handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER.getMessage(), ex.getMessage()),\n-                    userID);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    @Override\n-    public final void setUserClaimValueWithID(String userID, String claimURI, String claimValue, String profileName)\n-            throws UserStoreException {\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .setUserClaimValueWithID(userStore.getDomainFreeUserId(), claimURI, claimValue, profileName);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        boolean isUserExists;\n-        User user = null;\n-        if (isUniqueIdEnabled) {\n-            isUserExists = doCheckExistingUserWithID(userID);\n-        } else {\n-            user = userUniqueIDManger.getUser(userID, this);\n-            isUserExists = user != null;\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleSetUserClaimValueFailureWithID(errorCode, errorMessage, userID, claimURI, claimValue, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPreSetUserClaimValueWithID(userID, claimURI, claimValue, profileName, this)) {\n-                    handleSetUserClaimValueFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID, claimURI,\n-                            claimValue, profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValueFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUE.getMessage(),\n-                            e.getMessage()), userID, claimURI, claimValue, profileName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        //Check userstore is readonly or not\n-\n-        if (isReadOnly()) {\n-            handleSetUserClaimValueFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claimURI, claimValue,\n-                    profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        try {\n-            // If unique id feature is not enabled, we have to call the legacy methods.\n-            if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                doSetUserClaimValue(user.getUsername(), claimURI, claimValue, profileName);\n-            } else {\n-                doSetUserClaimValueWithID(userID, claimURI, claimValue, profileName);\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValueFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUE.getMessage(),\n-                            e.getMessage()), userID, claimURI, claimValue, profileName);\n-            throw e;\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener).doPostSetUserClaimValueWithID(userID, this)) {\n-                    handleSetUserClaimValueFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUE.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, claimURI,\n-                            claimValue, profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValueFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUE.getMessage(),\n-                            e.getMessage()), userID, claimURI, claimValue, profileName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    @Override\n-    public final void setUserClaimValuesWithID(String userID, Map<String, String> claims, String profileName)\n-            throws UserStoreException {\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .setUserClaimValuesWithID(userStore.getDomainFreeUserId(), claims, profileName);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        boolean isUserExists;\n-        if (isUniqueIdEnabled) {\n-            isUserExists = doCheckExistingUserWithID(userID);\n-        } else {\n-            String userNameFromUserID = doGetUserNameFromUserID(userID);\n-            isUserExists = userNameFromUserID != null;\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleSetUserClaimValuesFailureWithID(errorCode, errorMessage, userID, claims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-        if (claims == null) {\n-            claims = new HashMap<>();\n-        }\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPreSetUserClaimValuesWithID(userID, claims, profileName, this)) {\n-                    handleSetUserClaimValuesFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userID, claims, profileName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        //If user store is readonly this method should not get invoked with non empty claim set.\n-\n-        if (isReadOnly() && !claims.isEmpty()) {\n-            handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        // set claim values if user store is not read only.\n-\n-        try {\n-            if (!isReadOnly()) {\n-                // If unique id feature is not enabled, we have to call the legacy methods.\n-                if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                    User user = userUniqueIDManger.getUser(userID, this);\n-                    doSetUserClaimValues(user.getUsername(), claims, profileName);\n-                } else {\n-                    doSetUserClaimValuesWithID(userID, claims, profileName);\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userID, claims, profileName);\n-            throw e;\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPostSetUserClaimValuesWithID(userID, claims, profileName, this)) {\n-                    handleSetUserClaimValuesFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userID, claims, profileName);\n-            throw e;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    @Override\n-    public final void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n-                                               Map<String, List<String>> multiValuedClaimsToAdd,\n-                                               Map<String, List<String>> multiValuedClaimsToDelete,\n-                                               Map<String, List<String>> claimsExcludingMultiValuedClaims,\n-                                               String profileName) throws UserStoreException {\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .setUserClaimValuesWithID(userStore.getDomainFreeUserId(), oldClaimMap, multiValuedClaimsToAdd,\n-                            multiValuedClaimsToDelete, claimsExcludingMultiValuedClaims, profileName);\n-            return;\n-        }\n-        Map<String, String> claims =\n-                getModifiedClaims(oldClaimMap, multiValuedClaimsToAdd, multiValuedClaimsToDelete,\n-                        claimsExcludingMultiValuedClaims);\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-        boolean isUserExists;\n-        if (isUniqueIdEnabled) {\n-            isUserExists = doCheckExistingUserWithID(userID);\n-        } else {\n-            String userNameFromUserID = doGetUserNameFromUserID(userID);\n-            isUserExists = userNameFromUserID != null;\n-        }\n-\n-        if (!isUserExists) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleSetUserClaimValuesFailureWithID(errorCode, errorMessage, userID, claims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // #################### <Pre Listeners> #####################################################\n-        invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n-        // #################### </Pre Listeners> #####################################################\n-\n-        // If userstore is readonly this method should not get invoked with non empty claim set.\n-        if (isReadOnly() && !claims.isEmpty()) {\n-            handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        // Any additional simple claim modified due to pre listeners are taken into claimsExcludingMultiValuedClaims map.\n-        String separator = \",\";\n-        if (StringUtils.isNotEmpty(realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR))) {\n-            separator = realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR);\n-        }\n-        if (claimsExcludingMultiValuedClaims != null) {\n-            for (Map.Entry<String, String> claim : claims.entrySet()) {\n-                claimsExcludingMultiValuedClaims.put(claim.getKey(), Arrays.asList(claim.getValue().split(separator)));\n-            }\n-        }\n-        (claimsExcludingMultiValuedClaims.keySet()).removeAll(multiValuedClaimsToAdd.keySet());\n-        (claimsExcludingMultiValuedClaims.keySet()).removeAll(multiValuedClaimsToDelete.keySet());\n-\n-        // Set claim values if user store is not read only.\n-        try {\n-            if (!isReadOnly()) {\n-                // If unique id feature is not enabled, we have to call the legacy methods.\n-                if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                    User user = userUniqueIDManger.getUser(userID, this);\n-                    doSetUserClaimValues(user.getUsername(), multiValuedClaimsToAdd, multiValuedClaimsToDelete,\n-                            claimsExcludingMultiValuedClaims, profileName);\n-                } else {\n-                    doSetUserClaimValuesWithID(userID, multiValuedClaimsToAdd, multiValuedClaimsToDelete,\n-                            claimsExcludingMultiValuedClaims, profileName);\n-                }\n-            }\n-        } catch (NotImplementedException e) {\n-            if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                User user = userUniqueIDManger.getUser(userID, this);\n-                doSetUserClaimValues(user.getUsername(), claims, profileName);\n-            } else {\n-                doSetUserClaimValuesWithID(userID, claims, profileName);\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_SETTING_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userID, claims, profileName);\n-            throw e;\n-        }\n-\n-        // #################### <Post Listeners> #####################################################\n-        invokeDoPostSetUserClaimsWithIDListeners(userID, claims, profileName);\n-        // #################### </Post Listeners> #####################################################\n-    }\n-\n-    @Override\n-    public final void updateCredentialByAdminWithID(String userID, Object newCredential) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, Object.class };\n-            callSecure(\"updateCredentialByAdminWithID\", new Object[] { userID, newCredential }, argTypes);\n-            return;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .updateCredentialByAdminWithID(userStore.getDomainFreeUserId(), newCredential);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if (isReadOnly()) {\n-            handleUpdateCredentialByAdminFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, newCredential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        Secret newCredentialObj;\n-        try {\n-            newCredentialObj = Secret.getSecret(newCredential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleUpdateCredentialByAdminFailureWithID(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage() + \" \" + e.getMessage(), userID,\n-                    newCredential);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-        }\n-\n-        try {\n-            try {\n-                // #################### <Listeners> #####################################################\n-                for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = newCredentialObj;\n-                    } else {\n-                        credentialArgument = newCredential;\n-                    }\n-\n-                    if (!((AbstractUserStoreManagerListener) listener)\n-                            .updateCredentialByAdminWithID(userID, credentialArgument, this)) {\n-                        handleUpdateCredentialByAdminFailureWithID(\n-                                ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN\n-                                        .getMessage(), UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE),\n-                                userID, credentialArgument);\n-                        return;\n-                    }\n-                }\n-\n-                // using string buffers to allow the password to be changed by listener\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-\n-                    if (listener instanceof SecretHandleableListener) {\n-                        if (!((AbstractUserOperationEventListener) listener)\n-                                .doPreUpdateCredentialByAdminWithID(userID, newCredentialObj, this)) {\n-                            handleUpdateCredentialByAdminFailureWithID(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN\n-                                            .getMessage(), UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE),\n-                                    userID, newCredentialObj);\n-                            return;\n-                        }\n-                    } else {\n-                        // using string buffers to allow the password to be changed by listener\n-                        StringBuffer credBuff = null;\n-                        if (newCredential == null) { // a default password will be set\n-                            credBuff = new StringBuffer();\n-                        } else if (newCredential instanceof String) {\n-                            credBuff = new StringBuffer((String) newCredential);\n-                        }\n-\n-                        if (credBuff != null) {\n-                            if (!((AbstractUserOperationEventListener) listener)\n-                                    .doPreUpdateCredentialByAdminWithID(userID, credBuff, this)) {\n-                                handleUpdateCredentialByAdminFailureWithID(\n-                                        ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                                        String.format(\n-                                                ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN\n-                                                        .getMessage(),\n-                                                UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID,\n-                                        credBuff);\n-                                return;\n-                            }\n-                            // reading the modified value\n-                            newCredential = credBuff.toString();\n-                            newCredentialObj.clear();\n-                            try {\n-                                newCredentialObj = Secret.getSecret(newCredential);\n-                            } catch (UnsupportedSecretTypeException e) {\n-                                handleUpdateCredentialByAdminFailureWithID(\n-                                        ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                                        ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage() + \" \" + e\n-                                                .getMessage(), userID, newCredential);\n-                                throw new UserStoreException(\n-                                        ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-                            }\n-                        }\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleUpdateCredentialByAdminFailureWithID(\n-                        ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getMessage(),\n-                                ex.getMessage()), userID, newCredential);\n-                throw ex;\n-            }\n-            // #################### </Listeners> #####################################################\n-\n-            if (!checkUserPasswordValid(newCredential)) {\n-                String errorMsg = realmConfig.getUserStoreProperty(PROPERTY_PASSWORD_ERROR_MSG);\n-\n-                if (errorMsg != null) {\n-                    String errorCode = ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getCode();\n-                    String errorMessage = String\n-                            .format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_CREDENTIAL_BY_ADMIN.getMessage(),\n-                                    errorMsg);\n-                    handleUpdateCredentialByAdminFailureWithID(errorCode, errorMessage, userID, newCredential);\n-                    throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-                }\n-\n-                String errorCode = ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getCode();\n-                String errorMessage = String.format(ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getMessage(),\n-                        realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX));\n-                handleUpdateCredentialByAdminFailureWithID(errorCode, errorMessage, userID, newCredential);\n-                throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-            }\n-\n-            boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-            boolean isUserExists;\n-            if (isUniqueIdEnabled) {\n-                isUserExists = doCheckExistingUserWithID(userID);\n-            } else {\n-                String userNameFromUserID = doGetUserNameFromUserID(userID);\n-                isUserExists = userNameFromUserID != null;\n-            }\n-\n-            if (!isUserExists) {\n-                String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                        realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-                String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-                handleUpdateCredentialByAdminFailureWithID(errorCode, errorMessage, userID, newCredential);\n-                throw new UserStoreException(errorCode + \"-\" + errorMessage);\n-            }\n-\n-            try {\n-                // If unique id feature is not enabled, we have to call the legacy methods.\n-                if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                    User user = userUniqueIDManger.getUser(userID, this);\n-                    doUpdateCredentialByAdmin(user.getUsername(), newCredential);\n-                } else {\n-                    doUpdateCredentialByAdminWithID(userID, newCredentialObj);\n-                }\n-            } catch (UserStoreException ex) {\n-                handleUpdateCredentialByAdminFailureWithID(\n-                        ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_CREDENTIAL_BY_ADMIN.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_CREDENTIAL_BY_ADMIN.getMessage(),\n-                                ex.getMessage()), userID, newCredentialObj);\n-                throw ex;\n-            }\n-\n-            // #################### <Listeners> #####################################################\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = newCredentialObj;\n-                    } else {\n-                        credentialArgument = newCredential;\n-                    }\n-\n-                    if (!((AbstractUserOperationEventListener) listener)\n-                            .doPostUpdateCredentialByAdminWithID(userID, credentialArgument, this)) {\n-                        handleUpdateCredentialByAdminFailureWithID(\n-                                ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL_BY_ADMIN.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL_BY_ADMIN\n-                                        .getMessage(), UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE),\n-                                userID, newCredential);\n-                        return;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleUpdateCredentialByAdminFailureWithID(\n-                        ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL_BY_ADMIN.getCode(), String.format(\n-                                ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_CREDENTIAL_BY_ADMIN.getMessage(),\n-                                ex.getMessage()), userID, newCredential);\n-                throw ex;\n-            }\n-        } finally {\n-            newCredentialObj.clear();\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-    }\n-\n-    @Override\n-    public final void deleteUserClaimValueWithID(String userID, String claimURI, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class, String.class };\n-            callSecure(\"deleteUserClaimValueWithID\", new Object[] { userID, claimURI, profileName }, argTypes);\n-            return;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .deleteUserClaimValueWithID(userStore.getDomainFreeUserId(), claimURI, profileName);\n-            return;\n-        }\n-\n-        if (isReadOnly()) {\n-            handleDeleteUserClaimValueFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claimURI, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        User user = null;\n-        boolean isUserEixisting;\n-        if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-            isUserEixisting = doCheckExistingUserWithID(userID);\n-        } else {\n-            user = userUniqueIDManger.getUser(userID, this);\n-            isUserEixisting = user != null;\n-        }\n-\n-        if (!isUserEixisting) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleDeleteUserClaimValueFailureWithID(errorCode, errorMessage, userID, claimURI, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPreDeleteUserClaimValueWithID(userID, claimURI, profileName, this)) {\n-                    handleDeleteUserClaimValueFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUE.getCode(), String.format(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID, claimURI,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-            // #################### </Listeners> #####################################################\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValueFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userID, claimURI, profileName);\n-            throw ex;\n-        }\n-\n-        try {\n-\n-            // If unique id feature is not enabled, we have to call the legacy methods.\n-            if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                doDeleteUserClaimValue(user.getUsername(), claimURI, profileName);\n-            } else {\n-                doDeleteUserClaimValueWithID(userID, claimURI, profileName);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValueFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userID, claimURI, profileName);\n-            throw ex;\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener).doPostDeleteUserClaimValueWithID(userID, this)) {\n-                    handleDeleteUserClaimValueFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUE.getCode(), String.format(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUE.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, claimURI,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValueFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUE.getMessage(),\n-                            ex.getMessage()), userID, claimURI, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-    }\n-\n-    @Override\n-    public final void deleteUserClaimValuesWithID(String userID, String[] claims, String profileName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String[].class, String.class };\n-            callSecure(\"deleteUserClaimValuesWithID\", new Object[] { userID, claims, profileName }, argTypes);\n-            return;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .deleteUserClaimValuesWithID(userStore.getDomainFreeUserId(), claims, profileName);\n-            return;\n-        }\n-\n-        if (isReadOnly()) {\n-            handleDeleteUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        User user = null;\n-        boolean isUserExisting;\n-        if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-            isUserExisting = doCheckExistingUserWithID(userID);\n-        } else {\n-            user = userUniqueIDManger.getUser(userID, this);\n-            isUserExisting = user != null;\n-        }\n-\n-        if (!isUserExisting) {\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n-                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n-            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n-            handleDeleteUserClaimValuesFailureWithID(errorCode, errorMessage, userID, claims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        if (claims == null) {\n-            claims = new String[0];\n-        }\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPreDeleteUserClaimValuesWithID(userID, claims, profileName, this)) {\n-                    handleDeleteUserClaimValuesFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUES.getCode(), String.format(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-            // #################### </Listeners> #####################################################\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_DELETE_USER_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userID, claims, profileName);\n-            throw ex;\n-        }\n-\n-        try {\n-            // If unique id feature is not enabled, we have to call the legacy methods.\n-            if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                doDeleteUserClaimValues(user.getUsername(), claims, profileName);\n-            } else {\n-                doDeleteUserClaimValuesWithID(userID, claims, profileName);\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_DELETING_USER_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userID, claims, profileName);\n-            throw ex;\n-        }\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener).doPostDeleteUserClaimValuesWithID(userID, this)) {\n-                    handleDeleteUserClaimValuesFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUES.getCode(),\n-                            String.format(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleDeleteUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_DELETE_USER_CLAIM_VALUES.getMessage(),\n-                            ex.getMessage()), userID, claims, profileName);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-    }\n-\n-    @Override\n-    public Date getPasswordExpirationTimeWithID(String userID) throws UserStoreException {\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .getPasswordExpirationTimeWithID(userStore.getDomainFreeUserId());\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public final void updateRoleListOfUserWithID(final String userID, final String[] deletedRoles,\n-            final String[] newRoles) throws UserStoreException {\n-\n-        try {\n-            AccessController.doPrivileged((PrivilegedExceptionAction<String>) () -> {\n-                // If unique id feature is not enabled, we have to call the legacy methods.\n-                if (!isUniqueUserIdEnabled()) {\n-                    User user = userUniqueIDManger.getUser(userID, this);\n-                    if (user == null) {\n-                        throw new UserStoreException(\"User cannot be found.\");\n-                    }\n-                    updateRoleListOfUserInternal(user.getDomainQualifiedUsername(), deletedRoles, newRoles);\n-                    return null;\n-                } else {\n-                    updateRoleListOfUserInternalWithID(userID, deletedRoles, newRoles);\n-                    return null;\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            if (!(e.getException() instanceof UserStoreException)) {\n-                handleUpdateRoleListOfUserFailureWithID(\n-                        ErrorMessages.ERROR_CODE_ERROR_DURING_UPDATE_USERS_OF_ROLE.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_UPDATE_USERS_OF_ROLE.getMessage(),\n-                                e.getMessage()), userID, deletedRoles, newRoles);\n-            }\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    /**\n-     * Update role list of user.\n-     */\n-    private final void updateRoleListOfUserInternalWithID(String userID, String[] deletedRoles, String[] newRoles)\n-            throws UserStoreException {\n-\n-        String primaryDomain = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-        if (primaryDomain != null) {\n-            primaryDomain += CarbonConstants.DOMAIN_SEPARATOR;\n-        }\n-\n-        if (deletedRoles != null && deletedRoles.length > 0) {\n-            Arrays.sort(deletedRoles);\n-            if (UserCoreUtil.isPrimaryAdminUser(userID, realmConfig)) {\n-                for (int i = 0; i < deletedRoles.length; i++) {\n-                    if (deletedRoles[i].equalsIgnoreCase(realmConfig.getAdminRoleName()) || (primaryDomain\n-                            + deletedRoles[i]).equalsIgnoreCase(realmConfig.getAdminRoleName())) {\n-                        handleUpdateRoleListOfUserFailureWithID(\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.getCode(),\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.getMessage(), userID,\n-                                deletedRoles, newRoles);\n-                        throw new UserStoreException(\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.toString());\n-                    }\n-                }\n-            }\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .updateRoleListOfUserWithID(userStore.getDomainFreeUserId(),\n-                            UserCoreUtil.removeDomainFromNames(deletedRoles),\n-                            UserCoreUtil.removeDomainFromNames(newRoles));\n-            return;\n-        }\n-\n-        if (userStore.isSystemStore()) {\n-            systemUserRoleManager.updateSystemRoleListOfUser(userStore.getDomainAwareUserId(),\n-                    UserCoreUtil.removeDomainFromNames(deletedRoles), UserCoreUtil.removeDomainFromNames(newRoles));\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        if (deletedRoles == null) {\n-            deletedRoles = new String[0];\n-        }\n-        if (newRoles == null) {\n-            newRoles = new String[0];\n-        }\n-        // This happens only once during first startup - adding administrator user/role.\n-        if (userID.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-            userID = userStore.getDomainFreeName();\n-            deletedRoles = UserCoreUtil.removeDomainFromNames(deletedRoles);\n-            newRoles = UserCoreUtil.removeDomainFromNames(newRoles);\n-        }\n-\n-        List<String> internalRoleDel = new ArrayList<>();\n-        List<String> internalRoleNew = new ArrayList<>();\n-\n-        List<String> roleDel = new ArrayList<>();\n-        List<String> roleNew = new ArrayList<>();\n-\n-        if (deletedRoles != null && deletedRoles.length > 0) {\n-            for (String deleteRole : deletedRoles) {\n-                if (UserCoreUtil.isEveryoneRole(deleteRole, realmConfig)) {\n-                    handleUpdateRoleListOfUserFailureWithID(\n-                            ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getCode(),\n-                            ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getMessage(), userID, deletedRoles,\n-                            newRoles);\n-                    throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.toString());\n-                }\n-                String domain = null;\n-                int index1 = deleteRole.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-                if (index1 > 0) {\n-                    domain = deleteRole.substring(0, index1);\n-                }\n-                processDeletedRoles(internalRoleDel, roleDel, deleteRole, domain);\n-            }\n-            deletedRoles = roleDel.toArray(new String[0]);\n-        }\n-\n-        if (newRoles != null && newRoles.length > 0) {\n-            for (String newRole : newRoles) {\n-                if (UserCoreUtil.isEveryoneRole(newRole, realmConfig)) {\n-                    handleUpdateRoleListOfUserFailureWithID(\n-                            ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getCode(),\n-                            ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getMessage(), userID, deletedRoles,\n-                            newRoles);\n-                    throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.toString());\n-                }\n-                String domain = null;\n-                int index2 = newRole.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-                if (index2 > 0) {\n-                    domain = newRole.substring(0, index2);\n-                }\n-\n-                processNewRoles(internalRoleNew, roleNew, newRole, domain);\n-            }\n-            newRoles = roleNew.toArray(new String[0]);\n-        }\n-\n-        if (internalRoleDel.size() > 0 || internalRoleNew.size() > 0) {\n-            hybridRoleManager.updateHybridRoleListOfUser(doGetUserNameFromUserID(userID),\n-                    internalRoleDel.toArray(new String[0]), internalRoleNew.toArray(new String[0]));\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPreUpdateRoleListOfUserWithID(userID, deletedRoles, newRoles, this)) {\n-                    handleUpdateRoleListOfUserFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_OF_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_OF_USER.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID, deletedRoles,\n-                            newRoles);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateRoleListOfUserFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_OF_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_UPDATE_ROLE_OF_USER.getMessage(),\n-                            ex.getMessage()), userID, deletedRoles, newRoles);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        if ((deletedRoles != null && deletedRoles.length > 0) || (newRoles != null && newRoles.length > 0)) {\n-            if (!isReadOnly() && writeGroupsEnabled) {\n-                try {\n-                    if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                        doUpdateRoleListOfUserWithID(userID, deletedRoles, newRoles);\n-                    } else {\n-                        doUpdateRoleListOfUser(doGetUserNameFromUserID(userID), deletedRoles, newRoles);\n-                    }\n-                } catch (UserStoreException ex) {\n-                    handleUpdateRoleListOfUserFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_OF_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_OF_USER.getMessage(),\n-                                    ex.getMessage()), userID, deletedRoles, newRoles);\n-                    throw ex;\n-                }\n-            } else {\n-                handleUpdateRoleListOfUserFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                        ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, deletedRoles, newRoles);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-            }\n-        }\n-\n-        // Clear user role cache from username.\n-        String username = doGetUserNameFromUserID(userID);\n-        if (username != null) {\n-            clearUserRolesCache(username);\n-        }\n-\n-        // Call the relevant listeners after updating the role list of user.\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPostUpdateRoleListOfUserWithID(userID, deletedRoles, newRoles, this)) {\n-                    handleUpdateRoleListOfUserFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_OF_USER.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_OF_USER.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, deletedRoles,\n-                            newRoles);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateRoleListOfUserFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_OF_USER.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_UPDATE_ROLE_OF_USER.getMessage(),\n-                            ex.getMessage()), userID, deletedRoles, newRoles);\n-            throw ex;\n-        }\n-    }\n-\n-    private void processNewRoles(List<String> internalRoleNew, List<String> roleNew, String newRole, String domain)\n-            throws UserStoreException {\n-        if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain)) {\n-            // If this is an internal role.\n-            internalRoleNew.add(UserCoreUtil.removeDomainFromName(newRole));\n-        } else if (APPLICATION_DOMAIN.equalsIgnoreCase(domain) || WORKFLOW_DOMAIN.equalsIgnoreCase(domain)) {\n-            // If this is an application role or workflow role.\n-            internalRoleNew.add(newRole);\n-        } else if (this.isReadOnly()) {\n-            // If this is a readonly user store, we add even normal roles as internal roles.\n-            internalRoleNew.add(UserCoreUtil.removeDomainFromName(newRole));\n-        } else {\n-            roleNew.add(UserCoreUtil.removeDomainFromName(newRole));\n-        }\n-    }\n-\n-    private void processDeletedRoles(List<String> internalRoleDel, List<String> roleDel, String deleteRole,\n-            String domain) throws UserStoreException {\n-        if (APPLICATION_DOMAIN.equalsIgnoreCase(domain) || WORKFLOW_DOMAIN.equalsIgnoreCase(domain)) {\n-            internalRoleDel.add(deleteRole);\n-        } else if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain) || this.isReadOnly()) {\n-            internalRoleDel.add(UserCoreUtil.removeDomainFromName(deleteRole));\n-        } else {\n-            // This is domain free role name.\n-            roleDel.add(UserCoreUtil.removeDomainFromName(deleteRole));\n-        }\n-    }\n-\n-    @Override\n-    public final void updateUserListOfRoleWithID(final String roleName,  String[] deletedUserIDs,\n-             String[] newUserIDs) throws UserStoreException {\n-\n-        try {\n-            AccessController.doPrivileged((PrivilegedExceptionAction<String>) () -> {\n-                // If unique id feature is not enabled, we have to call the legacy methods.\n-                UserStore userStore = getUserStore(roleName);\n-                if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                    List<User> deletedUsers = new ArrayList<>();\n-                    List<User> newUsers = new ArrayList<>();\n-                    if (deletedUserIDs != null) {\n-                        deletedUsers = userUniqueIDManger.getUsers(Arrays.asList(deletedUserIDs), this);\n-                    }\n-                    if (newUserIDs != null) {\n-                        newUsers = userUniqueIDManger.getUsers(Arrays.asList(newUserIDs), this);\n-                    }\n-                    // If we don't have a record for this user, let's try to call directly using the user id.\n-                    updateUserListOfRoleInternal(roleName, deletedUsers.stream().map(User::getDomainQualifiedUsername)\n-                            .toArray(String[]::new), newUsers.stream().map(User::getDomainQualifiedUsername).toArray(String[]::new));\n-                    return null;\n-                }\n-                updateUserListOfRoleInternalWithID(roleName, deletedUserIDs, newUserIDs);\n-                return null;\n-            });\n-        } catch (PrivilegedActionException e) {\n-            if (!(e.getException() instanceof UserStoreException)) {\n-                handleUpdateRoleListOfUserFailureWithID(\n-                        ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_OF_USER.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_UPDATING_ROLE_OF_USER.getMessage(),\n-                                e.getMessage()), roleName, deletedUserIDs, newUserIDs);\n-            }\n-            throw (UserStoreException) e.getException();\n-        }\n-    }\n-\n-    /**\n-     * update user list of role.\n-     */\n-    private final void updateUserListOfRoleInternalWithID(String roleName, String[] deletedUserIDs, String[] newUserIDs)\n-            throws UserStoreException {\n-\n-        String[] deletedUsernames = new String[0];\n-        if (ArrayUtils.isNotEmpty(deletedUserIDs)) {\n-            List<String> deletedUsernameList = getUserNamesFromUserIDs(Arrays.asList(deletedUserIDs));\n-            deletedUsernames = deletedUsernameList.toArray(new String[0]);\n-        }\n-\n-        String[] newUsernames = new String[0];\n-        if (ArrayUtils.isNotEmpty(newUserIDs)) {\n-            List<String> newUsernameList = getUserNamesFromUserIDs(Arrays.asList(newUserIDs));\n-            newUsernames = newUsernameList.toArray(new String[0]);\n-        }\n-\n-        String primaryDomain = getMyDomainName();\n-        if (primaryDomain != null) {\n-            primaryDomain += CarbonConstants.DOMAIN_SEPARATOR;\n-        }\n-\n-        if (deletedUsernames.length > 0) {\n-            Arrays.sort(deletedUsernames);\n-            // Updating the user list of a role belong to the primary domain.\n-            if (UserCoreUtil.isPrimaryAdminRole(roleName, realmConfig)) {\n-                for (int i = 0; i < deletedUsernames.length; i++) {\n-                    if (deletedUsernames[i].equalsIgnoreCase(realmConfig.getAdminUserName()) || (primaryDomain\n-                            + deletedUsernames[i]).equalsIgnoreCase(realmConfig.getAdminUserName())) {\n-                        handleUpdateRoleListOfUserFailureWithID(\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.getCode(),\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.getMessage(), roleName,\n-                                deletedUserIDs, newUserIDs);\n-                        throw new UserStoreException(\n-                                ErrorMessages.ERROR_CODE_CANNOT_REMOVE_ADMIN_ROLE_FROM_ADMIN.toString());\n-                    }\n-\n-                }\n-            }\n-        }\n-\n-        UserStore userStore = getUserStoreOfRoles(roleName);\n-\n-        if (userStore.isHybridRole()) {\n-            // Check whether someone is trying to update Everyone role.\n-            if (UserCoreUtil.isEveryoneRole(roleName, realmConfig)) {\n-                handleUpdateRoleListOfUserFailureWithID(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getCode(),\n-                        ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.getMessage(), roleName, deletedUserIDs,\n-                        newUserIDs);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_UPDATE_EVERYONE_ROLE.toString());\n-            }\n-\n-            if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(userStore.getDomainName())) {\n-                hybridRoleManager.updateUserListOfHybridRole(userStore.getDomainFreeName(), deletedUsernames,\n-                        newUsernames);\n-                handleDoPostUpdateUserListOfRoleWithID(roleName, deletedUserIDs, newUserIDs, true);\n-            } else {\n-                hybridRoleManager.updateUserListOfHybridRole(userStore.getDomainAwareName(), deletedUsernames,\n-                        newUsernames);\n-                handleDoPostUpdateUserListOfRoleWithID(roleName, deletedUserIDs, newUserIDs, true);\n-            }\n-            clearUserRolesCacheByTenant(this.tenantId);\n-            return;\n-        }\n-\n-        if (userStore.isSystemStore()) {\n-            systemUserRoleManager.updateUserListOfSystemRole(userStore.getDomainFreeName(),\n-                    UserCoreUtil.removeDomainFromNames(deletedUsernames),\n-                    UserCoreUtil.removeDomainFromNames(newUsernames));\n-            handleDoPostUpdateUserListOfRoleWithID(roleName, deletedUserIDs, newUserIDs, true);\n-            return;\n-        }\n-\n-        if (userStore.isRecurssive()) {\n-            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .updateUserListOfRoleWithID(userStore.getDomainFreeName(),\n-                            UserCoreUtil.removeDomainFromNames(deletedUserIDs),\n-                            UserCoreUtil.removeDomainFromNames(newUserIDs));\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        if (deletedUserIDs == null) {\n-            deletedUserIDs = new String[0];\n-        }\n-        if (newUserIDs == null) {\n-            newUserIDs = new String[0];\n-        }\n-        // #################### <Listeners> #####################################################\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPreUpdateUserListOfRoleWithID(roleName, deletedUserIDs, newUserIDs, this)) {\n-                    handleUpdateRoleListOfUserFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_UPDATE_USERS_OF_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_UPDATE_USERS_OF_ROLE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), roleName, deletedUserIDs,\n-                            newUserIDs);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleUpdateRoleListOfUserFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_UPDATE_USERS_OF_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_PRE_UPDATE_USERS_OF_ROLE.getMessage(),\n-                            ex.getMessage()), roleName, deletedUserIDs, newUserIDs);\n-            throw ex;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        if (deletedUserIDs.length > 0 || newUserIDs.length > 0) {\n-            if (!isReadOnly() && writeGroupsEnabled) {\n-                try {\n-                    doUpdateUserListOfRoleWithID(userStore.getDomainFreeName(),\n-                            UserCoreUtil.removeDomainFromNames(deletedUserIDs),\n-                            UserCoreUtil.removeDomainFromNames(newUserIDs));\n-                } catch (UserStoreException ex) {\n-                    handleUpdateRoleListOfUserFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_UPDATE_USERS_OF_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_UPDATE_USERS_OF_ROLE.getMessage(),\n-                                    ex.getMessage()), roleName, deletedUserIDs, newUserIDs);\n-                    throw ex;\n-                }\n-            } else {\n-                handleUpdateRoleListOfUserFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                        ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), roleName, deletedUserIDs,\n-                        newUserIDs);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-            }\n-        }\n-\n-        // need to clear user roles cache upon roles update\n-        clearUserRolesCacheByTenant(this.tenantId);\n-\n-        // Call relevant listeners after updating user list of role.\n-        handleDoPostUpdateUserListOfRoleWithID(roleName, deletedUserIDs, newUserIDs, false);\n-    }\n-\n-    @Override\n-    public final User addUserWithID(String userName, Object credential, String[] roleList, Map<String, String> claims,\n-            String profileName) throws UserStoreException {\n-\n-        // We have to make sure this call is going through the Java Security Manager.\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[] {\n-                    String.class, Object.class, String[].class, Map.class, String.class\n-            };\n-            Object object = callSecure(\"addUserWithID\",\n-                    new Object[] { userName, credential, roleList, claims, profileName }, argTypes);\n-            return (User) object;\n-        }\n-\n-        // If we don't have a username, we cannot proceed.\n-        if (StringUtils.isEmpty(userName)) {\n-            String message = ErrorMessages.ERROR_CODE_USERNAME_CANNOT_BE_EMPTY.getMessage();\n-            String errorCode = ErrorMessages.ERROR_CODE_USERNAME_CANNOT_BE_EMPTY.getCode();\n-            handleAddUserFailureWithID(errorCode, message, null, credential, roleList, claims, profileName);\n-            throw new UserStoreException(errorCode + \" - \" + message);\n-        }\n-\n-        // If the username claims presents, the value should be equal to the username attribute.\n-        if (claims != null && claims.containsKey(USERNAME_CLAIM_URI) &&\n-                !claims.get(USERNAME_CLAIM_URI).equals(userName)) {\n-            // If not we cannot continue.\n-            throw new UserStoreException(\"Username and the username claim value should be same.\");\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .addUserWithID(userStore.getDomainFreeName(), credential, roleList, claims, profileName);\n-        }\n-\n-        // Convert the credential (Password) to a Secret.\n-        Secret credentialObj;\n-        try {\n-            credentialObj = Secret.getSecret(credential);\n-        } catch (UnsupportedSecretTypeException e) {\n-            handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), userName, credential, roleList,\n-                    claims, profileName);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-        }\n-\n-        User user;\n-        try {\n-            if (userStore.isSystemStore()) {\n-                systemUserRoleManager.addSystemUser(userName, credentialObj, roleList);\n-                return null;\n-            }\n-\n-            // #################### Domain Name Free Zone Starts Here ################################\n-\n-            if (isReadOnly()) {\n-                handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                        ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userName, credential, roleList,\n-                        claims, profileName);\n-                throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-            }\n-\n-            // This happens only once during first startup - adding administrator user/role.\n-            if (userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-                userName = userStore.getDomainFreeName();\n-                roleList = UserCoreUtil.removeDomainFromNames(roleList);\n-            }\n-            if (roleList == null) {\n-                roleList = new String[0];\n-            }\n-            if (claims == null) {\n-                claims = new HashMap<>();\n-            }\n-\n-            // #################### <Pre-Listeners> #####################################################\n-            try {\n-                // First call user store manager listeners.\n-                for (UserStoreManagerListener listener : UMListenerServiceComponent.getUserStoreManagerListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = credentialObj;\n-                    } else {\n-                        credentialArgument = credential;\n-                    }\n-\n-                    if (!((AbstractUserStoreManagerListener) listener)\n-                            .addUserWithID(userName, credentialArgument, roleList, claims, profileName, this)) {\n-                        handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                        UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName, credential,\n-                                roleList, claims, profileName);\n-                        return null;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(), ex.getMessage()),\n-                        userName, credential, roleList, claims, profileName);\n-                throw ex;\n-            }\n-\n-            // Then call the user operation listeners.\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-\n-                // This is to call all new listeners. All listeners should support the Secret object as the credential\n-                // for security reasons.\n-                if (listener instanceof SecretHandleableListener) {\n-                    try {\n-                        if (!((AbstractUserOperationEventListener) listener)\n-                                .doPreAddUserWithID(userName, credentialObj, roleList, claims, profileName, this)) {\n-                            handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                    credential, roleList, claims, profileName);\n-                            return null;\n-                        }\n-                    } catch (UserStoreException ex) {\n-                        String message = String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                ex.getMessage());\n-                        handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                message, userName, credential, roleList, claims, profileName);\n-                        throw ex;\n-                    }\n-                } else {\n-                    // This is to support the legacy listeners which does not know how to handle the Secret object as\n-                    // the credentials.\n-\n-                    // String buffers are used to let listeners to modify passwords\n-                    StringBuffer credBuff = null;\n-                    if (credential == null) {\n-                        // A default password will be set if the credential is null.\n-                        credBuff = new StringBuffer();\n-                    } else if (credential instanceof String) {\n-                        credBuff = new StringBuffer((String) credential);\n-                    }\n-\n-                    if (credBuff != null) {\n-                        try {\n-                            if (!((AbstractUserOperationEventListener) listener)\n-                                    .doPreAddUserWithID(userName, credBuff, roleList, claims, profileName, this)) {\n-                                handleAddUserFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                                UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                        credential, roleList, claims, profileName);\n-                                return null;\n-                            }\n-                        } catch (UserStoreException e) {\n-                            handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_USER.getMessage(),\n-                                            e.getMessage()), userName, credential, roleList, claims, profileName);\n-                            throw e;\n-                        }\n-                        // Reading the modified value.\n-                        credential = credBuff.toString();\n-                        credentialObj.clear();\n-                        try {\n-                            // Create the Secret from the modified credential.\n-                            credentialObj = Secret.getSecret(credential);\n-                        } catch (UnsupportedSecretTypeException e) {\n-                            handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getCode(),\n-                                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.getMessage(), userName,\n-                                    credential, roleList, claims, profileName);\n-                            throw new UserStoreException(\n-                                    ErrorMessages.ERROR_CODE_UNSUPPORTED_CREDENTIAL_TYPE.toString(), e);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // #################### </Pre-Listeners> #####################################################\n-\n-            // Validate the username against provided regular expressions.\n-            if (!checkUserNameValid(userStore.getDomainFreeName())) {\n-                String regEx = realmConfig\n-                        .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG_EX);\n-                // Inorder to support both UsernameJavaRegEx and UserNameJavaRegEx.\n-                if (StringUtils.isEmpty(regEx) || StringUtils.isEmpty(regEx.trim())) {\n-                    regEx = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG);\n-                }\n-                String message = String\n-                        .format(ErrorMessages.ERROR_CODE_INVALID_USER_NAME.getMessage(), userStore.getDomainFreeName(),\n-                                regEx);\n-                String errorCode = ErrorMessages.ERROR_CODE_INVALID_USER_NAME.getCode();\n-                handleAddUserFailureWithID(errorCode, message, userName, credential, roleList, claims, profileName);\n-                throw new UserStoreException(errorCode + \" - \" + message);\n-            }\n-\n-            // Validate the password against provided regular expressions.\n-            if (!checkUserPasswordValid(credentialObj)) {\n-                String regEx = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX);\n-                String message = String.format(ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getMessage(), regEx);\n-                String errorCode = ErrorMessages.ERROR_CODE_INVALID_PASSWORD.getCode();\n-                handleAddUserFailureWithID(errorCode, message, userName, credential, roleList, claims, profileName);\n-                throw new UserStoreException(errorCode + \" - \" + message);\n-            }\n-\n-            // Property to check whether this user store supports new APIs with unique user id.\n-            boolean isUniqueUserIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n-\n-            boolean isExistingUser;\n-            if (isUniqueUserIdEnabled) {\n-                isExistingUser = getUserIDFromUserName(userName) != null;\n-            } else {\n-                isExistingUser = doCheckExistingUser(userName);\n-            }\n-            // Check if the user already exists in the user store.\n-            if (isExistingUser) {\n-                String message = String.format(ErrorMessages.ERROR_CODE_USER_ALREADY_EXISTS.getMessage(), userName);\n-                String errorCode = ErrorMessages.ERROR_CODE_USER_ALREADY_EXISTS.getCode();\n-                handleAddUserFailureWithID(errorCode, message, userName, credential, roleList, claims, profileName);\n-                throw new UserStoreException(errorCode + \" - \" + message);\n-            }\n-\n-            // Filter roles into internal roles and external roles.\n-            List<String> internalRoles = new ArrayList<>();\n-            List<String> externalRoles = new ArrayList<>();\n-            filterRoles(roleList, internalRoles, externalRoles);\n-\n-            // Check existence of roles and claims before adding user.\n-            for (String internalRole : internalRoles) {\n-                if (!hybridRoleManager.isExistingRole(internalRole)) {\n-                    String message = String\n-                            .format(ErrorMessages.ERROR_CODE_INTERNAL_ROLE_NOT_EXISTS.getMessage(), internalRole);\n-                    String errorCode = ErrorMessages.ERROR_CODE_INTERNAL_ROLE_NOT_EXISTS.getCode();\n-                    handleAddUserFailureWithID(errorCode, message, userName, credential, roleList, claims, profileName);\n-                    throw new UserStoreException(errorCode + \" - \" + message);\n-                }\n-            }\n-\n-            // Check whether external roles are existing in the user store.\n-            for (String externalRole : externalRoles) {\n-                if (!doCheckExistingRole(externalRole)) {\n-                    String message = String\n-                            .format(ErrorMessages.ERROR_CODE_EXTERNAL_ROLE_NOT_EXISTS.getMessage(), externalRole);\n-                    String errorCode = ErrorMessages.ERROR_CODE_EXTERNAL_ROLE_NOT_EXISTS.getCode();\n-                    handleAddUserFailureWithID(errorCode, message, userName, credential, roleList, claims, profileName);\n-                    throw new UserStoreException(errorCode + \" - \" + message);\n-                }\n-            }\n-\n-            // Check whether the claims are existing.\n-            for (Map.Entry<String, String> entry : claims.entrySet()) {\n-                ClaimMapping claimMapping;\n-                try {\n-                    claimMapping = (ClaimMapping) claimManager.getClaimMapping(entry.getKey());\n-                } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                    String errorMessage = String\n-                            .format(ErrorMessages.ERROR_CODE_UNABLE_TO_FETCH_CLAIM_MAPPING.getMessage(),\n-                                    \"persisting user attributes.\");\n-                    String errorCode = ErrorMessages.ERROR_CODE_UNABLE_TO_FETCH_CLAIM_MAPPING.getCode();\n-                    handleAddUserFailureWithID(errorCode, errorMessage, userName, credential, roleList, claims,\n-                            profileName);\n-                    throw new UserStoreException(errorCode + \" - \" + errorMessage, e);\n-                }\n-                if (claimMapping == null) {\n-                    String errorMessage = String\n-                            .format(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getMessage(), entry.getKey());\n-                    String errorCode = ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getCode();\n-                    handleAddUserFailureWithID(errorCode, errorMessage, userName, credential, roleList, claims,\n-                            profileName);\n-                    throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-                }\n-            }\n-\n-            // Call the do add user method of the underlying user store to add the user.\n-            try {\n-                // If unique user id property is enabled, then we can call the new methods in the user store.\n-                if (isUniqueUserIdEnabled) {\n-                    user = doAddUserWithID(userName, credentialObj, externalRoles.toArray(new String[0]), claims,\n-                            profileName, false);\n-                } else {\n-                    // If the underlying user store does not support the unique ID generation, then we have to generate\n-                    // the ID and keep the mapping in our side.\n-                    doAddUser(userName, credentialObj, externalRoles.toArray(new String[0]), claims, profileName,\n-                            false);\n-                    user = userUniqueIDManger.addUser(userStore.getDomainFreeName(), profileName, this);\n-                }\n-            } catch (UserStoreException ex) {\n-                handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_ADDING_USER.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_ADDING_USER.getMessage(), ex.getMessage()),\n-                        userName, credential, roleList, claims, profileName);\n-                throw ex;\n-            }\n-\n-            if (internalRoles.size() > 0) {\n-                hybridRoleManager.updateHybridRoleListOfUser(userName, null, internalRoles.toArray(new String[0]));\n-            }\n-\n-            // #################### <Post-Listeners> #####################################################\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    Object credentialArgument;\n-                    if (listener instanceof SecretHandleableListener) {\n-                        credentialArgument = credentialObj;\n-                    } else {\n-                        credentialArgument = credential;\n-                    }\n-\n-                    if (!((AbstractUserOperationEventListener) listener)\n-                            .doPostAddUserWithID(user, credentialArgument, roleList, claims, profileName, this)) {\n-                        handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_USER.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_USER.getMessage(),\n-                                        UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userName,\n-                                credential, roleList, claims, profileName);\n-                        return null;\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleAddUserFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_USER.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_USER.getMessage(),\n-                                ex.getMessage()), userName, credential, roleList, claims, profileName);\n-                throw ex;\n-            }\n-            // #################### </Post-Listeners> #####################################################\n-        } finally {\n-            credentialObj.clear();\n-        }\n-\n-        // Clean the role cache since it contains old role information.\n-        clearUserRolesCache(userName);\n-        return user;\n-    }\n-\n-    @Override\n-    public void addRoleWithID(String roleName, String[] userIDList, Permission[] permissions, boolean isSharedRole)\n-            throws UserStoreException {\n-\n-        if (StringUtils.isEmpty(roleName)) {\n-            handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_CANNOT_ADD_EMPTY_ROLE.getCode(),\n-                    ErrorMessages.ERROR_CODE_CANNOT_ADD_EMPTY_ROLE.getMessage(), roleName, userIDList, permissions);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_CANNOT_ADD_EMPTY_ROLE.toString());\n-        }\n-\n-        if (userIDList == null) {\n-            userIDList = new String[0];\n-        }\n-        UserStore userStore = getUserStore(roleName);\n-\n-        if (isSharedRole && !isSharedGroupEnabled()) {\n-            handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_SHARED_ROLE_NOT_SUPPORTED.getCode(),\n-                    ErrorMessages.ERROR_CODE_SHARED_ROLE_NOT_SUPPORTED.getMessage(), roleName, userIDList, permissions);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_SHARED_ROLE_NOT_SUPPORTED.toString());\n-        }\n-        String[] userList = new String[0];\n-        if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-            userList = userUniqueIDManger.getUsers(Arrays.asList(userIDList), this)\n-                    .stream()\n-                    .map(User::getDomainQualifiedUsername)\n-                    .toArray(String[]::new);\n-        }\n-\n-        if (userStore.isHybridRole()) {\n-            //Invoke Pre listeners for hybrid roles.\n-            if (!handlePreAddRoleWithID(roleName, userIDList, permissions, false)) {\n-                return;\n-            }\n-\n-            if (isUniqueUserIdEnabledInUserStore(userStore)) {\n-                doAddInternalRoleWithID(roleName, userIDList, permissions);\n-            } else {\n-                doAddInternalRole(roleName, userList, permissions);\n-            }\n-            // Calling only the audit logger, to maintain the back-ward compatibility\n-            handlePostAddRoleWithID(roleName, userIDList, permissions, false);\n-            return;\n-        }\n-\n-        if (userStore.isRecurssive()) {\n-            ((UniqueIDUserStoreManager) userStore.getUserStoreManager())\n-                    .addRoleWithID(userStore.getDomainFreeName(), UserCoreUtil.removeDomainFromNames(userIDList),\n-                            permissions, isSharedRole);\n-            return;\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        if (userIDList == null) {\n-            userIDList = new String[0];\n-        }\n-        if (permissions == null) {\n-            permissions = new Permission[0];\n-        }\n-        // This happens only once during first startup - adding administrator user/role.\n-        if (roleName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-            roleName = userStore.getDomainFreeName();\n-            userIDList = UserCoreUtil.removeDomainFromNames(userIDList);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        if (!handlePreAddRoleWithID(roleName, userIDList, permissions, false)) {\n-            return;\n-        }\n-        // #################### </Listeners> #####################################################\n-\n-        // Check for validations\n-        if (isReadOnly()) {\n-            handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n-                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), roleName, userIDList, permissions);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n-        }\n-\n-        if (!isRoleNameValid(roleName)) {\n-            String regEx = realmConfig\n-                    .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n-            String errorMessage = String\n-                    .format(ErrorMessages.ERROR_CODE_INVALID_ROLE_NAME.getMessage(), roleName, regEx);\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_ROLE_NAME.getCode();\n-            handleAddRoleFailureWithID(errorCode, errorMessage, roleName, userIDList, permissions);\n-            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n-        }\n-\n-        if (doCheckExistingRole(roleName)) {\n-            handleRoleAlreadyExistExceptionWithID(roleName, userIDList, permissions);\n-        }\n-\n-        String roleWithDomain;\n-        if (writeGroupsEnabled) {\n-            try {\n-                // add role in to actual user store\n-                if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-                    List<User> users = userUniqueIDManger.getUsers(Arrays.asList(userIDList), this);\n-                    doAddRole(roleName, users.stream().map(User::getUsername).toArray(String[]::new), isSharedRole);\n-                } else {\n-                    doAddRoleWithID(roleName, userIDList, isSharedRole);\n-                }\n-                roleWithDomain = UserCoreUtil.addDomainToName(roleName, getMyDomainName());\n-            } catch (UserStoreException ex) {\n-                handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_ERROR_WHILE_ADDING_ROLE.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_ADDING_ROLE.getMessage(), ex.getMessage()),\n-                        roleName, userIDList, permissions);\n-                throw ex;\n-            }\n-        } else {\n-            handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.getCode(),\n-                    ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.getMessage(), roleName, userIDList,\n-                    permissions);\n-            throw new UserStoreException(ErrorMessages.ERROR_CODE_WRITE_GROUPS_NOT_ENABLED.toString());\n-        }\n-\n-        // add permission in to the the permission store\n-        for (org.wso2.carbon.user.api.Permission permission : permissions) {\n-            String resourceId = permission.getResourceId();\n-            String action = permission.getAction();\n-            if (resourceId == null || resourceId.trim().length() == 0) {\n-                continue;\n-            }\n-\n-            if (action == null || action.trim().length() == 0) {\n-                // default action value\n-                action = \"read\";\n-            }\n-            // This is a special case. We need to pass domain aware name.\n-            userRealm.getAuthorizationManager().authorizeRole(roleWithDomain, resourceId, action);\n-        }\n-\n-        // if existing users are added to role, need to update user role cache\n-        if ((userIDList != null) && (userIDList.length > 0)) {\n-            clearUserRolesCacheByTenant(tenantId);\n-        }\n-\n-        // #################### <Listeners> #####################################################\n-        handlePostAddRoleWithID(roleName, userIDList, permissions, false);\n-        // #################### </Listeners> #####################################################\n-    }\n-\n-    /**\n-     * This method is responsible for calling relevant postAddRole listener methods after successfully adding role.\n-     *\n-     * @param roleName       Name of the role.\n-     * @param userList       List of users.\n-     * @param permissions    Permissions that are assigned to the role.\n-     * @param isAuditLogOnly To indicate whether to only call the relevant audit logger.\n-     * @throws UserStoreException Exception that will be thrown by relevant listeners.\n-     */\n-    private void handlePostAddRoleWithID(String roleName, String[] userList, Permission[] permissions,\n-            boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            boolean internalRole = isAnInternalRole(roleName);\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName()\n-                        .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-\n-                boolean success = false;\n-                if (internalRole && listener instanceof AbstractUserOperationEventListener) {\n-                    success = ((AbstractUserOperationEventListener) listener)\n-                            .doPostAddInternalRoleWithID(roleName, userList, permissions, this);\n-                } else if (internalRole && !(listener instanceof AbstractUserOperationEventListener)) {\n-                    success = true;\n-                } else if (!internalRole) {\n-                    success = ((UniqueIDUserOperationEventListener) listener)\n-                            .doPostAddRoleWithID(roleName, userList, permissions, this);\n-                }\n-\n-                if (!success) {\n-                    handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_ROLE.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), roleName, userList,\n-                            permissions);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_ADD_ROLE.getMessage(), ex.getMessage()),\n-                    roleName, userList, permissions);\n-            throw ex;\n-        }\n-    }\n-\n-    /**\n-     * Handle pre add role tasks.\n-     */\n-    private boolean handlePreAddRoleWithID(String roleName, String[] userList, Permission[] permissions,\n-            boolean isAuditLogOnly) throws UserStoreException {\n-\n-        try {\n-            boolean internalRole = isAnInternalRole(roleName);\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (isAuditLogOnly && !listener.getClass().getName()\n-                        .endsWith(UserCoreErrorConstants.AUDIT_LOGGER_CLASS_NAME)) {\n-                    continue;\n-                }\n-\n-                boolean success = false;\n-                if (internalRole && listener instanceof AbstractUserOperationEventListener) {\n-                    success = ((AbstractUserOperationEventListener) listener)\n-                            .doPreAddInternalRoleWithID(roleName, userList, permissions, this);\n-                } else if (internalRole && !(listener instanceof AbstractUserOperationEventListener)) {\n-                    success = true;\n-                } else if (!internalRole) {\n-                    success = ((UniqueIDUserOperationEventListener) listener)\n-                            .doPreAddRoleWithID(roleName, userList, permissions, this);\n-                }\n-\n-                if (!success) {\n-                    handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_ROLE.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_ROLE.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), roleName, userList,\n-                            permissions);\n-                    return false;\n-                }\n-            }\n-        } catch (UserStoreException ex) {\n-            handleAddRoleFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_ROLE.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_ADD_ROLE.getMessage(), ex.getMessage()),\n-                    roleName, userList, permissions);\n-            throw ex;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Add the internal roles for the users.\n-     *\n-     * @param roleName    role name.\n-     * @param userIDList    user List.\n-     * @param permissions permissions.\n-     * @throws UserStoreException An unexpected exception has occurred.\n-     */\n-    protected void doAddInternalRoleWithID(String roleName, String[] userIDList,\n-                                           org.wso2.carbon.user.api.Permission[] permissions)\n-            throws UserStoreException {\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        String[] users = getUserNamesFromUserIDs(Arrays.asList(userIDList)).toArray(new String[0]);\n-        if (roleName.contains(UserCoreConstants.DOMAIN_SEPARATOR) && roleName.toLowerCase()\n-                .startsWith(APPLICATION_DOMAIN.toLowerCase())) {\n-            if (hybridRoleManager.isExistingRole(roleName)) {\n-                handleRoleAlreadyExistExceptionWithID(roleName, userIDList, permissions);\n-            }\n-            hybridRoleManager.addHybridRole(roleName, users);\n-        } else {\n-            if (hybridRoleManager.isExistingRole(UserCoreUtil.removeDomainFromName(roleName))) {\n-                handleRoleAlreadyExistExceptionWithID(roleName, userIDList, permissions);\n-            }\n-            hybridRoleManager.addHybridRole(UserCoreUtil.removeDomainFromName(roleName), users);\n-        }\n-\n-        if (permissions != null) {\n-            for (org.wso2.carbon.user.api.Permission permission : permissions) {\n-                String resourceId = permission.getResourceId();\n-                String action = permission.getAction();\n-                // This is a special case. We need to pass domain aware name.\n-                userRealm.getAuthorizationManager()\n-                        .authorizeRole(UserCoreUtil.addInternalDomainName(roleName), resourceId, action);\n-            }\n-        }\n-\n-        if ((userIDList != null) && (userIDList.length > 0)) {\n-            clearUserRolesCacheByTenant(this.tenantId);\n-        }\n-    }\n-\n-    /**\n-     * Categorize roles to the internal and external.\n-     */\n-    private void filterRoles(String[] roleList, List<String> internalRoles, List<String> externalRoles) {\n-\n-        if (roleList == null) {\n-            return;\n-        }\n-\n-        int index;\n-        for (String role : roleList) {\n-            if (role.trim().length() == 0) {\n-                continue;\n-            }\n-            index = role.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-            if (index > 0) {\n-                String domain = role.substring(0, index);\n-                if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain)) {\n-                    internalRoles.add(UserCoreUtil.removeDomainFromName(role));\n-                    continue;\n-                } else if (APPLICATION_DOMAIN.equalsIgnoreCase(domain) || WORKFLOW_DOMAIN\n-                        .equalsIgnoreCase(domain)) {\n-                    internalRoles.add(role);\n-                    continue;\n-                }\n-            }\n-            externalRoles.add(UserCoreUtil.removeDomainFromName(role));\n-        }\n-    }\n-\n-    @Override\n-    public boolean isUserInRoleWithID(String userID, String roleName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class, String.class};\n-            Object object = callSecure(\"isUserInRoleWithID\", new Object[] { userID, roleName }, argTypes);\n-            return (Boolean) object;\n-        }\n-\n-        UserStore userStore = getUserStoreWithID(userID);\n-\n-        if (userStore.isRecurssive() && (userStore.getUserStoreManager() instanceof AbstractUserStoreManager)) {\n-            return ((AbstractUserStoreManager) userStore.getUserStoreManager())\n-                    .isUserInRoleWithID(userStore.getDomainFreeUserId(), roleName);\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-        // If unique id feature is not enabled, we have to call the legacy methods.\n-        if (!isUniqueUserIdEnabledInUserStore(userStore)) {\n-            User user = userUniqueIDManger.getUser(userID, this);\n-            // If we don't have a record for this user, let's try to call directly using the user id.\n-            if (user == null) {\n-                return false;\n-            }\n-            return isUserInRole(user.getDomainQualifiedUsername(), roleName);\n-        }\n-\n-        if (roleName == null || roleName.trim().length() == 0 || userID == null || userID.trim().length() == 0) {\n-            return false;\n-        }\n-\n-        // anonymous user is always assigned to  anonymous role\n-        if (CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME.equalsIgnoreCase(roleName)\n-                && CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userID)) {\n-            return true;\n-        }\n-\n-        if (!CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userID) && realmConfig.getEveryOneRoleName()\n-                .equalsIgnoreCase(roleName) && !systemUserRoleManager.isExistingSystemUser(UserCoreUtil.\n-                removeDomainFromName(userID))) {\n-            return true;\n-        }\n-\n-        String[] roles;\n-\n-        String username = getUserNameFromUserID(userID);\n-        if (username == null) {\n-            roles = getRoleListOfUserFromCache(tenantId, userID);\n-            if (roles != null && roles.length > 0) {\n-                if (UserCoreUtil.isContain(roleName, roles)) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        String modifiedUserName = UserCoreConstants.IS_USER_IN_ROLE_CACHE_IDENTIFIER + username;\n-        roles = getRoleListOfUserFromCache(tenantId, modifiedUserName);\n-        if (roles != null && roles.length > 0) {\n-            if (UserCoreUtil.isContain(roleName, roles)) {\n-                return true;\n-            }\n-        }\n-\n-        if (UserCoreConstants.INTERNAL_DOMAIN.\n-                equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName)) || APPLICATION_DOMAIN\n-                .equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName)) || WORKFLOW_DOMAIN\n-                .equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName))) {\n-\n-            List<String> internalRoles = doGetInternalRoleListOfUserWithID(userID, roleName);\n-            if (internalRoles.contains(roleName)) {\n-                addToIsUserHasRole(modifiedUserName, roleName, roles);\n-                return true;\n-            }\n-        }\n-\n-        if (userStore.isSystemStore()) {\n-            return systemUserRoleManager\n-                    .isUserInRole(userStore.getDomainFreeUserId(), UserCoreUtil.removeDomainFromName(roleName));\n-        }\n-        // admin user is always assigned to admin role if it is in primary user store\n-        if (realmConfig.isPrimary() && roleName.equalsIgnoreCase(realmConfig.getAdminRoleName()) && userID\n-                .equalsIgnoreCase(realmConfig.getAdminUserName())) {\n-            return true;\n-        }\n-\n-        String roleDomainName = UserCoreUtil.extractDomainFromName(roleName);\n-\n-        String roleDomainNameForForest = realmConfig.\n-                getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_GROUP_SEARCH_DOMAINS);\n-        if (roleDomainNameForForest != null && roleDomainNameForForest.trim().length() > 0) {\n-            String[] values = roleDomainNameForForest.split(\"#\");\n-            for (String value : values) {\n-                if (value != null && !value.trim().equalsIgnoreCase(roleDomainName)) {\n-                    return false;\n-                }\n-            }\n-        } else if (!userStore.getDomainName().equalsIgnoreCase(roleDomainName)) {\n-            return false;\n-        }\n-\n-        boolean success = false;\n-        if (readGroupsEnabled) {\n-            success = doCheckIsUserInRoleWithID(userStore.getDomainFreeUserId(),\n-                    UserCoreUtil.removeDomainFromName(roleName));\n-        }\n-\n-        // add to cache\n-        if (success) {\n-            addToIsUserHasRole(modifiedUserName, roleName, roles);\n-        }\n-        return success;\n-    }\n-\n-    @Override\n-    public List<User> listUsersWithID(String filter, int limit, int offset) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[]{String.class, int.class, int.class};\n-            Object object = callSecure(\"listUsersWithID\", new Object[] { filter, limit, offset }, argTypes);\n-            return (List<User>) object;\n-        }\n-\n-        int index = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        UniqueIDPaginatedSearchResult userList;\n-\n-        List<User> users;\n-        if (offset <= 0) {\n-            offset = 1;\n-        }\n-\n-        if (index > 0) {\n-            String domain = filter.substring(0, index);\n-\n-            UserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-            if (secManager != null) {\n-                // Secondary UserStoreManager registered for this domain.\n-                filter = filter.substring(index + 1);\n-                if (secManager instanceof AbstractUserStoreManager) {\n-                    if (((AbstractUserStoreManager) secManager).isUniqueUserIdEnabled()) {\n-                        userList = ((AbstractUserStoreManager) secManager).doListUsersWithID(filter, limit, offset);\n-                        handlePostListPaginatedUsersWithID(filter, limit, offset, userList.getUsers(), true);\n-                    } else {\n-                        PaginatedSearchResult paginatedSearchResult = ((AbstractUserStoreManager) secManager)\n-                                .doListUsers(filter, limit, offset);\n-                        handlePostListPaginatedUsers(filter, limit, offset,\n-                                Arrays.asList(paginatedSearchResult.getUsers()), true);\n-                        userList = userUniqueIDManger.listUsers(paginatedSearchResult, this);\n-                    }\n-                    return userList.getUsers();\n-                }\n-            }\n-        } else if (index == 0) {\n-            if (isUniqueUserIdEnabled()) {\n-                userList = doListUsersWithID(filter.substring(1), limit, offset);\n-                handlePostListPaginatedUsersWithID(filter, limit, offset, userList.getUsers(), true);\n-            } else {\n-                PaginatedSearchResult paginatedSearchResult = doListUsers(filter.substring(1), limit, offset);\n-                handlePostListPaginatedUsers(filter, limit, offset, Arrays.asList(paginatedSearchResult.getUsers()),\n-                        true);\n-                userList = userUniqueIDManger.listUsers(paginatedSearchResult, this);\n-            }\n-\n-            return userList.getUsers();\n-        }\n-\n-        try {\n-            if (isUniqueUserIdEnabled()) {\n-                userList = doListUsersWithID(filter, limit, offset);\n-            } else {\n-                userList = userUniqueIDManger.listUsers(doListUsers(filter, limit, offset), this);\n-            }\n-            users = new ArrayList<>(userList.getUsers());\n-            limit = limit - users.size();\n-        } catch (UserStoreException ex) {\n-            handleGetPaginatedUserListFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_WHILE_LISTING_PAGINATED_USERS.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_LISTING_PAGINATED_USERS.getMessage(),\n-                            ex.getMessage()), null, null, null);\n-            throw ex;\n-        }\n-\n-        String primaryDomain = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\n-        int nonPaginatedUserCount = userList.getSkippedUserCount();\n-        if (this.getSecondaryUserStoreManager() != null) {\n-            for (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-                if (limit <= 0) {\n-                    return users;\n-                }\n-                if (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n-                    continue;\n-                }\n-                UserStoreManager storeManager = entry.getValue();\n-                if (storeManager instanceof AbstractUserStoreManager) {\n-                    try {\n-\n-                        if (userList.getUsers().size() > 0) {\n-                            offset = 1;\n-                        } else {\n-                            offset = offset - nonPaginatedUserCount;\n-                        }\n-\n-                        UniqueIDPaginatedSearchResult secondUserList;\n-                        if (((AbstractUserStoreManager) storeManager).isUniqueUserIdEnabled()) {\n-                            secondUserList = ((AbstractUserStoreManager) storeManager).doListUsersWithID(filter, limit, offset);\n-                            nonPaginatedUserCount = secondUserList.getSkippedUserCount();\n-                        } else {\n-                            PaginatedSearchResult paginatedSearchResult =\n-                                    ((AbstractUserStoreManager) storeManager).doListUsers(filter.substring(1), limit, offset);\n-                            secondUserList = userUniqueIDManger.listUsers(paginatedSearchResult, this);\n-                        }\n-                        users.addAll(secondUserList.getUsers());\n-                        limit = limit - users.size();\n-                    } catch (UserStoreException ex) {\n-                        handleGetPaginatedUserListFailure(\n-                                ErrorMessages.ERROR_CODE_ERROR_WHILE_LISTING_PAGINATED_USERS.getCode(),\n-                                String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_LISTING_PAGINATED_USERS.getMessage(),\n-                                        ex.getMessage()), null, null, null);\n-\n-                        // We can ignore and proceed. Ignore the results from this user store.\n-                        log.error(ex);\n-                    }\n-                }\n-            }\n-        }\n-        handlePostListPaginatedUsersWithID(filter, limit, offset, users, true);\n-        return users;\n-    }\n-\n-    @Override\n-    public List<User> getUserListWithID(String claim, String claimValue, String profileName, int limit, int offset)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class argTypes[] = new Class[] { String.class, String.class, String.class, int.class, int.class };\n-            Object object = callSecure(\"getUserListWithID\",\n-                    new Object[] { claim, claimValue, profileName, limit, offset }, argTypes);\n-            return (List<User>) object;\n-        }\n-\n-        if (claim == null) {\n-            String errorCode = ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getCode();\n-            String errorMessage = String.format(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.getMessage(), \"\");\n-            handleGetUserListFailureWithID(errorCode, errorMessage, null, claimValue, limit, offset, profileName);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_INVALID_CLAIM_URI.toString());\n-        }\n-\n-        if (claimValue == null) {\n-            handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.getCode(), ErrorMessages.\n-                    ERROR_CODE_INVALID_CLAIM_VALUE.getMessage(), claim, null, limit, offset, profileName);\n-            throw new IllegalArgumentException(ErrorMessages.ERROR_CODE_INVALID_CLAIM_VALUE.toString());\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Listing and paginate users who having value as \" + claimValue + \" for the claim \" + claim);\n-        }\n-\n-        if (USERNAME_CLAIM_URI.equalsIgnoreCase(claim) || SCIM_USERNAME_CLAIM_URI.equalsIgnoreCase(claim)\n-                || SCIM2_USERNAME_CLAIM_URI.equalsIgnoreCase(claim)) {\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Switching to paginate users using username\");\n-            }\n-\n-            List<User> filteredUsers;\n-            if (isUniqueUserIdEnabled()) {\n-                filteredUsers = listUsersWithID(claimValue, limit, offset);\n-            } else {\n-                filteredUsers = userUniqueIDManger.listUsers(listUsers(claimValue, limit, offset), this);\n-            }\n-\n-            return filteredUsers;\n-        }\n-\n-        // Extracting the domain from claimValue.\n-        String extractedDomain = null;\n-        int index;\n-        index = claimValue.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-        if (index > 0) {\n-            String names[] = claimValue.split(CarbonConstants.DOMAIN_SEPARATOR);\n-            extractedDomain = names[0].trim();\n-        }\n-\n-        UserStoreManager userManager = this;\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            userManager = getSecondaryUserStoreManager(extractedDomain);\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Domain: \" + extractedDomain + \" is passed with the claim and user store manager is loaded\"\n-                        + \" for the given domain name.\");\n-            }\n-        }\n-\n-        claimValue = UserCoreUtil.removeDomainFromName(claimValue);\n-\n-        final List<User> filteredUserList = new ArrayList<>();\n-\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-            try {\n-                for (UserOperationEventListener listener : UMListenerServiceComponent\n-                        .getUserOperationEventListeners()) {\n-                    if (listener instanceof AbstractUserOperationEventListener) {\n-                        AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                        if (!newListener.doPreGetUserListWithID(claim, claimValue, limit, offset, filteredUserList,\n-                                userManager)) {\n-                            handleGetUserListFailureWithID(\n-                                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST\n-                                                    .getMessage(),\n-                                            UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), claim,\n-                                    claimValue, limit, offset, profileName);\n-                            break;\n-                        }\n-                    }\n-                }\n-            } catch (UserStoreException ex) {\n-                handleGetUserListFailureWithID(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                ex.getMessage()), claim, claimValue, limit, offset, profileName);\n-                throw ex;\n-            }\n-        }\n-\n-        // Iterate through user stores and check for users for this claim.\n-        List<User> usersFromUserStore;\n-        if (isUniqueUserIdEnabled()) {\n-            usersFromUserStore = doGetUserListWithID(claim, claimValue, profileName, limit, offset,\n-                    extractedDomain, userManager);\n-        } else {\n-            usersFromUserStore = userUniqueIDManger.listUsers(doGetUserList(claim, claimValue, profileName, limit,\n-                    offset, extractedDomain, userManager), this);\n-        }\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Users from user store: \" + extractedDomain + \" : \" + usersFromUserStore);\n-        }\n-        filteredUserList.addAll(usersFromUserStore);\n-\n-        handlePostGetUserListWithID(claim, claimValue, filteredUserList, limit, offset, false);\n-\n-        return filteredUserList;\n-    }\n-\n-    @Override\n-    public List<User> getUserListWithID(Condition condition, String domain, String profileName, int limit, int offset,\n-                                        String sortBy, String sortOrder) throws UserStoreException {\n-\n-        validateCondition(condition);\n-        if (StringUtils.isNotEmpty(sortBy) && StringUtils.isNotEmpty(sortOrder)) {\n-            throw new UserStoreException(\"Sorting is not supported.\");\n-        }\n-\n-        if (StringUtils.isEmpty(domain)) {\n-            domain = UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME;\n-        }\n-\n-        if (StringUtils.isEmpty(profileName)) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n-\n-        handlePreGetUserListWithID(condition, domain, profileName, limit, offset, sortBy, sortOrder);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Pre listener get conditional  user list for domain: \" + domain);\n-        }\n-\n-        List<User> filteredUsers = new ArrayList<>();\n-        UserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-        if (secManager != null) {\n-            if (secManager instanceof AbstractUserStoreManager) {\n-                if (isUniqueUserIdEnabled(secManager)) {\n-                    UniqueIDPaginatedSearchResult users = ((AbstractUserStoreManager) secManager)\n-                            .doGetUserListWithID(condition, profileName, limit, offset, sortBy, sortOrder);\n-                    filteredUsers = users.getUsers();\n-                } else {\n-                    PaginatedSearchResult users = ((AbstractUserStoreManager) secManager)\n-                            .doGetUserList(condition, profileName, limit, offset, sortBy, sortOrder);\n-                    filteredUsers = userUniqueIDManger.listUsers(users.getUsers(), this);\n-                }\n-            }\n-        }\n-\n-        handlePostGetUserListWithID(condition, domain, profileName, limit, offset, sortBy, sortOrder, filteredUsers,\n-                false);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"post listener get conditional  user list for domain: \" + domain);\n-        }\n-        return filteredUsers;\n-    }\n-\n-    private List<User> doGetUserListWithID(String claim, String claimValue, String profileName, int limit, int offset,\n-            String extractedDomain, UserStoreManager userManager) throws UserStoreException {\n-\n-        String property;\n-\n-        // If domain is present, then we search within that domain only.\n-        if (StringUtils.isNotEmpty(extractedDomain)) {\n-\n-            if (userManager == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"No user store manager found for domain: \" + extractedDomain);\n-                }\n-                return Collections.emptyList();\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Domain found in claim value. Searching only in the \" + extractedDomain + \" for possible \"\n-                        + \"matches\");\n-            }\n-\n-            try {\n-                property = claimManager.getAttributeName(extractedDomain, claim);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                e.getMessage()), claim, claimValue, limit, offset, profileName);\n-                throw new UserStoreException(\n-                        \"Error occurred while retrieving attribute name for domain : \" + extractedDomain + \" and claim \"\n-                                + claim, e);\n-            }\n-            if (property == null) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Could not find matching property for\\n\" + \"claim :\" + claim + \"domain :\"\n-                            + extractedDomain);\n-                }\n-                return Collections.emptyList();\n-            }\n-\n-            if (userManager instanceof AbstractUserStoreManager) {\n-                // Get the user list and return with domain appended.\n-                try {\n-                    AbstractUserStoreManager userStoreManager = (AbstractUserStoreManager) userManager;\n-                    UniqueIDPaginatedSearchResult result = userStoreManager\n-                            .doGetUserListFromPropertiesWithID(property, claimValue, profileName, limit, offset);\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"List of filtered paginated users for: \" + extractedDomain + \" : \" + Arrays\n-                                .asList(result.getUsers()));\n-                    }\n-                    return result.getUsers();\n-                } catch (UserStoreException ex) {\n-                    handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_WHILE_GETTING_USER_LIST.getMessage(),\n-                                    ex.getMessage()), claim, claimValue, limit, offset, profileName);\n-                    throw ex;\n-                }\n-            } else {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\n-                            \"getUserListFromProperties is not supported by this user store: \" + userManager.getClass());\n-                }\n-                return Collections.emptyList();\n-            }\n-        }\n-\n-        // If domain is not given then search all the user stores.\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"No domain name found in claim value. Searching through all user stores for possible matches\");\n-        }\n-\n-        List<User> usersFromAllStoresList = new ArrayList<>();\n-        List<UserStoreManager> userStoreManagers = getUserStoreMangers();\n-        int nonPaginatedUserCount = 0;\n-\n-        // Iterate through all of available user store managers.\n-        for (UserStoreManager userStoreManager : userStoreManagers) {\n-\n-            // If this is not an instance of Abstract User Store Manger we can ignore the flow since we can't get the\n-            // domain name.\n-            if (!(userStoreManager instanceof AbstractUserStoreManager)) {\n-                continue;\n-            }\n-\n-            if (limit <= 0) {\n-                return usersFromAllStoresList;\n-            }\n-\n-            // For all the user stores append the domain name to the claim and pass it recursively (Including PRIMARY).\n-            String domainName = ((AbstractUserStoreManager) userStoreManager).getMyDomainName();\n-\n-            try {\n-                property = claimManager.getAttributeName(domainName, claim);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                handleGetUserListFailure(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getCode(),\n-                        String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_GET_USER_LIST.getMessage(),\n-                                e.getMessage()), claim, claimValue, limit, offset, profileName);\n-                throw new UserStoreException(\n-                        \"Error occurred while retrieving attribute name for domain : \" + extractedDomain + \" and claim \"\n-                                + claim, e);\n-            }\n-\n-            // Recursively call the getUserList method appending the domain to claim value.\n-            UniqueIDPaginatedSearchResult userList = doGetUserListFromPropertiesWithID(property, claimValue,\n-                    profileName, limit, offset);\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Secondary user list for domain: \" + domainName + \" : \" + userList);\n-            }\n-            limit = limit - userList.getUsers().size();\n-            nonPaginatedUserCount = userList.getSkippedUserCount();\n-\n-            if (userList.getUsers().size() > 0) {\n-                offset = 1;\n-            } else {\n-                offset = offset - nonPaginatedUserCount;\n-            }\n-\n-            usersFromAllStoresList.addAll(userList.getUsers());\n-        }\n-\n-        // Done with all user store processing. Return the user array if not empty.\n-        return usersFromAllStoresList;\n-    }\n-\n-    @Override\n-    public List<UniqueIDUserClaimSearchEntry> getUsersClaimValuesWithID(List<String> userIDs, List<String> claims,\n-            String profileName) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[] { List.class, List.class, String.class };\n-            Object object = callSecure(\"getUsersClaimValuesWithID\", new Object[] { userIDs, claims, profileName },\n-                    argTypes);\n-            return (List<UniqueIDUserClaimSearchEntry>) object;\n-        }\n-\n-        if (StringUtils.isEmpty(profileName)) {\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n-\n-        List<UniqueIDUserClaimSearchEntry> allUsers = new ArrayList<>();\n-        Map<String, List<String>> domainFreeUsers = getDomainFreeUsersWithID(userIDs);\n-\n-        for (Map.Entry<String, List<String>> entry : domainFreeUsers.entrySet()) {\n-            UserStoreManager secondaryUserStoreManager = getSecondaryUserStoreManager(entry.getKey());\n-            if (secondaryUserStoreManager instanceof AbstractUserStoreManager) {\n-                if (isUniqueUserIdEnabled(secondaryUserStoreManager)) {\n-                    List<UniqueIDUserClaimSearchEntry> users = ((AbstractUserStoreManager) secondaryUserStoreManager)\n-                            .doGetUsersClaimValuesWithID(entry.getValue(), claims, entry.getKey(), profileName);\n-                    allUsers.addAll(users);\n-                } else {\n-                    List<String> userNamesFromUserIDs = getUserNamesFromUserIDs(entry.getValue())\n-                            .stream().map(UserCoreUtil::removeDomainFromName)\n-                            .collect(Collectors.toList());\n-                    UserClaimSearchEntry[] users = ((AbstractUserStoreManager) secondaryUserStoreManager)\n-                            .doGetUsersClaimValues(userNamesFromUserIDs,\n-                                    claims.toArray(new String[0]), entry.getKey(), profileName);\n-                    List<UniqueIDUserClaimSearchEntry> uniqueIDUserClaimSearchEntries =\n-                            getUniqueIDUserClaimSearchEntries(users);\n-                    allUsers.addAll(uniqueIDUserClaimSearchEntries);\n-                }\n-            }\n-        }\n-\n-        for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-            if (listener instanceof AbstractUserOperationEventListener) {\n-                AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                if (!newListener.doPostGetUsersClaimValuesWithID(userIDs, claims, profileName, allUsers, this)) {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return allUsers;\n-    }\n-\n-    public List<UniqueIDUserClaimSearchEntry> getUniqueIDUserClaimSearchEntries(UserClaimSearchEntry[] users)\n-            throws UserStoreException {\n-\n-        List<UniqueIDUserClaimSearchEntry> uniqueIDUserClaimSearchEntries = new ArrayList<>();\n-        for (UserClaimSearchEntry userClaimSearchEntry : users) {\n-            UniqueIDUserClaimSearchEntry uniqueIDUserClaimSearchEntry = new UniqueIDUserClaimSearchEntry();\n-            String userName = userClaimSearchEntry.getUserName();\n-            String userID = getUserIDFromUserName(userName);\n-            User user = getUser(userID, userName);\n-            uniqueIDUserClaimSearchEntry.setUser(user);\n-            uniqueIDUserClaimSearchEntry.setClaims(userClaimSearchEntry.getClaims());\n-            uniqueIDUserClaimSearchEntry.setUserClaimSearchEntry(userClaimSearchEntry);\n-            uniqueIDUserClaimSearchEntries.add(uniqueIDUserClaimSearchEntry);\n-        }\n-        return uniqueIDUserClaimSearchEntries;\n-    }\n-\n-    public List<UniqueIDUserClaimSearchEntry> doGetUsersClaimValuesWithID(List<String> userIDs, List<String> claims,\n-            String domainName, String profileName) throws UserStoreException {\n-\n-        Set<String> propertySet = new HashSet<>();\n-        Map<String, String> claimToAttributeMap = new HashMap<>();\n-        List<UniqueIDUserClaimSearchEntry> userClaimSearchEntryList = new ArrayList<>();\n-        for (String claim : claims) {\n-            String property;\n-            try {\n-                property = getClaimAtrribute(claim, null, domainName);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                throw new UserStoreException(e);\n-            }\n-            propertySet.add(property);\n-            claimToAttributeMap.put(claim, property);\n-        }\n-\n-        String[] properties = propertySet.toArray(new String[0]);\n-        Map<String, Map<String, String>> userProperties = this\n-                .getUsersPropertyValuesWithID(userIDs, properties, profileName);\n-\n-        for (Map.Entry<String, Map<String, String>> entry : userProperties.entrySet()) {\n-            UniqueIDUserClaimSearchEntry uniqueIDUserClaimSearchEntry = new UniqueIDUserClaimSearchEntry();\n-            UserClaimSearchEntry userClaimSearchEntry = new UserClaimSearchEntry();\n-            String userID = entry.getKey();\n-            String userName = doGetUserNameFromUserID(userID);\n-            User user = getUser(userID, userName);\n-            uniqueIDUserClaimSearchEntry.setUser(user);\n-            userClaimSearchEntry.setUserName(user.getDomainQualifiedUsername());\n-            Map<String, String> userClaims = new HashMap<>();\n-\n-            for (String claim : claims) {\n-                for (Map.Entry<String, String> userAttribute : entry.getValue().entrySet()) {\n-                    if (claimToAttributeMap.get(claim) != null && claimToAttributeMap.get(claim)\n-                            .equals(userAttribute.getKey())) {\n-                        userClaims.put(claim, userAttribute.getValue());\n-                    }\n-                }\n-            }\n-            uniqueIDUserClaimSearchEntry.setClaims(userClaims);\n-            userClaimSearchEntry.setClaims(userClaims);\n-            uniqueIDUserClaimSearchEntry.setUserClaimSearchEntry(userClaimSearchEntry);\n-            userClaimSearchEntryList.add(uniqueIDUserClaimSearchEntry);\n-        }\n-        return userClaimSearchEntryList;\n-    }\n-\n-    private Map<String, List<String>> getDomainFreeUsersWithID(List<String> userIDs) throws UserStoreException {\n-\n-        Map<String, List<String>> domainAwareUsers = new HashMap<>();\n-        if (!userIDs.isEmpty()) {\n-            for (String userID : userIDs) {\n-                User user = getUser(userID, null);\n-                String domainName = user.getUserStoreDomain();\n-                List<String> users = domainAwareUsers.get(domainName);\n-                if (users == null) {\n-                    users = new ArrayList<>();\n-                    domainAwareUsers.put(domainName.toUpperCase(), users);\n-                }\n-                users.add(UserCoreUtil.removeDomainFromName(userID));\n-            }\n-        }\n-\n-        return domainAwareUsers;\n-    }\n-\n-    protected Map<String, Map<String, String>> getUsersPropertyValuesWithID(List<String> userIDs,\n-            String[] propertyNames, String profileName) throws UserStoreException {\n-\n-        Map<String, Map<String, String>> usersPropertyValuesMap = new HashMap<>();\n-        for (String userID : userIDs) {\n-            Map<String, String> propertyValuesMap = getUserPropertyValuesWithID(userID, propertyNames, profileName);\n-            processAttributesAfterRetrievalWithID(userID, propertyValuesMap, profileName);\n-            if (propertyValuesMap != null && !propertyValuesMap.isEmpty()) {\n-                usersPropertyValuesMap.put(userID, propertyValuesMap);\n-            }\n-        }\n-        return usersPropertyValuesMap;\n-    }\n-\n-    @Override\n-    public Map<String, List<String>> getRoleListOfUsersWithID(List<String> userIDs) throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[] { List.class };\n-            Object object = callSecure(\"getRoleListOfUsersWithID\", new Object[] { userIDs }, argTypes);\n-            return (Map<String, List<String>>) object;\n-        }\n-\n-        Map<String, List<String>> allRoleNames = new HashMap<>();\n-        Map<String, List<String>> domainFreeUsers = getDomainFreeUsersWithID(userIDs);\n-\n-        for (Map.Entry<String, List<String>> entry : domainFreeUsers.entrySet()) {\n-            UserStoreManager secondaryUserStoreManager = getSecondaryUserStoreManager(entry.getKey());\n-            if (secondaryUserStoreManager instanceof AbstractUserStoreManager) {\n-                if (((AbstractUserStoreManager) secondaryUserStoreManager).isUniqueUserIdEnabled()) {\n-                    Map<String, List<String>> roleNames = ((AbstractUserStoreManager) secondaryUserStoreManager)\n-                            .doGetRoleListOfUsersWithID(entry.getValue(), entry.getKey());\n-                    allRoleNames.putAll(roleNames);\n-                } else {\n-                    List<User> users = userUniqueIDManger\n-                            .getUsers(entry.getValue(), (AbstractUserStoreManager) secondaryUserStoreManager);\n-                    Map<String, List<String>> userRoles = ((AbstractUserStoreManager) secondaryUserStoreManager)\n-                            .doGetRoleListOfUsers(users.stream().map(User::getUsername).collect(Collectors.toList()),\n-                                    entry.getKey());\n-\n-                    for (User user : users) {\n-                        allRoleNames.put(user.getUserID(), userRoles.get(user.getUsername()));\n-                    }\n-                }\n-            }\n-        }\n-\n-        for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-            if (listener instanceof AbstractUserOperationEventListener) {\n-                AbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-                if (!newListener.doPostGetRoleListOfUsersWithID(userIDs, allRoleNames, this)) {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return allRoleNames;\n-    }\n-\n-    public Map<String, List<String>> doGetRoleListOfUsersWithID(List<String> userIDs, String domainName)\n-            throws UserStoreException {\n-\n-        if (!isSecureCall.get()) {\n-            Class[] argTypes = new Class[] { List.class, String.class };\n-            Object object = callSecure(\"doGetRoleListOfUsersWithID\", new Object[] { userIDs, domainName }, argTypes);\n-            return (Map<String, List<String>>) object;\n-        }\n-\n-        Map<String, List<String>> internalRoles = doGetInternalRoleListOfUsersWithID(userIDs, domainName);\n-\n-        Map<String, List<String>> externalRoles = new HashMap<>();\n-        if (readGroupsEnabled) {\n-            externalRoles = doGetExternalRoleListOfUsersWithID(userIDs);\n-        }\n-\n-        Map<String, List<String>> combinedRoles = new HashMap<>();\n-        if (!internalRoles.isEmpty() && !externalRoles.isEmpty()) {\n-            for (String userID : userIDs) {\n-                List<String> roles = new ArrayList<>();\n-                if (internalRoles.get(userID) != null) {\n-                    roles.addAll(internalRoles.get(userID));\n-                }\n-                if (externalRoles.get(userID) != null) {\n-                    List<String> domainQualifiedRoleNames = getNamesWithDomain(externalRoles.get(userID), domainName);\n-                    roles.addAll(domainQualifiedRoleNames);\n-                }\n-                if (!roles.isEmpty()) {\n-                    combinedRoles.put(userID, roles);\n-                }\n-            }\n-        } else if (!internalRoles.isEmpty()) {\n-            combinedRoles = internalRoles;\n-        } else if (!externalRoles.isEmpty()) {\n-            combinedRoles = externalRoles;\n-        }\n-\n-        return combinedRoles;\n-    }\n-\n-    @Override\n-    public List<Group> listGroups(Condition condition, int limit, int offset, String sortBy,\n-                                  String sortOrder) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"listGroups operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"listGroups operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public List<Group> listGroups(Condition condition, int limit, int offset) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"listGroups operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"listGroups operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public List<Group> listGroups(Condition condition) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"listGroups operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"listGroups operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public Group addGroup(String groupName, List<String> usersIDs, List<org.wso2.carbon.user.core.common.Claim> claims)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"addGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"addGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public List<Group> getGroupListOfUser(String userId, int limit, int offset, String sortBy, String sortOrder)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"getGroupListOfUser operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"getGroupListOfUser operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public List<User> getUserListOfGroup(String groupID, int limit, int offset, String sortBy, String sortOrder)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"getUserListOfGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"getUserListOfGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public void updateUserListOfGroup(String groupID, List<String> deletedUserIds, List<String> newUserIds)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"updateUserListOfGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"updateUserListOfGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public void updateGroupListOfUser(String userID, List<String> deletedGroupIds, List<String> newGroupIds)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"updateGroupListOfUser operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"updateGroupListOfUser operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public boolean isUserInGroup(String userID, String groupID) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"isUserInGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"isUserInGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public Map<String, List<Group>> getGroupListOfUsers(List<String> userIDs) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"getGroupListOfUsers operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"getGroupListOfUsers operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public boolean isGroupExist(String groupID) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"isGroupExist operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"isGroupExist operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public void deleteGroup(String groupID) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"deleteGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"deleteGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public Group renameGroup(String groupID, String newGroupName) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"renameGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"renameGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public User addUser(String userName, Object credential, List<Claim> claims, List<String> groupsIds,\n-                        String profileName) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"addUser operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"addUser operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public Group getGroup(String groupID, List<String> requiredAttributes) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"getGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"getGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public Group updateGroup(String groupID, List<org.wso2.carbon.user.core.common.Claim> claims)\n-            throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"updateGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\"updateGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public List<User> getUserListOfGroup(String groupID, String sortBy, String sortOrder) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"getUserListOfGroup operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"getUserListOfGroup operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    @Override\n-    public List<Group> getGroupListOfUser(String userId, String sortBy, String sortOrder) throws UserStoreException {\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"getGroupListOfUser operation is not implemented in: \" + this.getClass());\n-        }\n-        throw new NotImplementedException(\n-                \"getGroupListOfUser operation is not implemented in: \" + this.getClass());\n-    }\n-\n-    private List<String> getNamesWithDomain(List<String> identifiers, String domain) {\n-\n-        List<String> usersWithDomain = new ArrayList<>();\n-        for (String identifier : identifiers) {\n-            usersWithDomain.add(UserCoreUtil.addDomainToName(identifier, domain));\n-        }\n-        return usersWithDomain;\n-    }\n-\n-    private String getUserStoreDomainName(UserStoreManager userStoreManager) {\n-\n-        String domainNameProperty = userStoreManager.getRealmConfiguration()\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-        if (StringUtils.isEmpty(domainNameProperty)) {\n-            domainNameProperty = UserCoreConstants.PRIMARY_DEFAULT_DOMAIN_NAME;\n-        }\n-        return domainNameProperty;\n-    }\n-\n-    /**\n-     * Process and return the modifed claim values against claim URI. Add or remove specific claim values\n-     * against old claim values of multi-valued claims. Replace old claim values from modified values for\n-     * non multi-valued claims.\n-     *\n-     * @param oldClaimMap                      Map of claim URIs against old claim values of user.\n-     * @param multiValuedClaimsToAdd           Map of multi-valued claim URIs against values need to be added to\n-     *                                         old claim value.\n-     * @param multiValuedClaimsToDelete        Map of multi-valued claim URIs against values need to be removed from\n-     *                                         old claim value.\n-     * @param claimsExcludingMultiValuedClaims Map of non multi-valued claim URIs against modified values to be stred.\n-     * @return Map of claim URIs against the modified claim values.\n-     */\n-    private Map<String, String> getModifiedClaims(Map<String, List<String>> oldClaimMap,\n-                                                  Map<String, List<String>> multiValuedClaimsToAdd,\n-                                                  Map<String, List<String>> multiValuedClaimsToDelete,\n-                                                  Map<String, List<String>> claimsExcludingMultiValuedClaims) {\n-\n-        Map<String, String> claims = new HashMap<>();\n-        String separator = \",\";\n-        if (StringUtils.isNotEmpty(realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR))) {\n-            separator = realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR);\n-        }\n-        if (claimsExcludingMultiValuedClaims != null) {\n-            for (String claimURI : claimsExcludingMultiValuedClaims.keySet()) {\n-                claims.put(claimURI,\n-                        StringUtils.join(claimsExcludingMultiValuedClaims.get(claimURI).iterator(), separator));\n-            }\n-        }\n-\n-        // Get modified claim values for multi-valued claims.\n-        if (multiValuedClaimsToAdd != null) {\n-            for (String claimURI : multiValuedClaimsToAdd.keySet()) {\n-                List<String> modifiedValue = new ArrayList<>();\n-                if (oldClaimMap.containsKey(claimURI)) {\n-                    modifiedValue.addAll(oldClaimMap.get(claimURI));\n-                    modifiedValue.addAll(multiValuedClaimsToAdd.get(claimURI));\n-                } else {\n-                    modifiedValue.addAll(multiValuedClaimsToAdd.get(claimURI));\n-                }\n-                claims.put(claimURI, StringUtils.join(modifiedValue.iterator(), separator));\n-            }\n-        }\n-        if (multiValuedClaimsToDelete != null) {\n-            for (String claimURI : multiValuedClaimsToDelete.keySet()) {\n-                List<String> values = null;\n-                if (claims.containsKey(claimURI)) {\n-                    values = Arrays.asList(claims.get(claimURI).split(separator));\n-                } else if (oldClaimMap.containsKey(claimURI)) {\n-                    values = oldClaimMap.get(claimURI);\n-                }\n-                if (!CollectionUtils.isEmpty(values)) {\n-                    List<String> modifiedValue =\n-                            (List<String>) CollectionUtils.subtract(values, multiValuedClaimsToDelete.get(claimURI));\n-                    claims.put(claimURI, StringUtils.join(modifiedValue.iterator(), separator));\n-                }\n-            }\n-        }\n-        return claims;\n-    }\n-\n-    private void invokeDoPreSetUserClaimsWithIDListeners(String userID, Map<String, String> claims, String profileName)\n-            throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPreSetUserClaimValuesWithID(userID, claims, profileName, this)) {\n-                    handleSetUserClaimValuesFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userID, claims, profileName);\n-            throw e;\n-        }\n-    }\n-\n-    private void invokeDoPostSetUserClaimsWithIDListeners(String userID, Map<String, String> claims, String profileName)\n-            throws UserStoreException {\n-\n-        try {\n-            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n-                if (!((AbstractUserOperationEventListener) listener)\n-                        .doPostSetUserClaimValuesWithID(userID, claims, profileName, this)) {\n-                    handleSetUserClaimValuesFailureWithID(\n-                            ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getCode(),\n-                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getMessage(),\n-                                    UserCoreErrorConstants.POST_LISTENER_TASKS_FAILED_MESSAGE), userID, claims,\n-                            profileName);\n-                    return;\n-                }\n-            }\n-        } catch (UserStoreException e) {\n-            handleSetUserClaimValuesFailureWithID(\n-                    ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getCode(),\n-                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_POST_SET_USER_CLAIM_VALUES.getMessage(),\n-                            e.getMessage()), userID, claims, profileName);\n-            throw e;\n-        }\n+    public HybridRoleManager getInternalRoleManager() {\n+        return hybridRoleManager;\n     }\n }\n", "next_change": {"commit": "b47d5aa1581355733e4284fb19ed82bec7dd7b5f", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\ndeleted file mode 100644\nindex fe6bdb8e2..000000000\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ /dev/null\n", "chunk": "@@ -1,3604 +0,0 @@\n-/*\n- *  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n- *\n- *  WSO2 Inc. licenses this file to you under the Apache License,\n- *  Version 2.0 (the \"License\"); you may not use this file except\n- *  in compliance with the License.\n- *  You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.wso2.carbon.user.core.common;\n-\n-import java.lang.reflect.Constructor;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import javax.sql.DataSource;\n-\n-import org.apache.commons.logging.Log;\n-import org.apache.commons.logging.LogFactory;\n-import org.wso2.carbon.CarbonConstants;\n-import org.wso2.carbon.context.CarbonContext;\n-import org.wso2.carbon.user.api.RealmConfiguration;\n-import org.wso2.carbon.user.core.Permission;\n-import org.wso2.carbon.user.core.UserCoreConstants;\n-import org.wso2.carbon.user.core.UserRealm;\n-import org.wso2.carbon.user.core.UserStoreConfigConstants;\n-import org.wso2.carbon.user.core.UserStoreException;\n-import org.wso2.carbon.user.core.UserStoreManager;\n-import org.wso2.carbon.user.core.authorization.AuthorizationCache;\n-import org.wso2.carbon.user.core.claim.Claim;\n-import org.wso2.carbon.user.core.claim.ClaimManager;\n-import org.wso2.carbon.user.core.claim.ClaimMapping;\n-import org.wso2.carbon.user.core.dto.RoleDTO;\n-import org.wso2.carbon.user.core.hybrid.HybridRoleManager;\n-import org.wso2.carbon.user.core.internal.UMListenerServiceComponent;\n-import org.wso2.carbon.user.core.ldap.LDAPConstants;\n-import org.wso2.carbon.user.core.listener.UserOperationEventListener;\n-import org.wso2.carbon.user.core.listener.UserStoreManagerConfigurationListener;\n-import org.wso2.carbon.user.core.listener.UserStoreManagerListener;\n-import org.wso2.carbon.user.core.profile.ProfileConfigurationManager;\n-import org.wso2.carbon.user.core.system.SystemUserRoleManager;\n-import org.wso2.carbon.user.core.util.UserCoreUtil;\n-import org.wso2.carbon.utils.multitenancy.MultitenantConstants;\n-import org.wso2.carbon.utils.multitenancy.MultitenantUtils;\n-\n-public abstract class AbstractUserStoreManager implements UserStoreManager {\n-\n-\tprivate static Log log = LogFactory.getLog(AbstractUserStoreManager.class);\n-\n-\tprotected int tenantId;\n-\tprotected DataSource dataSource = null;\n-\tprotected RealmConfiguration realmConfig = null;\n-\tprotected ClaimManager claimManager = null;\n-\tprotected UserRealm userRealm = null;\n-\tprotected HybridRoleManager hybridRoleManager = null;\n-\n-\t// User roles cache\n-\tprotected UserRolesCache userRolesCache = null;\n-\tprotected SystemUserRoleManager systemUserRoleManager = null;\n-\tprotected boolean readGroupsEnabled = false;\n-\tprotected boolean writeGroupsEnabled = false;\n-\tprivate UserStoreManager secondaryUserStoreManager;\n-\tprivate boolean userRolesCacheEnabled = true;\n-\tprivate String cacheIdentifier;\n-\tprivate boolean replaceEscapeCharactersAtUserLogin = true;\n-\tprivate Map<String, UserStoreManager> userStoreManagerHolder = new HashMap<String, UserStoreManager>();\n-\tprivate Map<String, Integer> maxUserListCount = null;\n-\tprivate Map<String, Integer> maxRoleListCount = null;\n-\tprivate List<UserStoreManagerConfigurationListener> listener = new ArrayList<UserStoreManagerConfigurationListener>();\n-\n-\tprivate static final String MAX_LIST_LENGTH = \"100\";\n-\n-\tprotected static final String TRUE_VALUE = \"true\";\n-\tprotected static final String FALSE_VALUE = \"false\";\n-\n-\t/**\n-\t * This method is used by the support system to read properties\n-\t */\n-\tprotected abstract Map<String, String> getUserPropertyValues(String userName,\n-\t\t\tString[] propertyNames, String profileName) throws UserStoreException;\n-\n-\t/**\n-\t * \n-\t * @param roleName\n-\t * @return\n-\t */\n-\tprotected abstract boolean doCheckExistingRole(String roleName) throws UserStoreException;\n-\n-    /**\n-     * Creates the search base and other relevant parameters for the provided role name\n-     * @param roleName\n-     * @return\n-     */\n-    protected abstract RoleContext createRoleContext(String roleName) throws UserStoreException;\n-\n-\t/**\n-\t * \n-\t * @param userName\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected abstract boolean doCheckExistingUser(String userName) throws UserStoreException;\n-\n-\t/**\n-\t * Retrieves a list of user names for given user's property in user profile\n-\t * \n-\t * @param property user property in user profile\n-\t * @param value value of property\n-\t * @param profileName profile name, can be null. If null the default profile is considered.\n-\t * @return An array of user names\n-\t * @throws UserStoreException if the operation failed\n-\t */\n-\tprotected abstract String[] getUserListFromProperties(String property, String value,\n-\t\t\tString profileName) throws UserStoreException;\n-\n-\t/**\n-\t * Given the user name and a credential object, the implementation code must validate whether\n-\t * the user is authenticated.\n-\t * \n-\t * @param userName The user name\n-\t * @param credential The credential of a user\n-\t * @return If the value is true the provided credential match with the user name. False is\n-\t *         returned for invalid credential, invalid user name and mismatching credential with\n-\t *         user name.\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract boolean doAuthenticate(String userName, Object credential)\n-\t\t\tthrows UserStoreException;\n-\n-\t/**\n-\t * Add a user to the user store.\n-\t * \n-\t * @param userName User name of the user\n-\t * @param credential The credential/password of the user\n-\t * @param roleList The roles that user belongs\n-\t * @param claims Properties of the user\n-\t * @param profileName profile name, can be null. If null the default profile is considered.\n-\t * @param requirePasswordChange whether password required is need\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doAddUser(String userName, Object credential, String[] roleList,\n-\t\t\tMap<String, String> claims, String profileName, boolean requirePasswordChange)\n-\t\t\tthrows UserStoreException;\n-\n-\t/**\n-\t * Update the credential/password of the user\n-\t * \n-\t * @param userName The user name\n-\t * @param newCredential The new credential/password\n-\t * @param oldCredential The old credential/password\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doUpdateCredential(String userName, Object newCredential,\n-\t\t\tObject oldCredential) throws UserStoreException;\n-\n-\t/**\n-\t * Update credential/password by the admin of another user\n-\t * \n-\t * @param userName The user name\n-\t * @param newCredential The new credential\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doUpdateCredentialByAdmin(String userName, Object newCredential)\n-\t\t\tthrows UserStoreException;\n-\n-\t/**\n-\t * Delete the user with the given user name\n-\t * \n-\t * @param userName The user name\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doDeleteUser(String userName) throws UserStoreException;\n-\n-\t/**\n-\t * Set a single user claim value\n-\t * \n-\t * @param userName The user name\n-\t * @param claimURI The claim URI\n-\t * @param claimValue The value\n-\t * @param profileName The profile name, can be null. If null the default profile is considered.\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doSetUserClaimValue(String userName, String claimURI,\n-\t\t\tString claimValue, String profileName) throws UserStoreException;\n-\n-\t/**\n-\t * Set many user claim values\n-\t * \n-\t * @param userName The user name\n-\t * @param claims Map of claim URIs against values\n-\t * @param profileName The profile name, can be null. If null the default profile is considered.\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doSetUserClaimValues(String userName, Map<String, String> claims,\n-\t\t\tString profileName) throws UserStoreException;\n-\n-\t/**\n-\t * o * Delete a single user claim value\n-\t * \n-\t * @param userName The user name\n-\t * @param claimURI Name of the claim\n-\t * @param profileName The profile name, can be null. If null the default profile is considered.\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doDeleteUserClaimValue(String userName, String claimURI,\n-\t\t\tString profileName) throws UserStoreException;\n-\n-\t/**\n-\t * Delete many user claim values.\n-\t * \n-\t * @param userName The user name\n-\t * @param claims URIs of the claims to be deleted.\n-\t * @param profileName The profile name, can be null. If null the default profile is considered.\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doDeleteUserClaimValues(String userName, String[] claims,\n-\t\t\tString profileName) throws UserStoreException;\n-\n-\t/**\n-\t * Update user list of a particular role\n-\t * \n-\t * @param roleName The role name\n-\t * @param deletedUsers Array of user names, that is going to be removed from the role\n-\t * @param newUsers Array of user names, that is going to be added to the role\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doUpdateUserListOfRole(String roleName, String[] deletedUsers,\n-\t\t\tString[] newUsers) throws UserStoreException;\n-\n-\t/**\n-\t * Update role list of a particular user\n-\t * \n-\t * @param userName The user name\n-\t * @param deletedRoles Array of role names, that is going to be removed from the user\n-\t * @param newRoles Array of role names, that is going to be added to the user\n-\t * @throws UserStoreException An unexpected exception has occurred\n-\t */\n-\tprotected abstract void doUpdateRoleListOfUser(String userName, String[] deletedRoles,\n-\t\t\tString[] newRoles) throws UserStoreException;\n-\n-\t/**\n-\t * Only gets the internal roles of the user with internal domain name\n-\t * \n-\t * @param userName Name of the user - who we need to find roles.\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected String[] doGetInternalRoleListOfUser(String userName, String filter) throws UserStoreException {\n-\t\treturn hybridRoleManager.getHybridRoleListOfUser(userName, filter);\n-\t}\n-\n-\t/**\n-\t * Only gets the external roles of the user.\n-\t * \n-\t * @param userName Name of the user - who we need to find roles.\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected abstract String[] doGetExternalRoleListOfUser(String userName, String filter)\n-\t\t\tthrows UserStoreException;\n-\t\n-\n-\t/**\n-\t * Returns the shared roles list of the user\n-\t * \n-\t * @param userName\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected abstract String[] doGetSharedRoleListOfUser(String userName,\n-                                    String tenantDomain, String filter) throws UserStoreException;\n-\n-\t/**\n-\t * Add role with a list of users and permissions provided.\n-\t * \n-\t * @param roleName\n-\t * @param userList\n-\t * @throws UserStoreException\n-\t */\n-\tprotected abstract void doAddRole(String roleName, String[] userList, boolean shared) throws UserStoreException;\n-\n-\n-\t/**\n-\t * delete the role.\n-\t * \n-\t * @param roleName\n-\t * @throws UserStoreException\n-\t */\n-\tprotected abstract void doDeleteRole(String roleName) throws UserStoreException;\n-\n-\t/**\n-\t * update the role name with the new name\n-\t * \n-\t * @param roleName\n-\t * @param newRoleName\n-\t * @throws UserStoreException\n-\t */\n-\tprotected abstract void doUpdateRoleName(String roleName, String newRoleName)\n-\t\t\tthrows UserStoreException;\n-\n-\t/**\n-\t * This method would returns the role Name actually this must be implemented in interface. As it\n-\t * is not good to change the API in point release. This has been added to Abstract class\n-\t * \n-\t * @param filter\n-\t * @param maxItemLimit\n-\t * @return\n-\t * @throws .UserStoreException\n-\t */\n-\tprotected abstract String[] doGetRoleNames(String filter, int maxItemLimit)\n-\t\t\tthrows UserStoreException;\n-\t\t\n-\t/**\n-\t * \n-\t * @param filter\n-\t * @param maxItemLimit\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected abstract String[] doListUsers(String filter, int maxItemLimit)\n-\t\t\tthrows UserStoreException;\n-\n-    /*This is to get the display names of users in hybrid role according to the underlying user store, to be shown in UI*/\n-    protected abstract String[] doGetDisplayNamesForInternalRole(String[] userNames)\n-            throws UserStoreException;\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final boolean authenticate(String userName, Object credential) throws UserStoreException {\n-        if (userName == null || credential == null) {\n-            log.error(\"Authentication failure. Either Username or Password is null\");\n-            return false;\n-        }\n-        int index = userName != null ? userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) : -1;\n-\t\tboolean domainProvided = index > 0;\n-\t\treturn authenticate(userName, credential, domainProvided);\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param userName\n-\t * @param credential\n-\t * @param domainProvided\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected boolean authenticate(String userName, Object credential, boolean domainProvided)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tboolean authenticated = false;\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\treturn userStore.getUserStoreManager().authenticate(userStore.getDomainFreeName(),\n-\t\t\t\t\tcredential, domainProvided);\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserStoreManagerListeners()) {\n-\t\t\tif (!listener.authenticate(userName, credential, this)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreAuthenticate(userName, credential, this)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\t// We are here due to two reason. Either there is no secondary UserStoreManager or no\n-\t\t// domain name provided with user name.\n-\t\t\n-\t\ttry {\n-\t\t\t// Let's authenticate with the primary UserStoreManager.\n-\t\t\tauthenticated = doAuthenticate(userName, credential);\n-\t\t} catch (Exception e) {\n-\t\t\t// We can ignore and proceed. Ignore the results from this user store.\n-\t\t\tlog.error(e);\n-\t\t\tauthenticated = false;\n-\t\t}\n-\t\t\n-\t\tif (authenticated) {\n-\t\t\t// Set domain in thread local variable for subsequent operations\n-            String domain = UserCoreUtil.getDomainName(this.realmConfig);\n-            if (domain != null) {\n-                UserCoreUtil.setDomainInThreadLocal(domain.toUpperCase());\n-            }\n-        }\n-\n-\t\t// If authentication fails in the previous step and if the user has not specified a\n-\t\t// domain- then we need to execute chained UserStoreManagers recursively.\n-\t\tif (!authenticated && !domainProvided && this.getSecondaryUserStoreManager() != null) {\n-\t\t\tauthenticated = ((AbstractUserStoreManager) this.getSecondaryUserStoreManager())\n-\t\t\t\t\t.authenticate(userName, credential, domainProvided);\n-            return authenticated;\n-\t\t}\n-\n-\t\t// You cannot change authentication decision in post handler to TRUE\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostAuthenticate(userName, authenticated, this)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (log.isDebugEnabled()) {\n-\t\t\tif (!authenticated) {\n-\t\t\t\tlog.debug(\"Authentication failure. Wrong username or password is provided.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn authenticated;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final String getUserClaimValue(String userName, String claim, String profileName)\n-\t\t\tthrows UserStoreException {\n-\n-        // If user does not exist, just return\n-        if (!isExistingUser(userName)) {\n-            return null;\n-        }\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\treturn userStore.getUserStoreManager().getUserClaimValue(userStore.getDomainFreeName(),\n-\t\t\t\t\tclaim, profileName);\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\n-\n-        Map<String, String> finalValues = doGetUserClaimValues(userName, new String[] {claim}, \n-                userStore.getDomainName(), profileName);\n-\n-        String value = null;\n-\n-        if(finalValues != null){\n-\t\t    value = finalValues.get(claim);\n-        }\n-\n-\t\t// #################### <Listeners> #####################################################\n-\n-        List<String> list = new ArrayList<String>();\n-\t\tif (value != null) {\n-\t\t\tlist.add(value);\n-\t\t}\n-\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (listener instanceof AbstractUserOperationEventListener) {\n-\t\t\t\tAbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-\t\t\t\tif (!newListener.doPostGetUserClaimValue(userName, claim, list, profileName, this)) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\treturn value;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final Claim[] getUserClaimValues(String userName, String profileName)\n-\t\t\tthrows UserStoreException {\n-\n-        // If user does not exist, just return\n-        if (!isExistingUser(userName)) {\n-            return null;\n-        }\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\treturn userStore.getUserStoreManager().getUserClaimValues(\n-\t\t\t\t\tuserStore.getDomainFreeName(), profileName);\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif (profileName == null || profileName.trim().length() == 0) {\n-\t\t\tprofileName = UserCoreConstants.DEFAULT_PROFILE;\n-\t\t}\n-\n-\t\tString[] claims;\n-\t\ttry {\n-\t\t\tclaims = claimManager.getAllClaimUris();\n-\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n-\t\t\tthrow new UserStoreException(e);\n-\t\t}\n-\n-\t\tMap<String, String> values = this.getUserClaimValues(userName, claims, profileName);\n-\t\tClaim[] finalValues = new Claim[values.size()];\n-\t\tint i = 0;\n-\t\tfor (Iterator<Map.Entry<String, String>> ite = values.entrySet().iterator(); ite.hasNext();) {\n-\t\t\tMap.Entry<String, String> entry = ite.next();\n-\t\t\tClaim claim = new Claim();\n-\t\t\tclaim.setValue(entry.getValue());\n-\t\t\tclaim.setClaimUri(entry.getKey());\n-\t\t\tString displayTag;\n-\t\t\ttry {\n-\t\t\t\tdisplayTag = claimManager.getClaim(entry.getKey()).getDisplayTag();\n-\t\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n-\t\t\t\tthrow new UserStoreException(e);\n-\t\t\t}\n-\t\t\tclaim.setDisplayTag(displayTag);\n-\t\t\tfinalValues[i] = claim;\n-\t\t\ti++;\n-\t\t}\n-\n-\t\treturn finalValues;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final Map<String, String> getUserClaimValues(String userName, String[] claims,\n-\t\t\tString profileName) throws UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\treturn userStore.getUserStoreManager().getUserClaimValues(\n-\t\t\t\t\tuserStore.getDomainFreeName(), claims, profileName);\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tMap<String, String> finalValues = doGetUserClaimValues(userName, claims,\n-                userStore.getDomainName(), profileName);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (listener instanceof AbstractUserOperationEventListener) {\n-\t\t\t\tAbstractUserOperationEventListener newListener = (AbstractUserOperationEventListener) listener;\n-\t\t\t\tif (!newListener.doPostGetUserClaimValues(userStore.getDomainFreeName(), claims, profileName,\n-\t\t\t\t\t\tfinalValues, this)) {\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\treturn finalValues;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc} TODO : This does not support multiple user stores yet.\n-\t */\n-\tpublic final String[] getUserList(String claim, String claimValue, String profileName)\n-\t                                                                                      throws UserStoreException {\n-\n-\t\tString property;\n-\t\tString domainName = null;\n-\t\ttry {\n-\t\t\t// Attributed id from corresponding to the underlying user store,\n-\t\t\t// corresponding to the\n-\t\t\t// domain which this user store manager belongs to.\n-\t\t\tdomainName = this.getMyDomainName();\n-\t\t\tif (domainName != null && !domainName.isEmpty() &&\n-\t\t\t    !domainName.equals(UserStoreConfigConstants.PRIMARY)) {\n-\t\t\t\tproperty = claimManager.getAttributeName(domainName, claim);\n-\t\t\t\tif (property == null) {\n-\t\t\t\t\t// claim is not defined for the secondary user store. In\n-\t\t\t\t\t// this case property is taken from the primary user store\n-\t\t\t\t\tproperty = claimManager.getAttributeName(claim);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tproperty = claimManager.getAttributeName(claim);\n-\t\t\t}\n-\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n-\t\t\tthrow new UserStoreException(e);\n-\t\t}\n-\n-\t\tif (property == null) {\n-\t\t\tthrow new UserStoreException(\"Claim \" + claim + \" is not defined for \" +\n-\t\t\t                             this.getMyDomainName());\n-\t\t}\n-\n-\t\tString[] userList = getUserListFromProperties(property, claimValue, profileName);\n-\n-\t\tif ((userList == null || userList.length < 1) &&\n-\t\t    this.getSecondaryUserStoreManager() != null) {\n-\t\t\tif (log.isDebugEnabled()) {\n-\t\t\t\tString currentDomain = this.getMyDomainName();\n-\t\t\t\tString childDomain =\n-\t\t\t\t                     ((AbstractUserStoreManager) this.getSecondaryUserStoreManager()).getMyDomainName();\n-\t\t\t\tlog.debug(\"No users found in: \" + currentDomain +\n-\t\t\t\t          \" Looking in the secondary user store \" + childDomain);\n-\t\t\t}\n-\t\t\tuserList =\n-\t\t\t           ((AbstractUserStoreManager) this.getSecondaryUserStoreManager()).getUserList(claim,\n-\t\t\t                                                                                        claimValue,\n-\t\t\t                                                                                        profileName);\n-\n-\t\t} else if (!UserStoreConfigConstants.PRIMARY.equals(domainName)) {\n-\t\t\t// if we find any result, we should append the domain\n-\t\t\tList<String> usersWithDomain = new ArrayList<String>();\n-\t\t\tfor (String user : userList) {\n-\t\t\t\tif (log.isDebugEnabled()) {\n-\t\t\t\t\tlog.debug(\"Found user: \" + user);\n-\t\t\t\t}\n-\t\t\t\tString nameWithDomain = UserCoreUtil.addDomainToName(user, domainName);\n-\t\t\t\tusersWithDomain.add(nameWithDomain);\n-\t\t\t}\n-\t\t\treturn usersWithDomain.toArray(new String[usersWithDomain.size()]);\n-\t\t}\n-\t\t// no multipe user store configs\n-\t\treturn userList;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void updateCredential(String userName, Object newCredential, Object oldCredential)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().updateCredential(userStore.getDomainFreeName(),\n-\t\t\t\t\tnewCredential, oldCredential);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserStoreManagerListeners()) {\n-\t\t\tif (!listener.updateCredential(userName, newCredential, oldCredential, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreUpdateCredential(userName, newCredential, oldCredential, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\t// This user name here is domain-less.\n-\t\t// We directly authenticate user against the selected UserStoreManager.\n-\t\tboolean isAuth = this.doAuthenticate(userName, oldCredential);\n-\n-\t\tif (isAuth) {\n-\n-\t\t\tthis.doUpdateCredential(userName, newCredential, oldCredential);\n-\n-\t\t\t// #################### <Listeners> ##################################################\n-\t\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\t\tif (!listener.doPostUpdateCredential(userName, newCredential, this)) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t// #################### </Listeners> ##################################################\n-\n-\t\t\treturn;\n-\t\t} else {\n-\t\t\tthrow new UserStoreException(\n-\t\t\t\t\t\"Old credential does not match with the existing credentials.\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void updateCredentialByAdmin(String userName, Object newCredential)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().updateCredentialByAdmin(userStore.getDomainFreeName(),\n-\t\t\t\t\tnewCredential);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserStoreManagerListeners()) {\n-\t\t\tif (!listener.updateCredentialByAdmin(userName, newCredential, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// using string buffers to allow the password to be changed by listener\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif(newCredential == null) { // a default password will be set\n-\t\t\t\tStringBuffer credBuff = new StringBuffer();\n-\t\t\t\tif (!listener.doPreUpdateCredentialByAdmin(userName, newCredential, this)) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tnewCredential = credBuff.toString(); // reading the modified value\n-\t\t\t} else if (newCredential instanceof String) {\n-\t\t\t\tStringBuffer credBuff = new StringBuffer((String)newCredential);\n-\t\t\t\tif (!listener.doPreUpdateCredentialByAdmin(userName, credBuff, this)) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tnewCredential = credBuff.toString(); // reading the modified value\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tdoUpdateCredentialByAdmin(userName, newCredential);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostUpdateCredentialByAdmin(userName, newCredential, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\t\n-\t/**\n-\t * Get the attribute for the provided claim uri and identifier.\n-\t * \n-\t * @param claimURI\n-\t * @param identifier\n-\t *            user name or role.\n-\t * @param domainName TODO\n-\t * @return claim attribute value. NULL if attribute is not defined for the\n-\t *         claim uri\n-\t * @throws org.wso2.carbon.user.api.UserStoreException\n-\t */\n-\tprotected String getClaimAtrribute(String claimURI, String identifier, String domainName)\n-\t                                                                      throws org.wso2.carbon.user.api.UserStoreException {\n-\t\tdomainName =\n-\t\t             (domainName == null || domainName.isEmpty())\n-\t\t                                                         ? (identifier.indexOf(UserCoreConstants.DOMAIN_SEPARATOR) > -1\n-\t\t                                                                                                                       ? identifier.split(UserCoreConstants.DOMAIN_SEPARATOR)[0]\n-\t\t                                                                                                                       : realmConfig.getUserStoreProperty(UserStoreConfigConstants.DOMAIN_NAME))\n-\t\t                                                         : domainName;\n-\t\tString attributeName = null;\n-\t\tif (domainName != null && !domainName.equals(UserStoreConfigConstants.PRIMARY)) {\n-\t\t\tattributeName = claimManager.getAttributeName(domainName, claimURI);\n-\t\t}\n-\t\tif (attributeName == null || attributeName.isEmpty()) {\n-\t\t\tattributeName = claimManager.getAttributeName(claimURI);\n-\t\t}\n-\t\treturn attributeName != null ? attributeName : claimURI;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void deleteUser(String userName) throws UserStoreException {\n-\t\t\n-\t\tString loggedInUser = CarbonContext.getThreadLocalCarbonContext().getUsername();\n-\t\tif(loggedInUser!= null && loggedInUser.equals(userName)) {\n-\t\t\tlog.debug(\"User \" + userName + \" tried to delete him/her self\");\n-\t\t\tthrow new UserStoreException(\"Cannot delete logged in user\");\n-\t\t}\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().deleteUser(userStore.getDomainFreeName());\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif (UserCoreUtil.isPrimaryAdminUser(userName, realmConfig)) {\n-\t\t\tthrow new UserStoreException(\"Cannot delete admin user\");\n-\t\t}\n-\n-\t\tif (UserCoreUtil.isRegistryAnnonymousUser(userName)) {\n-\t\t\tthrow new UserStoreException(\"Cannot delete anonymous user\");\n-\t\t}\n-\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserStoreManagerListeners()) {\n-\t\t\tif (!listener.deleteUser(userName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreDeleteUser(userName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tif (!doCheckExistingUser(userName)) {\n-\t\t\tthrow new UserStoreException(\"Cannot delete user who is not exist\");\n-\t\t}\n-\n-\t\t// Remove users from internal role mapping\n-\t\thybridRoleManager.deleteUser(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n-\n-\t\tdoDeleteUser(userName);\n-\n-\t\t// Needs to clear roles cache upon deletion of a user\n-        clearUserRolesCache(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostDeleteUser(userName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void setUserClaimValue(String userName, String claimURI, String claimValue,\n-\t\t\tString profileName) throws UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().setUserClaimValue(userStore.getDomainFreeName(),\n-\t\t\t\t\tclaimURI, claimValue, profileName);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreSetUserClaimValue(userName, claimURI, claimValue, profileName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tdoSetUserClaimValue(userName, claimURI, claimValue, profileName);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostSetUserClaimValue(userName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void setUserClaimValues(String userName, Map<String, String> claims,\n-\t\t\tString profileName) throws UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().setUserClaimValues(userStore.getDomainFreeName(),\n-\t\t\t\t\tclaims, profileName);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreSetUserClaimValues(userName, claims, profileName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tdoSetUserClaimValues(userName, claims, profileName);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostSetUserClaimValues(userName, claims, profileName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void deleteUserClaimValue(String userName, String claimURI, String profileName)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().deleteUserClaimValue(userStore.getDomainFreeName(),\n-\t\t\t\t\tclaimURI, profileName);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreDeleteUserClaimValue(userName, claimURI, profileName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tdoDeleteUserClaimValue(userName, claimURI, profileName);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostDeleteUserClaimValue(userName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void deleteUserClaimValues(String userName, String[] claims, String profileName)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().deleteUserClaimValues(userStore.getDomainFreeName(),\n-\t\t\t\t\tclaims, profileName);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreDeleteUserClaimValues(userName, claims, profileName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tdoDeleteUserClaimValues(userName, claims, profileName);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostDeleteUserClaimValues(userName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void addUser(String userName, Object credential, String[] roleList,\n-\t\t\tMap<String, String> claims, String profileName, boolean requirePasswordChange)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().addUser(userStore.getDomainFreeName(), credential,\n-\t\t\t\t\troleList, claims, profileName, requirePasswordChange);\n-\t\t\treturn;\n-\t\t}\n-        \n-        if(userStore.isSystemStore()){\n-            systemUserRoleManager.addSystemUser(userName, credential, roleList);\n-            return;\n-        }\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\"Invalid operation. User store is read only\");\n-\t\t}\n-\n-\t\t// This happens only once during first startup - adding administrator user/role.\n-\t\tif (userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-\t\t\tuserName = userStore.getDomainFreeName();\n-\t\t\troleList = UserCoreUtil.removeDomainFromNames(roleList);\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserStoreManagerListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserStoreManagerListeners()) {\n-\t\t\tif (!listener.addUser(userName, credential, roleList, claims, profileName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// String buffers are used to let listeners to modify passwords\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif(credential == null) { // a default password will be set\n-\t\t\t\tStringBuffer credBuff = new StringBuffer();\n-\t\t\t\tif (!listener.doPreAddUser(userName, credBuff, roleList, claims, profileName,\n-\t\t\t\t                           this)) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tcredential = credBuff.toString(); // reading the modified value\n-\t\t\t} else if (credential instanceof String) {\n-\t\t\t\tStringBuffer credBuff = new StringBuffer((String)credential);\n-\t\t\t\tif (!listener.doPreAddUser(userName, credBuff, roleList, claims, profileName,\n-\t\t\t\t                           this)) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\tcredential = credBuff.toString(); // reading the modified value\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tif (!checkUserNameValid(userStore.getDomainFreeName())) {\n-\t\t\tString message = \"Username \"+ userStore.getDomainFreeName() +\" is not valid. User name must be a non null string with following format, \";\n-\t\t\tString regEx = realmConfig\n-\t\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG_EX);\n-\t\t\tthrow new UserStoreException(message + regEx);\n-\t\t}\n-\n-\t\tif (!checkUserPasswordValid(credential)) {\n-\t\t\tString message = \"Credential not valid. Credential must be a non null string with following format, \";\n-\t\t\tString regEx = realmConfig\n-\t\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX);\n-\t\t\tthrow new UserStoreException(message + regEx);\n-\t\t}\n-\n-\t\tif (doCheckExistingUser(userStore.getDomainFreeName())) {\n-\t\t\tthrow new UserStoreException(\"Username '\" + userName\n-\t\t\t\t\t+ \"' already exists in the system. Please pick another username.\");\n-\t\t}\n-        \n-        \n-   \n-\t\tList<String> internalRoles = new ArrayList<String>();\n-\t\tList<String> externalRoles = new ArrayList<String>();\n-\t\tint index;\n-\t\tif (roleList != null) {\n-\t\t\tfor (String role : roleList) {\n-                if(role != null && role.trim().length() > 0){\n-                    index = role.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-                    if (index > 0) {\n-                        String domain = role.substring(0, index);\n-                        if (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain)) {\n-                            internalRoles.add(UserCoreUtil.removeDomainFromName(role));\n-                            continue;\n-                        }\n-                    }\n-                    externalRoles.add(UserCoreUtil.removeDomainFromName(role));\n-                }\n-\t\t\t}\n-\t\t}\n-        \n-        // check existance of roles and claims before user is adding\n-        for(String internalRole : internalRoles){\n-            if(!hybridRoleManager.isExistingRole(internalRole)){\n-                throw new UserStoreException(\"Internal role is not exist : \" + internalRole);\n-            }\n-        }\n-\n-        for(String externalRole : externalRoles){\n-            if(!doCheckExistingRole(externalRole)){\n-                throw new UserStoreException(\"External role is not exist : \" + externalRole);\n-            }\n-        }\n-        \n-        if(claims != null){\n-            for(Map.Entry<String, String> entry : claims.entrySet()){\n-                ClaimMapping claimMapping = null;\n-                try {\n-                    claimMapping = (ClaimMapping)claimManager.getClaimMapping(entry.getKey());\n-                } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                    String errorMessage = \"Error in obtaining claim mapping for persisting user attributes.\";\n-                    throw new UserStoreException(errorMessage, e);                    \n-                }\n-                if(claimMapping == null){\n-                    String errorMessage = \"Invalid claim uri has been provided.\";\n-                    throw new UserStoreException(errorMessage);\n-                }\n-            }\n-        }\n-        \n-\t\tdoAddUser(userName, credential, externalRoles.toArray(new String[externalRoles.size()]),\n-\t\t\t\tclaims, profileName, requirePasswordChange);\n-\n-\t\tif (internalRoles.size() > 0) {\n-\t\t\thybridRoleManager.updateHybridRoleListOfUser(userName, null,\n-\t\t\t\t\tinternalRoles.toArray(new String[internalRoles.size()]));\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostAddUser(userName, credential, roleList, claims, profileName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic void addUser(String userName, Object credential, String[] roleList,\n-\t\t\tMap<String, String> claims, String profileName) throws UserStoreException {\n-\t\tthis.addUser(userName, credential, roleList, claims, profileName, false);\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void updateUserListOfRole(String roleName, String[] deletedUsers, String[] newUsers)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tString primaryDomain = getMyDomainName();\n-\t\tif (primaryDomain != null) {\n-\t\t\tprimaryDomain += CarbonConstants.DOMAIN_SEPARATOR;\n-\t\t}\n-\n-\t\tif (deletedUsers != null && deletedUsers.length > 0) {\n-\t\t\tArrays.sort(deletedUsers);\n-\t\t\t// Updating the user list of a role belong to the primary domain.\n-\t\t\tif (UserCoreUtil.isPrimaryAdminRole(roleName, realmConfig)) {\n-\t\t\t\tfor (int i = 0; i < deletedUsers.length; i++) {\n-\t\t\t\t\tif (deletedUsers[i].equalsIgnoreCase(realmConfig.getAdminUserName())\n-\t\t\t\t\t\t\t|| (primaryDomain + deletedUsers[i]).equalsIgnoreCase(realmConfig\n-\t\t\t\t\t\t\t\t\t.getAdminUserName())) {\n-\t\t\t\t\t\tthrow new UserStoreException(\"Cannot remove Admin user from Admin role\");\n-\t\t\t\t\t}\n-\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tUserStore userStore = getUserStore(roleName);\n-\n-        if (userStore.isHybridRole()) {\n-\t\t\t// Check whether someone is trying to update Everyone role.\n-\t\t\tif (UserCoreUtil.isEveryoneRole(roleName, realmConfig)) {\n-\t\t\t\tthrow new UserStoreException(\"Cannot update everyone role\");\n-\t\t\t}\n-\n-            hybridRoleManager.updateUserListOfHybridRole(userStore.getDomainFreeName(),\n-                                                         deletedUsers, newUsers);\n-            clearUserRolesCacheByTenant(this.tenantId);\n-\t\t\treturn;\n-\t\t}\n-\n-        if(userStore.isSystemStore()){\n-            systemUserRoleManager.updateUserListOfSystemRole(userStore.getDomainFreeName(),\n-                                                UserCoreUtil.removeDomainFromNames(deletedUsers),\n-                                                UserCoreUtil.removeDomainFromNames(newUsers));\n-            return;\n-        }\n-\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().updateUserListOfRole(userStore.getDomainFreeName(),\n-\t\t\t\t\tUserCoreUtil.removeDomainFromNames(deletedUsers),\n-\t\t\t\t\tUserCoreUtil.removeDomainFromNames(newUsers));\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreUpdateUserListOfRole(roleName, deletedUsers,\n-\t\t\t                                        newUsers, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tif ((deletedUsers != null && deletedUsers.length > 0)\n-\t\t\t\t|| (newUsers != null && newUsers.length > 0)) {\n-\t\t\tif (!isReadOnly() && writeGroupsEnabled) {\n-\t\t\t\tdoUpdateUserListOfRole(userStore.getDomainFreeName(),\n-\t\t\t\t\t\tUserCoreUtil.removeDomainFromNames(deletedUsers),\n-\t\t\t\t\t\tUserCoreUtil.removeDomainFromNames(newUsers));\n-\t\t\t} else {\n-\t\t\t\tthrow new UserStoreException(\n-\t\t\t\t\t\t\"Read-only user store.Roles cannot be added or modfified\");\n-\t\t\t}\n-\t\t}\n-\n-\t\t// need to clear user roles cache upon roles update\n-\t\tclearUserRolesCacheByTenant(this.tenantId);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostUpdateUserListOfRole(roleName, deletedUsers,\n-\t\t\t                                         newUsers, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void updateRoleListOfUser(String userName, String[] deletedRoles, String[] newRoles)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tString primaryDomain = realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\t\tif (primaryDomain != null) {\n-\t\t\tprimaryDomain += CarbonConstants.DOMAIN_SEPARATOR;\n-\t\t}\n-\n-\t\tif (deletedRoles != null && deletedRoles.length > 0) {\n-\t\t\tArrays.sort(deletedRoles);\n-\t\t\tif (UserCoreUtil.isPrimaryAdminUser(userName, realmConfig)) {\n-\t\t\t\tfor (int i = 0; i < deletedRoles.length; i++) {\n-\t\t\t\t\tif (deletedRoles[i].equalsIgnoreCase(realmConfig.getAdminRoleName())\n-\t\t\t\t\t\t\t|| (primaryDomain + deletedRoles[i]).equalsIgnoreCase(realmConfig\n-\t\t\t\t\t\t\t\t\t.getAdminRoleName())) {\n-\t\t\t\t\t\tthrow new UserStoreException(\"Cannot remove Admin user from Admin role\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().updateRoleListOfUser(userStore.getDomainFreeName(),\n-\t\t\t\t\tUserCoreUtil.removeDomainFromNames(deletedRoles),\n-\t\t\t\t\tUserCoreUtil.removeDomainFromNames(newRoles));\n-\t\t\treturn;\n-\t\t}\n-\n-        if(userStore.isSystemStore()){\n-            systemUserRoleManager.updateSystemRoleListOfUser(userStore.getDomainFreeName(),\n-                    UserCoreUtil.removeDomainFromNames(deletedRoles),\n-                    UserCoreUtil.removeDomainFromNames(newRoles));\n-            return;\n-        }\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\t// This happens only once during first startup - adding administrator user/role.\n-\t\tif (userName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-\t\t\tuserName = userStore.getDomainFreeName();\n-\t\t\tdeletedRoles = UserCoreUtil.removeDomainFromNames(deletedRoles);\n-\t\t\tnewRoles = UserCoreUtil.removeDomainFromNames(newRoles);\n-\t\t}\n-\n-\t\tList<String> internalRoleDel = new ArrayList<String>();\n-\t\tList<String> internalRoleNew = new ArrayList<String>();\n-\n-\t\tList<String> roleDel = new ArrayList<String>();\n-\t\tList<String> roleNew = new ArrayList<String>();\n-\n-\t\tif (deletedRoles != null && deletedRoles.length > 0) {\n-\t\t\tfor (String deleteRole : deletedRoles) {\n-                if (UserCoreUtil.isEveryoneRole(deleteRole, realmConfig)) {\n-\t\t\t\t\tthrow new UserStoreException(\"Everyone role cannot be updated\");\n-\t\t\t\t}\n-\t\t\t\tString domain = null;\n-\t\t\t\tint index1 = deleteRole.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-\t\t\t\tif (index1 > 0) {\n-\t\t\t\t\tdomain = deleteRole.substring(0, index1);\n-\t\t\t\t}\n-\t\t\t\tif (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain) || this.isReadOnly()) {\n-\t\t\t\t\tinternalRoleDel.add(UserCoreUtil.removeDomainFromName(deleteRole));\n-\t\t\t\t} else {\n-\t\t\t\t\t// This is domain free role name.\n-\t\t\t\t\troleDel.add(UserCoreUtil.removeDomainFromName(deleteRole));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tdeletedRoles = roleDel.toArray(new String[roleDel.size()]);\n-\t\t}\n-\n-\t\tif (newRoles != null && newRoles.length > 0) {\n-\t\t\tfor (String newRole : newRoles) {\n-\t\t\t\tif (UserCoreUtil.isEveryoneRole(newRole, realmConfig)) {\n-\t\t\t\t\tthrow new UserStoreException(\"Everyone role cannot be updated\");\n-\t\t\t\t}\n-\t\t\t\tString domain = null;\n-\t\t\t\tint index2 = newRole.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-\t\t\t\tif (index2 > 0) {\n-\t\t\t\t\tdomain = newRole.substring(0, index2);\n-\t\t\t\t}\n-\t\t\t\tif (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain) || this.isReadOnly()) {\n-\t\t\t\t\tinternalRoleNew.add(UserCoreUtil.removeDomainFromName(newRole));\n-\t\t\t\t} else {\n-\t\t\t\t\troleNew.add(UserCoreUtil.removeDomainFromName(newRole));\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tnewRoles = roleNew.toArray(new String[roleNew.size()]);\n-\t\t}\n-\n-\t\tif (internalRoleDel.size() > 0 || internalRoleNew.size() > 0) {\n-\t\t\thybridRoleManager.updateHybridRoleListOfUser(userStore.getDomainFreeName(),\n-\t\t\t\t\tinternalRoleDel.toArray(new String[internalRoleDel.size()]),\n-\t\t\t\t\tinternalRoleNew.toArray(new String[internalRoleNew.size()]));\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreUpdateRoleListOfUser(userName, deletedRoles, newRoles, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tif ((deletedRoles != null && deletedRoles.length > 0)\n-\t\t\t\t|| (newRoles != null && newRoles.length > 0)) {\n-\t\t\tif (!isReadOnly() && writeGroupsEnabled) {\n-\t\t\t\tdoUpdateRoleListOfUser(userName, deletedRoles, newRoles);\n-\t\t\t} else {\n-\t\t\t\tthrow new UserStoreException(\"Read-only user store. Cannot add/modify roles.\");\n-\t\t\t}\n-\t\t}\n-\n-        clearUserRolesCache(UserCoreUtil.addDomainToName(userName, getMyDomainName()));\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostUpdateRoleListOfUser(userName, deletedRoles, newRoles, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void updateRoleName(String roleName, String newRoleName) throws UserStoreException {\n-\n-\t\tif (UserCoreUtil.isPrimaryAdminRole(newRoleName, realmConfig)) {\n-\t\t\tthrow new UserStoreException(\"Cannot rename admin role\");\n-\t\t}\n-\n-\t\tif (UserCoreUtil.isEveryoneRole(newRoleName, realmConfig)) {\n-\t\t\tthrow new UserStoreException(\"Cannot rename everyone role\");\n-\t\t}\n-\n-\t\tUserStore userStore = getUserStore(roleName);\n-\t\tUserStore userStoreNew = getUserStore(newRoleName);\n-\n-\t\tif (!UserCoreUtil.canRoleBeRenamed(userStore, userStoreNew, realmConfig)) {\n-\t\t\tthrow new UserStoreException(\"The role cannot be renamed\");\n-\t\t}\n-\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().updateRoleName(userStore.getDomainFreeName(),\n-\t\t\t\t\tuserStoreNew.getDomainFreeName());\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif (userStore.isHybridRole()) {\n-\t\t\thybridRoleManager.updateHybridRoleName(userStore.getDomainFreeName(),\n-\t\t\t\t\tuserStoreNew.getDomainFreeName());\n-\n-\t\t\t// This is a special case. We need to pass roles with domains.\n-\t\t\tuserRealm.getAuthorizationManager().resetPermissionOnUpdateRole(\n-\t\t\t\t\tuserStore.getDomainAwareName(), userStoreNew.getDomainAwareName());\n-\n-\t\t\t// Need to update user role cache upon update of role names\n-\t\t\tclearUserRolesCacheByTenant(this.tenantId);\n-\t\t\treturn;\n-\t\t}\n-//\n-//\t\tRoleContext ctx = createRoleContext(roleName);\n-//        if (isOthersSharedRole(roleName)) {          // TODO do we need this\n-//            throw new UserStoreException(\n-//                    \"Logged in user doesn't have permission to delete a role belong to other tenant\");\n-//        }\n-\n-        if (isExistingRole(newRoleName)) {\n-            throw new UserStoreException(\"Role name: \" + newRoleName\n-                    + \" in the system. Please pick another role name.\");\n-        }\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreUpdateRoleName(roleName, newRoleName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tif (!isReadOnly() && writeGroupsEnabled) {\n-\t\t\tdoUpdateRoleName(userStore.getDomainFreeName(), userStoreNew.getDomainFreeName());\n-\t\t} else {\n-\t\t\tthrow new UserStoreException(\n-\t\t\t\t\t\"Read-only UserStoreManager. Roles cannot be added or modified.\");\n-\t\t}\n-\n-\t\t// This is a special case. We need to pass domain aware name.\n-\t\tuserRealm.getAuthorizationManager().resetPermissionOnUpdateRole(\n-\t\t\t\tuserStore.getDomainAwareName(), userStoreNew.getDomainAwareName());\n-\n-\t\t// need to update user role cache upon update of role names\n-\t\tclearUserRolesCacheByTenant(tenantId);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostUpdateRoleName(roleName, newRoleName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-\n-    @Override\n-    public boolean isExistingRole(String roleName, boolean shared) throws org.wso2.carbon.user.api.UserStoreException {\n-        if(shared){\n-            return isExistingShareRole(roleName);\n-        } else {\n-            return isExistingRole(roleName);\n-        }\n-    }\n-\n-    /**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic boolean isExistingRole(String roleName) throws UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(roleName);\n-\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\treturn userStore.getUserStoreManager().isExistingRole(userStore.getDomainFreeName());\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-        if(userStore.isSystemStore()){\n-            return systemUserRoleManager.isExistingRole(userStore.getDomainFreeName());\n-        }\n-\n-\t\tif (userStore.isHybridRole()) {\n-\t\t\tboolean exist = hybridRoleManager.isExistingRole(userStore.getDomainFreeName());\n-\t\t\tif(exist) {\n-\t\t\t\treturn true;\n-\t\t\t} else if(!readGroupsEnabled) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// This happens only once during first startup - adding administrator user/role.\n-\t\troleName = userStore.getDomainFreeName();\n-\n-        // you can not check existence of shared role using this method.\n-        if(isSharedGroupEnabled() && roleName.contains(UserCoreConstants.TENANT_DOMAIN_COMBINER)){\n-            return false;\n-        }\n-        \n-\t\tboolean isExisting = doCheckExistingRole(roleName);\n-\n-\t\tif (!isExisting && (isReadOnly() || !readGroupsEnabled)) {\n-\t\t\tisExisting = hybridRoleManager.isExistingRole(roleName);\n-\t\t}\n-\n-\t\tif (!isExisting) {\n-\t\t\tif (systemUserRoleManager.isExistingRole(roleName)) {\n-\t\t\t\tisExisting = true;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn isExisting;\n-\t}\n-\n-//////////////////////////////////// Shared role APIs start //////////////////////////////////////////\n-    /**\n-     * TODO move to API\n-     * @param roleName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public boolean isExistingShareRole(String roleName) throws UserStoreException {\n-\n-        UserStoreManager manager  = getUserStoreWithSharedRoles();\n-\n-        if(manager == null){\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        return ((AbstractUserStoreManager)manager).doCheckExistingRole(roleName);\n-    }\n-\n-    /**\n-     * TODO  move to API\n-     * @param roleName\n-     * @param deletedUsers\n-     * @param newUsers\n-     * @throws UserStoreException\n-     */\n-    public void updateUsersOfSharedRole(String roleName,\n-                                String[] deletedUsers, String[] newUsers) throws UserStoreException{\n-\n-        UserStoreManager manager  = getUserStoreWithSharedRoles();\n-\n-        if(manager == null){\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        ((AbstractUserStoreManager)manager).doUpdateUserListOfRole(roleName, deletedUsers, newUsers);\n-    }\n-    /**\n-     * TODO move to API\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public String[] getSharedRolesOfUser(String userName,\n-                                    String tenantDomain, String filter) throws UserStoreException {\n-\n-        UserStore userStore = getUserStore(userName);\n-        UserStoreManager manager  = userStore.getUserStoreManager();\n-\n-        if(!((AbstractUserStoreManager)manager).isSharedGroupEnabled()){\n-            throw new UserStoreException(\"Share Groups are not supported by user store\");\n-        }\n-\n-        String[] sharedRoles = ((AbstractUserStoreManager)manager).\n-                doGetSharedRoleListOfUser(userStore.getDomainFreeName(), tenantDomain, filter);\n-        return UserCoreUtil. removeDomainFromNames(sharedRoles);\n-    }\n-\n-    /**\n-     * TODO move to API\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public String[] getUsersOfSharedRole(String roleName, String filter) throws UserStoreException {\n-\n-        UserStoreManager manager  = getUserStoreWithSharedRoles();\n-\n-        if(manager == null){\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        String[] users = ((AbstractUserStoreManager)manager).doGetUserListOfRole(roleName, filter);\n-        return UserCoreUtil. removeDomainFromNames(users);\n-    }\n-\n-    /**\n-     * TODO move to API\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public String[] getSharedRoleNames(String tenantDomain, String filter,\n-                                                    int maxItemLimit) throws UserStoreException {\n-\n-\n-        UserStoreManager manager  = getUserStoreWithSharedRoles();\n-\n-        if(manager == null){\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        String[] sharedRoles = null;\n-        try{\n-            sharedRoles = ((AbstractUserStoreManager)manager).\n-                                        doGetSharedRoleNames(tenantDomain, filter, maxItemLimit);\n-        } catch (UserStoreException e){\n-            throw new UserStoreException(\"Error while retrieving shared roles\", e);\n-        }\n-        return UserCoreUtil. removeDomainFromNames(sharedRoles);\n-    }\n-\n-\n-    /**\n-     * TODO move to API\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public String[] getSharedRoleNames(String filter, int maxItemLimit) throws UserStoreException {\n-\n-        UserStoreManager manager  = getUserStoreWithSharedRoles();\n-\n-        if(manager == null){\n-            throw new UserStoreException(\"Share Groups are not supported by this realm\");\n-        }\n-\n-        String[] sharedRoles = null;\n-        try{\n-            sharedRoles = ((AbstractUserStoreManager)manager).\n-                    doGetSharedRoleNames(null, filter, maxItemLimit);\n-        } catch (UserStoreException e){\n-            throw new UserStoreException(\"Error while retrieving shared roles\", e);\n-        }\n-        return UserCoreUtil. removeDomainFromNames(sharedRoles);\n-    }\n-\n-\n-    public void addInternalRole(String roleName, String[] userList,\n-                    org.wso2.carbon.user.api.Permission[] permission) throws UserStoreException {\n-        doAddInternalRole(roleName, userList, permission);\n-    }\n-\n-    private UserStoreManager getUserStoreWithSharedRoles() throws UserStoreException {\n-        \n-        UserStoreManager sharedRoleManager = null;\n-        \n-        if(isSharedGroupEnabled()) {\n-            return this;\n-        }\n-        \n-        for(Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()){\n-            UserStoreManager manager = entry.getValue();\n-            if(manager != null && ((AbstractUserStoreManager)manager).isSharedGroupEnabled()){\n-                if(sharedRoleManager != null){\n-                    throw new UserStoreException(\"There can not be more than one user store that support\" +\n-                            \"shared groups\");\n-                }\n-                sharedRoleManager =  manager;               \n-            }\n-        }\n-        \n-        return  sharedRoleManager;\n-    }\n-\n-    /**\n-     * TODO move to API\n-     * @param userName\n-     * @param roleName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public boolean isUserInRole(String userName, String roleName) throws UserStoreException {\n-\n-        if(roleName == null || roleName.trim().length() == 0 || userName == null ||\n-                userName.trim().length() == 0){\n-            return false;\n-        }\n-        \n-        // anonymous user is always assigned to  anonymous role\n-        if(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME.equalsIgnoreCase(roleName) &&\n-                        CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userName)){\n-            return true;\n-        }\n-\n-        if(!CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME.equalsIgnoreCase(userName) &&\n-                realmConfig.getEveryOneRoleName().equalsIgnoreCase(roleName) &&\n-                !systemUserRoleManager.isExistingSystemUser(UserCoreUtil.\n-                        removeDomainFromName(userName))) {\n-            return true;\n-        }\n-        \n-        \n-\n-        String[] roles = null;\n-\n-        try{\n-            roles = getRoleListOfUserFromCache(tenantId, userName);\n-        } catch (Exception e){\n-            //ignore\n-        }\n-\n-        if(roles != null){\n-            if(UserCoreUtil.isContain(roleName, roles)){\n-                return true;\n-            }\n-        }\n-\n-        // TODO create new cache for this method\n-        String  modifiedUserName =  UserCoreConstants.IS_USER_IN_ROLE_CACHE_IDENTIFIER + userName;\n-        try{\n-            roles = getRoleListOfUserFromCache(tenantId, modifiedUserName);\n-        } catch (Exception e){\n-            //ignore\n-        }\n-\n-        if(roles != null){\n-            if(UserCoreUtil.isContain(roleName, roles)){\n-                return true;\n-            }\n-        }\n-\n-        if(UserCoreConstants.INTERNAL_DOMAIN.\n-                                equalsIgnoreCase(UserCoreUtil.extractDomainFromName(roleName))){\n-            String[] internalRoles = doGetInternalRoleListOfUser(userName, \"*\");\n-            if(UserCoreUtil.isContain(roleName, internalRoles)){\n-                addToIsUserHasRole(modifiedUserName, roleName, roles);\n-                return true;\n-            }\n-        }\n-\n-        UserStore userStore = getUserStore(userName);\n-        if (userStore.isRecurssive()) {\n-            return userStore.getUserStoreManager().isUserInRole(userStore.getDomainFreeName(), roleName);\n-        }\n-\n-        // #################### Domain Name Free Zone Starts Here ################################\n-\n-        if(userStore.isSystemStore()){\n-            return systemUserRoleManager.isUserInRole(userStore.getDomainFreeName(),\n-                                                    UserCoreUtil.removeDomainFromName(roleName));\n-        }\n-        // admin user is always assigned to admin role if it is in primary user store\n-        if(realmConfig.isPrimary() && roleName.equalsIgnoreCase(realmConfig.getAdminRoleName()) &&\n-                                userName.equalsIgnoreCase(realmConfig.getAdminUserName())){\n-            return true;\n-        }\n-\n-        String roleDomainName = UserCoreUtil.extractDomainFromName(roleName);\n-\n-        String roleDomainNameForForest = realmConfig.\n-                getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_GROUP_SEARCH_DOMAINS);\n-        if(roleDomainNameForForest != null && roleDomainNameForForest.trim().length() > 0){\n-            String[] values = roleDomainNameForForest.split(\"#\");\n-            for(String value : values){\n-                if(value != null && !value.trim().equalsIgnoreCase(roleDomainName)){\n-                    return false;\n-                }\n-            }\n-        } else if (!userStore.getDomainName().equalsIgnoreCase(roleDomainName)) {\n-            return false;\n-        }\n-        \n-        boolean success = false;\n-        if(readGroupsEnabled){        \n-            success = doCheckIsUserInRole(userStore.getDomainFreeName(),\n-                                                    UserCoreUtil.removeDomainFromName(roleName));\n-        }\n-\n-        // add to cache\n-        if(success){\n-            addToIsUserHasRole(modifiedUserName, roleName, roles);\n-        }\n-        return success;\n-    }\n-\n-    /**\n-     * \n-     * @param userName\n-     * @param roleName\n-     * @return\n-     * @throws UserStoreException\n-     */\n-    public abstract boolean doCheckIsUserInRole(String userName, String roleName) throws UserStoreException;\n-\n-    /**\n-     * Helper method\n-     * @param userName\n-     * @param roleName\n-     * @param currentRoles\n-     */\n-    private void addToIsUserHasRole(String userName, String roleName, String[] currentRoles){\n-        List<String> roles;\n-        if(currentRoles != null){\n-            roles = new ArrayList<String>(Arrays.asList(currentRoles));\n-        } else {\n-            roles = new ArrayList<String>();\n-        }\n-        roles.add(roleName);\n-        addToUserRolesCache(tenantId, UserCoreUtil.addDomainToName(userName, getMyDomainName()),\n-                roles.toArray(new String[roles.size()]));\n-    }    \n-\n-//////////////////////////////////// Shared role APIs finish //////////////////////////////////////////\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic boolean isExistingUser(String userName) throws UserStoreException {\n-\n-\t\tif (UserCoreUtil.isRegistrySystemUser(userName)) {\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\treturn userStore.getUserStoreManager().isExistingUser(userStore.getDomainFreeName());\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif(userStore.isSystemStore()){\n-            systemUserRoleManager.isExistingSystemUser(userName);\n-        }\n-        \n-        \n-        return doCheckExistingUser(userStore.getDomainFreeName());\n-\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final String[] listUsers(String filter, int maxItemLimit) throws UserStoreException {\n-\n-\t\tint index;\n-\t\tindex = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-\n-\t\t// Check whether we have a secondary UserStoreManager setup.\n-\t\tif (index > 0) {\n-\t\t\t// Using the short-circuit. User name comes with the domain name.\n-\t\t\tString domain = filter.substring(0, index);\n-\n-\t\t\tUserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-\t\t\tif (secManager != null) {\n-\t\t\t\t// We have a secondary UserStoreManager registered for this domain.\n-\t\t\t\tfilter = filter.substring(index + 1);\n-\t\t\t\tif (secManager instanceof AbstractUserStoreManager) {\n-\t\t\t\t\treturn ((AbstractUserStoreManager) secManager)\n-\t\t\t\t\t\t\t.doListUsers(filter, maxItemLimit);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\t// Exception is not need to as listing of users\n-\t\t\t\t// throw new UserStoreException(\"Invalid Domain Name\");\n-\t\t\t}\n-\t\t} else if (index == 0) {\n-\t\t\treturn doListUsers(filter.substring(index + 1), maxItemLimit);\n-\t\t}\n-\n-\t\tString[] userList = doListUsers(filter, maxItemLimit);\n-\n-\t\tString primaryDomain = realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\n-\t\tif (this.getSecondaryUserStoreManager() != null) {\n-\t\t\tfor (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-\t\t\t\tif (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tUserStoreManager storeManager = entry.getValue();\n-\t\t\t\tif (storeManager instanceof AbstractUserStoreManager) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tString[] secondUserList = ((AbstractUserStoreManager) storeManager)\n-\t\t\t\t\t\t\t\t.doListUsers(filter, maxItemLimit);\n-\t\t\t\t\t\tuserList = UserCoreUtil.combineArrays(userList, secondUserList);\n-\t\t\t\t\t} catch (UserStoreException ex) {\n-\t\t\t\t\t\t// We can ignore and proceed. Ignore the results from this user store.\n-\t\t\t\t\t\tlog.error(ex);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn userList;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final String[] getUserListOfRole(String roleName) throws UserStoreException {\n-\n-\t\tString[] userNames = new String[0];\n-\n-\t\t// If role does not exit, just return\n-\t\tif (!isExistingRole(roleName)) {\n-\t\t\treturn userNames;\n-\t\t}\n-\n-\t\tUserStore userStore = getUserStore(roleName);\n-\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\treturn userStore.getUserStoreManager().getUserListOfRole(userStore.getDomainFreeName());\n-\t\t}\n-\n-\n-\t\t// #################### Domain Name Free Zone Starts Here\n-\t\t// ################################\n-\n-        if(userStore.isSystemStore()){\n-            return systemUserRoleManager.getUserListOfSystemRole(userStore.getDomainFreeName());\n-        }\n-\n-        String[] userNamesInHybrid = new String[0];\n-\t\tif (userStore.isHybridRole()) {\n-\t\t\tuserNamesInHybrid =\n-\t\t\t                    hybridRoleManager.getUserListOfHybridRole(userStore.getDomainFreeName());\n-\t\t\t// remove domain\n-\t\t\tList<String> finalNameList = new ArrayList<String>();\n-            String displayNameAttribute =\n-                    this.realmConfig.getUserStoreProperty(LDAPConstants.DISPLAY_NAME_ATTRIBUTE);\n-\n-            if(userNamesInHybrid != null  && userNamesInHybrid.length > 0){\n-                if(displayNameAttribute != null && displayNameAttribute.trim().length() > 0){\n-                    for (String userName : userNamesInHybrid) {\n-                        String domainName = UserCoreUtil.extractDomainFromName(userName);\n-                        if(domainName == null || domainName.trim().length() == 0){\n-                            finalNameList.add(userName);\n-                        }\n-                        UserStoreManager userManager = userStoreManagerHolder.get(domainName);\n-                        userName = UserCoreUtil.removeDomainFromName(userName);\n-                        if(userManager != null){\n-                            // get displayNames\n-                            String[] displayNames =  ((AbstractUserStoreManager) userManager).\n-                                                    doGetDisplayNamesForInternalRole(new String[]{userName});\n-                            for (String displayName : displayNames) {\n-                                // if domain names are not added by above method, add it\n-                                // here\n-                                String nameWithDomain = UserCoreUtil.addDomainToName(displayName, domainName);\n-                                finalNameList.add(nameWithDomain);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    return userNamesInHybrid;\n-                }\n-            }\n-\t\t\treturn finalNameList.toArray(new String[finalNameList.size()]);\n-\t\t\t// return\n-\t\t\t// hybridRoleManager.getUserListOfHybridRole(userStore.getDomainFreeName());\n-\t\t}\n-\n-\t\tif (readGroupsEnabled) {\n-\t\t\tuserNames = doGetUserListOfRole(roleName, \"*\");\n-\t\t}\n-\n-\t\treturn userNames;\n-\t}\n-\t\n-\tpublic String[] getRoleListOfUser(String userName) throws UserStoreException {\n-\t\tString[] roleNames = null;\n-\n-\t\t// If user does not exist, just return\n-\t\tif (!isExistingUser(userName)) {\n-\t\t\treturn new String[0];\n-\t\t}\n-\n-\t\t// Check whether roles exist in cache\n-\t\ttry {\n-\t\t\troleNames = getRoleListOfUserFromCache(this.tenantId, userName);\n-\t\t\tif (roleNames != null) {\n-\t\t\t\treturn roleNames;\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\t// If not exist in cache, continue\n-\t\t}\n-\n-\t\tUserStore userStore = getUserStore(userName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\treturn userStore.getUserStoreManager().getRoleListOfUser(userStore.getDomainFreeName());\n-\t\t}\n-\n-        if(userStore.isSystemStore()){\n-            return systemUserRoleManager.getSystemRoleListOfUser(userStore.getDomainFreeName());\n-        }\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-        roleNames = doGetRoleListOfUser(userName, \"*\");\n-\n-\t\taddToUserRolesCache(this.tenantId,\n-\t\t\t\tUserCoreUtil.addDomainToName(userName, getMyDomainName()), roleNames);\n-\n-\t\treturn roleNames;\n-\n-\t}\n-\n-\t/**\n-\t * Getter method for claim manager property specifically to be used in the implementations of\n-\t * UserOperationEventListener implementations\n-\t * \n-\t * @return\n-\t */\n-\tpublic ClaimManager getClaimManager() {\n-\t\treturn claimManager;\n-\t}\n-\n-\t/**\n-\t * \n-\t */\n-\tpublic void addRole(String roleName, String[] userList,\n-\t\t\torg.wso2.carbon.user.api.Permission[] permissions, boolean isSharedRole)\n-\t\t\tthrows org.wso2.carbon.user.api.UserStoreException {\n-\n-\t\tUserStore userStore = getUserStore(roleName);\n-\t\t\n-\t\tif (isSharedRole && !isSharedGroupEnabled()) {\n-\t\t\tthrow new org.wso2.carbon.user.api.UserStoreException(\n-\t\t\t                                                      \"User store doesn't support shared user roles functionality\");\n-\t\t}\n-\n-        if (userStore.isHybridRole()) {\n-\t\t\tdoAddInternalRole(userStore.getDomainFreeName(), userList, permissions);\n-\t\t\treturn;\n-\t\t}\n-        \n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().addRole(userStore.getDomainFreeName(),\n-\t\t\t\t\tUserCoreUtil.removeDomainFromNames(userList), permissions, isSharedRole);\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\t// This happens only once during first startup - adding administrator user/role.\n-\t\tif (roleName.indexOf(CarbonConstants.DOMAIN_SEPARATOR) > 0) {\n-\t\t\troleName = userStore.getDomainFreeName();\n-\t\t\tuserList = UserCoreUtil.removeDomainFromNames(userList);\n-\t\t}\n-\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreAddRole(roleName, userList, permissions, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\t// Check for validations\n-\t\tif (isReadOnly()) {\n-\t\t\tthrow new UserStoreException(\n-\t\t\t\t\t\"Cannot add role to Read Only user store unless it is primary\");\n-\t\t}\n-\n-\t\tif (!isRoleNameValid(roleName)) {\n-\t\t\tString regEx = realmConfig\n-\t\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n-\t\t\tthrow new UserStoreException(\n-\t\t\t\t\t\"Role name not valid. Role name must be a non null string with following format, \"\n-\t\t\t\t\t\t\t+ regEx);\n-\t\t}\n-\n-\t\tif (doCheckExistingRole(roleName)) {\n-\t\t\tthrow new UserStoreException(\"Role name: \" + roleName +\n-\t\t\t                             \" in the system. Please pick another role name.\");\n-\t\t}\n-\n-\t\tString roleWithDomain = null;\n-\t\tif (!isReadOnly() && writeGroupsEnabled) {\n-\t\t\t// add role in to actual user store\n-\t\t\tdoAddRole(roleName, userList,isSharedRole);\n-\n-\t\t\troleWithDomain = UserCoreUtil.addDomainToName(roleName, getMyDomainName());\n-\t\t} else {\n-\t\t\tthrow new UserStoreException(\n-                         \"Role cannot be added. User store is read only or cannot write groups.\");\n-\t\t}\n-\n-\t\t// add permission in to the the permission store\n-\t\tif (permissions != null) {\n-\t\t\tfor (org.wso2.carbon.user.api.Permission permission : permissions) {\n-\t\t\t\tString resourceId = permission.getResourceId();\n-\t\t\t\tString action = permission.getAction();\n-                if(resourceId == null || resourceId.trim().length() ==0 ){\n-                    continue;\n-                }\n-\n-                if(action == null || action.trim().length() ==0 ){\n-                    // default action value // TODO\n-                    action = \"read\";\n-                }\n-\t\t\t\t// This is a special case. We need to pass domain aware name.\n-\t\t\t\tuserRealm.getAuthorizationManager().authorizeRole(roleWithDomain, resourceId,\n-\t\t\t\t\t\taction);\n-\t\t\t}\n-\t\t}\n-\n-\t\t// if existing users are added to role, need to update user role cache\n-\t\tif ((userList != null) && (userList.length > 0)) {\n-\t\t\tclearUserRolesCacheByTenant(tenantId);\n-\t\t}\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostAddRole(roleName, userList, permissions, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-    /**\n-     * TODO move to API\n-     *\n-     * @return\n-     */\n-\tpublic boolean isSharedGroupEnabled() {\n-\t\tString value = realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.SHARED_GROUPS_ENABLED);\n-\t\ttry {\n-\t\t\treturn realmConfig.isPrimary() && !isReadOnly() && TRUE_VALUE.equalsIgnoreCase(value);\n-\t\t} catch (UserStoreException e) {\n-\t\t\tlog.error(e);\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Removes the shared roles relevant to the provided tenant domain\n-\t * \n-\t * @param sharedRoles\n-\t * @param tenantDomain\n-\t */\n-\tprotected void filterSharedRoles(List<String> sharedRoles, String tenantDomain) {\n-\t\tif (tenantDomain != null) {\n-\t\t\tfor (Iterator<String> i = sharedRoles.iterator(); i.hasNext();) {\n-\t\t\t\tString role = i.next();\n-\t\t\t\tif (role.indexOf(tenantDomain) > -1) {\n-\t\t\t\t\ti.remove();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Delete the role with the given role name\n-\t * \n-\t * @param roleName The role name\n-\t * @throws org.wso2.carbon.user.core.UserStoreException\n-\t * \n-\t */\n-\tpublic final void deleteRole(String roleName) throws UserStoreException {\n-\n-\t\tif (UserCoreUtil.isPrimaryAdminRole(roleName, realmConfig)) {\n-\t\t\tthrow new UserStoreException(\"Cannot delete admin role\");\n-\t\t}\n-\t\tif (UserCoreUtil.isEveryoneRole(roleName, realmConfig)) {\n-\t\t\tthrow new UserStoreException(\"Cannot delete everyone role\");\n-\t\t}\n-\n-\t\tUserStore userStore = getUserStore(roleName);\n-\t\tif (userStore.isRecurssive()) {\n-\t\t\tuserStore.getUserStoreManager().deleteRole(userStore.getDomainFreeName());\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif (userStore.isHybridRole()) {\n-\t\t\thybridRoleManager.deleteHybridRole(userStore.getDomainFreeName());\n-            clearUserRolesCacheByTenant(tenantId);\n-\t\t\treturn;\n-\t\t}\n-//\n-//\t\tRoleContext ctx = createRoleContext(roleName);\n-//\t\tif (isOthersSharedRole(roleName)) {\n-//\t\t\tthrow new UserStoreException(\n-//\t\t\t                             \"Logged in user doesn't have permission to delete a role belong to other tenant\");\n-//\t\t}\n-\n-\n-        if (!doCheckExistingRole(roleName)) {\n-            throw new UserStoreException(\"Can not delete non exiting role\");\n-        }\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPreDeleteRole(roleName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t\tif (!isReadOnly() && writeGroupsEnabled) {\n-\t\t\tdoDeleteRole(roleName);\n-\t\t} else {\n-\t\t\tthrow new UserStoreException(\n-\t\t\t                             \"Role cannot be deleted. User store is read only or cannot write groups.\");\n-\t\t}\n-\n-        // clear role authorization\n-        userRealm.getAuthorizationManager().clearRoleAuthorization(roleName);\n-\n-        // clear cache\n-\t\tclearUserRolesCacheByTenant(tenantId);\n-\n-\t\t// #################### <Listeners> #####################################################\n-\t\tfor (UserOperationEventListener listener : UMListenerServiceComponent\n-\t\t\t\t.getUserOperationEventListeners()) {\n-\t\t\tif (!listener.doPostDeleteRole(roleName, this)) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t}\n-\t\t// #################### </Listeners> #####################################################\n-\n-\t}\n-\n-\t/**\n-\t *\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprivate UserStore getUserStore(String user) throws UserStoreException {\n-\n-\t\tint index;\n-\t\tindex = user.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-\t\tUserStore userStore = new UserStore();\n-\t\tString domainFreeName = null;\n-\n-\t\t// Check whether we have a secondary UserStoreManager setup.\n-\t\tif (index > 0) {\n-\t\t\t// Using the short-circuit. User name comes with the domain name.\n-\t\t\tString domain = user.substring(0, index);\n-\t\t\tUserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-\t\t\tdomainFreeName = user.substring(index + 1);\n-\n-\t\t\tif (secManager != null) {\n-\t\t\t\tuserStore.setUserStoreManager((AbstractUserStoreManager) secManager);\n-\t\t\t\tuserStore.setDomainAwareName(user);\n-\t\t\t\tuserStore.setDomainFreeName(domainFreeName);\n-\t\t\t\tuserStore.setDomainName(domain);\n-\t\t\t\tuserStore.setRecurssive(true);\n-\t\t\t\treturn userStore;\n-\t\t\t} else {\n-\t\t\t\tif (!domain.equalsIgnoreCase(getMyDomainName())) {\n-\t\t\t\t\tif ((UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain))) {\n-\t\t\t\t\t\tuserStore.setHybridRole(true);\n-                    } else if(UserCoreConstants.SYSTEM_DOMAIN_NAME.equalsIgnoreCase(domain)) {\n-                        userStore.setSystemStore(true);\n-\t\t\t\t\t} else {\n-                        throw new UserStoreException(\"Invalid Domain Name\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tString domain = UserCoreUtil.getDomainName(realmConfig);\n-\t\tuserStore.setUserStoreManager(this);\n-\t\tif (index > 0) {\n-\t\t\tuserStore.setDomainAwareName(user);\n-\t\t\tuserStore.setDomainFreeName(domainFreeName);\n-\t\t} else {\n-\t\t\tuserStore.setDomainAwareName(domain + CarbonConstants.DOMAIN_SEPARATOR + user);\n-\t\t\tuserStore.setDomainFreeName(user);\n-\t\t}\n-\t\tuserStore.setRecurssive(false);\n-\t\tuserStore.setDomainName(domain);\n-\n-        return userStore;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final UserStoreManager getSecondaryUserStoreManager() {\n-\t\treturn secondaryUserStoreManager;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final UserStoreManager getSecondaryUserStoreManager(String userDomain) {\n-\t\tif (userDomain == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\treturn userStoreManagerHolder.get(userDomain.toUpperCase());\n-\t}\n-\n-\t/**\n-\t * \n-\t */\n-\tpublic final void setSecondaryUserStoreManager(UserStoreManager secondaryUserStoreManager) {\n-\t\tthis.secondaryUserStoreManager = secondaryUserStoreManager;\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final void addSecondaryUserStoreManager(String userDomain,\n-\t\t\tUserStoreManager userStoreManager) {\n-\t\tif (userDomain != null) {\n-\t\t\tuserStoreManagerHolder.put(userDomain.toUpperCase(), userStoreManager);\n-\t\t}\n-\t}\n-\t\n-    public final void clearAllSecondaryUserStores() {\n-        userStoreManagerHolder.clear();\n-        \n-        if (getMyDomainName() != null) {\n-            userStoreManagerHolder.put(getMyDomainName().toUpperCase(), this);\n-        }\n-    }\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final String[] getAllSecondaryRoles() throws UserStoreException {\n-\t\tUserStoreManager secondary = this.getSecondaryUserStoreManager();\n-\t\tList<String> roleList = new ArrayList<String>();\n-\t\twhile (secondary != null) {\n-\t\t\tString[] roles = secondary.getRoleNames(true);\n-\t\t\tif (roles != null && roles.length > 0) {\n-\t\t\t\tCollections.addAll(roleList, roles);\n-\t\t\t}\n-\t\t\tsecondary = secondary.getSecondaryUserStoreManager();\n-\t\t}\n-\t\treturn roleList.toArray(new String[roleList.size()]);\n-\t}\n-\n-\t/**\n-\t * \n-\t * @return\n-\t */\n-\tpublic boolean isSCIMEnabled() {\n-\t\tString scimEnabled = realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_SCIM_ENABLED);\n-\t\tif (scimEnabled != null) {\n-\t\t\treturn Boolean.parseBoolean(scimEnabled);\n-\t\t} else {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}                  doAddInternalRole\n-\t */\n-\tpublic final String[] getHybridRoles() throws UserStoreException {\n-\t\treturn hybridRoleManager.getHybridRoles(\"*\");\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final String[] getRoleNames() throws UserStoreException {\n-\t\treturn getRoleNames(false);\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tpublic final String[] getRoleNames(boolean noHybridRoles) throws UserStoreException {\n-\t\treturn getRoleNames(\"*\", -1, noHybridRoles, true, true);\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param roleName\n-\t * @param userList\n-\t * @param permissions\n-\t * @throws UserStoreException\n-\t */\n-\tprotected void doAddInternalRole(String roleName, String[] userList,\n-                                                org.wso2.carbon.user.api.Permission [] permissions)\n-\t\t\tthrows UserStoreException {\n-\n-\t\t// #################### Domain Name Free Zone Starts Here ################################\n-\n-\t\tif (hybridRoleManager.isExistingRole(UserCoreUtil.removeDomainFromName(roleName))) {\n-\t\t\tthrow new UserStoreException(\"Role name: \" + roleName\n-\t\t\t\t\t+ \" in the system. Please pick another role name.\");\n-\t\t}\n-\n-\t\thybridRoleManager.addHybridRole(UserCoreUtil.removeDomainFromName(roleName), userList);\n-\n-\t\tif (permissions != null) {\n-\t\t\tfor (org.wso2.carbon.user.api.Permission  permission : permissions) {\n-\t\t\t\tString resourceId = permission.getResourceId();\n-\t\t\t\tString action = permission.getAction();\n-\t\t\t\t// This is a special case. We need to pass domain aware name.\n-\t\t\t\tuserRealm.getAuthorizationManager().authorizeRole(\n-\t\t\t\t\t\tUserCoreUtil.addInternalDomainName(roleName), resourceId, action);\n-\t\t\t}\n-\t\t}\n-\n-\t\tif ((userList != null) && (userList.length > 0)) {\n-\t\t\tclearUserRolesCacheByTenant(this.tenantId);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Returns the set of shared roles which applicable for the logged in tenant\n-\t * \n-\t * @param tenantDomain tenant domain of the shared roles. If this is null, \n-     *                     returns all shared roles of available tenant domains\n-     * @param filter\n-\t * @param maxItemLimit\n-\t * @return\n-\t */\n-\tprotected abstract String[] doGetSharedRoleNames(String tenantDomain, String filter, \n-                                                     int maxItemLimit) throws UserStoreException;\n-\n-\t/**\n-\t * TODO This method would returns the role Name actually this must be implemented in interface.\n-\t * As it is not good to change the API in point release. This has been added to Abstract class\n-\t * \n-\t * @param filter\n-\t * @param maxItemLimit\n-\t * @param noInternalRoles\n-     * @return\n-\t * @throws UserStoreException\n-\t */\n-\tpublic final String[] getRoleNames(String filter, int maxItemLimit, boolean noInternalRoles,\n-                                                    boolean noSystemRole, boolean  noSharedRoles)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tString[] roleList = new String[0];\n-\n-\t\tif (!noInternalRoles) {\n-\t\t\troleList = hybridRoleManager.getHybridRoles(UserCoreUtil.removeDomainFromName(filter));\n-\t\t}\n-        \n-        if(!noSystemRole){\n-            String[] systemRoles = systemUserRoleManager.getSystemRoles();\n-            roleList = UserCoreUtil.combineArrays(roleList, systemRoles);\n-        }\n-\n-\t\tint index;\n-\t\tindex = filter.indexOf(CarbonConstants.DOMAIN_SEPARATOR);\n-\n-\t\t// Check whether we have a secondary UserStoreManager setup.\n-\t\tif (index > 0) {\n-\t\t\t// Using the short-circuit. User name comes with the domain name.\n-\t\t\tString domain = filter.substring(0, index);\n-\n-\t\t\tUserStoreManager secManager = getSecondaryUserStoreManager(domain);\n-\t\t\tif (UserCoreConstants.INTERNAL_DOMAIN.equalsIgnoreCase(domain)) {\n-\t\t\t\treturn new String[0];\n-\t\t\t}\n-\t\t\tif (secManager != null) {\n-\t\t\t\t// We have a secondary UserStoreManager registered for this domain.\n-\t\t\t\tfilter = filter.substring(index + 1);\n-\t\t\t\tif (secManager instanceof AbstractUserStoreManager) {\n-\t\t\t\t\tString[] externalRoles = ((AbstractUserStoreManager) secManager)\n-\t\t\t\t\t\t\t.doGetRoleNames(filter, maxItemLimit);\n-\t\t\t\t\treturn UserCoreUtil.combineArrays(roleList, externalRoles);\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tthrow new UserStoreException(\"Invalid Domain Name\");\n-\t\t\t}\n-\t\t} else if (index == 0) {\n-\t\t\tString[] externalRoles = doGetRoleNames(filter.substring(index + 1), maxItemLimit);\n-\t\t\treturn UserCoreUtil.combineArrays(roleList, externalRoles);\n-\t\t}\n-\n-\t\tString[] externalRoles = doGetRoleNames(filter, maxItemLimit);\n-\t\troleList = UserCoreUtil.combineArrays(externalRoles, roleList);\n-\n-\t\tString primaryDomain = getMyDomainName();\n-\n-\t\tif (this.getSecondaryUserStoreManager() != null) {\n-\t\t\tfor (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-\t\t\t\tif (entry.getKey().equalsIgnoreCase(primaryDomain)) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tUserStoreManager storeManager = entry.getValue();\n-\t\t\t\tif (storeManager instanceof AbstractUserStoreManager) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tString[] secondRoleList = ((AbstractUserStoreManager) storeManager)\n-\t\t\t\t\t\t\t\t.doGetRoleNames(filter, maxItemLimit);\n-\t\t\t\t\t\troleList = UserCoreUtil.combineArrays(roleList, secondRoleList);\n-\t\t\t\t\t} catch (UserStoreException e) {\n-\t\t\t\t\t\t// We can ignore and proceed. Ignore the results from this user store.\n-\t\t\t\t\t\tlog.error(e);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn roleList;\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param userName\n-\t * @param claims\n-\t * @param domainName\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprivate Map<String, String> doGetUserClaimValues(String userName, String[] claims,\n-\t\t\tString domainName, String profileName) throws UserStoreException {\n-\n-\t\t// Here the user name should be domain-less.\n-\t\tboolean requireRoles = false;\n-\t\tboolean requireIntRoles = false;\n-\t\tboolean requireExtRoles = false;\n-\t\tString roleClaim = null;\n-\n-        if(profileName == null || profileName.trim().length() == 0){\n-            profileName = UserCoreConstants.DEFAULT_PROFILE;\n-        }\n-\n-\t\tSet<String> propertySet = new HashSet<String>();\n-\t\tfor (String claim : claims) {\n-\n-\t\t\t// There can be cases some claim values being requested for claims\n-\t\t\t// we don't have.\n-\t\t\tString property = null;\n-\t\t\ttry {\n-\t            property = getClaimAtrribute(claim, userName, domainName);\n-            } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-\t            throw new UserStoreException(e);\n-            }\n-\t\t\tif (property != null\n-\t\t\t\t\t&& (!UserCoreConstants.ROLE_CLAIM.equalsIgnoreCase(claim)\n-\t\t\t\t\t\t\t|| !UserCoreConstants.INT_ROLE_CLAIM.equalsIgnoreCase(claim) ||\n-                               !UserCoreConstants.EXT_ROLE_CLAIM.equalsIgnoreCase(claim))) {\n-\t\t\t\tpropertySet.add(property);\n-\t\t\t}\n-\n-\t\t\tif (UserCoreConstants.ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-\t\t\t\trequireRoles = true;\n-\t\t\t\troleClaim = claim;\n-\t\t\t} else if (UserCoreConstants.INT_ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-\t\t\t\trequireIntRoles = true;\n-\t\t\t\troleClaim = claim;\n-\t\t\t} else if (UserCoreConstants.EXT_ROLE_CLAIM.equalsIgnoreCase(claim)) {\n-\t\t\t\trequireExtRoles = true;\n-\t\t\t\troleClaim = claim;\n-\t\t\t}\n-\t\t}\n-\n-\t\tString[] properties = propertySet.toArray(new String[propertySet.size()]);\n-\t\tMap<String, String> uerProperties = this.getUserPropertyValues(userName, properties,\n-\t\t\t\tprofileName);\n-\n-\t\tList<String> getAgain = new ArrayList<String>();\n-\t\tMap<String, String> finalValues = new HashMap<String, String>();\n-\n-\t\tfor (String claim : claims) {\n-\t\t\tClaimMapping mapping;\n-\t\t\ttry {\n-\t\t\t\tmapping = (ClaimMapping) claimManager.getClaimMapping(claim);\n-\t\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n-\t\t\t\tthrow new UserStoreException(e);\n-\t\t\t}\n-\t\t\tif (mapping != null) {\n-\t\t\t\tString property = null;\n-\n-\t\t\t\tif (domainName != null) {\n-\t\t\t\t\tMap<String, String> attrMap = mapping.getMappedAttributes();\n-\t\t\t\t\tif (attrMap != null) {\n-\t\t\t\t\t\tString attr = null;\n-\t\t\t\t\t\tif ((attr = attrMap.get(domainName.toUpperCase())) != null) {\n-\t\t\t\t\t\t\tproperty = attr;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tproperty = mapping.getMappedAttribute();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tproperty = mapping.getMappedAttribute();\n-\t\t\t\t}\n-\n-\t\t\t\tString value = uerProperties.get(property);\n-\n-\t\t\t\tif (profileName.equals(UserCoreConstants.DEFAULT_PROFILE)) {\n-\t\t\t\t\t// Check whether we have a value for the requested attribute\n-\t\t\t\t\tif (value != null && value.trim().length() > 0) {\n-\t\t\t\t\t\tfinalValues.put(claim, value);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tif (value != null && value.trim().length() > 0) {\n-\t\t\t\t\t\tfinalValues.put(claim, value);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (getAgain.size() > 0) {\n-\t\t\t// oh the beautiful recursion\n-\t\t\tMap<String, String> mapClaimValues = this.getUserClaimValues(userName,\n-\t\t\t\t\t(String[]) getAgain.toArray(new String[getAgain.size()]),\n-\t\t\t\t\tprofileName);\n-\n-\t\t\tIterator<Map.Entry<String, String>> ite3 = mapClaimValues.entrySet().iterator();\n-\t\t\twhile (ite3.hasNext()) {\n-\t\t\t\tMap.Entry<String, String> entry = ite3.next();\n-\t\t\t\tif (entry.getValue() != null) {\n-\t\t\t\t\tfinalValues.put(entry.getKey(), entry.getValue());\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t// We treat roles claim in special way.\n-\t\tString[] roles = null;\n-\n-\t\tif (requireRoles) {\n-\t\t\troles = getRoleListOfUser(userName);\n-\t\t} else if (requireIntRoles) {\n-\t\t\troles = doGetInternalRoleListOfUser(userName, \"*\");\n-\t\t} else if (requireExtRoles) {\n-\n-\t\t\tList<String> rolesList = new ArrayList<String>();\n-\t\t\tString[] externalRoles = doGetExternalRoleListOfUser(userName, \"*\");\n-\t\t\trolesList.addAll(Arrays.asList(externalRoles));\n-            //if only shared enable\n-            if(isSharedGroupEnabled()){\n-                String[] sharedRoles = doGetSharedRoleListOfUser(userName, null, \"*\");\n-                if (sharedRoles != null) {\n-                    rolesList.addAll(Arrays.asList(sharedRoles));\n-                }\n-            }\n-\n-\t\t\troles = rolesList.toArray(new String[rolesList.size()]);\n-\t\t}\n-\n-\t\tif (roles != null && roles.length > 0) {\n-\t\t\tString delim = \"\";\n-\t\t\tStringBuffer roleBf = new StringBuffer();\n-\t\t\tfor (String role : roles) {\n-\t\t\t\troleBf.append(delim).append(role);\n-\t\t\t\tdelim = \",\";\n-\t\t\t}\n-\t\t\tfinalValues.put(roleClaim, roleBf.toString());\n-\t\t}\n-\n-\t\treturn finalValues;\n-\t}\n-\n-\t/**\n-\t * \n-\t * @return\n-\t */\n-\tprotected String getEveryOneRoleName() {\n-\t\treturn realmConfig.getEveryOneRoleName();\n-\t}\n-\n-\t/**\n-\t * \n-\t * @return\n-\t */\n-\tprotected String getAdminRoleName() {\n-\t\treturn realmConfig.getAdminRoleName();\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param credential\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected boolean checkUserPasswordValid(Object credential) throws UserStoreException {\n-\n-\t\tif (credential == null) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (!(credential instanceof String)) {\n-\t\t\tthrow new UserStoreException(\"Can handle only string type credentials\");\n-\t\t}\n-\n-\t\tString password = ((String) credential).trim();\n-\n-\t\tif (password.length() < 1) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tString regularExpression = realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_JAVA_REG_EX);\n-\t\treturn regularExpression == null || isFormatCorrect(regularExpression, password);\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param userName\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected boolean checkUserNameValid(String userName) throws UserStoreException {\n-\n-\t\tif (userName == null || CarbonConstants.REGISTRY_SYSTEM_USERNAME.equals(userName)) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tuserName = userName.trim();\n-\n-\t\tif (userName.length() < 1) {\n-\t\t\treturn false;\n-\t\t}\n-\n-        String regularExpression = realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_JAVA_REG_EX);\n-        \n-        if (MultitenantUtils.isEmailUserName()) {\n-            regularExpression = realmConfig\n-                    .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_NAME_WITH_EMAIL_JS_REG_EX);\n-            if (regularExpression == null) {\n-                regularExpression = UserCoreConstants.RealmConfig.EMAIL_VALIDATION_REGEX;\n-            }\n-        }\n-        \n-        if (regularExpression != null){\n-             regularExpression = regularExpression.trim();\n-        }\n-\n-\t\treturn regularExpression == null || regularExpression.equals(\"\")\n-\t\t\t\t|| isFormatCorrect(regularExpression, userName);\n-\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param roleName\n-\t * @return\n-\t */\n-\tprotected boolean isRoleNameValid(String roleName) {\n-\t\tif (roleName == null) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tif (roleName.length() < 1) {\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\tString regularExpression = realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n-\t\tif (regularExpression != null) {\n-\t\t\tif (!isFormatCorrect(regularExpression, roleName)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn true;\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param tenantID\n-\t * @param userName\n-\t * @return\n-\t */\n-\tprotected String[] getRoleListOfUserFromCache(int tenantID, String userName) {\n-\t\tif (userRolesCache != null) {\n-\t\t\treturn userRolesCache.getRolesListOfUser(cacheIdentifier, tenantID, userName);\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param tenantID\n-\t */\n-\tprotected void clearUserRolesCacheByTenant(int tenantID) {\n-\t\tif (userRolesCache != null) {\n-\t\t\tuserRolesCache.clearCacheByTenant(tenantID);\n-\t\t}\n-\t\tAuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n-\t\tauthorizationCache.clearCacheByTenant(tenantID);\n-\t}\n-\n-    /**\n-     *\n-     * @param userName\n-     */\n-    protected void clearUserRolesCache(String userName) {\n-        if (userRolesCache != null) {\n-            userRolesCache.clearCacheEntry(cacheIdentifier, tenantId, userName);\n-        }\n-        AuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n-        authorizationCache.clearCacheByUser(tenantId, userName);\n-    }\n-\n-\t/**\n-\t * \n-\t * @param tenantID\n-\t * @param userName\n-\t * @param roleList\n-\t */\n-\tprotected void addToUserRolesCache(int tenantID, String userName, String[] roleList) {\n-\t\tif (userRolesCache != null) {\n-\t\t\tuserRolesCache.addToCache(cacheIdentifier, tenantID, userName, roleList);\n-\t\t\tAuthorizationCache authorizationCache = AuthorizationCache.getInstance();\n-\t\t\tauthorizationCache.clearCacheByTenant(tenantID);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * {@inheritDoc}\n-\t */\n-\tprotected void initUserRolesCache() {\n-\n-\t\tString userRolesCacheEnabledString = (realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLES_CACHE_ENABLED));\n-\n-\t\tString userCoreCacheIdentifier = realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_CORE_CACHE_IDENTIFIER);\n-\n-\t\tif (userCoreCacheIdentifier != null && userCoreCacheIdentifier.trim().length() > 0) {\n-\t\t\tcacheIdentifier = userCoreCacheIdentifier;\n-\t\t} else {\n-            cacheIdentifier = UserCoreConstants.DEFAULT_CACHE_IDENTIFIER;\n-        }\n-\n-\t\tif (userRolesCacheEnabledString != null && !userRolesCacheEnabledString.equals(\"\")) {\n-\t\t\tuserRolesCacheEnabled = Boolean.parseBoolean(userRolesCacheEnabledString);\n-\t\t\tif (log.isDebugEnabled()) {\n-\t\t\t\tlog.debug(\"User Roles Cache is configured to:\" + userRolesCacheEnabledString);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tif (log.isDebugEnabled()) {\n-\t\t\t\tlog.info(\"User Roles Cache is not configured. Default value: \"\n-\t\t\t\t\t\t+ userRolesCacheEnabled + \" is taken.\");\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (userRolesCacheEnabled) {\n-            int timeOut = UserCoreConstants.USER_ROLE_CACHE_DEFAULT_TIME_OUT;\n-            String timeOutString = realmConfig.\n-                getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_USER_ROLE_CACHE_TIME_OUT);\n-            if(timeOutString != null){\n-                timeOut = Integer.parseInt(timeOutString);\n-            }\n-\t\t\tuserRolesCache = UserRolesCache.getInstance();\n-            userRolesCache.setTimeOut(timeOut);\n-\t\t}\n-\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param regularExpression\n-\t * @param attribute\n-\t * @return\n-\t */\n-\tprivate boolean isFormatCorrect(String regularExpression, String attribute) {\n-\t\tPattern p2 = Pattern.compile(regularExpression);\n-\t\tMatcher m2 = p2.matcher(attribute);\n-\t\treturn m2.matches();\n-\t}\n-\n-\t/**\n-\t * This is to replace escape characters in user name at user login if replace escape characters\n-\t * enabled in user-mgt.xml. Some User Stores like ApacheDS stores user names by replacing escape\n-\t * characters. In that case, we have to parse the username accordingly.\n-\t * \n-\t * @param userName\n-\t */\n-\tprotected String replaceEscapeCharacters(String userName) {\n-\t\t\n-\t\tif(log.isDebugEnabled()) {\n-\t\t\tlog.debug(\"Replacing excape characters in \" + userName);\n-\t\t}\n-\t\tString replaceEscapeCharactersAtUserLoginString = realmConfig\n-\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_REPLACE_ESCAPE_CHARACTERS_AT_USER_LOGIN);\n-\n-\t\tif (replaceEscapeCharactersAtUserLoginString != null) {\n-\t\t\treplaceEscapeCharactersAtUserLogin = Boolean\n-\t\t\t\t\t.parseBoolean(replaceEscapeCharactersAtUserLoginString);\n-\t\t\tif (log.isDebugEnabled()) {\n-\t\t\t\tlog.debug(\"Replace escape characters at userlogin is condifured to: \"\n-\t\t\t\t\t\t+ replaceEscapeCharactersAtUserLoginString);\n-\t\t\t}\n-\t\t\tif (replaceEscapeCharactersAtUserLogin) {\n-\t\t\t\t// Currently only '\\' & '\\\\' are identified as escape characters\n-\t\t\t\t// that needs to be\n-\t\t\t\t// replaced.\n-\t\t\t\treturn userName.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\");\n-\t\t\t}\n-\t\t}\n-\t\treturn userName;\n-\t}\n-\n-\t/**\n-\t * TODO: Remove this method. We should not use DTOs\n-\t * \n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tpublic RoleDTO[] getAllSecondaryRoleDTOs() throws UserStoreException {\n-\t\tUserStoreManager secondary = this.getSecondaryUserStoreManager();\n-\t\tList<RoleDTO> roleList = new ArrayList<RoleDTO>();\n-\t\twhile (secondary != null) {\n-\t\t\tString domain = secondary.getRealmConfiguration().getUserStoreProperty(\n-\t\t\t\t\tUserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\t\t\tString[] roles = secondary.getRoleNames(true);\n-\t\t\tif (roles != null && roles.length > 0) {\n-\t\t\t\tCollections.addAll(roleList, UserCoreUtil.convertRoleNamesToRoleDTO(roles, domain));\n-\t\t\t}\n-\t\t\tsecondary = secondary.getSecondaryUserStoreManager();\n-\t\t}\n-\t\treturn roleList.toArray(new RoleDTO[roleList.size()]);\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param roleName\n-\t * @param userList\n-\t * @param permissions\n-\t * @throws UserStoreException\n-\t */\n-\tpublic void addSystemRole(String roleName, String[] userList, Permission[] permissions)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tif (!isRoleNameValid(roleName)) {\n-\t\t\tString regEx = realmConfig\n-\t\t\t\t\t.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_ROLE_NAME_JAVA_REG_EX);\n-\t\t\tthrow new UserStoreException(\n-\t\t\t\t\t\"Role name not valid. Role name must be a non null string with following format, \"\n-\t\t\t\t\t\t\t+ regEx);\n-\t\t}\n-\n-\t\tif (systemUserRoleManager.isExistingRole(roleName)) {\n-\t\t\tthrow new UserStoreException(\"Role name: \" + roleName\n-\t\t\t\t\t+ \" in the system. Please pick another role name.\");\n-\t\t}\n-\t\tsystemUserRoleManager.addSystemRole(roleName, userList);\n-\t}\n-\n-\n-\t/**\n-\t * \n-\t * \n-\t * @param roleName\n-\t * @param filter\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected abstract String[] doGetUserListOfRole(String roleName, String filter)\n-\t\t\tthrows UserStoreException;\n-\n-\t/**\n-\t * \n-\t * \n-\t * @param userName\n-\t * @param filter\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tpublic final String[] doGetRoleListOfUser(String userName, String filter)\n-\t\t\tthrows UserStoreException {\n-\n-\t\tString[] roleList;\n-\n-\t\tString[] internalRoles = doGetInternalRoleListOfUser(userName, filter);\n-\n-\t\tString[] modifiedExternalRoleList = new String[0];\n-\n-\t\tif (readGroupsEnabled) {\n-\t\t\tList<String> roles = new ArrayList<String>();\n-\t\t\tString[] externalRoles = doGetExternalRoleListOfUser(userName, \"*\");\n-\t\t\troles.addAll(Arrays.asList(externalRoles));\n-            if(isSharedGroupEnabled()){\n-                String[] sharedRoles = doGetSharedRoleListOfUser(userName, null, \"*\");\n-                if (sharedRoles != null) {\n-                    roles.addAll(Arrays.asList(sharedRoles));\n-                }\n-            }\n-\t\t\tmodifiedExternalRoleList =\n-\t\t\t                           UserCoreUtil.addDomainToNames(roles.toArray(new String[roles.size()]),\n-\t\t\t                                                         getMyDomainName());\n-\t\t}\n-\n-\t\troleList = UserCoreUtil.combine(internalRoles, Arrays.asList(modifiedExternalRoleList));\n-\n-\t\treturn roleList;\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param filter\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tpublic final String[] getHybridRoles(String filter) throws UserStoreException {\n-\t\treturn hybridRoleManager.getHybridRoles(filter);\n-\t}\n-\n-\t/**\n-\t * \n-\t * @param claimList\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tprotected List<String> getMappingAttributeList(List<String> claimList)\n-\t\t\tthrows UserStoreException {\n-\t\tArrayList<String> attributeList = null;\n-\t\tIterator<String> claimIter = null;\n-\n-\t\tattributeList = new ArrayList<String>();\n-\t\tif (claimList == null) {\n-\t\t\treturn attributeList;\n-\t\t}\n-\t\tclaimIter = claimList.iterator();\n-\t\twhile (claimIter.hasNext()) {\n-\t\t\ttry {\n-\t\t\t\tattributeList.add(claimManager.getAttributeName(claimIter.next()));\n-\t\t\t} catch (org.wso2.carbon.user.api.UserStoreException e) {\n-\t\t\t\tthrow new UserStoreException(e);\n-\t\t\t}\n-\t\t}\n-\t\treturn attributeList;\n-\t}\n-\n-    protected  void doInitialSetup() throws UserStoreException {\n-        systemUserRoleManager = new SystemUserRoleManager(dataSource, tenantId);\n-        hybridRoleManager = new HybridRoleManager(dataSource, tenantId, realmConfig, userRealm);\n-    }\n-    /**\n-     *\n-     * @throws UserStoreException\n-     * @return whether this is the initial startup\n-     */\n-    protected void doInitialUserAdding() throws UserStoreException {\n-\n-        String systemUser = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME);\n-        String systemRole = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME);\n-\n-        if (!systemUserRoleManager.isExistingSystemUser(systemUser)) {\n-            systemUserRoleManager.addSystemUser(systemUser,\n-                    UserCoreUtil.getPolicyFriendlyRandomPassword(systemUser), null);\n-        }\n-\n-        if (!systemUserRoleManager.isExistingRole(systemRole)) {\n-            systemUserRoleManager.addSystemRole(systemRole, new String[]{systemUser});\n-        }\n-\n-        if (!hybridRoleManager.isExistingRole(UserCoreUtil.removeDomainFromName(realmConfig\n-                .getEveryOneRoleName()))) {\n-            hybridRoleManager.addHybridRole(\n-                    UserCoreUtil.removeDomainFromName(realmConfig.getEveryOneRoleName()), null);\n-        }\n-    }\n-\n-\n-\n-\n-    protected boolean isInitSetupDone() throws UserStoreException {\n-\n-        boolean isInitialSetUp = false;\n-        String systemUser = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_USERNAME);\n-        String systemRole = UserCoreUtil.removeDomainFromName(CarbonConstants.REGISTRY_ANONNYMOUS_ROLE_NAME);\n-\n-        if (systemUserRoleManager.isExistingSystemUser(systemUser)) {\n-            isInitialSetUp = true;\n-        }\n-\n-        if (systemUserRoleManager.isExistingRole(systemRole)) {\n-            isInitialSetUp = true;\n-        }\n-\n-        return isInitialSetUp;\n-    }\n-\n-    /**\n-     *\n-     * @throws UserStoreException\n-     */\n-    protected void addInitialAdminData(boolean addAdmin, boolean initialSetup) throws UserStoreException {\n-\n-        if (realmConfig.getAdminRoleName() == null || realmConfig.getAdminUserName() == null) {\n-            log.error(\"Admin user name or role name is not valid. Please provide valid values.\");\n-            throw new UserStoreException(\n-                    \"Admin user name or role name is not valid. Please provide valid values.\");\n-        }\n-        String adminUserName = UserCoreUtil.removeDomainFromName(realmConfig.getAdminUserName());\n-        String adminRoleName = UserCoreUtil.removeDomainFromName(realmConfig.getAdminRoleName());\n-        boolean userExist = false;\n-        boolean roleExist = false;\n-        boolean isInternalRole = false;\n-\n-        try{\n-        \tif(Boolean.parseBoolean(this.getRealmConfiguration().getUserStoreProperty(\n-        \t\t\tUserCoreConstants.RealmConfig.READ_GROUPS_ENABLED))){\n-            \troleExist = doCheckExistingRole(adminRoleName);\n-        \t}\n-        } catch (Exception e){\n-            //ignore\n-        }\n-\n-        if(!roleExist){\n-            try{\n-                roleExist = hybridRoleManager.isExistingRole(adminRoleName);\n-            } catch (Exception e){\n-                //ignore\n-            }\n-            if(roleExist){\n-                isInternalRole = true;\n-            }\n-        }\n-\n-        try{\n-            userExist = doCheckExistingUser(adminUserName);\n-        } catch (Exception e){\n-            //ignore\n-        }\n-\n-        if (!userExist) {\n-            if (isReadOnly()) {\n-                String message = \"Admin user can not be created in primary user store. \" +\n-                        \"User store is read only. \" +\n-                        \"Please pick a user name which is exist in the primary user store as Admin user\";\n-                if(initialSetup){\n-                    throw new UserStoreException(message);\n-                } else if(log.isDebugEnabled()){\n-                    log.error(message);\n-                }\n-            } else if(addAdmin){\n-                try {\n-                    this.doAddUser(adminUserName, realmConfig.getAdminPassword(),\n-                            null, null, null, false);\n-                } catch (Exception e){\n-                    String message = \"Admin user has not been created. \" +\n-                            \"Error occurs while creating Admin user in primary user store.\" ;\n-                    if(initialSetup){\n-                        throw new UserStoreException(message, e);\n-                    } else if(log.isDebugEnabled()){\n-                        log.error(message, e);\n-                    }\n-                }\n-            } else {\n-                if(initialSetup){\n-                    String message = \"Admin user can not be created in primary user store. \" +\n-                            \"Add-Admin has been set to false. \" +\n-                            \"Please pick a User name which is exist in the primary user store as Admin user\";\n-                    if(initialSetup){\n-                        throw new UserStoreException(message);\n-                    } else if(log.isDebugEnabled()){\n-                        log.error(message);\n-                    }\n-                }\n-            }\n-        }\n-        \n-\n-        if (!roleExist) {\n-            if(addAdmin){\n-                if(!isReadOnly() && writeGroupsEnabled){\n-                    try {\n-                        this.doAddRole(adminRoleName, new String[]{adminUserName}, false);\n-                    } catch (org.wso2.carbon.user.api.UserStoreException e) {\n-                        String message = \"Admin role has not been created. \" +\n-                                \"Error occurs while creating Admin role in primary user store.\" ;\n-                        if(initialSetup){\n-                            throw new UserStoreException(message, e);\n-                        } else if(log.isDebugEnabled()){\n-                            log.error(message, e);\n-                        }\n-                    }\n-                } else {\n-                    // creates internal role\n-                    try{\n-                        hybridRoleManager.addHybridRole(adminRoleName, new String[]{adminUserName});\n-                        isInternalRole = true;\n-                    } catch (Exception e){\n-                        String message = \"Admin role has not been created. \" +\n-                                \"Error occurs while creating Admin role in primary user store.\";\n-                        if(initialSetup){\n-                            throw new UserStoreException(message, e);\n-                        } else if(log.isDebugEnabled()){\n-                            log.error(message, e);\n-                        }\n-                    }\n-                }\n-            } else {\n-                String message = \"Admin role can not be created in primary user store. \" +\n-                        \"Add-Admin has been set to false. \" +\n-                        \"Please pick a Role name which is exist in the primary user store as Admin Role\";\n-                if(initialSetup){\n-                    throw new UserStoreException(message);\n-                } else if(log.isDebugEnabled()){\n-                    log.error(message);\n-                }\n-            }\n-        }\n-\n-\n-        if(isInternalRole){\n-            if(!hybridRoleManager.isUserInRole(adminUserName, adminRoleName)){\n-                try{\n-                    hybridRoleManager.updateHybridRoleListOfUser(adminUserName, null,\n-                            new String[] { adminRoleName });\n-                } catch (Exception e){\n-                    String message = \"Admin user has not been assigned to Admin role. \" +\n-                            \"Error while assignment is done\";\n-                    if(initialSetup){\n-                        throw new UserStoreException(message, e);\n-                    } else if(log.isDebugEnabled()){\n-                        log.error(message, e);\n-                    }\n-                }\n-            }\n-            realmConfig.setAdminRoleName(UserCoreUtil.addInternalDomainName(adminRoleName));\n-        } else if(!isReadOnly() && writeGroupsEnabled){\n-            if(!this.doCheckIsUserInRole(adminUserName, adminRoleName)){\n-                if(addAdmin){\n-                    try {\n-                        this.doUpdateRoleListOfUser(adminUserName, null,\n-                                new String[] { adminRoleName });\n-                    } catch (Exception e){\n-                        String message = \"Admin user has not been assigned to Admin role. \" +\n-                                \"Error while assignment is done\";\n-                        if(initialSetup){\n-                            throw new UserStoreException(message, e);\n-                        } else if(log.isDebugEnabled()){\n-                            log.error(message, e);\n-                        }\n-                    }\n-                } else {\n-                    String message = \"Admin user can not be assigned to Admin role \" +\n-                            \"Add-Admin has been set to false. Please do the assign it in user store level\";\n-                    if(initialSetup){\n-                        throw new UserStoreException(message);\n-                    } else if(log.isDebugEnabled()){\n-                        log.error(message);\n-                    }\n-                }\n-            }\n-        }\n-\n-        doInitialUserAdding();\n-    }\n-\t/**\n-\t * \n-\t * @param type\n-\t * @return\n-\t * @throws UserStoreException\n-\t */\n-\tpublic Map<String, Integer> getMaxListCount(String type) throws UserStoreException {\n-\n-\t\tif (!type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)\n-\t\t\t\t&& !type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)) {\n-\t\t\tthrow new UserStoreException(\"Invalid count parameter\");\n-\t\t}\n-\n-\t\tif (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)\n-\t\t\t\t&& maxUserListCount != null) {\n-\t\t\treturn maxUserListCount;\n-\t\t}\n-\n-\t\tif (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)\n-\t\t\t\t&& maxRoleListCount != null) {\n-\t\t\treturn maxRoleListCount;\n-\t\t}\n-\n-\t\tMap<String, Integer> maxListCount = new HashMap<String, Integer>();\n-\t\tfor (Map.Entry<String, UserStoreManager> entry : userStoreManagerHolder.entrySet()) {\n-\t\t\tUserStoreManager storeManager = entry.getValue();\n-\t\t\tif (storeManager instanceof AbstractUserStoreManager) {\n-\t\t\t\tString maxConfig = storeManager.getRealmConfiguration().getUserStoreProperty(type);\n-\t\t\t\tif (maxConfig == null) {\n-\t\t\t\t\t// set a default value\n-\t\t\t\t\tmaxConfig = MAX_LIST_LENGTH;\n-\t\t\t\t}\n-\t\t\t\tmaxListCount.put(entry.getKey(), Integer.parseInt(maxConfig));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME) == null) {\n-\t\t\tString maxConfig = realmConfig.getUserStoreProperty(type);\n-\t\t\tif (maxConfig == null) {\n-\t\t\t\t// set a default value\n-\t\t\t\tmaxConfig = MAX_LIST_LENGTH;\n-\t\t\t}\n-\t\t\tmaxListCount.put(null, Integer.parseInt(maxConfig));\n-\t\t}\n-\n-\t\tif (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_USER_LIST)) {\n-\t\t\tthis.maxUserListCount = maxListCount;\n-\t\t\treturn this.maxUserListCount;\n-\t\t} else if (type.equals(UserCoreConstants.RealmConfig.PROPERTY_MAX_ROLE_LIST)) {\n-\t\t\tthis.maxRoleListCount = maxListCount;\n-\t\t\treturn this.maxRoleListCount;\n-\t\t} else {\n-\t\t\tthrow new UserStoreException(\"Invalid count parameter\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * \n-\t * @return\n-\t */\n-\tprotected String getMyDomainName() {\n-\t\treturn UserCoreUtil.getDomainName(realmConfig);\n-\t}\n-\n-    protected void persistDomain() throws UserStoreException {\n-        String domain = UserCoreUtil.getDomainName(this.realmConfig);\n-        if (domain != null) {\n-            UserCoreUtil.persistDomain(domain, this.tenantId, this.dataSource);\n-        }\n-    }\n-\n-    public void deletePersistedDomain(String domain) throws UserStoreException {\n-        if (domain != null) {\n-        \tif(log.isDebugEnabled()) {\n-        \t\tlog.debug(\"Deleting persisted domain \" + domain);\n-        \t}\n-            UserCoreUtil.deletePersistedDomain(domain, this.tenantId, this.dataSource);\n-        }\n-    }\n-    \n-    public void updatePersistedDomain(String oldDomain, String newDomain) throws UserStoreException {\n-        if (oldDomain != null && newDomain != null) {\n-        \t// Checks for the newDomain exists already\n-        \t// Traverse through realm configuration chain since USM chain doesn't contains the disabled USMs\n-        \tRealmConfiguration realmConfigTmp = this.getRealmConfiguration();\n-        \twhile (realmConfigTmp != null) {\n-        \t\tString domainName = realmConfigTmp.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-        \t\tif (newDomain.equalsIgnoreCase(domainName)) {\n-        \t\t\tthrow new UserStoreException(\"Cannot update persisted domain name \"+oldDomain+\" into \"+newDomain+\". New domain name already in use\");\n-        \t\t}\n-        \t\trealmConfigTmp = realmConfigTmp.getSecondaryRealmConfig();\n-        \t}\n-        \t\n-        \tif(log.isDebugEnabled()) {\n-        \t\tlog.debug(\"Renaming persisted domain \" + oldDomain + \" to \" + newDomain);\n-        \t}\n-            UserCoreUtil.updatePersistedDomain(oldDomain, newDomain, this.tenantId, this.dataSource);\n-        }\n-    }\n-\n-\t/**\n-\t * Checks whether the role is a shared role or not\n-\t * \n-\t * @param roleName\n-\t * @param roleNameBase\n-\t * @return\n-\t */\n-\tpublic boolean isSharedRole(String roleName, String roleNameBase) {\n-\n-\t\t// Only checks the shared groups are enabled\n-\t\treturn isSharedGroupEnabled();\n-\t}\t\n-\t\n-\t/**\n-\t * Checks whether the provided role name belongs to the logged in tenant.\n-\t * This check is done using the domain name which is appended at the end of\n-\t * the role name\n-\t * \n-\t * @param roleName\n-\t * @return\n-\t */\n-\tprotected boolean isOwnRole(String roleName) {\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-    public void addRole(String roleName, String[] userList,\n-                        org.wso2.carbon.user.api.Permission[] permissions)\n-                                              throws org.wso2.carbon.user.api.UserStoreException {\n-\t\taddRole(roleName, userList, permissions, false);\n-\t    \n-    }\n-\n-    public boolean isOthersSharedRole(String roleName) {\n-\t    return false;\n-    }\n-    public void notifyListeners(String domainName) {\n-        for (UserStoreManagerConfigurationListener aListener : listener) {\n-            aListener.propertyChange(domainName);\n-        }\n-    }\n-\n-    public void addChangeListener(UserStoreManagerConfigurationListener newListener) {\n-        listener.add(newListener);\n-    }\n-\n-    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-    private UserStoreManager createSecondaryUserStoreManager(RealmConfiguration realmConfig,\n-                                                    UserRealm realm) throws UserStoreException {\n-\n-        // setting global realm configurations such as everyone role, admin role and admin user\n-        realmConfig.setEveryOneRoleName(this.realmConfig.getEveryOneRoleName());\n-        realmConfig.setAdminUserName(this.realmConfig.getAdminUserName());\n-        realmConfig.setAdminRoleName(this.realmConfig.getAdminRoleName());\n-\n-        String className = realmConfig.getUserStoreClass();\n-        if (className == null) {\n-            String errmsg = \"Unable to add user store. UserStoreManager class name is null.\";\n-            log.error(errmsg);\n-            throw new UserStoreException(errmsg);\n-        }\n-\n-        HashMap<String, Object> properties = new HashMap<String, Object>();\n-        properties.put(UserCoreConstants.DATA_SOURCE, this.dataSource);\n-        properties.put(UserCoreConstants.FIRST_STARTUP_CHECK, false);\n-        \n-        Class[] initClassOpt1 = new Class[]{RealmConfiguration.class, Map.class,\n-                ClaimManager.class, ProfileConfigurationManager.class, UserRealm.class,\n-                Integer.class};\n-        Object[] initObjOpt1 = new Object[]{realmConfig, properties, realm.getClaimManager(), null, realm,\n-                tenantId};\n-\n-\t// These two methods won't be used\n-        Class[] initClassOpt2 = new Class[]{RealmConfiguration.class, Map.class,\n-                ClaimManager.class, ProfileConfigurationManager.class, UserRealm.class};\n-        Object[] initObjOpt2 = new Object[]{realmConfig, properties, realm.getClaimManager(), null, realm};\n-\n-        Class[] initClassOpt3 = new Class[]{RealmConfiguration.class, Map.class};\n-        Object[] initObjOpt3 = new Object[]{realmConfig, properties};\n-\n-        try {\n-            Class clazz = Class.forName(className);\n-            Constructor constructor = null;\n-            Object newObject = null;\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"Start initializing class with the first option\");\n-            }\n-\n-            try {\n-                constructor = clazz.getConstructor(initClassOpt1);\n-                newObject = constructor.newInstance(initObjOpt1);\n-                return (UserStoreManager) newObject;\n-            } catch (NoSuchMethodException e) {\n-\t\t// if not found try again.\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Cannont initialize \" + className + \" using the option 1\");\n-                }\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"End initializing class with the first option\");\n-            }\n-\n-            try {\n-                constructor = clazz.getConstructor(initClassOpt2);\n-                newObject = constructor.newInstance(initObjOpt2);\n-                return (UserStoreManager) newObject;\n-            } catch (NoSuchMethodException e) {\n-\t\t// if not found try again.\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Cannont initialize \" + className + \" using the option 2\");\n-                }\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"End initializing class with the second option\");\n-            }\n-\n-            try {\n-                constructor = clazz.getConstructor(initClassOpt3);\n-                newObject = constructor.newInstance(initObjOpt3);\n-                return (UserStoreManager) newObject;\n-            } catch (NoSuchMethodException e) {\n-\t\t// cannot initialize in any of the methods. Throw exception.\n-                String message = \"Cannot initialize \" + className + \". Error \" + e.getMessage();\n-                log.error(message);\n-                throw new UserStoreException(message);\n-            }\n-\n-        } catch (Throwable e) {\n-            log.error(\"Cannot create \" + className, e);\n-            throw new UserStoreException(e.getMessage() + \"Type \" + e.getClass(), e);\n-        }\n-\n-    }\n-\n-    /**\n-     * Adding new User Store Manager to USM chain\n-     * \n-     * @param userStoreRealmConfig\n-     * @param realm \n-     * @throws UserStoreException\n-     */\n-    public void addSecondaryUserStoreManager(RealmConfiguration userStoreRealmConfig,\n-                                                    UserRealm realm) throws UserStoreException {\n-    \t// Creating new UserStoreManager\n-        UserStoreManager manager = createSecondaryUserStoreManager(userStoreRealmConfig, realm);\n-\n-        String domainName = userStoreRealmConfig\n-                .getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME);\n-\n-        if (domainName != null) {\n-            if (this.getSecondaryUserStoreManager(domainName) != null) {\n-                String errmsg = \"Could not initialize new user store manager : \"+domainName\n-                        + \" Duplicate domain names not allowed.\";\n-                if(log.isDebugEnabled()) {\n-                \tlog.debug(errmsg);\n-                }\n-                throw new UserStoreException(errmsg);\n-            } else {\n-            \tBoolean isDisabled = false;\n-                if (userStoreRealmConfig\n-                        .getUserStoreProperty(UserCoreConstants.RealmConfig.USER_STORE_DISABLED) != null) {\n-                    isDisabled = Boolean\n-                            .parseBoolean(userStoreRealmConfig\n-                                    .getUserStoreProperty(UserCoreConstants.RealmConfig.USER_STORE_DISABLED));\n-                    if (isDisabled) {\n-                        log.warn(\"Secondary user store disabled with domain \"\n-                                + domainName + \".\");\n-                    }\n-                    else {\n-                    \t// Fulfilled requirements for adding UserStore,\n-                    \t\n-                    \t// Now adding UserStoreManager to end of the UserStoreManager chain\n-                        UserStoreManager tmpUserStoreManager = this;\n-                        while (tmpUserStoreManager.getSecondaryUserStoreManager() != null) {\n-                            tmpUserStoreManager = tmpUserStoreManager\n-                                    .getSecondaryUserStoreManager();\n-                        }\n-                        tmpUserStoreManager.setSecondaryUserStoreManager(manager);\n-\n-                        // update domainName-USM map to retrieve USM directly by its domain name\n-                        this.addSecondaryUserStoreManager(domainName.toUpperCase(),\n-                                tmpUserStoreManager.getSecondaryUserStoreManager());\n-\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\"UserStoreManager : \" + domainName\n-                                    + \"added to the list\");\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            log.warn(\"Could not initialize new user store manager.  \"\n-                    + \"Domain name is not defined\");\n-        }\n-    }\n-\n-    /**\n-     * Remove given User Store Manager from USM chain\n-     * \n-     * @param userStoreDomainName\n-     * @throws UserStoreException\n-     */\n-    public void removeSecondaryUserStoreManager(String userStoreDomainName) throws UserStoreException {\n-    \t\n-    \tif(userStoreDomainName == null) {\n-    \t\tthrow new UserStoreException(\"Cannot remove user store. User store domain name is null\");\n-    \t}\n-    \tif(\"\".equals(userStoreDomainName)) {\n-    \t\tthrow new UserStoreException(\"Cannot remove user store. User store domain name is empty\");\n-    \t}  \n-//    \tif(!this.userStoreManagerHolder.containsKey(userStoreDomainName.toUpperCase())) {\n-//    \t\tthrow new UserStoreException(\"Cannot remove user store. User store domain name does not exists\");\n-//    \t}\n-    \t\n-    \tuserStoreDomainName = userStoreDomainName.toUpperCase();\n-    \t\n-    \tboolean isUSMContainsInMap = false;\n-    \tif(this.userStoreManagerHolder.containsKey(userStoreDomainName.toUpperCase())) {\n-    \t\tisUSMContainsInMap = true;\n-        \tthis.userStoreManagerHolder.remove(userStoreDomainName.toUpperCase());\n-        \tif (log.isDebugEnabled()) {\n-                log.debug(\"UserStore: \" + userStoreDomainName+ \" removed from map\");\n-            }\n-    \t}\n-    \t\n-    \tboolean isUSMConatainsInChain = false;\n-        UserStoreManager prevUserStoreManager = this;\n-        while (prevUserStoreManager.getSecondaryUserStoreManager() != null) {\n-            UserStoreManager secondaryUSM =  prevUserStoreManager.getSecondaryUserStoreManager();\n-            if (secondaryUSM.getRealmConfiguration().getUserStoreProperty(UserStoreConfigConstants.DOMAIN_NAME).equalsIgnoreCase(userStoreDomainName)) {\n-            \tisUSMConatainsInChain = true;\n-            \t// Omit deleting user store manager from the chain\n-            \tprevUserStoreManager.setSecondaryUserStoreManager(secondaryUSM.getSecondaryUserStoreManager());\n-                log.info(\"User store: \" + userStoreDomainName + \" of tenant:\" + tenantId + \" is removed from user store chain.\");\n-                return;\n-            }\n-            prevUserStoreManager = secondaryUSM;\n-        }\n-        \n-\t    if(!isUSMContainsInMap && isUSMConatainsInChain ) {\n-\t       \tthrow new UserStoreException(\"Removed user store manager : \"+userStoreDomainName+\" didnt exists in userStoreManagerHolder map\");\n-\t    }\n-        else if(isUSMContainsInMap && !isUSMConatainsInChain) {\n-        \tthrow new UserStoreException(\"Removed user store manager : \"+userStoreDomainName+\" didnt exists in user store manager chain\");\n-        }\n-    }\n-\n-    public HybridRoleManager getInternalRoleManager() {\n-        return hybridRoleManager;\n-    }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "518b7af0f2f3740d640e87b712d71a2a8dd54fa9", "message": "Merge commit", "committedDate": null}, {"oid": "224cc38bdaf5d709293e8a85116585ef69ee6745", "committedDate": "2013-11-29 15:48:16 +0530", "message": "adding initial source of c5 carbon kernel consiting of carbon deployment engine, server runtime, logging framework and base component"}, {"oid": "b47d5aa1581355733e4284fb19ed82bec7dd7b5f", "committedDate": "2013-12-11 16:36:05 +0530", "message": "rename core to modules"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNjgxMg==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463906812", "body": "Can we check for `StringUtils.isBlank`?", "bodyText": "Can we check for StringUtils.isBlank?", "bodyHTML": "<p dir=\"auto\">Can we check for <code>StringUtils.isBlank</code>?</p>", "author": "somindatommy", "createdAt": "2020-08-01T02:02:35Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -667,6 +713,45 @@ public void doSetUserClaimValues(String userName, Map<String, String> claims,\n         doSetUserAttributes(userName, claimAttributeValueMapForPersist, profileName);\n     }\n \n+    /**\n+     * Set many user claim values by treating multi-valued claims independently from simple claims.\n+     *\n+     * @param userName                         User's username.\n+     * @param multiValuedClaimsToAdd           Map of multi-valued claim URIs against values to be added.\n+     * @param multiValuedClaimsToDelete        Map of multi-valued claim URIs against values to be deleted.\n+     * @param claimsExcludingMultiValuedClaims Map of claim URIs excluding multi-valued claims against values\n+     *                                         to be modified.\n+     * @param profileName                      The profile name, can be null. If null the default profile is considered.\n+     * @throws UserStoreException      An unexpected exception has occurred.\n+     * @throws NotImplementedException Functionality is not implemented exception.\n+     */\n+    protected void doSetUserClaimValues(String userName, Map<String, List<String>> multiValuedClaimsToAdd,\n+                                        Map<String, List<String>> multiValuedClaimsToDelete,\n+                                        Map<String, List<String>> claimsExcludingMultiValuedClaims,\n+                                        String profileName)\n+            throws UserStoreException, NotImplementedException {\n+\n+        if (profileName == null) {", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjY0Nw==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499736647", "bodyText": "addressed in fb430db", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:48:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNjgxMg=="}], "type": "inlineReview", "revised_code": {"commit": "3f2294363dedc5b782da00e295e7e75f500b9646", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 86f03821a..a6ee9fe4d 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -731,7 +735,7 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n                                         String profileName)\n             throws UserStoreException, NotImplementedException {\n \n-        if (profileName == null) {\n+        if (StringUtils.isBlank(profileName)) {\n             profileName = UserCoreConstants.DEFAULT_PROFILE;\n         }\n \n", "next_change": {"commit": "fcde39da236f7f4061e3b5644117c3d04f8adba7", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex a6ee9fe4d..12258ffc6 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -735,7 +735,7 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n                                         String profileName)\n             throws UserStoreException, NotImplementedException {\n \n-        if (StringUtils.isBlank(profileName)) {\n+        if (profileName == null) {\n             profileName = UserCoreConstants.DEFAULT_PROFILE;\n         }\n \n", "next_change": {"commit": "fc932b05f8215d6d5fc6bfe0ca30902a75f64eb1", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 12258ffc6..a6ee9fe4d 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -735,7 +735,7 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n                                         String profileName)\n             throws UserStoreException, NotImplementedException {\n \n-        if (profileName == null) {\n+        if (StringUtils.isBlank(profileName)) {\n             profileName = UserCoreConstants.DEFAULT_PROFILE;\n         }\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNzA3Mg==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463907072", "body": "Shall we remove these extra new lines?", "bodyText": "Shall we remove these extra new lines?", "bodyHTML": "<p dir=\"auto\">Shall we remove these extra new lines?</p>", "author": "somindatommy", "createdAt": "2020-08-01T02:05:19Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -698,6 +783,30 @@ public void doSetUserClaimValues(String userName, Map<String, String> claims,\n         return userStoreAttributeValueMap;\n     }\n \n+    private Map<String, List<String>> resolveUserStoreAttributeValueMaps(String userIdentifier,\n+                                                                         Map<String, List<String>> claims)\n+            throws UserStoreException {\n+\n+        Map<String, List<String>> userStoreAttributeValueMap = new HashMap<>();\n+\n+        try {\n+            for (Map.Entry<String, List<String>> claimEntry : claims.entrySet()) {\n+                String claimURI = claimEntry.getKey();\n+                String attributeName = getClaimAtrribute(claimURI, userIdentifier, null);\n+                userStoreAttributeValueMap.put(attributeName, claimEntry.getValue());\n+            }\n+        } catch (org.wso2.carbon.user.api.UserStoreException e) {\n+            String errorMessage = \"Error occurred while getting claim attribute for user : \" + userIdentifier;\n+", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjU4NA==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499736584", "bodyText": "addressed in fb430db", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNzA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3f2294363dedc5b782da00e295e7e75f500b9646", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 86f03821a..a6ee9fe4d 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -797,11 +800,9 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n             }\n         } catch (org.wso2.carbon.user.api.UserStoreException e) {\n             String errorMessage = \"Error occurred while getting claim attribute for user : \" + userIdentifier;\n-\n             if (log.isDebugEnabled()) {\n                 log.debug(errorMessage, e);\n             }\n-\n             throw new UserStoreException(errorMessage, e);\n         }\n         return userStoreAttributeValueMap;\n", "next_change": {"commit": "fcde39da236f7f4061e3b5644117c3d04f8adba7", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex a6ee9fe4d..12258ffc6 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -800,9 +801,11 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n             }\n         } catch (org.wso2.carbon.user.api.UserStoreException e) {\n             String errorMessage = \"Error occurred while getting claim attribute for user : \" + userIdentifier;\n+\n             if (log.isDebugEnabled()) {\n                 log.debug(errorMessage, e);\n             }\n+\n             throw new UserStoreException(errorMessage, e);\n         }\n         return userStoreAttributeValueMap;\n", "next_change": {"commit": "fc932b05f8215d6d5fc6bfe0ca30902a75f64eb1", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 12258ffc6..a6ee9fe4d 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -801,11 +800,9 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n             }\n         } catch (org.wso2.carbon.user.api.UserStoreException e) {\n             String errorMessage = \"Error occurred while getting claim attribute for user : \" + userIdentifier;\n-\n             if (log.isDebugEnabled()) {\n                 log.debug(errorMessage, e);\n             }\n-\n             throw new UserStoreException(errorMessage, e);\n         }\n         return userStoreAttributeValueMap;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNzM5OQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463907399", "body": "Shall we remove this new line since its related to the of condition?", "bodyText": "Shall we remove this new line since its related to the of condition?", "bodyHTML": "<p dir=\"auto\">Shall we remove this new line since its related to the of condition?</p>", "author": "somindatommy", "createdAt": "2020-08-01T02:09:28Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -12417,6 +12561,101 @@ public final void setUserClaimValuesWithID(String userID, Map<String, String> cl\n \n     }\n \n+    @Override\n+    public final void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n+                                               Map<String, List<String>> multiValuedClaimsToAdd,\n+                                               Map<String, List<String>> multiValuedClaimsToDelete,\n+                                               Map<String, List<String>> claimsExcludingMultiValuedClaims,\n+                                               String profileName) throws UserStoreException {\n+\n+        UserStore userStore = getUserStoreWithID(userID);\n+        if (userStore.isRecurssive()) {\n+            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n+                    .setUserClaimValuesWithID(userStore.getDomainFreeUserId(), oldClaimMap, multiValuedClaimsToAdd,\n+                            multiValuedClaimsToDelete, claimsExcludingMultiValuedClaims, profileName);\n+            return;\n+        }\n+        Map<String, String> claims =\n+                getModifiedClaims(oldClaimMap, multiValuedClaimsToAdd, multiValuedClaimsToDelete,\n+                        claimsExcludingMultiValuedClaims);\n+\n+        // #################### Domain Name Free Zone Starts Here ################################\n+\n+        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n+        boolean isUserExists;\n+        if (isUniqueIdEnabled) {\n+            isUserExists = doCheckExistingUserWithID(userID);\n+        } else {\n+            String userNameFromUserID = doGetUserNameFromUserID(userID);\n+            isUserExists = userNameFromUserID != null;\n+        }\n+\n+        if (!isUserExists) {\n+            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n+                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n+            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n+            handleSetUserClaimValuesFailureWithID(errorCode, errorMessage, userID, claims, profileName);\n+            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n+        }\n+\n+        // #################### <Pre Listeners> #####################################################\n+        invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n+        // #################### </Pre Listeners> #####################################################\n+\n+        // If user store is readonly this method should not get invoked with non empty claim set.\n+", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjUzOQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499736539", "bodyText": "addressed in fb430db", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNzM5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "3f2294363dedc5b782da00e295e7e75f500b9646", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 86f03821a..a6ee9fe4d 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -12602,8 +12902,7 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n         invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n         // #################### </Pre Listeners> #####################################################\n \n-        // If user store is readonly this method should not get invoked with non empty claim set.\n-\n+        // If userstore is readonly this method should not get invoked with non empty claim set.\n         if (isReadOnly() && !claims.isEmpty()) {\n             handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n                     ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n", "next_change": {"commit": "fcde39da236f7f4061e3b5644117c3d04f8adba7", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex a6ee9fe4d..12258ffc6 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -12902,7 +12915,8 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n         invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n         // #################### </Pre Listeners> #####################################################\n \n-        // If userstore is readonly this method should not get invoked with non empty claim set.\n+        // If user store is readonly this method should not get invoked with non empty claim set.\n+\n         if (isReadOnly() && !claims.isEmpty()) {\n             handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n                     ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n", "next_change": {"commit": "fc932b05f8215d6d5fc6bfe0ca30902a75f64eb1", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 12258ffc6..a6ee9fe4d 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -12915,8 +12902,7 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n         invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n         // #################### </Pre Listeners> #####################################################\n \n-        // If user store is readonly this method should not get invoked with non empty claim set.\n-\n+        // If userstore is readonly this method should not get invoked with non empty claim set.\n         if (isReadOnly() && !claims.isEmpty()) {\n             handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n                     ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNzY2NQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463907665", "body": "Is this our existing logic? dont we have to check the userstore before we invoke the pre listeners?", "bodyText": "Is this our existing logic? dont we have to check the userstore before we invoke the pre listeners?", "bodyHTML": "<p dir=\"auto\">Is this our existing logic? dont we have to check the userstore before we invoke the pre listeners?</p>", "author": "somindatommy", "createdAt": "2020-08-01T02:11:46Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -12417,6 +12561,101 @@ public final void setUserClaimValuesWithID(String userID, Map<String, String> cl\n \n     }\n \n+    @Override\n+    public final void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n+                                               Map<String, List<String>> multiValuedClaimsToAdd,\n+                                               Map<String, List<String>> multiValuedClaimsToDelete,\n+                                               Map<String, List<String>> claimsExcludingMultiValuedClaims,\n+                                               String profileName) throws UserStoreException {\n+\n+        UserStore userStore = getUserStoreWithID(userID);\n+        if (userStore.isRecurssive()) {\n+            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n+                    .setUserClaimValuesWithID(userStore.getDomainFreeUserId(), oldClaimMap, multiValuedClaimsToAdd,\n+                            multiValuedClaimsToDelete, claimsExcludingMultiValuedClaims, profileName);\n+            return;\n+        }\n+        Map<String, String> claims =\n+                getModifiedClaims(oldClaimMap, multiValuedClaimsToAdd, multiValuedClaimsToDelete,\n+                        claimsExcludingMultiValuedClaims);\n+\n+        // #################### Domain Name Free Zone Starts Here ################################\n+\n+        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n+        boolean isUserExists;\n+        if (isUniqueIdEnabled) {\n+            isUserExists = doCheckExistingUserWithID(userID);\n+        } else {\n+            String userNameFromUserID = doGetUserNameFromUserID(userID);\n+            isUserExists = userNameFromUserID != null;\n+        }\n+\n+        if (!isUserExists) {\n+            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n+                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n+            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n+            handleSetUserClaimValuesFailureWithID(errorCode, errorMessage, userID, claims, profileName);\n+            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n+        }\n+\n+        // #################### <Pre Listeners> #####################################################\n+        invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n+        // #################### </Pre Listeners> #####################################################\n+\n+        // If user store is readonly this method should not get invoked with non empty claim set.\n+\n+        if (isReadOnly() && !claims.isEmpty()) {", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNjI1MA==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499726250", "bodyText": "yes, this is an existing logic.", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:30:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNzY2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3f2294363dedc5b782da00e295e7e75f500b9646", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 86f03821a..a6ee9fe4d 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -12602,8 +12902,7 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n         invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n         // #################### </Pre Listeners> #####################################################\n \n-        // If user store is readonly this method should not get invoked with non empty claim set.\n-\n+        // If userstore is readonly this method should not get invoked with non empty claim set.\n         if (isReadOnly() && !claims.isEmpty()) {\n             handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n                     ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n", "next_change": {"commit": "fcde39da236f7f4061e3b5644117c3d04f8adba7", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex a6ee9fe4d..12258ffc6 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -12902,7 +12915,8 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n         invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n         // #################### </Pre Listeners> #####################################################\n \n-        // If userstore is readonly this method should not get invoked with non empty claim set.\n+        // If user store is readonly this method should not get invoked with non empty claim set.\n+\n         if (isReadOnly() && !claims.isEmpty()) {\n             handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n                     ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n", "next_change": {"commit": "fc932b05f8215d6d5fc6bfe0ca30902a75f64eb1", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex 12258ffc6..a6ee9fe4d 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -12915,8 +12902,7 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n         invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n         // #################### </Pre Listeners> #####################################################\n \n-        // If user store is readonly this method should not get invoked with non empty claim set.\n-\n+        // If userstore is readonly this method should not get invoked with non empty claim set.\n         if (isReadOnly() && !claims.isEmpty()) {\n             handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n                     ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNzc2Ng==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463907766", "body": "Can we use MapUtils here?", "bodyText": "Can we use MapUtils here?", "bodyHTML": "<p dir=\"auto\">Can we use MapUtils here?</p>", "author": "somindatommy", "createdAt": "2020-08-01T02:13:18Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -12417,6 +12561,101 @@ public final void setUserClaimValuesWithID(String userID, Map<String, String> cl\n \n     }\n \n+    @Override\n+    public final void setUserClaimValuesWithID(String userID, Map<String, List<String>> oldClaimMap,\n+                                               Map<String, List<String>> multiValuedClaimsToAdd,\n+                                               Map<String, List<String>> multiValuedClaimsToDelete,\n+                                               Map<String, List<String>> claimsExcludingMultiValuedClaims,\n+                                               String profileName) throws UserStoreException {\n+\n+        UserStore userStore = getUserStoreWithID(userID);\n+        if (userStore.isRecurssive()) {\n+            ((AbstractUserStoreManager) userStore.getUserStoreManager())\n+                    .setUserClaimValuesWithID(userStore.getDomainFreeUserId(), oldClaimMap, multiValuedClaimsToAdd,\n+                            multiValuedClaimsToDelete, claimsExcludingMultiValuedClaims, profileName);\n+            return;\n+        }\n+        Map<String, String> claims =\n+                getModifiedClaims(oldClaimMap, multiValuedClaimsToAdd, multiValuedClaimsToDelete,\n+                        claimsExcludingMultiValuedClaims);\n+\n+        // #################### Domain Name Free Zone Starts Here ################################\n+\n+        boolean isUniqueIdEnabled = isUniqueUserIdEnabledInUserStore(userStore);\n+        boolean isUserExists;\n+        if (isUniqueIdEnabled) {\n+            isUserExists = doCheckExistingUserWithID(userID);\n+        } else {\n+            String userNameFromUserID = doGetUserNameFromUserID(userID);\n+            isUserExists = userNameFromUserID != null;\n+        }\n+\n+        if (!isUserExists) {\n+            String errorMessage = String.format(ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getMessage(), userID,\n+                    realmConfig.getUserStoreProperty(UserCoreConstants.RealmConfig.PROPERTY_DOMAIN_NAME));\n+            String errorCode = ErrorMessages.ERROR_CODE_NON_EXISTING_USER.getCode();\n+            handleSetUserClaimValuesFailureWithID(errorCode, errorMessage, userID, claims, profileName);\n+            throw new UserStoreException(errorCode + \" - \" + errorMessage);\n+        }\n+\n+        // #################### <Pre Listeners> #####################################################\n+        invokeDoPreSetUserClaimsWithIDListeners(userID, claims, profileName);\n+        // #################### </Pre Listeners> #####################################################\n+\n+        // If user store is readonly this method should not get invoked with non empty claim set.\n+\n+        if (isReadOnly() && !claims.isEmpty()) {\n+            handleSetUserClaimValuesFailureWithID(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getCode(),\n+                    ErrorMessages.ERROR_CODE_READONLY_USER_STORE.getMessage(), userID, claims, profileName);\n+            throw new UserStoreException(ErrorMessages.ERROR_CODE_READONLY_USER_STORE.toString());\n+        }\n+\n+        // Any additional simple claim modified due to pre listeners are taken into claimsExcludingMultiValuedClaims map.\n+        String separator = \",\";\n+        if (StringUtils.isNotEmpty(realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR))) {\n+            separator = realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR);\n+        }\n+        if (claimsExcludingMultiValuedClaims != null) {", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyOTE5MA==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499729190", "bodyText": "A null check is sufficient here due to the following for loop.\nwso2-support/carbon-kernel#984 (comment)", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNzc2Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk1MTQ1Mw==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463951453", "body": "Can we use mapUtils?", "bodyText": "Can we use mapUtils?", "bodyHTML": "<p dir=\"auto\">Can we use mapUtils?</p>", "author": "somindatommy", "createdAt": "2020-08-01T11:07:33Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -14817,4 +15056,114 @@ private String getUserStoreDomainName(UserStoreManager userStoreManager) {\n         }\n         return domainNameProperty;\n     }\n+\n+    /**\n+     * Process and return the modifed claim values against claim URI. Add or remove specific claim values\n+     * against old claim values of multi-valued claims. Replace old claim values from modified values for\n+     * non multi-valued claims.\n+     *\n+     * @param oldClaimMap                      Map of claim URIs against old claim values of user.\n+     * @param multiValuedClaimsToAdd           Map of multi-valued claim URIs against values need to be added to\n+     *                                         old claim value.\n+     * @param multiValuedClaimsToDelete        Map of multi-valued claim URIs against values need to be removed from\n+     *                                         old claim value.\n+     * @param claimsExcludingMultiValuedClaims Map of non multi-valued claim URIs against modified values to be stred.\n+     * @return Map of claim URIs against the modified claim values.\n+     */\n+    private Map<String, String> getModifiedClaims(Map<String, List<String>> oldClaimMap,\n+                                                  Map<String, List<String>> multiValuedClaimsToAdd,\n+                                                  Map<String, List<String>> multiValuedClaimsToDelete,\n+                                                  Map<String, List<String>> claimsExcludingMultiValuedClaims) {\n+\n+        Map<String, String> claims = new HashMap<>();\n+        String separator = \",\";\n+        if (StringUtils.isNotEmpty(realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR))) {\n+            separator = realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR);\n+        }\n+        if (claimsExcludingMultiValuedClaims != null) {\n+            for (String claimURI : claimsExcludingMultiValuedClaims.keySet()) {\n+                claims.put(claimURI,\n+                        StringUtils.join(claimsExcludingMultiValuedClaims.get(claimURI).iterator(), separator));\n+            }\n+        }\n+\n+        // Get modified claim values for multi-valued claims.\n+        if (multiValuedClaimsToAdd != null) {", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMDA3Nw==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499730077", "bodyText": "A null check is sufficient here due to the following for loop.\nwso2-support/carbon-kernel#984 (comment)", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk1MTQ1Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk1MTQ4Mw==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463951483", "body": "Can we use MapUtils?", "bodyText": "Can we use MapUtils?", "bodyHTML": "<p dir=\"auto\">Can we use MapUtils?</p>", "author": "somindatommy", "createdAt": "2020-08-01T11:07:59Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -14817,4 +15056,114 @@ private String getUserStoreDomainName(UserStoreManager userStoreManager) {\n         }\n         return domainNameProperty;\n     }\n+\n+    /**\n+     * Process and return the modifed claim values against claim URI. Add or remove specific claim values\n+     * against old claim values of multi-valued claims. Replace old claim values from modified values for\n+     * non multi-valued claims.\n+     *\n+     * @param oldClaimMap                      Map of claim URIs against old claim values of user.\n+     * @param multiValuedClaimsToAdd           Map of multi-valued claim URIs against values need to be added to\n+     *                                         old claim value.\n+     * @param multiValuedClaimsToDelete        Map of multi-valued claim URIs against values need to be removed from\n+     *                                         old claim value.\n+     * @param claimsExcludingMultiValuedClaims Map of non multi-valued claim URIs against modified values to be stred.\n+     * @return Map of claim URIs against the modified claim values.\n+     */\n+    private Map<String, String> getModifiedClaims(Map<String, List<String>> oldClaimMap,\n+                                                  Map<String, List<String>> multiValuedClaimsToAdd,\n+                                                  Map<String, List<String>> multiValuedClaimsToDelete,\n+                                                  Map<String, List<String>> claimsExcludingMultiValuedClaims) {\n+\n+        Map<String, String> claims = new HashMap<>();\n+        String separator = \",\";\n+        if (StringUtils.isNotEmpty(realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR))) {\n+            separator = realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR);\n+        }\n+        if (claimsExcludingMultiValuedClaims != null) {\n+            for (String claimURI : claimsExcludingMultiValuedClaims.keySet()) {\n+                claims.put(claimURI,\n+                        StringUtils.join(claimsExcludingMultiValuedClaims.get(claimURI).iterator(), separator));\n+            }\n+        }\n+\n+        // Get modified claim values for multi-valued claims.\n+        if (multiValuedClaimsToAdd != null) {\n+            for (String claimURI : multiValuedClaimsToAdd.keySet()) {\n+                List<String> modifiedValue = new ArrayList<>();\n+                if (oldClaimMap.containsKey(claimURI)) {\n+                    modifiedValue.addAll(oldClaimMap.get(claimURI));\n+                    modifiedValue.addAll(multiValuedClaimsToAdd.get(claimURI));\n+                } else {\n+                    modifiedValue.addAll(multiValuedClaimsToAdd.get(claimURI));\n+                }\n+                claims.put(claimURI, StringUtils.join(modifiedValue.iterator(), separator));\n+            }\n+        }\n+        if (multiValuedClaimsToDelete != null) {", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczMDAxOQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499730019", "bodyText": "A null check is sufficient here due to the following for loop.\nwso2-support/carbon-kernel#984 (comment)", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk1MTQ4Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk1MTczNQ==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r463951735", "body": "Shall we remove extra newlines?", "bodyText": "Shall we remove extra newlines?", "bodyHTML": "<p dir=\"auto\">Shall we remove extra newlines?</p>", "author": "somindatommy", "createdAt": "2020-08-01T11:11:25Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java", "diffHunk": "@@ -917,6 +918,80 @@ protected void doSetUserAttributes(String userName, Map<String, String> processe\n         }\n     }\n \n+    protected void doSetUserAttributes(String userName, Map<String, List<String>> claimAttributesToAdd,\n+                                       Map<String, List<String>> claimAttributesToDelete,\n+                                       Map<String, List<String>> claimAttributesToReplace, String profileName)\n+            throws UserStoreException, NotImplementedException {\n+\n+        // Get the LDAP Directory context.\n+        DirContext dirContext = this.connectionSource.getContext();\n+        DirContext subDirContext = null;\n+        // Search the relevant user entry by user name.\n+        String userSearchBase = realmConfig.getUserStoreProperty(LDAPConstants.USER_SEARCH_BASE);\n+        String userSearchFilter = realmConfig\n+                .getUserStoreProperty(LDAPConstants.USER_NAME_SEARCH_FILTER);\n+        // If user name contains domain name, remove domain name.\n+        userName = UserCoreUtil.removeDomainFromName(userName);\n+        userSearchFilter = userSearchFilter.replace(\"?\", escapeSpecialCharactersForFilter(userName));\n+\n+        SearchControls searchControls = new SearchControls();\n+        searchControls.setSearchScope(SearchControls.SUBTREE_SCOPE);\n+        searchControls.setReturningAttributes(null);\n+\n+        NamingEnumeration<SearchResult> returnedResultList = null;\n+        String returnedUserEntry = StringUtils.EMPTY;\n+\n+        try {\n+            subDirContext = (DirContext) dirContext.lookup(escapeDNForSearch(userSearchBase));\n+            returnedResultList = dirContext.search(escapeDNForSearch(userSearchBase), userSearchFilter, searchControls);\n+\n+            // Assume only one user is returned from the search.\n+            if (returnedResultList.hasMore()) {\n+                returnedUserEntry = returnedResultList.next().getName();\n+                handleLdapUserNameAttributeChanges(claimAttributesToReplace, subDirContext, returnedUserEntry);\n+            }\n+\n+        } catch (NamingException e) {\n+            String errorMessage = \"Results could not be retrieved from the directory context for user : \" + userName;\n+", "originalCommit": "852a23c9f3930e0b32df4c52255506f00e428c7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjM4NA==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r499736384", "bodyText": "addressed in fb430db", "author": "AnuradhaSK", "createdAt": "2020-10-05T16:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk1MTczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "3f2294363dedc5b782da00e295e7e75f500b9646", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\nindex 6979d0c54..dd3755d53 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\n", "chunk": "@@ -950,14 +954,11 @@ public class ReadWriteLDAPUserStoreManager extends ReadOnlyLDAPUserStoreManager\n                 returnedUserEntry = returnedResultList.next().getName();\n                 handleLdapUserNameAttributeChanges(claimAttributesToReplace, subDirContext, returnedUserEntry);\n             }\n-\n         } catch (NamingException e) {\n             String errorMessage = \"Results could not be retrieved from the directory context for user : \" + userName;\n-\n             if (log.isDebugEnabled()) {\n                 log.debug(errorMessage, e);\n             }\n-\n             throw new UserStoreException(errorMessage, e);\n         } finally {\n             JNDIUtil.closeNamingEnumeration(returnedResultList);\n", "next_change": {"commit": "fcde39da236f7f4061e3b5644117c3d04f8adba7", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\nindex dd3755d53..34ba606a3 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\n", "chunk": "@@ -954,11 +954,14 @@ public class ReadWriteLDAPUserStoreManager extends ReadOnlyLDAPUserStoreManager\n                 returnedUserEntry = returnedResultList.next().getName();\n                 handleLdapUserNameAttributeChanges(claimAttributesToReplace, subDirContext, returnedUserEntry);\n             }\n+\n         } catch (NamingException e) {\n             String errorMessage = \"Results could not be retrieved from the directory context for user : \" + userName;\n+\n             if (log.isDebugEnabled()) {\n                 log.debug(errorMessage, e);\n             }\n+\n             throw new UserStoreException(errorMessage, e);\n         } finally {\n             JNDIUtil.closeNamingEnumeration(returnedResultList);\n", "next_change": {"commit": "fc932b05f8215d6d5fc6bfe0ca30902a75f64eb1", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\nindex 34ba606a3..dd3755d53 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/ldap/ReadWriteLDAPUserStoreManager.java\n", "chunk": "@@ -954,14 +954,11 @@ public class ReadWriteLDAPUserStoreManager extends ReadOnlyLDAPUserStoreManager\n                 returnedUserEntry = returnedResultList.next().getName();\n                 handleLdapUserNameAttributeChanges(claimAttributesToReplace, subDirContext, returnedUserEntry);\n             }\n-\n         } catch (NamingException e) {\n             String errorMessage = \"Results could not be retrieved from the directory context for user : \" + userName;\n-\n             if (log.isDebugEnabled()) {\n                 log.debug(errorMessage, e);\n             }\n-\n             throw new UserStoreException(errorMessage, e);\n         } finally {\n             JNDIUtil.closeNamingEnumeration(returnedResultList);\n", "next_change": null}]}}]}}]}}, {"oid": "3f2294363dedc5b782da00e295e7e75f500b9646", "url": "https://github.com/wso2/carbon-kernel/commit/3f2294363dedc5b782da00e295e7e75f500b9646", "message": "address comments", "committedDate": "2020-10-05T16:58:10Z", "type": "forcePushed"}, {"oid": "fcde39da236f7f4061e3b5644117c3d04f8adba7", "url": "https://github.com/wso2/carbon-kernel/commit/fcde39da236f7f4061e3b5644117c3d04f8adba7", "message": "Update multi-valued user claims independently from non-multi-valued claims", "committedDate": "2020-10-06T12:52:48Z", "type": "commit"}, {"oid": "e08b9e45db7e61ed00333444cf76f9044095e50c", "url": "https://github.com/wso2/carbon-kernel/commit/e08b9e45db7e61ed00333444cf76f9044095e50c", "message": "Add setUserClaimValuesWithID method into UniqueIDUserStoreManager interface", "committedDate": "2020-10-06T12:52:48Z", "type": "commit"}, {"oid": "fc932b05f8215d6d5fc6bfe0ca30902a75f64eb1", "url": "https://github.com/wso2/carbon-kernel/commit/fc932b05f8215d6d5fc6bfe0ca30902a75f64eb1", "message": "address comments", "committedDate": "2020-10-06T12:52:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM5MzMyMg==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r500393322", "body": "Shall we remove the additional newline here?", "bodyText": "Shall we remove the additional newline here?", "bodyHTML": "<p dir=\"auto\">Shall we remove the additional newline here?</p>", "author": "somindatommy", "createdAt": "2020-10-06T15:31:26Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java", "diffHunk": "@@ -15123,4 +15358,114 @@ private String getUserStoreDomainName(UserStoreManager userStoreManager) {\n         }\n         return domainNameProperty;\n     }\n+\n+    /**\n+     * Process and return the modifed claim values against claim URI. Add or remove specific claim values\n+     * against old claim values of multi-valued claims. Replace old claim values from modified values for\n+     * non multi-valued claims.\n+     *\n+     * @param oldClaimMap                      Map of claim URIs against old claim values of user.\n+     * @param multiValuedClaimsToAdd           Map of multi-valued claim URIs against values need to be added to\n+     *                                         old claim value.\n+     * @param multiValuedClaimsToDelete        Map of multi-valued claim URIs against values need to be removed from\n+     *                                         old claim value.\n+     * @param claimsExcludingMultiValuedClaims Map of non multi-valued claim URIs against modified values to be stred.\n+     * @return Map of claim URIs against the modified claim values.\n+     */\n+    private Map<String, String> getModifiedClaims(Map<String, List<String>> oldClaimMap,\n+                                                  Map<String, List<String>> multiValuedClaimsToAdd,\n+                                                  Map<String, List<String>> multiValuedClaimsToDelete,\n+                                                  Map<String, List<String>> claimsExcludingMultiValuedClaims) {\n+\n+        Map<String, String> claims = new HashMap<>();\n+        String separator = \",\";\n+        if (StringUtils.isNotEmpty(realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR))) {\n+            separator = realmConfig.getUserStoreProperty(MULTI_ATTRIBUTE_SEPARATOR);\n+        }\n+        if (claimsExcludingMultiValuedClaims != null) {\n+            for (String claimURI : claimsExcludingMultiValuedClaims.keySet()) {\n+                claims.put(claimURI,\n+                        StringUtils.join(claimsExcludingMultiValuedClaims.get(claimURI).iterator(), separator));\n+            }\n+        }\n+\n+        // Get modified claim values for multi-valued claims.\n+        if (multiValuedClaimsToAdd != null) {\n+            for (String claimURI : multiValuedClaimsToAdd.keySet()) {\n+                List<String> modifiedValue = new ArrayList<>();\n+                if (oldClaimMap.containsKey(claimURI)) {\n+                    modifiedValue.addAll(oldClaimMap.get(claimURI));\n+                    modifiedValue.addAll(multiValuedClaimsToAdd.get(claimURI));\n+                } else {\n+                    modifiedValue.addAll(multiValuedClaimsToAdd.get(claimURI));\n+                }\n+                claims.put(claimURI, StringUtils.join(modifiedValue.iterator(), separator));\n+            }\n+        }\n+        if (multiValuedClaimsToDelete != null) {\n+            for (String claimURI : multiValuedClaimsToDelete.keySet()) {\n+                List<String> values = null;\n+                if (claims.containsKey(claimURI)) {\n+                    values = Arrays.asList(claims.get(claimURI).split(separator));\n+                } else if (oldClaimMap.containsKey(claimURI)) {\n+                    values = oldClaimMap.get(claimURI);\n+                }\n+                if (!CollectionUtils.isEmpty(values)) {\n+                    List<String> modifiedValue =\n+                            (List<String>) CollectionUtils.subtract(values, multiValuedClaimsToDelete.get(claimURI));\n+                    claims.put(claimURI, StringUtils.join(modifiedValue.iterator(), separator));\n+                }\n+            }\n+        }\n+        return claims;\n+    }\n+\n+    private void invokeDoPreSetUserClaimsWithIDListeners(String userID, Map<String, String> claims, String profileName)\n+            throws UserStoreException {\n+\n+        try {\n+            for (UserOperationEventListener listener : UMListenerServiceComponent.getUserOperationEventListeners()) {\n+                if (!((AbstractUserOperationEventListener) listener)\n+                        .doPreSetUserClaimValuesWithID(userID, claims, profileName, this)) {\n+                    handleSetUserClaimValuesFailureWithID(\n+                            ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getCode(),\n+                            String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getMessage(),\n+                                    UserCoreErrorConstants.PRE_LISTENER_TASKS_FAILED_MESSAGE), userID, claims,\n+                            profileName);\n+                    return;\n+                }\n+            }\n+        } catch (UserStoreException e) {\n+            handleSetUserClaimValuesFailureWithID(\n+                    ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getCode(),\n+                    String.format(ErrorMessages.ERROR_CODE_ERROR_DURING_PRE_SET_USER_CLAIM_VALUES.getMessage(),\n+                            e.getMessage()), userID, claims, profileName);\n+            throw e;\n+        }\n+", "originalCommit": "3f2294363dedc5b782da00e295e7e75f500b9646", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1OTUzNw==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r500459537", "bodyText": "fixed in 0b9e061", "author": "AnuradhaSK", "createdAt": "2020-10-06T17:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM5MzMyMg=="}], "type": "inlineReview", "revised_code": {"commit": "0b9e0615f73df04ff560b0323874d376248c8758", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\nindex a6ee9fe4d..66e178591 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/common/AbstractUserStoreManager.java\n", "chunk": "@@ -15442,7 +15435,6 @@ public abstract class AbstractUserStoreManager implements PaginatedUserStoreMana\n                             e.getMessage()), userID, claims, profileName);\n             throw e;\n         }\n-\n     }\n \n     private void invokeDoPostSetUserClaimsWithIDListeners(String userID, Map<String, String> claims, String profileName)\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM5NDQzNg==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r500394436", "body": "Don't we have to say that this is uniqueId JDBC?", "bodyText": "Don't we have to say that this is uniqueId JDBC?", "bodyHTML": "<p dir=\"auto\">Don't we have to say that this is uniqueId JDBC?</p>", "author": "somindatommy", "createdAt": "2020-10-06T15:32:37Z", "path": "core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/jdbc/UniqueIDJDBCUserStoreManager.java", "diffHunk": "@@ -1816,6 +1826,15 @@ public void doSetUserClaimValuesWithID(String userID, Map<String, String> claims\n         super.doSetUserClaimValuesWithID(userID, claims, profileName);\n     }\n \n+    @Override\n+    public void doSetUserClaimValuesWithID(String userID, Map<String, List<String>> multiValuedClaimsToAdd,\n+                                           Map<String, List<String>> multiValuedClaimsToDelete,\n+                                           Map<String, List<String>> claimsExcludingMultiValuedClaims,\n+                                           String profileName) throws NotImplementedException {\n+\n+        throw new NotImplementedException(\"This functionality is not yet implemented for JDBC userstores.\");", "originalCommit": "3f2294363dedc5b782da00e295e7e75f500b9646", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1OTQwMA==", "url": "https://github.com/wso2/carbon-kernel/pull/2705#discussion_r500459400", "bodyText": "fixed in 0b9e061", "author": "AnuradhaSK", "createdAt": "2020-10-06T17:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM5NDQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "0b9e0615f73df04ff560b0323874d376248c8758", "changed_code": [{"header": "diff --git a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/jdbc/UniqueIDJDBCUserStoreManager.java b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/jdbc/UniqueIDJDBCUserStoreManager.java\nindex 09becd40b..4076a2973 100644\n--- a/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/jdbc/UniqueIDJDBCUserStoreManager.java\n+++ b/core/org.wso2.carbon.user.core/src/main/java/org/wso2/carbon/user/core/jdbc/UniqueIDJDBCUserStoreManager.java\n", "chunk": "@@ -1832,7 +1832,7 @@ public class UniqueIDJDBCUserStoreManager extends JDBCUserStoreManager {\n                                            Map<String, List<String>> claimsExcludingMultiValuedClaims,\n                                            String profileName) throws NotImplementedException {\n \n-        throw new NotImplementedException(\"This functionality is not yet implemented for JDBC userstores.\");\n+        throw new NotImplementedException(\"This functionality is not yet implemented for UniqueID JDBC userstores.\");\n     }\n \n     @Override\n", "next_change": null}]}}, {"oid": "0b9e0615f73df04ff560b0323874d376248c8758", "url": "https://github.com/wso2/carbon-kernel/commit/0b9e0615f73df04ff560b0323874d376248c8758", "message": "improve logs and fix formatting issues", "committedDate": "2020-10-06T17:05:31Z", "type": "commit"}, {"oid": "0b9e0615f73df04ff560b0323874d376248c8758", "url": "https://github.com/wso2/carbon-kernel/commit/0b9e0615f73df04ff560b0323874d376248c8758", "message": "improve logs and fix formatting issues", "committedDate": "2020-10-06T17:05:31Z", "type": "forcePushed"}]}