{"pr_number": 1432, "pr_title": "SOLR-14404 CoreContainer level custom requesthandlers", "pr_author": "noblepaul", "pr_createdAt": "2020-04-14T13:32:29Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1432", "merge_commit": "57a892f896f543913d6b22a81577f69184cd94b6", "timeline": [{"oid": "87a57bc680352018da29a6698bda53d7f3f71c82", "url": "https://github.com/apache/lucene-solr/commit/87a57bc680352018da29a6698bda53d7f3f71c82", "message": "initial commit", "committedDate": "2020-04-13T00:06:19Z", "type": "commit"}, {"oid": "e9500d2a61647af86b85369d78c5c1b589c38de5", "url": "https://github.com/apache/lucene-solr/commit/e9500d2a61647af86b85369d78c5c1b589c38de5", "message": "Added a few tests . Still WIP", "committedDate": "2020-04-13T18:04:29Z", "type": "commit"}, {"oid": "2a172f5ec68e648d5b0b15d66f4f07bdd011b14d", "url": "https://github.com/apache/lucene-solr/commit/2a172f5ec68e648d5b0b15d66f4f07bdd011b14d", "message": "Added more tests . Still WIP", "committedDate": "2020-04-14T01:42:02Z", "type": "commit"}, {"oid": "288a261c43d6373aec89630b1388a8a4d3f51943", "url": "https://github.com/apache/lucene-solr/commit/288a261c43d6373aec89630b1388a8a4d3f51943", "message": "Added more tests . Still WIP", "committedDate": "2020-04-14T07:16:59Z", "type": "commit"}, {"oid": "453911ed39b3b9301c738b29654cb7b96b01dff2", "url": "https://github.com/apache/lucene-solr/commit/453911ed39b3b9301c738b29654cb7b96b01dff2", "message": "Added more tests. Ready for review", "committedDate": "2020-04-14T13:27:40Z", "type": "commit"}, {"oid": "e1118c707c6a973a26b21dc47cd99ae30a967b6a", "url": "https://github.com/apache/lucene-solr/commit/e1118c707c6a973a26b21dc47cd99ae30a967b6a", "message": "Some more refatoring", "committedDate": "2020-04-15T03:33:55Z", "type": "commit"}, {"oid": "82bcd38bb851274c0b2fba85190f29b46400640f", "url": "https://github.com/apache/lucene-solr/commit/82bcd38bb851274c0b2fba85190f29b46400640f", "message": "Some more refatoring", "committedDate": "2020-04-15T07:03:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY3NjI2NA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409676264", "body": "Should this be synchronized to match `register`?", "bodyText": "Should this be synchronized to match register?", "bodyHTML": "<p dir=\"auto\">Should this be synchronized to match <code>register</code>?</p>", "author": "madrob", "createdAt": "2020-04-16T16:07:58Z", "path": "solr/core/src/java/org/apache/solr/api/ApiBag.java", "diffHunk": "@@ -134,6 +142,14 @@ static void registerIntrospect(List<String> l, PathTrie<Api> registry, Map<Strin\n     registry.insert(copy, substitutes, introspect);\n   }\n \n+  public Api unregister(SolrRequest.METHOD method, String path) {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f051b497f549762a727ce4b1248a0fc5fa513d24", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/ApiBag.java b/solr/core/src/java/org/apache/solr/api/ApiBag.java\nindex c19e586b945..bef5a633bf8 100644\n--- a/solr/core/src/java/org/apache/solr/api/ApiBag.java\n+++ b/solr/core/src/java/org/apache/solr/api/ApiBag.java\n", "chunk": "@@ -142,7 +148,7 @@ public class ApiBag {\n     registry.insert(copy, substitutes, introspect);\n   }\n \n-  public Api unregister(SolrRequest.METHOD method, String path) {\n+  public synchronized Api unregister(SolrRequest.METHOD method, String path) {\n     List<String> l = PathTrie.getPathSegments(path);\n     List<String> introspectPath = new ArrayList<>(l);\n     introspectPath.add(\"_introspect\");\n", "next_change": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/ApiBag.java b/solr/core/src/java/org/apache/solr/api/ApiBag.java\nindex bef5a633bf8..8b64829ad60 100644\n--- a/solr/core/src/java/org/apache/solr/api/ApiBag.java\n+++ b/solr/core/src/java/org/apache/solr/api/ApiBag.java\n", "chunk": "@@ -152,8 +155,8 @@ public class ApiBag {\n     List<String> l = PathTrie.getPathSegments(path);\n     List<String> introspectPath = new ArrayList<>(l);\n     introspectPath.add(\"_introspect\");\n-    getRegistry(method.toString()).unregister(introspectPath);\n-    return getRegistry(method.toString()).unregister(l);\n+    getRegistry(method.toString()).remove(introspectPath);\n+    return getRegistry(method.toString()).remove(l);\n   }\n \n   public static class IntrospectApi extends Api {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/ApiBag.java b/solr/core/src/java/org/apache/solr/api/ApiBag.java\nindex c19e586b945..8b64829ad60 100644\n--- a/solr/core/src/java/org/apache/solr/api/ApiBag.java\n+++ b/solr/core/src/java/org/apache/solr/api/ApiBag.java\n", "chunk": "@@ -142,12 +151,12 @@ public class ApiBag {\n     registry.insert(copy, substitutes, introspect);\n   }\n \n-  public Api unregister(SolrRequest.METHOD method, String path) {\n+  public synchronized Api unregister(SolrRequest.METHOD method, String path) {\n     List<String> l = PathTrie.getPathSegments(path);\n     List<String> introspectPath = new ArrayList<>(l);\n     introspectPath.add(\"_introspect\");\n-    getRegistry(method.toString()).unregister(introspectPath);\n-    return getRegistry(method.toString()).unregister(l);\n+    getRegistry(method.toString()).remove(introspectPath);\n+    return getRegistry(method.toString()).remove(l);\n   }\n \n   public static class IntrospectApi extends Api {\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/ApiBag.java b/solr/core/src/java/org/apache/solr/api/ApiBag.java\ndeleted file mode 100644\nindex 8b64829ad60..00000000000\n--- a/solr/core/src/java/org/apache/solr/api/ApiBag.java\n+++ /dev/null\n", "chunk": "@@ -1,392 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.api;\n-\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-import org.apache.solr.client.solrj.SolrRequest;\n-import org.apache.solr.common.SolrException;\n-import org.apache.solr.common.SpecProvider;\n-import org.apache.solr.common.util.CommandOperation;\n-import org.apache.solr.common.util.ContentStream;\n-import org.apache.solr.common.util.JsonSchemaValidator;\n-import org.apache.solr.common.util.NamedList;\n-import org.apache.solr.common.util.PathTrie;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.common.util.ValidatingJsonMap;\n-import org.apache.solr.core.PluginBag;\n-import org.apache.solr.core.PluginInfo;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.request.SolrRequestHandler;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.AuthorizationContext;\n-import org.apache.solr.security.PermissionNameProvider;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.solr.client.solrj.SolrRequest.SUPPORTED_METHODS;\n-import static org.apache.solr.common.params.CommonParams.NAME;\n-import static org.apache.solr.common.util.StrUtils.formatString;\n-import static org.apache.solr.common.util.ValidatingJsonMap.ENUM_OF;\n-import static org.apache.solr.common.util.ValidatingJsonMap.NOT_NULL;\n-\n-public class ApiBag {\n-  private final boolean isCoreSpecific;\n-  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-  private final Map<String, PathTrie<Api>> apis = new ConcurrentHashMap<>();\n-\n-  public ApiBag(boolean isCoreSpecific) {\n-    this.isCoreSpecific = isCoreSpecific;\n-  }\n-\n-  /**Register a POJO annotated with {@link EndPoint}\n-   * @param o the instance to be used for invocations\n-   */\n-  @SuppressWarnings({\"unchecked\"})\n-  public synchronized List<Api> registerObject(Object o) {\n-    List<Api> l = AnnotatedApi.getApis(o);\n-    for (Api api : l) {\n-      register(api, Collections.EMPTY_MAP);\n-    }\n-    return l;\n-  }\n-  @SuppressWarnings({\"unchecked\"})\n-  public synchronized void register(Api api) {\n-    register(api, Collections.EMPTY_MAP);\n-  }\n-  public synchronized void register(Api api, Map<String, String> nameSubstitutes) {\n-    try {\n-      validateAndRegister(api, nameSubstitutes);\n-    } catch (Exception e) {\n-      log.error(\"Unable to register plugin: {} with spec {} :\", api.getClass().getName(), Utils.toJSONString(api.getSpec()), e);\n-      if (e instanceof RuntimeException) {\n-        throw (RuntimeException) e;\n-      } else {\n-        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n-      }\n-\n-    }\n-  }\n-\n-  @SuppressWarnings({\"unchecked\"})\n-  private void validateAndRegister(Api api, Map<String, String> nameSubstitutes) {\n-    ValidatingJsonMap spec = api.getSpec();\n-    Api introspect = new IntrospectApi(api, isCoreSpecific);\n-    List<String> methods = spec.getList(\"methods\", ENUM_OF, SUPPORTED_METHODS);\n-    for (String method : methods) {\n-      PathTrie<Api> registry = apis.get(method);\n-\n-      if (registry == null) apis.put(method, registry = new PathTrie<>(ImmutableSet.of(\"_introspect\")));\n-      ValidatingJsonMap url = spec.getMap(\"url\", NOT_NULL);\n-      ValidatingJsonMap params = url.getMap(\"params\", null);\n-      if (params != null) {\n-        for (Object o : params.keySet()) {\n-          ValidatingJsonMap param = params.getMap(o.toString(), NOT_NULL);\n-          param.get(\"type\", ENUM_OF, KNOWN_TYPES);\n-        }\n-      }\n-      List<String> paths = url.getList(\"paths\", NOT_NULL);\n-      ValidatingJsonMap parts = url.getMap(\"parts\", null);\n-      if (parts != null) {\n-        Set<String> wildCardNames = getWildCardNames(paths);\n-        for (Object o : parts.keySet()) {\n-          if (!wildCardNames.contains(o.toString()))\n-            throw new RuntimeException(\"\" + o + \" is not a valid part name\");\n-          ValidatingJsonMap pathMeta = parts.getMap(o.toString(), NOT_NULL);\n-          pathMeta.get(\"type\", ENUM_OF, ImmutableSet.of(\"enum\", \"string\", \"int\", \"number\", \"boolean\"));\n-        }\n-      }\n-      verifyCommands(api.getSpec());\n-      for (String path : paths) {\n-        registry.insert(path, nameSubstitutes, api);\n-        registerIntrospect(nameSubstitutes, registry, path, introspect);\n-      }\n-    }\n-  }\n-\n-  public static void registerIntrospect(Map<String, String> nameSubstitutes, PathTrie<Api> registry, String path, Api introspect) {\n-    List<String> l = PathTrie.getPathSegments(path);\n-    registerIntrospect(l, registry, nameSubstitutes, introspect);\n-    int lastIdx = l.size() - 1;\n-    for (int i = lastIdx; i >= 0; i--) {\n-      String itemAt = l.get(i);\n-      if (PathTrie.templateName(itemAt) == null) break;\n-      l.remove(i);\n-      if (registry.lookup(l, new HashMap<>()) != null) break;\n-      registerIntrospect(l, registry, nameSubstitutes, introspect);\n-    }\n-  }\n-\n-  static void registerIntrospect(List<String> l, PathTrie<Api> registry, Map<String, String> substitutes, Api introspect) {\n-    ArrayList<String> copy = new ArrayList<>(l);\n-    copy.add(\"_introspect\");\n-    registry.insert(copy, substitutes, introspect);\n-  }\n-\n-  public synchronized Api unregister(SolrRequest.METHOD method, String path) {\n-    List<String> l = PathTrie.getPathSegments(path);\n-    List<String> introspectPath = new ArrayList<>(l);\n-    introspectPath.add(\"_introspect\");\n-    getRegistry(method.toString()).remove(introspectPath);\n-    return getRegistry(method.toString()).remove(l);\n-  }\n-\n-  public static class IntrospectApi extends Api {\n-    Api baseApi;\n-    final boolean isCoreSpecific;\n-\n-    public IntrospectApi(Api base, boolean isCoreSpecific) {\n-      super(EMPTY_SPEC);\n-      this.baseApi = base;\n-      this.isCoreSpecific = isCoreSpecific;\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-\n-      String cmd = req.getParams().get(\"command\");\n-      ValidatingJsonMap result = null;\n-      if (cmd == null) {\n-        result = isCoreSpecific ? ValidatingJsonMap.getDeepCopy(baseApi.getSpec(), 5, true) : baseApi.getSpec();\n-      } else {\n-        ValidatingJsonMap specCopy = ValidatingJsonMap.getDeepCopy(baseApi.getSpec(), 5, true);\n-        ValidatingJsonMap commands = specCopy.getMap(\"commands\", null);\n-        if (commands != null) {\n-          ValidatingJsonMap m = commands.getMap(cmd, null);\n-          if (m == null) {\n-            specCopy.put(\"commands\", Collections.singletonMap(cmd, \"Command not found!\"));\n-          } else {\n-            specCopy.put(\"commands\", Collections.singletonMap(cmd, m));\n-          }\n-\n-        }\n-        result = specCopy;\n-      }\n-      if (isCoreSpecific) {\n-        List<String> pieces = req.getHttpSolrCall() == null ? null : ((V2HttpCall) req.getHttpSolrCall()).pieces;\n-        if (pieces != null) {\n-          String prefix = \"/\" + pieces.get(0) + \"/\" + pieces.get(1);\n-          List<String> paths = result.getMap(\"url\", NOT_NULL).getList(\"paths\", NOT_NULL);\n-          result.getMap(\"url\", NOT_NULL).put(\"paths\",\n-              paths.stream()\n-                  .map(s -> prefix + s)\n-                  .collect(Collectors.toList()));\n-        }\n-      }\n-      List l = (List) rsp.getValues().get(\"spec\");\n-      if (l == null) rsp.getValues().add(\"spec\", l = new ArrayList());\n-      l.add(result);\n-    }\n-  }\n-\n-  public static Map<String, JsonSchemaValidator> getParsedSchema(ValidatingJsonMap commands) {\n-    Map<String, JsonSchemaValidator> validators = new HashMap<>();\n-    for (Object o : commands.entrySet()) {\n-      @SuppressWarnings({\"rawtypes\"})\n-      Map.Entry cmd = (Map.Entry) o;\n-      try {\n-        validators.put((String) cmd.getKey(), new JsonSchemaValidator((Map) cmd.getValue()));\n-      } catch (Exception e) {\n-        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error in api spec\", e);\n-      }\n-    }\n-    return validators;\n-  }\n-\n-\n-  private void verifyCommands(ValidatingJsonMap spec) {\n-    ValidatingJsonMap commands = spec.getMap(\"commands\", null);\n-    if (commands == null) return;\n-    getParsedSchema(commands);\n-\n-  }\n-\n-  private Set<String> getWildCardNames(List<String> paths) {\n-    Set<String> wildCardNames = new HashSet<>();\n-    for (String path : paths) {\n-      List<String> p = PathTrie.getPathSegments(path);\n-      for (String s : p) {\n-        String wildCard = PathTrie.templateName(s);\n-        if (wildCard != null) wildCardNames.add(wildCard);\n-      }\n-    }\n-    return wildCardNames;\n-  }\n-\n-\n-  public Api lookup(String path, String httpMethod, Map<String, String> parts) {\n-    if (httpMethod == null) {\n-      for (PathTrie<Api> trie : apis.values()) {\n-        Api api = trie.lookup(path, parts);\n-        if (api != null) return api;\n-      }\n-      return null;\n-    } else {\n-      PathTrie<Api> registry = apis.get(httpMethod);\n-      if (registry == null) return null;\n-      return registry.lookup(path, parts);\n-    }\n-  }\n-\n-  public static class ReqHandlerToApi extends Api implements PermissionNameProvider {\n-    SolrRequestHandler rh;\n-\n-    public ReqHandlerToApi(SolrRequestHandler rh, SpecProvider spec) {\n-      super(spec);\n-      this.rh = rh;\n-    }\n-\n-    @Override\n-    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rh.handleRequest(req, rsp);\n-    }\n-\n-    @Override\n-    public Name getPermissionName(AuthorizationContext ctx) {\n-      if (rh instanceof PermissionNameProvider) {\n-        return ((PermissionNameProvider) rh).getPermissionName(ctx);\n-      }\n-      return null;\n-    }\n-  }\n-\n-  public static List<Api> wrapRequestHandlers(final SolrRequestHandler rh, String... specs) {\n-    ImmutableList.Builder<Api> b = ImmutableList.builder();\n-    for (String spec : specs) b.add(new ReqHandlerToApi(rh, Utils.getSpec(spec)));\n-    return b.build();\n-  }\n-\n-\n-  public static final SpecProvider EMPTY_SPEC = () -> ValidatingJsonMap.EMPTY;\n-  public static final String HANDLER_NAME = \"handlerName\";\n-  public static final Set<String> KNOWN_TYPES = ImmutableSet.of(\"string\", \"boolean\", \"list\", \"int\", \"double\", \"object\");\n-\n-  public PathTrie<Api> getRegistry(String method) {\n-    return apis.get(method);\n-  }\n-\n-  public void registerLazy(PluginBag.PluginHolder<SolrRequestHandler> holder, PluginInfo info) {\n-    String specName = info.attributes.get(\"spec\");\n-    if (specName == null) specName = \"emptySpec\";\n-    register(new LazyLoadedApi(Utils.getSpec(specName), holder), Collections.singletonMap(HANDLER_NAME, info.attributes.get(NAME)));\n-  }\n-\n-  public static SpecProvider constructSpec(PluginInfo info) {\n-    Object specObj = info == null ? null : info.attributes.get(\"spec\");\n-    if (specObj == null) specObj = \"emptySpec\";\n-    if (specObj instanceof Map) {\n-      @SuppressWarnings({\"rawtypes\"})\n-      Map map = (Map) specObj;\n-      return () -> ValidatingJsonMap.getDeepCopy(map, 4, false);\n-    } else {\n-      return Utils.getSpec((String) specObj);\n-    }\n-  }\n-\n-  @SuppressWarnings({\"rawtypes\"})\n-  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n-    List<CommandOperation> parsedCommands = null;\n-    try {\n-      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n-    } catch (IOException e) {\n-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\",e);\n-    }\n-\n-    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n-      return parsedCommands;\n-    }\n-\n-    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n-\n-    for (CommandOperation cmd : commandsCopy) {\n-      JsonSchemaValidator validator = validators.get(cmd.name);\n-      if (validator == null) {\n-        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n-            validators.keySet()));\n-        continue;\n-      } else {\n-        List<String> errs = validator.validateJson(cmd.getCommandData());\n-        if (errs != null){\n-          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n-          // which is quite unhelpful.\n-          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n-          for (String err : errs) cmd.addError(err);\n-        }\n-      }\n-\n-    }\n-    @SuppressWarnings({\"rawtypes\"})\n-    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n-    if (!errs.isEmpty()) {\n-      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n-    }\n-    return commandsCopy;\n-  }\n-\n-  public static class ExceptionWithErrObject extends SolrException {\n-    @SuppressWarnings({\"rawtypes\"})\n-    private List<Map> errs;\n-\n-    public ExceptionWithErrObject(ErrorCode code, String msg, @SuppressWarnings({\"rawtypes\"})List<Map> errs) {\n-      super(code, msg);\n-      this.errs = errs;\n-    }\n-\n-    @SuppressWarnings({\"rawtypes\"})\n-    public List<Map> getErrs() {\n-      return errs;\n-    }\n-\n-    public String toString() {\n-      return super.toString() + \", errors: \" + getErrs() + \", \";\n-    }\n-  }\n-\n-  public static class LazyLoadedApi extends Api {\n-\n-    private final PluginBag.PluginHolder<SolrRequestHandler> holder;\n-    private Api delegate;\n-\n-    protected LazyLoadedApi(SpecProvider specProvider, PluginBag.PluginHolder<SolrRequestHandler> lazyPluginHolder) {\n-      super(specProvider);\n-      this.holder = lazyPluginHolder;\n-    }\n-\n-    @Override\n-    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      if (!holder.isLoaded()) {\n-        delegate = new ReqHandlerToApi(holder.get(), ApiBag.EMPTY_SPEC);\n-      }\n-      delegate.call(req, rsp);\n-    }\n-  }\n-\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4MDAyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409680029", "body": "Should this be METHOD.DELETE instead of a post?", "bodyText": "Should this be METHOD.DELETE instead of a post?", "bodyHTML": "<p dir=\"auto\">Should this be METHOD.DELETE instead of a post?</p>", "author": "madrob", "createdAt": "2020-04-16T16:13:33Z", "path": "solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler.admin;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.apache.solr.api.AnnotatedApi;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.CustomContainerPlugins;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.api.PayloadObj;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.cloud.SolrZkClient;\n+import org.apache.solr.common.cloud.ZkStateReader;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+\n+public class ContainerPluginsApi {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String PLUGIN = \"plugin\";\n+  private final Supplier<SolrZkClient> zkClientSupplier;\n+  private final CoreContainer coreContainer;\n+  public final Read readAPI = new Read();\n+  public final Edit editAPI = new Edit();\n+\n+  public ContainerPluginsApi(CoreContainer coreContainer) {\n+    this.zkClientSupplier = coreContainer.zkClientSupplier;\n+    this.coreContainer = coreContainer;\n+  }\n+\n+  @EndPoint(method = METHOD.GET,\n+      path = \"/cluster/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+  public class Read {\n+\n+    @Command\n+    public void list(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n+      rsp.add(PLUGIN, plugins(zkClientSupplier));\n+    }\n+  }\n+\n+  @EndPoint(method = METHOD.POST,\n+      path = \"/cluster/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_EDIT_PERM)\n+  public class Edit {\n+\n+    @Command(name = \"add\")\n+    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta> payload) throws IOException {\n+      PluginMeta info = payload.get();\n+      validateConfig(payload, info);\n+      if(payload.hasError()) return;\n+      persistPlugins(map -> {\n+        if (map.containsKey(info.name)) {\n+          payload.addError(info.name + \" already exists\");\n+          return null;\n+        }\n+        map.put(info.name, info);\n+        return map;\n+      });\n+    }\n+\n+    @Command(name = \"remove\")\n+    public void remove(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<String> payload) throws IOException {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE0ODExMw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412148113", "bodyText": "We could, but , this is the convention that we follow", "author": "noblepaul", "createdAt": "2020-04-21T12:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4MDAyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4818edf01bae0b50c48a0e48bd3170eccb43e828", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\nindex 088b008f316..9c532003edd 100644\n--- a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n+++ b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n", "chunk": "@@ -94,7 +90,7 @@ public class ContainerPluginsApi {\n     }\n \n     @Command(name = \"remove\")\n-    public void remove(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<String> payload) throws IOException {\n+    public void remove(PayloadObj<String> payload) throws IOException {\n       persistPlugins(map -> {\n         if (map.remove(payload.get()) == null) {\n           payload.addError(\"No such plugin: \" + payload.get());\n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\nindex 088b008f316..21c16e344d2 100644\n--- a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n+++ b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n", "chunk": "@@ -94,7 +92,7 @@ public class ContainerPluginsApi {\n     }\n \n     @Command(name = \"remove\")\n-    public void remove(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<String> payload) throws IOException {\n+    public void remove(PayloadObj<String> payload) throws IOException {\n       persistPlugins(map -> {\n         if (map.remove(payload.get()) == null) {\n           payload.addError(\"No such plugin: \" + payload.get());\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\ndeleted file mode 100644\nindex 21c16e344d2..00000000000\n--- a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n+++ /dev/null\n", "chunk": "@@ -1,179 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.handler.admin;\n-\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-\n-import org.apache.solr.api.AnnotatedApi;\n-import org.apache.solr.api.Command;\n-import org.apache.solr.api.CustomContainerPlugins;\n-import org.apache.solr.api.EndPoint;\n-import org.apache.solr.api.PayloadObj;\n-import org.apache.solr.client.solrj.SolrRequest.METHOD;\n-import org.apache.solr.client.solrj.request.beans.PluginMeta;\n-import org.apache.solr.common.cloud.SolrZkClient;\n-import org.apache.solr.common.cloud.ZkStateReader;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.core.CoreContainer;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.PermissionNameProvider;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.data.Stat;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n-\n-\n-public class ContainerPluginsApi {\n-  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-  public static final String PLUGIN = \"plugin\";\n-  private final Supplier<SolrZkClient> zkClientSupplier;\n-  private final CoreContainer coreContainer;\n-  public final Read readAPI = new Read();\n-  public final Edit editAPI = new Edit();\n-\n-  public ContainerPluginsApi(CoreContainer coreContainer) {\n-    this.zkClientSupplier = coreContainer.zkClientSupplier;\n-    this.coreContainer = coreContainer;\n-  }\n-\n-  public class Read {\n-    @EndPoint(method = METHOD.GET,\n-        path = \"/cluster/plugin\",\n-        permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-    public void list(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n-      rsp.add(PLUGIN, plugins(zkClientSupplier));\n-    }\n-  }\n-\n-  @EndPoint(method = METHOD.POST,\n-      path = \"/cluster/plugin\",\n-      permission = PermissionNameProvider.Name.COLL_EDIT_PERM)\n-  public class Edit {\n-\n-    @Command(name = \"add\")\n-    public void add(PayloadObj<PluginMeta> payload) throws IOException {\n-      PluginMeta info = payload.get();\n-      validateConfig(payload, info);\n-      if(payload.hasError()) return;\n-      persistPlugins(map -> {\n-        if (map.containsKey(info.name)) {\n-          payload.addError(info.name + \" already exists\");\n-          return null;\n-        }\n-        map.put(info.name, info);\n-        return map;\n-      });\n-    }\n-\n-    @Command(name = \"remove\")\n-    public void remove(PayloadObj<String> payload) throws IOException {\n-      persistPlugins(map -> {\n-        if (map.remove(payload.get()) == null) {\n-          payload.addError(\"No such plugin: \" + payload.get());\n-          return null;\n-        }\n-        return map;\n-      });\n-    }\n-\n-    @Command(name = \"update\")\n-    @SuppressWarnings(\"unchecked\")\n-    public void update(PayloadObj<PluginMeta> payload) throws IOException {\n-      PluginMeta info = payload.get();\n-      validateConfig(payload, info);\n-      if(payload.hasError()) return;\n-      persistPlugins(map -> {\n-        Map<String, Object> existing = (Map<String, Object>) map.get(info.name);\n-        if (existing == null) {\n-          payload.addError(\"No such plugin: \" + info.name);\n-          return null;\n-        } else {\n-          map.put(info.name, info);\n-          return map;\n-        }\n-      });\n-    }\n-  }\n-\n-  private void validateConfig(PayloadObj<PluginMeta> payload, PluginMeta info) {\n-    if (info.klass.indexOf(':') > 0) {\n-      if (info.version == null) {\n-        payload.addError(\"Using package. must provide a packageVersion\");\n-        return;\n-      }\n-    }\n-    List<String> errs = new ArrayList<>();\n-    CustomContainerPlugins.ApiInfo apiInfo = coreContainer.getCustomContainerPlugins().createInfo(info, errs);\n-    if (!errs.isEmpty()) {\n-      for (String err : errs) payload.addError(err);\n-      return;\n-    }\n-    AnnotatedApi api = null ;\n-    try {\n-      apiInfo.init();\n-    } catch (Exception e) {\n-      log.error(\"Error instantiating plugin \", e);\n-      errs.add(e.getMessage());\n-      return;\n-    } finally {\n-      closeWhileHandlingException(api);\n-    }\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static Map<String, Object> plugins(Supplier<SolrZkClient> zkClientSupplier) throws IOException {\n-    SolrZkClient zkClient = zkClientSupplier.get();\n-    try {\n-      Map<String, Object> clusterPropsJson = (Map<String, Object>) Utils.fromJSON(zkClient.getData(ZkStateReader.CLUSTER_PROPS, null, new Stat(), true));\n-      return (Map<String, Object>) clusterPropsJson.computeIfAbsent(PLUGIN, Utils.NEW_LINKED_HASHMAP_FUN);\n-    } catch (KeeperException.NoNodeException e) {\n-      return new LinkedHashMap<>();\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IOException(\"Error reading cluster property\", SolrZkClient.checkInterrupted(e));\n-    }\n-  }\n-\n-  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-  private void persistPlugins(Function<Map<String,Object>, Map<String,Object>> modifier) throws IOException {\n-    try {\n-      zkClientSupplier.get().atomicUpdate(ZkStateReader.CLUSTER_PROPS, bytes -> {\n-        Map rawJson = bytes == null ? new LinkedHashMap() :\n-            (Map) Utils.fromJSON(bytes);\n-        Map pluginsModified = modifier.apply((Map) rawJson.computeIfAbsent(PLUGIN, Utils.NEW_LINKED_HASHMAP_FUN));\n-        if (pluginsModified == null) return null;\n-        rawJson.put(PLUGIN, pluginsModified);\n-        return Utils.toJSON(rawJson);\n-      });\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IOException(\"Error reading cluster property\", SolrZkClient.checkInterrupted(e));\n-    }\n-  }\n-\n-\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "f71ba62d4ae3100ffe54bdf5df8254e2bbf6ec9d", "committedDate": "2020-09-05 09:19:45 -0400", "message": "SOLR-14579: Comment SolrJ 'Utils' generic map functions"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}, {"oid": "73d5e7ae77d8953cb9be35a7cbcebe3a516dd04a", "committedDate": "2020-11-17 00:19:50 +1100", "message": "SOLR-14977 :  ContainerPlugins should be configurable (#2065)"}, {"oid": "3df72502ccb72c2775db72b3347e99dc621d2d6b", "committedDate": "2020-12-01 20:07:08 +0100", "message": "SOLR-15004: tests for the replica placement API + placement plugin fixes and light refactoring (#2110)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NDE1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409684159", "body": "Why do we need this check? setCore already handles nulls.", "bodyText": "Why do we need this check? setCore already handles nulls.", "bodyHTML": "<p dir=\"auto\">Why do we need this check? setCore already handles nulls.</p>", "author": "madrob", "createdAt": "2020-04-16T16:19:38Z", "path": "solr/core/src/java/org/apache/solr/pkg/PackageListeners.java", "diffHunk": "@@ -63,13 +63,13 @@ public synchronized void removeListener(Listener listener) {\n   }\n \n   synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n-    MDCLoggingContext.setCore(core);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE0OTgyMA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412149820", "bodyText": "because we are calling a\nMDCLoggingContext.clear(); in finally", "author": "noblepaul", "createdAt": "2020-04-21T12:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NDE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MDY3OA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412490678", "bodyText": "I was under the impression that it setCore/clear still work even if the core was null.", "author": "madrob", "createdAt": "2020-04-21T21:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NDE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzNzQwNA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426237404", "bodyText": "OK, got it. I misunderstood the comment", "author": "noblepaul", "createdAt": "2020-05-17T09:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NDE1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f051b497f549762a727ce4b1248a0fc5fa513d24", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\nindex b54c4884ec8..ad1b67eb2df 100644\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n", "chunk": "@@ -63,7 +63,7 @@ public class PackageListeners {\n   }\n \n   synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n-    if(core != null) MDCLoggingContext.setCore(core);\n+    MDCLoggingContext.setCore(core);\n     try {\n       for (PackageLoader.Package pkgInfo : pkgs) {\n         invokeListeners(pkgInfo);\n", "next_change": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\nindex ad1b67eb2df..9094ae9d2f4 100644\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n", "chunk": "@@ -69,7 +70,7 @@ public class PackageListeners {\n         invokeListeners(pkgInfo);\n       }\n     } finally {\n-      if(core != null) MDCLoggingContext.clear();\n+      MDCLoggingContext.clear();\n     }\n   }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\nindex b54c4884ec8..b5b295f156f 100644\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n", "chunk": "@@ -63,13 +63,13 @@ public class PackageListeners {\n   }\n \n   synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n-    if(core != null) MDCLoggingContext.setCore(core);\n+    MDCLoggingContext.setCore(core);\n     try {\n       for (PackageLoader.Package pkgInfo : pkgs) {\n         invokeListeners(pkgInfo);\n       }\n     } finally {\n-      if(core != null) MDCLoggingContext.clear();\n+      MDCLoggingContext.clear();\n     }\n   }\n \n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\nindex b5b295f156f..1895b6d3069 100644\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n", "chunk": "@@ -64,21 +65,23 @@ public class PackageListeners {\n \n   synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n     MDCLoggingContext.setCore(core);\n+    Listener.Ctx ctx = new Listener.Ctx();\n     try {\n       for (PackageLoader.Package pkgInfo : pkgs) {\n-        invokeListeners(pkgInfo);\n+        invokeListeners(pkgInfo, ctx);\n       }\n     } finally {\n+      ctx.runLaterTasks(core::runAsync);\n       MDCLoggingContext.clear();\n     }\n   }\n \n-  private synchronized void invokeListeners(PackageLoader.Package pkg) {\n+  private synchronized void invokeListeners(PackageLoader.Package pkg, Listener.Ctx ctx) {\n     for (Reference<Listener> ref : listeners) {\n       Listener listener = ref.get();\n       if(listener == null) continue;\n       if (listener.packageName() == null || listener.packageName().equals(pkg.name())) {\n-        listener.changed(pkg);\n+        listener.changed(pkg, ctx);\n       }\n     }\n   }\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\ndeleted file mode 100644\nindex 1895b6d3069..00000000000\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ /dev/null\n", "chunk": "@@ -1,139 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.pkg;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.ref.Reference;\n-import java.lang.ref.SoftReference;\n-import java.util.*;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.function.Consumer;\n-\n-import org.apache.solr.common.MapWriter;\n-import org.apache.solr.core.PluginInfo;\n-import org.apache.solr.core.SolrCore;\n-import org.apache.solr.logging.MDCLoggingContext;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class PackageListeners {\n-  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-  public static final String PACKAGE_VERSIONS = \"PKG_VERSIONS\";\n-  private final SolrCore core;\n-\n-  public PackageListeners(SolrCore core) {\n-    this.core = core;\n-  }\n-\n-  // this registry only keeps a weak reference because it does not want to\n-  // cause a memory leak if the listener forgets to unregister itself\n-  private List<Reference<Listener>> listeners = new CopyOnWriteArrayList<>();\n-\n-  public synchronized void addListener(Listener listener) {\n-    listeners.add(new SoftReference<>(listener));\n-\n-  }\n-\n-  public synchronized void removeListener(Listener listener) {\n-    Iterator<Reference<Listener>> it = listeners.iterator();\n-    while (it.hasNext()) {\n-      Reference<Listener> ref = it.next();\n-      Listener pkgListener = ref.get();\n-      if (pkgListener == null || pkgListener == listener) {\n-        it.remove();\n-      }\n-\n-    }\n-\n-  }\n-\n-  synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n-    MDCLoggingContext.setCore(core);\n-    Listener.Ctx ctx = new Listener.Ctx();\n-    try {\n-      for (PackageLoader.Package pkgInfo : pkgs) {\n-        invokeListeners(pkgInfo, ctx);\n-      }\n-    } finally {\n-      ctx.runLaterTasks(core::runAsync);\n-      MDCLoggingContext.clear();\n-    }\n-  }\n-\n-  private synchronized void invokeListeners(PackageLoader.Package pkg, Listener.Ctx ctx) {\n-    for (Reference<Listener> ref : listeners) {\n-      Listener listener = ref.get();\n-      if(listener == null) continue;\n-      if (listener.packageName() == null || listener.packageName().equals(pkg.name())) {\n-        listener.changed(pkg, ctx);\n-      }\n-    }\n-  }\n-\n-  public List<Listener> getListeners() {\n-    List<Listener> result = new ArrayList<>();\n-    for (Reference<Listener> ref : listeners) {\n-      Listener l = ref.get();\n-      if (l != null) {\n-        result.add(l);\n-      }\n-    }\n-    return result;\n-  }\n-\n-\n-  public interface Listener {\n-    /**Name of the package or null to listen to all package changes */\n-    String packageName();\n-\n-    PluginInfo pluginInfo();\n-\n-    /**A callback when the package is updated */\n-    void changed(PackageLoader.Package pkg, Ctx ctx);\n-\n-    default MapWriter getPackageVersion(PluginInfo.ClassName cName) {\n-      return null;\n-    }\n-    class Ctx {\n-      private Map<String, Runnable> runLater;\n-\n-      /**\n-       * If there are multiple packages to be updated and there are multiple listeners,\n-       * This is executed after all of the {@link Listener#changed(PackageLoader.Package, Ctx)}\n-       * calls are invoked. The name is a unique identifier that can be used by consumers to avoid duplicate\n-       * If no deduplication is required, use null as the name\n-       */\n-      public void runLater(String name, Runnable runnable) {\n-        if (runLater == null) runLater = new LinkedHashMap<>();\n-        if (name == null) {\n-          name = runnable.getClass().getSimpleName() + \"@\" + runnable.hashCode();\n-        }\n-        runLater.put(name, runnable);\n-      }\n-\n-      private void runLaterTasks(Consumer<Runnable> runnableExecutor) {\n-        if (runLater == null) return;\n-        for (Runnable r : runLater.values()) {\n-          runnableExecutor.accept(r);\n-        }\n-      }\n-    }\n-\n-  }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "9466af576a4a9d3cd750438123063928329fbb46", "committedDate": "2021-01-13 22:28:01 +1100", "message": "SOLR-14155: Load all other SolrCore plugins from packages (#1666)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NzU2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409687566", "body": "I assume this is used to generate containerplugin.v.1.jar.bin and v.2? Should we have two source files for those? Can we do this some other way, besides checking in binaries to the repo?", "bodyText": "I assume this is used to generate containerplugin.v.1.jar.bin and v.2? Should we have two source files for those? Can we do this some other way, besides checking in binaries to the repo?", "bodyHTML": "<p dir=\"auto\">I assume this is used to generate containerplugin.v.1.jar.bin and v.2? Should we have two source files for those? Can we do this some other way, besides checking in binaries to the repo?</p>", "author": "madrob", "createdAt": "2020-04-16T16:24:42Z", "path": "solr/core/src/test-files/runtimecode/MyPlugin.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler;\n+\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+\n+@EndPoint(path = \"/plugin/my/path\",\n+    method = METHOD.GET,\n+    permission = PermissionNameProvider.Name.CONFIG_READ_PERM)\n+public class MyPlugin {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MTYwNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412151606", "bodyText": "This is for documentation purposes for anyone who wants to know what the code looks like. Yes, we could possibly have 2 files, but then , they will have to be different files and the class name can't match the file name\n\nCan we do this some other way,\n\nUnfortunately it's so hard. We need to ensure that these classes are never in the classpath. If we try to compile it some other way, it may come under the classpath and the purpose of the test is defeated. I'm not saying it is not possible, but it is not easy", "author": "noblepaul", "createdAt": "2020-04-21T12:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4NzU2Ng=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "4728a710e9ca2d84c275c55208a45c804bd5a3f0", "changed_code": [{"header": "diff --git a/solr/core/src/test-files/runtimecode/MyPlugin.java b/solr/core/src/test-files/runtimecode/MyPlugin.java\ndeleted file mode 100644\nindex cbaa3478afb..00000000000\n--- a/solr/core/src/test-files/runtimecode/MyPlugin.java\n+++ /dev/null\n", "chunk": "@@ -1,43 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.handler;\n-\n-import org.apache.solr.api.Command;\n-import org.apache.solr.api.EndPoint;\n-import org.apache.solr.client.solrj.SolrRequest.METHOD;\n-import org.apache.solr.core.CoreContainer;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.PermissionNameProvider;\n-\n-@EndPoint(path = \"/plugin/my/path\",\n-    method = METHOD.GET,\n-    permission = PermissionNameProvider.Name.CONFIG_READ_PERM)\n-public class MyPlugin {\n-\n-  private final CoreContainer coreContainer;\n-\n-  public MyPlugin(CoreContainer coreContainer) {\n-    this.coreContainer = coreContainer;\n-  }\n-\n-  @Command\n-  public void call(SolrQueryRequest req, SolrQueryResponse rsp){\n-    rsp.add(\"myplugin.version\", \"2.0\");\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "adf3361428e82c29d3972bf2d4fd8d2ec3362125", "committedDate": "2020-06-30 15:50:40 +0530", "message": "SOLR-14599: Package manager support for cluster level plugins"}, {"oid": "4728a710e9ca2d84c275c55208a45c804bd5a3f0", "committedDate": "2020-10-04 21:44:01 +1100", "message": "LUCENE-9559: \"gradle eclipse\" do not work if .java files are not in proper package"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4ODU2OA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409688568", "body": "use `expectThrows` here.", "bodyText": "use expectThrows here.", "bodyHTML": "<p dir=\"auto\">use <code>expectThrows</code> here.</p>", "author": "madrob", "createdAt": "2020-04-16T16:26:08Z", "path": "solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.client.solrj.SolrClient;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;\n+import org.apache.solr.client.solrj.request.V2Request;\n+import org.apache.solr.client.solrj.request.beans.Package;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.client.solrj.response.V2Response;\n+import org.apache.solr.cloud.MiniSolrCloudCluster;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.NavigableObject;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.filestore.PackageStoreAPI;\n+import org.apache.solr.filestore.TestDistribPackageStore;\n+import org.apache.solr.pkg.TestPackages;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.POST;\n+import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n+import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+public class TestContainerPlugin extends SolrCloudTestCase {\n+\n+  @Before\n+  public void setup() {\n+    System.setProperty(\"enable.packages\", \"true\");\n+  }\n+\n+  @After\n+  public void teardown() {\n+    System.clearProperty(\"enable.packages\");\n+  }\n+\n+  @Test\n+  public void testApi() throws Exception {\n+    MiniSolrCloudCluster cluster =\n+        configureCluster(4)\n+            .withJettyConfig(jetty -> jetty.enableV2(true))\n+            .configure();\n+    String errPath = \"/error/details[0]/errorMessages[0]\";\n+    try {\n+      PluginMeta plugin = new PluginMeta();\n+      plugin.name = \"testplugin\";\n+      plugin.klass = C2.class.getName();\n+      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"add\", plugin))\n+          .build();\n+      expectError(req, cluster.getSolrClient(), errPath, \"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n+\n+      plugin.klass = C1.class.getName();\n+      expectError(req, cluster.getSolrClient(), errPath, \"Invalid class, no @EndPoint annotation\");\n+\n+      plugin.klass = C3.class.getName();\n+      req.process(cluster.getSolrClient());\n+\n+      V2Response rsp = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient());\n+      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n+              .forceV2(true)\n+              .withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\"/testkey\", \"testval\"));\n+\n+      new V2Request.Builder(\"/cluster/plugin\")\n+          .withMethod(POST)\n+          .forceV2(true)\n+          .withPayload(\"{remove : testplugin}\")\n+          .build()\n+          .process(cluster.getSolrClient());\n+\n+      rsp = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient());\n+      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n+\n+    } finally {\n+      cluster.shutdown();\n+    }\n+  }\n+  @Test\n+  public void testApiFromPackage() throws Exception {\n+    MiniSolrCloudCluster cluster =\n+        configureCluster(4)\n+            .withJettyConfig(jetty -> jetty.enableV2(true))\n+            .configure();\n+    String FILE1 = \"/myplugin/v1.jar\";\n+    String FILE2 = \"/myplugin/v2.jar\";\n+\n+    String errPath = \"/error/details[0]/errorMessages[0]\";\n+    try {\n+      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n+      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n+      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.1.jar.bin\", FILE1,\n+          \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n+     TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n+          \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n+\n+      Package.AddVersion add = new Package.AddVersion();\n+      add.version = \"1.0\";\n+      add.pkg = \"mypkg\";\n+      add.files = List.of(FILE1);\n+      V2Request addPkgVersionReq = new V2Request.Builder(\"/cluster/package\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"add\", add))\n+          .build();\n+      addPkgVersionReq.process(cluster.getSolrClient());\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/cluster/package\").\n+              withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          Utils.makeMap(\n+              \":result:packages:mypkg[0]:version\", \"1.0\",\n+              \":result:packages:mypkg[0]:files[0]\", FILE1\n+          ));\n+\n+      PluginMeta plugin = new PluginMeta();\n+      plugin.name = \"myplugin\";\n+      plugin.klass = \"mypkg:org.apache.solr.handler.MyPlugin\";\n+      plugin.version = add.version;\n+      V2Request req1 = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"add\", plugin))\n+          .build();\n+      req1.process(cluster.getSolrClient());\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/cluster/plugin\").\n+              withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\n+              \"/plugin/myplugin/class\", plugin.klass,\n+              \"/plugin/myplugin/version\", plugin.version\n+          ));\n+      Callable<NavigableObject> invokePlugin = () -> new V2Request.Builder(\"/plugin/my/path\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build().process(cluster.getSolrClient());\n+      TestDistribPackageStore.assertResponseValues(10,\n+          invokePlugin,\n+          ImmutableMap.of(\"/myplugin.version\", \"1.0\"));\n+\n+      add.version = \"2.0\";\n+      add.files = List.of(FILE2);\n+      addPkgVersionReq.process(cluster.getSolrClient());\n+\n+      plugin.version = add.version;\n+      new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"update\", plugin))\n+          .build()\n+      .process(cluster.getSolrClient());\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/cluster/plugin\").\n+              withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\n+              \"/plugin/myplugin/class\", plugin.klass,\n+              \"/plugin/myplugin/version\", \"2.0\"\n+          ));\n+      TestDistribPackageStore.assertResponseValues(10,\n+          invokePlugin,\n+          ImmutableMap.of(\"/myplugin.version\", \"2.0\"));\n+    } finally {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  public static class C1 {\n+\n+  }\n+\n+  @EndPoint(\n+      method = GET,\n+      path = \"/plugin/my/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+  public class C2 {\n+\n+\n+  }\n+\n+  @EndPoint(\n+      method = GET,\n+      path = \"/plugin/my/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+  public static class C3 {\n+    @Command\n+    public void read(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      rsp.add(\"testkey\", \"testval\");\n+    }\n+\n+  }\n+\n+\n+  private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n+    try {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQzNDYxNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426434616", "bodyText": "expectThrows does not work here", "author": "noblepaul", "createdAt": "2020-05-18T07:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4ODU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2MjY4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443962681", "bodyText": "fixed", "author": "noblepaul", "createdAt": "2020-06-23T05:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4ODU2OA=="}], "type": "inlineReview", "revised_code": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex bcdfe9a1483..a95c6e045c2 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -237,6 +271,24 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n \n   }\n \n+  public static class C4 {\n+\n+    @EndPoint(method = GET,\n+        path = \"/plugin/$plugin-name/my/plugin\",\n+        permission = PermissionNameProvider.Name.READ_PERM)\n+    public void m1(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      rsp.add(\"method.name\", \"m1\");\n+    }\n+\n+    @EndPoint(method = GET,\n+        path = \"/plugin/$plugin-name/their/plugin\",\n+        permission = PermissionNameProvider.Name.READ_PERM)\n+    public void m2(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      rsp.add(\"method.name\", \"m2\");\n+    }\n+\n+  }\n+\n \n   private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n     try {\n", "next_change": {"commit": "4818edf01bae0b50c48a0e48bd3170eccb43e828", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex a95c6e045c2..d819ba2e6b9 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -289,6 +288,13 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n \n   }\n \n+    public static void waitForAllNodesToSync(MiniSolrCloudCluster cluster, String path, Map expected ) throws Exception {\n+        for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n+            String baseUrl = jettySolrRunner.getBaseUrl().toString().replace(\"/solr\", \"/api\");\n+            String url = baseUrl  + path + \"?wt=javabin\";\n+            TestDistribPackageStore.assertResponseValues(10, new Fetcher(url, jettySolrRunner), expected);\n+        }\n+    }\n \n   private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n     try {\n", "next_change": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex d819ba2e6b9..ffd64ec18e7 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -297,12 +296,8 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n     }\n \n   private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n-    try {\n-      req.process(client);\n-      fail(\"should have failed with message : \" + expectErrorMsg);\n-    } catch (BaseHttpSolrClient.RemoteExecutionException e) {\n-      String msg = e.getMetaData()._getStr(errPath, \"\");\n-      assertThat(msg, containsString(expectErrorMsg));\n-    }\n+    RemoteExecutionException e = expectThrows(RemoteExecutionException.class, () -> req.process(client));\n+    String msg = e.getMetaData()._getStr(errPath, \"\");\n+    assertTrue(expectErrorMsg, msg.contains(expectErrorMsg));\n   }\n }\n", "next_change": {"commit": "371c92b54587d90c376929ae99dfc9d2acc15a5e", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex ffd64ec18e7..a08bff78506 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -287,13 +287,14 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n \n   }\n \n-    public static void waitForAllNodesToSync(MiniSolrCloudCluster cluster, String path, Map expected ) throws Exception {\n-        for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n-            String baseUrl = jettySolrRunner.getBaseUrl().toString().replace(\"/solr\", \"/api\");\n-            String url = baseUrl  + path + \"?wt=javabin\";\n-            TestDistribPackageStore.assertResponseValues(10, new Fetcher(url, jettySolrRunner), expected);\n-        }\n+  @SuppressWarnings(\"unchecked\")\n+  public static void waitForAllNodesToSync(MiniSolrCloudCluster cluster, String path, Map expected) throws Exception {\n+    for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n+      String baseUrl = jettySolrRunner.getBaseUrl().toString().replace(\"/solr\", \"/api\");\n+      String url = baseUrl + path + \"?wt=javabin\";\n+      TestDistribPackageStore.assertResponseValues(10, new Fetcher(url, jettySolrRunner), expected);\n     }\n+  }\n \n   private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n     RemoteExecutionException e = expectThrows(RemoteExecutionException.class, () -> req.process(client));\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex bcdfe9a1483..2d417e149b1 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -237,14 +269,36 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n \n   }\n \n+  public static class C4 {\n \n-  private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n-    try {\n-      req.process(client);\n-      fail(\"should have failed with message : \" + expectErrorMsg);\n-    } catch (BaseHttpSolrClient.RemoteExecutionException e) {\n-      String msg = e.getMetaData()._getStr(errPath, \"\");\n-      assertThat(msg, containsString(expectErrorMsg));\n+    @EndPoint(method = GET,\n+        path = \"$plugin-name/my/plugin\",\n+        permission = PermissionNameProvider.Name.READ_PERM)\n+    public void m1(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      rsp.add(\"method.name\", \"m1\");\n     }\n+\n+    @EndPoint(method = GET,\n+        path = \"$plugin-name/their/plugin\",\n+        permission = PermissionNameProvider.Name.READ_PERM)\n+    public void m2(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      rsp.add(\"method.name\", \"m2\");\n+    }\n+\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static void waitForAllNodesToSync(MiniSolrCloudCluster cluster, String path, Map<String,Object> expected) throws Exception {\n+    for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n+      String baseUrl = jettySolrRunner.getBaseUrl().toString().replace(\"/solr\", \"/api\");\n+      String url = baseUrl + path + \"?wt=javabin\";\n+      TestDistribPackageStore.assertResponseValues(10, new Fetcher(url, jettySolrRunner), expected);\n+    }\n+  }\n+\n+  private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n+    RemoteExecutionException e = expectThrows(RemoteExecutionException.class, () -> req.process(client));\n+    String msg = e.getMetaData()._getStr(errPath, \"\");\n+    assertTrue(expectErrorMsg, msg.contains(expectErrorMsg));\n   }\n }\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\ndeleted file mode 100644\nindex 2d417e149b1..00000000000\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ /dev/null\n", "chunk": "@@ -1,304 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.handler;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.Callable;\n-\n-import com.google.common.collect.ImmutableMap;\n-import org.apache.solr.api.Command;\n-import org.apache.solr.api.EndPoint;\n-import org.apache.solr.client.solrj.SolrClient;\n-import org.apache.solr.client.solrj.SolrServerException;\n-import org.apache.solr.client.solrj.embedded.JettySolrRunner;\n-import org.apache.solr.client.solrj.impl.BaseHttpSolrClient.RemoteExecutionException;\n-import org.apache.solr.client.solrj.request.V2Request;\n-import org.apache.solr.client.solrj.request.beans.Package;\n-import org.apache.solr.client.solrj.request.beans.PluginMeta;\n-import org.apache.solr.client.solrj.response.V2Response;\n-import org.apache.solr.cloud.MiniSolrCloudCluster;\n-import org.apache.solr.cloud.SolrCloudTestCase;\n-import org.apache.solr.common.NavigableObject;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.filestore.PackageStoreAPI;\n-import org.apache.solr.filestore.TestDistribPackageStore;\n-import org.apache.solr.filestore.TestDistribPackageStore.Fetcher;\n-import org.apache.solr.pkg.TestPackages;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.PermissionNameProvider;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import static java.util.Collections.singletonMap;\n-import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n-import static org.apache.solr.client.solrj.SolrRequest.METHOD.POST;\n-import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n-import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n-\n-public class TestContainerPlugin extends SolrCloudTestCase {\n-\n-  @Before\n-  public void setup() {\n-    System.setProperty(\"enable.packages\", \"true\");\n-  }\n-\n-  @After\n-  public void teardown() {\n-    System.clearProperty(\"enable.packages\");\n-  }\n-\n-  @Test\n-  public void testApi() throws Exception {\n-    MiniSolrCloudCluster cluster =\n-        configureCluster(4)\n-            .withJettyConfig(jetty -> jetty.enableV2(true))\n-            .configure();\n-    String errPath = \"/error/details[0]/errorMessages[0]\";\n-    try {\n-      PluginMeta plugin = new PluginMeta();\n-      plugin.name = \"testplugin\";\n-      plugin.klass = C2.class.getName();\n-      //test with an invalid class\n-      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"add\", plugin))\n-          .build();\n-      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n-\n-      //test with an invalid class\n-      plugin.klass = C1.class.getName();\n-      expectError(req, cluster.getSolrClient(), errPath, \"No @EndPoints\");\n-\n-      //test with a valid class. This should succeed now\n-      plugin.klass = C3.class.getName();\n-      req.process(cluster.getSolrClient());\n-\n-      //just check if the plugin is indeed registered\n-      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(GET)\n-          .build();\n-      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n-      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n-\n-      //let's test the plugin\n-      TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n-              .forceV2(true)\n-              .withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          ImmutableMap.of(\"/testkey\", \"testval\"));\n-\n-      //now remove the plugin\n-      new V2Request.Builder(\"/cluster/plugin\")\n-          .withMethod(POST)\n-          .forceV2(true)\n-          .withPayload(\"{remove : testplugin}\")\n-          .build()\n-          .process(cluster.getSolrClient());\n-\n-      //verify it is removed\n-      rsp = readPluginState.process(cluster.getSolrClient());\n-      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n-\n-      //test with a class  @EndPoint methods. This also uses a template in the path name\n-      plugin.klass = C4.class.getName();\n-      plugin.name = \"collections\";\n-      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n-\n-      plugin.name = \"my-random-name\";\n-      req.process(cluster.getSolrClient());\n-\n-      //let's test the plugin\n-      TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n-              .forceV2(true)\n-              .withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          ImmutableMap.of(\"/method.name\", \"m1\"));\n-\n-  TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/my-random-name/their/plugin\")\n-              .forceV2(true)\n-              .withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          ImmutableMap.of(\"/method.name\", \"m2\"));\n-\n-    } finally {\n-      cluster.shutdown();\n-    }\n-  }\n-  @Test\n-  public void testApiFromPackage() throws Exception {\n-    MiniSolrCloudCluster cluster =\n-        configureCluster(4)\n-            .withJettyConfig(jetty -> jetty.enableV2(true))\n-            .configure();\n-    String FILE1 = \"/myplugin/v1.jar\";\n-    String FILE2 = \"/myplugin/v2.jar\";\n-\n-    String errPath = \"/error/details[0]/errorMessages[0]\";\n-    try {\n-      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n-      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n-      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.1.jar.bin\", FILE1,\n-          \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n-     TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n-          \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n-\n-     // We have two versions of the plugin in 2 different jar files. they are already uploaded to the package store\n-      Package.AddVersion add = new Package.AddVersion();\n-      add.version = \"1.0\";\n-      add.pkg = \"mypkg\";\n-      add.files = List.of(FILE1);\n-      V2Request addPkgVersionReq = new V2Request.Builder(\"/cluster/package\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"add\", add))\n-          .build();\n-      addPkgVersionReq.process(cluster.getSolrClient());\n-\n-      waitForAllNodesToSync(cluster, \"/cluster/package\", Utils.makeMap(\n-              \":result:packages:mypkg[0]:version\", \"1.0\",\n-              \":result:packages:mypkg[0]:files[0]\", FILE1\n-      ));\n-\n-      // Now lets create a plugin using v1 jar file\n-      PluginMeta plugin = new PluginMeta();\n-      plugin.name = \"myplugin\";\n-      plugin.klass = \"mypkg:org.apache.solr.handler.MyPlugin\";\n-      plugin.version = add.version;\n-      V2Request req1 = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"add\", plugin))\n-          .build();\n-      req1.process(cluster.getSolrClient());\n-      //verify the plugin creation\n-      TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/cluster/plugin\").\n-              withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          ImmutableMap.of(\n-              \"/plugin/myplugin/class\", plugin.klass,\n-              \"/plugin/myplugin/version\", plugin.version\n-          ));\n-      //let's test this now\n-      Callable<NavigableObject> invokePlugin = () -> new V2Request.Builder(\"/plugin/my/path\")\n-          .forceV2(true)\n-          .withMethod(GET)\n-          .build().process(cluster.getSolrClient());\n-      TestDistribPackageStore.assertResponseValues(10,\n-          invokePlugin,\n-          ImmutableMap.of(\"/myplugin.version\", \"1.0\"));\n-\n-      //now let's upload the jar file for version 2.0 of the plugin\n-      add.version = \"2.0\";\n-      add.files = List.of(FILE2);\n-      addPkgVersionReq.process(cluster.getSolrClient());\n-\n-      //here the plugin version is updated\n-      plugin.version = add.version;\n-      new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"update\", plugin))\n-          .build()\n-      .process(cluster.getSolrClient());\n-\n-      //now verify if it is indeed updated\n-      TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/cluster/plugin\").\n-              withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          ImmutableMap.of(\n-              \"/plugin/myplugin/class\", plugin.klass,\n-              \"/plugin/myplugin/version\", \"2.0\"\n-          ));\n-      // invoke the plugin and test thye output\n-      TestDistribPackageStore.assertResponseValues(10,\n-          invokePlugin,\n-          ImmutableMap.of(\"/myplugin.version\", \"2.0\"));\n-    } finally {\n-      cluster.shutdown();\n-    }\n-  }\n-\n-  public static class C1 {\n-\n-  }\n-\n-  @EndPoint(\n-      method = GET,\n-      path = \"/plugin/my/plugin\",\n-      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-  public class C2 {\n-\n-\n-  }\n-\n-  @EndPoint(\n-      method = GET,\n-      path = \"/plugin/my/plugin\",\n-      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-  public static class C3 {\n-    @Command\n-    public void read(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"testkey\", \"testval\");\n-    }\n-\n-  }\n-\n-  public static class C4 {\n-\n-    @EndPoint(method = GET,\n-        path = \"$plugin-name/my/plugin\",\n-        permission = PermissionNameProvider.Name.READ_PERM)\n-    public void m1(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"method.name\", \"m1\");\n-    }\n-\n-    @EndPoint(method = GET,\n-        path = \"$plugin-name/their/plugin\",\n-        permission = PermissionNameProvider.Name.READ_PERM)\n-    public void m2(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"method.name\", \"m2\");\n-    }\n-\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static void waitForAllNodesToSync(MiniSolrCloudCluster cluster, String path, Map<String,Object> expected) throws Exception {\n-    for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n-      String baseUrl = jettySolrRunner.getBaseUrl().toString().replace(\"/solr\", \"/api\");\n-      String url = baseUrl + path + \"?wt=javabin\";\n-      TestDistribPackageStore.assertResponseValues(10, new Fetcher(url, jettySolrRunner), expected);\n-    }\n-  }\n-\n-  private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n-    RemoteExecutionException e = expectThrows(RemoteExecutionException.class, () -> req.process(client));\n-    String msg = e.getMetaData()._getStr(errPath, \"\");\n-    assertTrue(expectErrorMsg, msg.contains(expectErrorMsg));\n-  }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "584e4d5f3c954e02ac16437366ed84b75eeee2c5", "committedDate": "2020-06-28 15:22:42 +1000", "message": "syncing with branch_8x"}, {"oid": "d883cd69fc2884352e0a363b98e3d5a37142dd52", "committedDate": "2020-06-29 14:03:17 +1000", "message": "SOLR-14481: use classloader to open resource"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "ccdfee2cf06a77da81f9bd7566d028d4093fb607", "committedDate": "2020-07-02 12:24:05 +0530", "message": "Remove Redundant Import in TestContainerPlugin"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "e826b1f3446cf5ac2e95b205dfec442f6719ec25", "committedDate": "2020-10-22 12:35:47 +1100", "message": "refactor method names"}, {"oid": "052efd62aec3262744049a9b6002348df1d6e1c4", "committedDate": "2020-10-22 15:25:31 +1100", "message": "Revert \"refactor method names\""}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}, {"oid": "73d5e7ae77d8953cb9be35a7cbcebe3a516dd04a", "committedDate": "2020-11-17 00:19:50 +1100", "message": "SOLR-14977 :  ContainerPlugins should be configurable (#2065)"}, {"oid": "cced5078ea13797a49658cdf76f693a79788c533", "committedDate": "2020-12-06 14:51:10 +0100", "message": "SOLR-15016: Replica placement plugins should use container plugins API / configs."}, {"oid": "7ada4032180b516548fc0263f42da6a7a917f92b", "committedDate": "2021-03-09 16:58:29 +0100", "message": "SOLR-14749: Make sure the plugin config is reloaded on Overseer."}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4OTQ0MQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409689441", "body": "cluster setup and teardown can go in Before/After methods", "bodyText": "cluster setup and teardown can go in Before/After methods", "bodyHTML": "<p dir=\"auto\">cluster setup and teardown can go in Before/After methods</p>", "author": "madrob", "createdAt": "2020-04-16T16:27:30Z", "path": "solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.client.solrj.SolrClient;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;\n+import org.apache.solr.client.solrj.request.V2Request;\n+import org.apache.solr.client.solrj.request.beans.Package;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.client.solrj.response.V2Response;\n+import org.apache.solr.cloud.MiniSolrCloudCluster;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.NavigableObject;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.filestore.PackageStoreAPI;\n+import org.apache.solr.filestore.TestDistribPackageStore;\n+import org.apache.solr.pkg.TestPackages;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.POST;\n+import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n+import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+public class TestContainerPlugin extends SolrCloudTestCase {\n+\n+  @Before\n+  public void setup() {\n+    System.setProperty(\"enable.packages\", \"true\");\n+  }\n+\n+  @After\n+  public void teardown() {\n+    System.clearProperty(\"enable.packages\");\n+  }\n+\n+  @Test\n+  public void testApi() throws Exception {\n+    MiniSolrCloudCluster cluster =", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTY5Mg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426209692", "bodyText": "These clusters are created on a per testcase basis. We don't want remnants of other tests to screw up other tests", "author": "noblepaul", "createdAt": "2020-05-17T02:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY4OTQ0MQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "7ada4032180b516548fc0263f42da6a7a917f92b", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex bcdfe9a1483..fb63e0ead88 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -67,168 +84,433 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n   @Test\n   public void testApi() throws Exception {\n     MiniSolrCloudCluster cluster =\n-        configureCluster(4)\n-            .withJettyConfig(jetty -> jetty.enableV2(true))\n-            .configure();\n+            configureCluster(4)\n+                    .withJettyConfig(jetty -> jetty.enableV2(true))\n+                    .configure();\n+    ContainerPluginsRegistry pluginsRegistry = cluster.getOpenOverseer().getCoreContainer().getContainerPluginsRegistry();\n+    pluginsRegistry.setPhaser(phaser);\n+\n+    int version = phaser.getPhase();\n+\n     String errPath = \"/error/details[0]/errorMessages[0]\";\n     try {\n       PluginMeta plugin = new PluginMeta();\n       plugin.name = \"testplugin\";\n       plugin.klass = C2.class.getName();\n+      //test with an invalid class\n       V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"add\", plugin))\n-          .build();\n-      expectError(req, cluster.getSolrClient(), errPath, \"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n-\n-      plugin.klass = C1.class.getName();\n-      expectError(req, cluster.getSolrClient(), errPath, \"Invalid class, no @EndPoint annotation\");\n+              .forceV2(true)\n+              .POST()\n+              .withPayload(singletonMap(\"add\", plugin))\n+              .build();\n+      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n \n+      //test with a valid class. This should succeed now\n       plugin.klass = C3.class.getName();\n       req.process(cluster.getSolrClient());\n \n-      V2Response rsp = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(GET)\n-          .build()\n-          .process(cluster.getSolrClient());\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+\n+      //just check if the plugin is indeed registered\n+      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n+              .forceV2(true)\n+              .GET()\n+              .build();\n+      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n       assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n \n+      //let's test the plugin\n       TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n-              .forceV2(true)\n-              .withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          ImmutableMap.of(\"/testkey\", \"testval\"));\n+              () -> new V2Request.Builder(\"/plugin/my/plugin\")\n+                      .forceV2(true)\n+                      .GET()\n+                      .build().process(cluster.getSolrClient()),\n+              ImmutableMap.of(\"/testkey\", \"testval\"));\n \n+      //now remove the plugin\n       new V2Request.Builder(\"/cluster/plugin\")\n-          .withMethod(POST)\n-          .forceV2(true)\n-          .withPayload(\"{remove : testplugin}\")\n-          .build()\n-          .process(cluster.getSolrClient());\n-\n-      rsp = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(GET)\n-          .build()\n-          .process(cluster.getSolrClient());\n+              .POST()\n+              .forceV2(true)\n+              .withPayload(\"{remove : testplugin}\")\n+              .build()\n+              .process(cluster.getSolrClient());\n+\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+\n+      //verify it is removed\n+      rsp = readPluginState.process(cluster.getSolrClient());\n       assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n \n+      //test with a class  @EndPoint methods. This also uses a template in the path name\n+      plugin.klass = C4.class.getName();\n+      plugin.name = \"collections\";\n+      plugin.pathPrefix = \"collections\";\n+      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n+\n+      plugin.name = \"my-random-name\";\n+      plugin.pathPrefix = \"my-random-prefix\";\n+\n+      req.process(cluster.getSolrClient());\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+\n+      //let's test the plugin\n+      TestDistribPackageStore.assertResponseValues(10,\n+              () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n+                      .forceV2(true)\n+                      .GET()\n+                      .build().process(cluster.getSolrClient()),\n+              ImmutableMap.of(\"/method.name\", \"m1\"));\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+              () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n+                      .forceV2(true)\n+                      .GET()\n+                      .build().process(cluster.getSolrClient()),\n+              ImmutableMap.of(\"/method.name\", \"m2\"));\n+      //now remove the plugin\n+      new V2Request.Builder(\"/cluster/plugin\")\n+              .POST()\n+              .forceV2(true)\n+              .withPayload(\"{remove : my-random-name}\")\n+              .build()\n+              .process(cluster.getSolrClient());\n+\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+\n+      expectFail(() -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n+              .forceV2(true)\n+              .GET()\n+              .build()\n+              .process(cluster.getSolrClient()));\n+      expectFail(() -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n+              .forceV2(true)\n+              .GET()\n+              .build()\n+              .process(cluster.getSolrClient()));\n+\n+      // test ClusterSingleton plugin\n+      plugin.name = \"clusterSingleton\";\n+      plugin.klass = C6.class.getName();\n+      req.process(cluster.getSolrClient());\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+\n+\n+        //just check if the plugin is indeed registered\n+      readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n+              .forceV2(true)\n+              .GET()\n+              .build();\n+      rsp = readPluginState.process(cluster.getSolrClient());\n+      assertEquals(C6.class.getName(), rsp._getStr(\"/plugin/clusterSingleton/class\", null));\n+\n+      assertTrue(\"ccProvided\", C6.ccProvided);\n+      assertTrue(\"startCalled\", C6.startCalled);\n+      assertFalse(\"stopCalled\", C6.stopCalled);\n+\n+      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC()));\n+      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC1()));\n+      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC2()));\n+\n+      CConfig cfg = new CConfig();\n+      cfg.boolVal = Boolean.TRUE;\n+      cfg.strVal = \"Something\";\n+      cfg.longVal = 1234L;\n+      PluginMeta p = new PluginMeta();\n+      p.name = \"hello\";\n+      p.klass = CC.class.getName();\n+      p.config = cfg;\n+\n+      new V2Request.Builder(\"/cluster/plugin\")\n+              .forceV2(true)\n+              .POST()\n+              .withPayload(singletonMap(\"add\", p))\n+              .build()\n+              .process(cluster.getSolrClient());\n+\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+\n+        TestDistribPackageStore.assertResponseValues(10,\n+              () -> new V2Request.Builder(\"hello/plugin\")\n+                      .forceV2(true)\n+                      .GET()\n+                      .build().process(cluster.getSolrClient()),\n+              ImmutableMap.of(\"/config/boolVal\", \"true\", \"/config/strVal\", \"Something\", \"/config/longVal\", \"1234\"));\n+\n+      cfg.strVal = \"Something else\";\n+      new V2Request.Builder(\"/cluster/plugin\")\n+              .forceV2(true)\n+              .POST()\n+              .withPayload(singletonMap(\"update\", p))\n+              .build()\n+              .process(cluster.getSolrClient());\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+              () -> new V2Request.Builder(\"hello/plugin\")\n+                      .forceV2(true)\n+                      .GET()\n+                      .build().process(cluster.getSolrClient()),\n+              ImmutableMap.of(\"/config/boolVal\", \"true\", \"/config/strVal\", cfg.strVal, \"/config/longVal\", \"1234\"));\n+\n+      // kill the Overseer leader\n+      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n+        if (!jetty.getCoreContainer().getZkController().getOverseer().isClosed()) {\n+          cluster.stopJettySolrRunner(jetty);\n+          cluster.waitForJettyToStop(jetty);\n+        }\n+      }\n+      assertTrue(\"stopCalled\", C6.stopCalled);\n     } finally {\n       cluster.shutdown();\n     }\n   }\n+\n+  private void expectFail(ThrowingRunnable runnable) throws Exception {\n+    for (int i = 0; i < 20; i++) {\n+      try {\n+        runnable.run();\n+      } catch (Throwable throwable) {\n+        return;\n+      }\n+      Thread.sleep(100);\n+    }\n+    fail(\"should have failed with an exception\");\n+  }\n+\n   @Test\n   public void testApiFromPackage() throws Exception {\n     MiniSolrCloudCluster cluster =\n-        configureCluster(4)\n-            .withJettyConfig(jetty -> jetty.enableV2(true))\n-            .configure();\n+            configureCluster(4)\n+                    .withJettyConfig(jetty -> jetty.enableV2(true))\n+                    .configure();\n     String FILE1 = \"/myplugin/v1.jar\";\n     String FILE2 = \"/myplugin/v2.jar\";\n+    ContainerPluginsRegistry pluginsRegistry = cluster.getOpenOverseer().getCoreContainer().getContainerPluginsRegistry();\n+    pluginsRegistry.setPhaser(phaser);\n+\n+    int version = phaser.getPhase();\n+\n \n     String errPath = \"/error/details[0]/errorMessages[0]\";\n     try {\n       byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n-      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n+      uploadKey(derFile, PackageStoreAPI.KEYS_DIR + \"/pub_key512.der\", cluster);\n       TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.1.jar.bin\", FILE1,\n-          \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n-     TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n-          \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n+              \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n+      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n+              \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n \n+      // We have two versions of the plugin in 2 different jar files. they are already uploaded to the package store\n       Package.AddVersion add = new Package.AddVersion();\n       add.version = \"1.0\";\n       add.pkg = \"mypkg\";\n-      add.files = List.of(FILE1);\n+      add.files = singletonList(FILE1);\n       V2Request addPkgVersionReq = new V2Request.Builder(\"/cluster/package\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"add\", add))\n-          .build();\n+              .forceV2(true)\n+              .POST()\n+              .withPayload(singletonMap(\"add\", add))\n+              .build();\n       addPkgVersionReq.process(cluster.getSolrClient());\n \n-      TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/cluster/package\").\n-              withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          Utils.makeMap(\n+      waitForAllNodesToSync(cluster, \"/cluster/package\", Utils.makeMap(\n               \":result:packages:mypkg[0]:version\", \"1.0\",\n               \":result:packages:mypkg[0]:files[0]\", FILE1\n-          ));\n+      ));\n \n+      // Now lets create a plugin using v1 jar file\n       PluginMeta plugin = new PluginMeta();\n       plugin.name = \"myplugin\";\n       plugin.klass = \"mypkg:org.apache.solr.handler.MyPlugin\";\n       plugin.version = add.version;\n-      V2Request req1 = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"add\", plugin))\n-          .build();\n+      final V2Request req1 = new V2Request.Builder(\"/cluster/plugin\")\n+              .forceV2(true)\n+              .POST()\n+              .withPayload(singletonMap(\"add\", plugin))\n+              .build();\n       req1.process(cluster.getSolrClient());\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+\n+        //verify the plugin creation\n       TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/cluster/plugin\").\n-              withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          ImmutableMap.of(\n-              \"/plugin/myplugin/class\", plugin.klass,\n-              \"/plugin/myplugin/version\", plugin.version\n-          ));\n+              () -> new V2Request.Builder(\"/cluster/plugin\").\n+                      GET()\n+                      .build().process(cluster.getSolrClient()),\n+              ImmutableMap.of(\n+                      \"/plugin/myplugin/class\", plugin.klass,\n+                      \"/plugin/myplugin/version\", plugin.version\n+              ));\n+      //let's test this now\n       Callable<NavigableObject> invokePlugin = () -> new V2Request.Builder(\"/plugin/my/path\")\n-          .forceV2(true)\n-          .withMethod(GET)\n-          .build().process(cluster.getSolrClient());\n+              .forceV2(true)\n+              .GET()\n+              .build().process(cluster.getSolrClient());\n       TestDistribPackageStore.assertResponseValues(10,\n-          invokePlugin,\n-          ImmutableMap.of(\"/myplugin.version\", \"1.0\"));\n+              invokePlugin,\n+              ImmutableMap.of(\"/myplugin.version\", \"1.0\"));\n \n+      //now let's upload the jar file for version 2.0 of the plugin\n       add.version = \"2.0\";\n-      add.files = List.of(FILE2);\n+      add.files = singletonList(FILE2);\n       addPkgVersionReq.process(cluster.getSolrClient());\n \n+      //here the plugin version is updated\n       plugin.version = add.version;\n       new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"update\", plugin))\n-          .build()\n-      .process(cluster.getSolrClient());\n+              .forceV2(true)\n+              .POST()\n+              .withPayload(singletonMap(\"update\", plugin))\n+              .build()\n+              .process(cluster.getSolrClient());\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n \n+      //now verify if it is indeed updated\n       TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/cluster/plugin\").\n-              withMethod(GET)\n-              .build().process(cluster.getSolrClient()),\n-          ImmutableMap.of(\n-              \"/plugin/myplugin/class\", plugin.klass,\n-              \"/plugin/myplugin/version\", \"2.0\"\n-          ));\n+              () -> new V2Request.Builder(\"/cluster/plugin\").\n+                      GET()\n+                      .build().process(cluster.getSolrClient()),\n+              ImmutableMap.of(\n+                      \"/plugin/myplugin/class\", plugin.klass,\n+                      \"/plugin/myplugin/version\", \"2.0\"\n+              ));\n+      // invoke the plugin and test thye output\n       TestDistribPackageStore.assertResponseValues(10,\n-          invokePlugin,\n-          ImmutableMap.of(\"/myplugin.version\", \"2.0\"));\n+              invokePlugin,\n+              ImmutableMap.of(\"/myplugin.version\", \"2.0\"));\n+\n+      plugin.name = \"plugin2\";\n+      plugin.klass = \"mypkg:\" + C5.class.getName();\n+      plugin.version = \"2.0\";\n+      req1.process(cluster.getSolrClient());\n+      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n+      assertNotNull(C5.classData);\n+      assertEquals(1452, C5.classData.limit());\n     } finally {\n       cluster.shutdown();\n     }\n   }\n \n+  public static class CC1 extends CC {\n+\n+  }\n+\n+  public static class CC2 extends CC1 {\n+\n+  }\n+\n+  public static class CC implements ConfigurablePlugin<CConfig> {\n+    private CConfig cfg;\n+\n+\n+    @Override\n+    public void configure(CConfig cfg) {\n+      this.cfg = cfg;\n+\n+    }\n+\n+    @EndPoint(method = GET,\n+            path = \"/hello/plugin\",\n+            permission = PermissionNameProvider.Name.READ_PERM)\n+    public void m2(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      rsp.add(\"config\", cfg);\n+    }\n+\n+  }\n+\n+  public static class CConfig implements ReflectMapWriter {\n+\n+    @JsonProperty\n+    public String strVal;\n+\n+    @JsonProperty\n+    public Long longVal;\n+\n+    @JsonProperty\n+    public Boolean boolVal;\n+  }\n+\n+  public static class C6 implements ClusterSingleton {\n+    static boolean startCalled = false;\n+    static boolean stopCalled = false;\n+    static boolean ccProvided = false;\n+\n+    private State state = State.STOPPED;\n+\n+    public C6(CoreContainer cc) {\n+      if (cc != null) {\n+        ccProvided = true;\n+      }\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return \"C6\";\n+    }\n+\n+    @Override\n+    public void start() throws Exception {\n+      state = State.STARTING;\n+      startCalled = true;\n+      state = State.RUNNING;\n+    }\n+\n+    @Override\n+    public State getState() {\n+      return state;\n+    }\n+\n+    @Override\n+    public void stop() {\n+      state = State.STOPPING;\n+      stopCalled = true;\n+      state = State.STOPPED;\n+    }\n+  }\n+\n+\n+  public static class C5 implements ResourceLoaderAware {\n+    static ByteBuffer classData;\n+    private SolrResourceLoader resourceLoader;\n+\n+    @Override\n+    public void inform(ResourceLoader loader) throws IOException {\n+      this.resourceLoader = (SolrResourceLoader) loader;\n+      try {\n+        InputStream is = resourceLoader.openResource(\"org/apache/solr/handler/MyPlugin.class\");\n+        byte[] buf = new byte[1024 * 5];\n+        int sz = IOUtils.read(is, buf);\n+        classData = ByteBuffer.wrap(buf, 0, sz);\n+      } catch (IOException e) {\n+        //do not do anything\n+      }\n+    }\n+\n+    @EndPoint(method = GET,\n+            path = \"/$plugin-name/m2\",\n+            permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+    public void m2() {\n+\n+\n+    }\n+\n+  }\n+\n   public static class C1 {\n \n   }\n \n   @EndPoint(\n-      method = GET,\n-      path = \"/plugin/my/plugin\",\n-      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+          method = GET,\n+          path = \"/plugin/my/plugin\",\n+          permission = PermissionNameProvider.Name.COLL_READ_PERM)\n   public class C2 {\n \n \n   }\n \n   @EndPoint(\n-      method = GET,\n-      path = \"/plugin/my/plugin\",\n-      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+          method = GET,\n+          path = \"/plugin/my/plugin\",\n+          permission = PermissionNameProvider.Name.COLL_READ_PERM)\n   public static class C3 {\n     @Command\n     public void read(SolrQueryRequest req, SolrQueryResponse rsp) {\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\ndeleted file mode 100644\nindex fb63e0ead88..00000000000\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ /dev/null\n", "chunk": "@@ -1,554 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.handler;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.util.Map;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.Phaser;\n-import java.util.concurrent.TimeUnit;\n-\n-import com.google.common.collect.ImmutableMap;\n-import org.apache.commons.io.IOUtils;\n-import org.apache.lucene.util.ResourceLoader;\n-import org.apache.lucene.util.ResourceLoaderAware;\n-import org.apache.solr.api.Command;\n-import org.apache.solr.api.ConfigurablePlugin;\n-import org.apache.solr.api.ContainerPluginsRegistry;\n-import org.apache.solr.api.EndPoint;\n-import org.apache.solr.client.solrj.SolrClient;\n-import org.apache.solr.client.solrj.SolrServerException;\n-import org.apache.solr.client.solrj.embedded.JettySolrRunner;\n-import org.apache.solr.client.solrj.impl.BaseHttpSolrClient.RemoteExecutionException;\n-import org.apache.solr.client.solrj.request.V2Request;\n-import org.apache.solr.client.solrj.request.beans.Package;\n-import org.apache.solr.client.solrj.request.beans.PluginMeta;\n-import org.apache.solr.client.solrj.response.V2Response;\n-import org.apache.solr.cloud.ClusterSingleton;\n-import org.apache.solr.cloud.MiniSolrCloudCluster;\n-import org.apache.solr.cloud.SolrCloudTestCase;\n-import org.apache.solr.common.NavigableObject;\n-import org.apache.solr.common.annotation.JsonProperty;\n-import org.apache.solr.common.util.ReflectMapWriter;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.core.CoreContainer;\n-import org.apache.solr.core.SolrResourceLoader;\n-import org.apache.solr.filestore.PackageStoreAPI;\n-import org.apache.solr.filestore.TestDistribPackageStore;\n-import org.apache.solr.filestore.TestDistribPackageStore.Fetcher;\n-import org.apache.solr.pkg.TestPackages;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.PermissionNameProvider;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import static java.util.Collections.singletonList;\n-import static java.util.Collections.singletonMap;\n-import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n-import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n-import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n-\n-public class TestContainerPlugin extends SolrCloudTestCase {\n-  private Phaser phaser;\n-\n-  @Before\n-  public void setup() {\n-    System.setProperty(\"enable.packages\", \"true\");\n-    phaser = new Phaser();\n-  }\n-\n-  @After\n-  public void teardown() {\n-    System.clearProperty(\"enable.packages\");\n-  }\n-\n-  @Test\n-  public void testApi() throws Exception {\n-    MiniSolrCloudCluster cluster =\n-            configureCluster(4)\n-                    .withJettyConfig(jetty -> jetty.enableV2(true))\n-                    .configure();\n-    ContainerPluginsRegistry pluginsRegistry = cluster.getOpenOverseer().getCoreContainer().getContainerPluginsRegistry();\n-    pluginsRegistry.setPhaser(phaser);\n-\n-    int version = phaser.getPhase();\n-\n-    String errPath = \"/error/details[0]/errorMessages[0]\";\n-    try {\n-      PluginMeta plugin = new PluginMeta();\n-      plugin.name = \"testplugin\";\n-      plugin.klass = C2.class.getName();\n-      //test with an invalid class\n-      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"add\", plugin))\n-              .build();\n-      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n-\n-      //test with a valid class. This should succeed now\n-      plugin.klass = C3.class.getName();\n-      req.process(cluster.getSolrClient());\n-\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      //just check if the plugin is indeed registered\n-      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .GET()\n-              .build();\n-      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n-      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n-\n-      //let's test the plugin\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/plugin/my/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/testkey\", \"testval\"));\n-\n-      //now remove the plugin\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .POST()\n-              .forceV2(true)\n-              .withPayload(\"{remove : testplugin}\")\n-              .build()\n-              .process(cluster.getSolrClient());\n-\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      //verify it is removed\n-      rsp = readPluginState.process(cluster.getSolrClient());\n-      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n-\n-      //test with a class  @EndPoint methods. This also uses a template in the path name\n-      plugin.klass = C4.class.getName();\n-      plugin.name = \"collections\";\n-      plugin.pathPrefix = \"collections\";\n-      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n-\n-      plugin.name = \"my-random-name\";\n-      plugin.pathPrefix = \"my-random-prefix\";\n-\n-      req.process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      //let's test the plugin\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/method.name\", \"m1\"));\n-\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/method.name\", \"m2\"));\n-      //now remove the plugin\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .POST()\n-              .forceV2(true)\n-              .withPayload(\"{remove : my-random-name}\")\n-              .build()\n-              .process(cluster.getSolrClient());\n-\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      expectFail(() -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n-              .forceV2(true)\n-              .GET()\n-              .build()\n-              .process(cluster.getSolrClient()));\n-      expectFail(() -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n-              .forceV2(true)\n-              .GET()\n-              .build()\n-              .process(cluster.getSolrClient()));\n-\n-      // test ClusterSingleton plugin\n-      plugin.name = \"clusterSingleton\";\n-      plugin.klass = C6.class.getName();\n-      req.process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-\n-        //just check if the plugin is indeed registered\n-      readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .GET()\n-              .build();\n-      rsp = readPluginState.process(cluster.getSolrClient());\n-      assertEquals(C6.class.getName(), rsp._getStr(\"/plugin/clusterSingleton/class\", null));\n-\n-      assertTrue(\"ccProvided\", C6.ccProvided);\n-      assertTrue(\"startCalled\", C6.startCalled);\n-      assertFalse(\"stopCalled\", C6.stopCalled);\n-\n-      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC()));\n-      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC1()));\n-      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC2()));\n-\n-      CConfig cfg = new CConfig();\n-      cfg.boolVal = Boolean.TRUE;\n-      cfg.strVal = \"Something\";\n-      cfg.longVal = 1234L;\n-      PluginMeta p = new PluginMeta();\n-      p.name = \"hello\";\n-      p.klass = CC.class.getName();\n-      p.config = cfg;\n-\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"add\", p))\n-              .build()\n-              .process(cluster.getSolrClient());\n-\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-        TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"hello/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/config/boolVal\", \"true\", \"/config/strVal\", \"Something\", \"/config/longVal\", \"1234\"));\n-\n-      cfg.strVal = \"Something else\";\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"update\", p))\n-              .build()\n-              .process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"hello/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/config/boolVal\", \"true\", \"/config/strVal\", cfg.strVal, \"/config/longVal\", \"1234\"));\n-\n-      // kill the Overseer leader\n-      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n-        if (!jetty.getCoreContainer().getZkController().getOverseer().isClosed()) {\n-          cluster.stopJettySolrRunner(jetty);\n-          cluster.waitForJettyToStop(jetty);\n-        }\n-      }\n-      assertTrue(\"stopCalled\", C6.stopCalled);\n-    } finally {\n-      cluster.shutdown();\n-    }\n-  }\n-\n-  private void expectFail(ThrowingRunnable runnable) throws Exception {\n-    for (int i = 0; i < 20; i++) {\n-      try {\n-        runnable.run();\n-      } catch (Throwable throwable) {\n-        return;\n-      }\n-      Thread.sleep(100);\n-    }\n-    fail(\"should have failed with an exception\");\n-  }\n-\n-  @Test\n-  public void testApiFromPackage() throws Exception {\n-    MiniSolrCloudCluster cluster =\n-            configureCluster(4)\n-                    .withJettyConfig(jetty -> jetty.enableV2(true))\n-                    .configure();\n-    String FILE1 = \"/myplugin/v1.jar\";\n-    String FILE2 = \"/myplugin/v2.jar\";\n-    ContainerPluginsRegistry pluginsRegistry = cluster.getOpenOverseer().getCoreContainer().getContainerPluginsRegistry();\n-    pluginsRegistry.setPhaser(phaser);\n-\n-    int version = phaser.getPhase();\n-\n-\n-    String errPath = \"/error/details[0]/errorMessages[0]\";\n-    try {\n-      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n-      uploadKey(derFile, PackageStoreAPI.KEYS_DIR + \"/pub_key512.der\", cluster);\n-      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.1.jar.bin\", FILE1,\n-              \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n-      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n-              \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n-\n-      // We have two versions of the plugin in 2 different jar files. they are already uploaded to the package store\n-      Package.AddVersion add = new Package.AddVersion();\n-      add.version = \"1.0\";\n-      add.pkg = \"mypkg\";\n-      add.files = singletonList(FILE1);\n-      V2Request addPkgVersionReq = new V2Request.Builder(\"/cluster/package\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"add\", add))\n-              .build();\n-      addPkgVersionReq.process(cluster.getSolrClient());\n-\n-      waitForAllNodesToSync(cluster, \"/cluster/package\", Utils.makeMap(\n-              \":result:packages:mypkg[0]:version\", \"1.0\",\n-              \":result:packages:mypkg[0]:files[0]\", FILE1\n-      ));\n-\n-      // Now lets create a plugin using v1 jar file\n-      PluginMeta plugin = new PluginMeta();\n-      plugin.name = \"myplugin\";\n-      plugin.klass = \"mypkg:org.apache.solr.handler.MyPlugin\";\n-      plugin.version = add.version;\n-      final V2Request req1 = new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"add\", plugin))\n-              .build();\n-      req1.process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-        //verify the plugin creation\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/cluster/plugin\").\n-                      GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\n-                      \"/plugin/myplugin/class\", plugin.klass,\n-                      \"/plugin/myplugin/version\", plugin.version\n-              ));\n-      //let's test this now\n-      Callable<NavigableObject> invokePlugin = () -> new V2Request.Builder(\"/plugin/my/path\")\n-              .forceV2(true)\n-              .GET()\n-              .build().process(cluster.getSolrClient());\n-      TestDistribPackageStore.assertResponseValues(10,\n-              invokePlugin,\n-              ImmutableMap.of(\"/myplugin.version\", \"1.0\"));\n-\n-      //now let's upload the jar file for version 2.0 of the plugin\n-      add.version = \"2.0\";\n-      add.files = singletonList(FILE2);\n-      addPkgVersionReq.process(cluster.getSolrClient());\n-\n-      //here the plugin version is updated\n-      plugin.version = add.version;\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"update\", plugin))\n-              .build()\n-              .process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      //now verify if it is indeed updated\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/cluster/plugin\").\n-                      GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\n-                      \"/plugin/myplugin/class\", plugin.klass,\n-                      \"/plugin/myplugin/version\", \"2.0\"\n-              ));\n-      // invoke the plugin and test thye output\n-      TestDistribPackageStore.assertResponseValues(10,\n-              invokePlugin,\n-              ImmutableMap.of(\"/myplugin.version\", \"2.0\"));\n-\n-      plugin.name = \"plugin2\";\n-      plugin.klass = \"mypkg:\" + C5.class.getName();\n-      plugin.version = \"2.0\";\n-      req1.process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-      assertNotNull(C5.classData);\n-      assertEquals(1452, C5.classData.limit());\n-    } finally {\n-      cluster.shutdown();\n-    }\n-  }\n-\n-  public static class CC1 extends CC {\n-\n-  }\n-\n-  public static class CC2 extends CC1 {\n-\n-  }\n-\n-  public static class CC implements ConfigurablePlugin<CConfig> {\n-    private CConfig cfg;\n-\n-\n-    @Override\n-    public void configure(CConfig cfg) {\n-      this.cfg = cfg;\n-\n-    }\n-\n-    @EndPoint(method = GET,\n-            path = \"/hello/plugin\",\n-            permission = PermissionNameProvider.Name.READ_PERM)\n-    public void m2(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"config\", cfg);\n-    }\n-\n-  }\n-\n-  public static class CConfig implements ReflectMapWriter {\n-\n-    @JsonProperty\n-    public String strVal;\n-\n-    @JsonProperty\n-    public Long longVal;\n-\n-    @JsonProperty\n-    public Boolean boolVal;\n-  }\n-\n-  public static class C6 implements ClusterSingleton {\n-    static boolean startCalled = false;\n-    static boolean stopCalled = false;\n-    static boolean ccProvided = false;\n-\n-    private State state = State.STOPPED;\n-\n-    public C6(CoreContainer cc) {\n-      if (cc != null) {\n-        ccProvided = true;\n-      }\n-    }\n-\n-    @Override\n-    public String getName() {\n-      return \"C6\";\n-    }\n-\n-    @Override\n-    public void start() throws Exception {\n-      state = State.STARTING;\n-      startCalled = true;\n-      state = State.RUNNING;\n-    }\n-\n-    @Override\n-    public State getState() {\n-      return state;\n-    }\n-\n-    @Override\n-    public void stop() {\n-      state = State.STOPPING;\n-      stopCalled = true;\n-      state = State.STOPPED;\n-    }\n-  }\n-\n-\n-  public static class C5 implements ResourceLoaderAware {\n-    static ByteBuffer classData;\n-    private SolrResourceLoader resourceLoader;\n-\n-    @Override\n-    public void inform(ResourceLoader loader) throws IOException {\n-      this.resourceLoader = (SolrResourceLoader) loader;\n-      try {\n-        InputStream is = resourceLoader.openResource(\"org/apache/solr/handler/MyPlugin.class\");\n-        byte[] buf = new byte[1024 * 5];\n-        int sz = IOUtils.read(is, buf);\n-        classData = ByteBuffer.wrap(buf, 0, sz);\n-      } catch (IOException e) {\n-        //do not do anything\n-      }\n-    }\n-\n-    @EndPoint(method = GET,\n-            path = \"/$plugin-name/m2\",\n-            permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-    public void m2() {\n-\n-\n-    }\n-\n-  }\n-\n-  public static class C1 {\n-\n-  }\n-\n-  @EndPoint(\n-          method = GET,\n-          path = \"/plugin/my/plugin\",\n-          permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-  public class C2 {\n-\n-\n-  }\n-\n-  @EndPoint(\n-          method = GET,\n-          path = \"/plugin/my/plugin\",\n-          permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-  public static class C3 {\n-    @Command\n-    public void read(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"testkey\", \"testval\");\n-    }\n-\n-  }\n-\n-  public static class C4 {\n-\n-    @EndPoint(method = GET,\n-            path = \"$plugin-name/my/plugin\",\n-            permission = PermissionNameProvider.Name.READ_PERM)\n-    public void m1(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"method.name\", \"m1\");\n-    }\n-\n-    @EndPoint(method = GET,\n-            path = \"$path-prefix/their/plugin\",\n-            permission = PermissionNameProvider.Name.READ_PERM)\n-    public void m2(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"method.name\", \"m2\");\n-    }\n-\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static void waitForAllNodesToSync(MiniSolrCloudCluster cluster, String path, Map<String, Object> expected) throws Exception {\n-    for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n-      String baseUrl = jettySolrRunner.getBaseUrl().toString().replace(\"/solr\", \"/api\");\n-      String url = baseUrl + path + \"?wt=javabin\";\n-      TestDistribPackageStore.assertResponseValues(10, new Fetcher(url, jettySolrRunner), expected);\n-    }\n-  }\n-\n-  private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n-    RemoteExecutionException e = expectThrows(RemoteExecutionException.class, () -> req.process(client));\n-    String msg = e.getMetaData()._getStr(errPath, \"\");\n-    assertTrue(expectErrorMsg, msg.contains(expectErrorMsg));\n-  }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "584e4d5f3c954e02ac16437366ed84b75eeee2c5", "committedDate": "2020-06-28 15:22:42 +1000", "message": "syncing with branch_8x"}, {"oid": "d883cd69fc2884352e0a363b98e3d5a37142dd52", "committedDate": "2020-06-29 14:03:17 +1000", "message": "SOLR-14481: use classloader to open resource"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "ccdfee2cf06a77da81f9bd7566d028d4093fb607", "committedDate": "2020-07-02 12:24:05 +0530", "message": "Remove Redundant Import in TestContainerPlugin"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "e826b1f3446cf5ac2e95b205dfec442f6719ec25", "committedDate": "2020-10-22 12:35:47 +1100", "message": "refactor method names"}, {"oid": "052efd62aec3262744049a9b6002348df1d6e1c4", "committedDate": "2020-10-22 15:25:31 +1100", "message": "Revert \"refactor method names\""}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}, {"oid": "73d5e7ae77d8953cb9be35a7cbcebe3a516dd04a", "committedDate": "2020-11-17 00:19:50 +1100", "message": "SOLR-14977 :  ContainerPlugins should be configurable (#2065)"}, {"oid": "cced5078ea13797a49658cdf76f693a79788c533", "committedDate": "2020-12-06 14:51:10 +0100", "message": "SOLR-15016: Replica placement plugins should use container plugins API / configs."}, {"oid": "7ada4032180b516548fc0263f42da6a7a917f92b", "committedDate": "2021-03-09 16:58:29 +0100", "message": "SOLR-14749: Make sure the plugin config is reloaded on Overseer."}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MDg5Mw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409690893", "body": "unclear what this test is testing", "bodyText": "unclear what this test is testing", "bodyHTML": "<p dir=\"auto\">unclear what this test is testing</p>", "author": "madrob", "createdAt": "2020-04-16T16:29:41Z", "path": "solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java", "diffHunk": "@@ -199,6 +200,25 @@ public void testPayload() {\n \n   }\n \n+  public void testApiWrapper() {\n+    Class<ApiWithConstructor> klas = ApiWithConstructor.class;", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1MjE2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426452163", "bodyText": "it got in there accidentally , removed", "author": "noblepaul", "createdAt": "2020-05-18T08:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MDg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f051b497f549762a727ce4b1248a0fc5fa513d24", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java b/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\nindex 38fac62e2c6..3ecb6199688 100644\n--- a/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\n+++ b/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\n", "chunk": "@@ -200,25 +199,6 @@ public class TestApiFramework extends SolrTestCaseJ4 {\n \n   }\n \n-  public void testApiWrapper() {\n-    Class<ApiWithConstructor> klas = ApiWithConstructor.class;\n-    for (Constructor<?> constructor : klas.getConstructors()) {\n-      constructor.getParameterTypes();\n-\n-    }\n-\n-\n-\n-  }\n-\n-  public static class ApiWithConstructor{\n-    private final CoreContainer cc;\n-\n-    public ApiWithConstructor(CoreContainer cc) {\n-      this.cc = cc;\n-    }\n-  }\n-\n   @EndPoint(method = POST, path = \"/cluster/package\", permission = PermissionNameProvider.Name.ALL)\n   public static class ApiTest {\n     @Command(name = \"add\")\n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java b/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\nindex 38fac62e2c6..5f0a57a4296 100644\n--- a/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\n+++ b/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\n", "chunk": "@@ -200,25 +179,6 @@ public class TestApiFramework extends SolrTestCaseJ4 {\n \n   }\n \n-  public void testApiWrapper() {\n-    Class<ApiWithConstructor> klas = ApiWithConstructor.class;\n-    for (Constructor<?> constructor : klas.getConstructors()) {\n-      constructor.getParameterTypes();\n-\n-    }\n-\n-\n-\n-  }\n-\n-  public static class ApiWithConstructor{\n-    private final CoreContainer cc;\n-\n-    public ApiWithConstructor(CoreContainer cc) {\n-      this.cc = cc;\n-    }\n-  }\n-\n   @EndPoint(method = POST, path = \"/cluster/package\", permission = PermissionNameProvider.Name.ALL)\n   public static class ApiTest {\n     @Command(name = \"add\")\n", "next_change": {"commit": "20c1fdbf7e4573948434cfa82e1f7b0fc4d54b31", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java b/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\nindex 5f0a57a4296..55ce63b73e7 100644\n--- a/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\n+++ b/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\n", "chunk": "@@ -176,7 +176,18 @@ public class TestApiFramework extends SolrTestCaseJ4 {\n     assertEquals(\"b.jar\", addversion.files.get(1));\n \n \n+    apiBag.registerObject(new C());\n+    rsp = v2ApiInvoke(apiBag, \"/path1\", \"POST\", new ModifiableSolrParams(),\n+            new ByteArrayInputStream(\"{\\\"package\\\":\\\"mypkg\\\", \\\"version\\\": \\\"1.0\\\", \\\"files\\\" : [\\\"a.jar\\\", \\\"b.jar\\\"]}\".getBytes(UTF_8)));\n+    assertEquals(\"mypkg\", rsp.getValues()._getStr(\"payload/package\", null));\n+    assertEquals(\"1.0\", rsp.getValues()._getStr(\"payload/version\", null));\n+  }\n \n+  public static class C {\n+    @EndPoint(path = \"/path1\", method = POST, permission = PermissionNameProvider.Name.ALL)\n+    public void m1(PayloadObj<AddVersion> add) {\n+      add.getResponse().add(\"payload\",add.get());\n+    }\n   }\n \n   @EndPoint(method = POST, path = \"/cluster/package\", permission = PermissionNameProvider.Name.ALL)\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java b/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\ndeleted file mode 100644\nindex 55ce63b73e7..00000000000\n--- a/solr/core/src/test/org/apache/solr/handler/admin/TestApiFramework.java\n+++ /dev/null\n", "chunk": "@@ -1,371 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.handler.admin;\n-\n-import org.apache.solr.SolrTestCaseJ4;\n-import org.apache.solr.api.*;\n-import org.apache.solr.api.V2HttpCall.CompositeApi;\n-import org.apache.solr.client.solrj.SolrRequest;\n-import org.apache.solr.common.annotation.JsonProperty;\n-import org.apache.solr.common.params.MapSolrParams;\n-import org.apache.solr.common.params.ModifiableSolrParams;\n-import org.apache.solr.common.params.SolrParams;\n-import org.apache.solr.common.util.*;\n-import org.apache.solr.core.CoreContainer;\n-import org.apache.solr.core.PluginBag;\n-import org.apache.solr.handler.PingRequestHandler;\n-import org.apache.solr.handler.SchemaHandler;\n-import org.apache.solr.handler.SolrConfigHandler;\n-import org.apache.solr.request.LocalSolrQueryRequest;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.request.SolrQueryRequestBase;\n-import org.apache.solr.request.SolrRequestHandler;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.PermissionNameProvider;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.*;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-import static org.apache.solr.api.ApiBag.EMPTY_SPEC;\n-import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n-import static org.apache.solr.client.solrj.SolrRequest.METHOD.POST;\n-import static org.apache.solr.common.params.CommonParams.*;\n-import static org.apache.solr.common.util.ValidatingJsonMap.NOT_NULL;\n-\n-public class TestApiFramework extends SolrTestCaseJ4 {\n-\n-  public void testFramework() {\n-    Map<String, Object[]> calls = new HashMap<>();\n-    Map<String, Object> out = new HashMap<>();\n-    CoreContainer mockCC = TestCoreAdminApis.getCoreContainerMock(calls, out);\n-    PluginBag<SolrRequestHandler> containerHandlers = new PluginBag<>(SolrRequestHandler.class, null, false);\n-    containerHandlers.put(COLLECTIONS_HANDLER_PATH, new TestCollectionAPIs.MockCollectionsHandler());\n-    containerHandlers.put(CORES_HANDLER_PATH, new CoreAdminHandler(mockCC));\n-    containerHandlers.put(CONFIGSETS_HANDLER_PATH, new ConfigSetsHandler(mockCC));\n-    out.put(\"getRequestHandlers\", containerHandlers);\n-\n-    PluginBag<SolrRequestHandler> coreHandlers = new PluginBag<>(SolrRequestHandler.class, null, false);\n-    coreHandlers.put(\"/schema\", new SchemaHandler());\n-    coreHandlers.put(\"/config\", new SolrConfigHandler());\n-    coreHandlers.put(\"/admin/ping\", new PingRequestHandler());\n-\n-    Map<String, String> parts = new HashMap<>();\n-    String fullPath = \"/collections/hello/shards\";\n-    Api api = V2HttpCall.getApiInfo(containerHandlers, fullPath, \"POST\",\n-        fullPath, parts);\n-    assertNotNull(api);\n-    assertConditions(api.getSpec(), Utils.makeMap(\n-        \"/methods[0]\", \"POST\",\n-        \"/commands/create\", NOT_NULL));\n-    assertEquals(\"hello\", parts.get(\"collection\"));\n-\n-\n-    parts = new HashMap<>();\n-    api = V2HttpCall.getApiInfo(containerHandlers, \"/collections/hello/shards\", \"POST\",\n-        null, parts);\n-    assertConditions(api.getSpec(), Utils.makeMap(\n-        \"/methods[0]\", \"POST\",\n-        \"/commands/split\", NOT_NULL,\n-        \"/commands/add-replica\", NOT_NULL\n-    ));\n-\n-\n-    parts = new HashMap<>();\n-    api = V2HttpCall.getApiInfo(containerHandlers, \"/collections/hello/shards/shard1\", \"POST\",\n-        null, parts);\n-    assertConditions(api.getSpec(), Utils.makeMap(\n-        \"/methods[0]\", \"POST\",\n-        \"/commands/force-leader\", NOT_NULL\n-    ));\n-    assertEquals(\"hello\", parts.get(\"collection\"));\n-    assertEquals(\"shard1\", parts.get(\"shard\"));\n-\n-\n-    parts = new HashMap<>();\n-    api = V2HttpCall.getApiInfo(containerHandlers, \"/collections/hello\", \"POST\",\n-        null, parts);\n-    assertConditions(api.getSpec(), Utils.makeMap(\n-        \"/methods[0]\", \"POST\",\n-        \"/commands/add-replica-property\", NOT_NULL,\n-        \"/commands/delete-replica-property\", NOT_NULL\n-    ));\n-    assertEquals(\"hello\", parts.get(\"collection\"));\n-\n-    api = V2HttpCall.getApiInfo(containerHandlers, \"/collections/hello/shards/shard1/replica1\", \"DELETE\",\n-        null, parts);\n-    assertConditions(api.getSpec(), Utils.makeMap(\n-        \"/methods[0]\", \"DELETE\",\n-        \"/url/params/onlyIfDown/type\", \"boolean\"\n-    ));\n-    assertEquals(\"hello\", parts.get(\"collection\"));\n-    assertEquals(\"shard1\", parts.get(\"shard\"));\n-    assertEquals(\"replica1\", parts.get(\"replica\"));\n-\n-    SolrQueryResponse rsp = invoke(containerHandlers, null, \"/collections/_introspect\", GET, mockCC);\n-\n-    Set<String> methodNames = new HashSet<>();\n-    methodNames.add(rsp.getValues()._getStr(\"/spec[0]/methods[0]\", null));\n-    methodNames.add(rsp.getValues()._getStr(\"/spec[1]/methods[0]\", null));\n-    methodNames.add(rsp.getValues()._getStr(\"/spec[2]/methods[0]\", null));\n-    assertTrue(methodNames.contains(\"DELETE\"));\n-    assertTrue(methodNames.contains(\"POST\"));\n-    assertTrue(methodNames.contains(\"GET\"));\n-\n-    methodNames = new HashSet<>();\n-\n-    rsp = invoke(coreHandlers, \"/schema/_introspect\", \"/collections/hello/schema/_introspect\", GET, mockCC);\n-    methodNames.add(rsp.getValues()._getStr(\"/spec[0]/methods[0]\", null));\n-    methodNames.add(rsp.getValues()._getStr(\"/spec[1]/methods[0]\", null));\n-    assertTrue(methodNames.contains(\"POST\"));\n-    assertTrue(methodNames.contains(\"GET\"));\n-\n-    rsp = invoke(coreHandlers, \"/\", \"/collections/hello/_introspect\", GET, mockCC);\n-    assertConditions(rsp.getValues().asMap(2), Utils.makeMap(\n-        \"/availableSubPaths\", NOT_NULL,\n-        \"availableSubPaths /collections/hello/config/jmx\", NOT_NULL,\n-        \"availableSubPaths /collections/hello/schema\", NOT_NULL,\n-        \"availableSubPaths /collections/hello/shards\", NOT_NULL,\n-        \"availableSubPaths /collections/hello/shards/{shard}\", NOT_NULL,\n-        \"availableSubPaths /collections/hello/shards/{shard}/{replica}\", NOT_NULL\n-    ));\n-\n-  }\n-\n-  public void testPayload() throws IOException {\n-    String json = \"{package:pkg1, version: '0.1', files  :[a.jar, b.jar]}\";\n-    Utils.fromJSONString(json);\n-\n-    ApiBag apiBag = new ApiBag(false);\n-    List<Api> apis =  apiBag.registerObject(new ApiTest());\n-\n-    ValidatingJsonMap spec = apis.get(0).getSpec();\n-\n-    assertEquals(\"POST\", spec._getStr(\"/methods[0]\",null) );\n-    assertEquals(\"POST\", spec._getStr(\"/methods[0]\",null) );\n-    assertEquals(\"/cluster/package\", spec._getStr(\"/url/paths[0]\",null) );\n-    assertEquals(\"string\", spec._getStr(\"/commands/add/properties/package/type\",null) );\n-    assertEquals(\"array\", spec._getStr(\"/commands/add/properties/files/type\",null) );\n-    assertEquals(\"string\", spec._getStr(\"/commands/add/properties/files/items/type\",null) );\n-    assertEquals(\"string\", spec._getStr(\"/commands/delete/items/type\",null) );\n-    SolrQueryResponse rsp = v2ApiInvoke(apiBag, \"/cluster/package\", \"POST\", new ModifiableSolrParams(),\n-        new ByteArrayInputStream(\"{add:{package:mypkg, version: '1.0', files : [a.jar, b.jar]}}\".getBytes(UTF_8)));\n-\n-\n-    AddVersion addversion = (AddVersion) rsp.getValues().get(\"add\");\n-    assertEquals(\"mypkg\", addversion.pkg);\n-    assertEquals(\"1.0\", addversion.version);\n-    assertEquals(\"a.jar\", addversion.files.get(0));\n-    assertEquals(\"b.jar\", addversion.files.get(1));\n-\n-\n-    apiBag.registerObject(new C());\n-    rsp = v2ApiInvoke(apiBag, \"/path1\", \"POST\", new ModifiableSolrParams(),\n-            new ByteArrayInputStream(\"{\\\"package\\\":\\\"mypkg\\\", \\\"version\\\": \\\"1.0\\\", \\\"files\\\" : [\\\"a.jar\\\", \\\"b.jar\\\"]}\".getBytes(UTF_8)));\n-    assertEquals(\"mypkg\", rsp.getValues()._getStr(\"payload/package\", null));\n-    assertEquals(\"1.0\", rsp.getValues()._getStr(\"payload/version\", null));\n-  }\n-\n-  public static class C {\n-    @EndPoint(path = \"/path1\", method = POST, permission = PermissionNameProvider.Name.ALL)\n-    public void m1(PayloadObj<AddVersion> add) {\n-      add.getResponse().add(\"payload\",add.get());\n-    }\n-  }\n-\n-  @EndPoint(method = POST, path = \"/cluster/package\", permission = PermissionNameProvider.Name.ALL)\n-  public static class ApiTest {\n-    @Command(name = \"add\")\n-    public void add(SolrQueryRequest req, SolrQueryResponse rsp, AddVersion addVersion) {\n-      rsp.add(\"add\", addVersion);\n-\n-    }\n-\n-    @Command(name = \"delete\")\n-    public void del(SolrQueryRequest req, SolrQueryResponse rsp, List<String> names) {\n-      rsp.add(\"delete\",names);\n-\n-    }\n-\n-  }\n-\n-  public static class AddVersion implements ReflectMapWriter {\n-    @JsonProperty(value = \"package\", required = true)\n-    public String pkg;\n-    @JsonProperty(value = \"version\", required = true)\n-    public String version;\n-    @JsonProperty(value = \"files\", required = true)\n-    public List<String> files;\n-  }\n-\n-  public void testAnnotatedApi() {\n-    ApiBag apiBag = new ApiBag(false);\n-    apiBag.registerObject(new DummyTest());\n-    SolrQueryResponse rsp = v2ApiInvoke(apiBag, \"/node/filestore/package/mypkg/jar1.jar\", \"GET\",\n-        new ModifiableSolrParams(), null);\n-    assertEquals(\"/package/mypkg/jar1.jar\", rsp.getValues().get(\"path\"));\n-\n-    apiBag = new ApiBag(false);\n-    apiBag.registerObject(new DummyTest1());\n-    rsp = v2ApiInvoke(apiBag, \"/node/filestore/package/mypkg/jar1.jar\", \"GET\",\n-        new ModifiableSolrParams(), null);\n-    assertEquals(\"/package/mypkg/jar1.jar\", rsp.getValues().get(\"path\"));\n-\n-  }\n-\n-  @EndPoint(\n-      path = \"/node/filestore/*\",\n-      method = SolrRequest.METHOD.GET,\n-      permission = PermissionNameProvider.Name.ALL)\n-  public class DummyTest {\n-    @Command\n-    public void read(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"FSRead.called\", \"true\");\n-      rsp.add(\"path\", req.getPathTemplateValues().get(\"*\"));\n-    }\n-  }\n-\n-\n-  public class DummyTest1 {\n-    @EndPoint(\n-        path = \"/node/filestore/*\",\n-        method = SolrRequest.METHOD.GET,\n-        permission = PermissionNameProvider.Name.ALL)\n-    public void read(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"FSRead.called\", \"true\");\n-      rsp.add(\"path\", req.getPathTemplateValues().get(\"*\"));\n-    }\n-  }\n-\n-  private static SolrQueryResponse v2ApiInvoke(ApiBag bag, String uri, String method, SolrParams params, InputStream payload) {\n-    if (params == null) params = new ModifiableSolrParams();\n-    SolrQueryResponse rsp = new SolrQueryResponse();\n-    HashMap<String, String> templateVals = new HashMap<>();\n-    Api[] currentApi = new Api[1];\n-\n-    SolrQueryRequestBase req = new SolrQueryRequestBase(null, params) {\n-\n-      @Override\n-      public Map<String, String> getPathTemplateValues() {\n-        return templateVals;\n-      }\n-\n-      @Override\n-      protected Map<String, JsonSchemaValidator> getValidators() {\n-        return currentApi[0] == null?\n-            Collections.emptyMap():\n-            currentApi[0].getCommandSchema();\n-      }\n-\n-      @Override\n-      public Iterable<ContentStream> getContentStreams() {\n-        return Collections.singletonList(new ContentStreamBase() {\n-          @Override\n-          public InputStream getStream() throws IOException {\n-            return payload;\n-          }\n-        });\n-\n-      }\n-    };\n-    Api api = bag.lookup(uri, method, templateVals);\n-    currentApi[0] = api;\n-\n-\n-    api.call(req, rsp);\n-    return rsp;\n-\n-  }\n-\n-  public void testTrailingTemplatePaths() {\n-    PathTrie<Api> registry = new PathTrie<>();\n-    Api api = new Api(EMPTY_SPEC) {\n-      @Override\n-      public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-\n-      }\n-    };\n-    Api intropsect = new ApiBag.IntrospectApi(api, false);\n-    ApiBag.registerIntrospect(Collections.emptyMap(), registry, \"/c/.system/blob/{name}\", intropsect);\n-    ApiBag.registerIntrospect(Collections.emptyMap(), registry, \"/c/.system/{x}/{name}\", intropsect);\n-    assertEquals(intropsect, registry.lookup(\"/c/.system/blob/random_string/_introspect\", new HashMap<>()));\n-    assertEquals(intropsect, registry.lookup(\"/c/.system/blob/_introspect\", new HashMap<>()));\n-    assertEquals(intropsect, registry.lookup(\"/c/.system/_introspect\", new HashMap<>()));\n-    assertEquals(intropsect, registry.lookup(\"/c/.system/v1/_introspect\", new HashMap<>()));\n-    assertEquals(intropsect, registry.lookup(\"/c/.system/v1/v2/_introspect\", new HashMap<>()));\n-  }\n-\n-  private SolrQueryResponse invoke(PluginBag<SolrRequestHandler> reqHandlers, String path,\n-                                   String fullPath, SolrRequest.METHOD method,\n-                                   CoreContainer mockCC) {\n-    HashMap<String, String> parts = new HashMap<>();\n-    boolean containerHandlerLookup = mockCC.getRequestHandlers() == reqHandlers;\n-    path = path == null ? fullPath : path;\n-    Api api = null;\n-    if (containerHandlerLookup) {\n-      api = V2HttpCall.getApiInfo(reqHandlers, path, \"GET\", fullPath, parts);\n-    } else {\n-      api = V2HttpCall.getApiInfo(mockCC.getRequestHandlers(), fullPath, \"GET\", fullPath, parts);\n-      if (api == null) api = new CompositeApi(null);\n-      if (api instanceof CompositeApi) {\n-        CompositeApi compositeApi = (CompositeApi) api;\n-        api = V2HttpCall.getApiInfo(reqHandlers, path, \"GET\", fullPath, parts);\n-        compositeApi.add(api);\n-        api = compositeApi;\n-      }\n-    }\n-\n-    SolrQueryResponse rsp = new SolrQueryResponse();\n-    LocalSolrQueryRequest req = new LocalSolrQueryRequest(null, new MapSolrParams(new HashMap<>())) {\n-      @Override\n-      public List<CommandOperation> getCommands(boolean validateInput) {\n-        return Collections.emptyList();\n-      }\n-    };\n-\n-    api.call(req, rsp);\n-    return rsp;\n-\n-  }\n-\n-\n-  public static void assertConditions(@SuppressWarnings({\"rawtypes\"})Map root,\n-                                      @SuppressWarnings({\"rawtypes\"})Map conditions) {\n-    for (Object o : conditions.entrySet()) {\n-      @SuppressWarnings({\"rawtypes\"})\n-      Map.Entry e = (Map.Entry) o;\n-      String path = (String) e.getKey();\n-      List<String> parts = StrUtils.splitSmart(path, path.charAt(0) == '/' ? '/' : ' ', true);\n-      Object val = Utils.getObjectByPath(root, false, parts);\n-      if (e.getValue() instanceof ValidatingJsonMap.PredicateWithErrMsg) {\n-        @SuppressWarnings({\"rawtypes\"})\n-        ValidatingJsonMap.PredicateWithErrMsg value = (ValidatingJsonMap.PredicateWithErrMsg) e.getValue();\n-        @SuppressWarnings({\"unchecked\"})\n-        String err = value.test(val);\n-        if (err != null) {\n-          assertEquals(err + \" for \" + e.getKey() + \" in :\" + Utils.toJSONString(root), e.getValue(), val);\n-        }\n-\n-      } else {\n-        assertEquals(\"incorrect value for path \" + e.getKey() + \" in :\" + Utils.toJSONString(root), e.getValue(), val);\n-      }\n-    }\n-  }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "20c1fdbf7e4573948434cfa82e1f7b0fc4d54b31", "committedDate": "2020-06-30 22:40:26 +1000", "message": "SOLR-14404: use MethodHandles in AnnotatedAPI (#1624)"}, {"oid": "565c5b1ac4ac0b7beca0361607846119f5902af4", "committedDate": "2020-09-24 12:37:12 +1000", "message": "SOLR-14894: Use annotations to implement V2 collection APIs"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MTkyNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409691926", "body": "There's already a null check later, what kinds of messages do we get here that are useful and don't leak too much internals?", "bodyText": "There's already a null check later, what kinds of messages do we get here that are useful and don't leak too much internals?", "bodyHTML": "<p dir=\"auto\">There's already a null check later, what kinds of messages do we get here that are useful and don't leak too much internals?</p>", "author": "madrob", "createdAt": "2020-04-16T16:31:24Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java", "diffHunk": "@@ -62,6 +63,9 @@ public static RemoteExecutionException create(String host, NamedList errResponse\n       if (errObj != null) {\n         Number code = (Number) getObjectByPath(errObj, true, Collections.singletonList(\"code\"));\n         String msg = (String) getObjectByPath(errObj, true, Collections.singletonList(\"msg\"));\n+        if(msg == null) msg = \"\";", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\nindex 08b5ff1d700..594e7f3e7a6 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\n", "chunk": "@@ -50,15 +50,16 @@ public abstract class BaseHttpSolrClient extends SolrClient {\n    * it sends a proper payload back to the client\n    */\n   public static class RemoteExecutionException extends RemoteSolrException {\n+    @SuppressWarnings({\"rawtypes\"})\n     private NamedList meta;\n \n-    public RemoteExecutionException(String remoteHost, int code, String msg, NamedList meta) {\n+    public RemoteExecutionException(String remoteHost, int code, String msg, @SuppressWarnings({\"rawtypes\"})NamedList meta) {\n       super(remoteHost, code, msg, null);\n       this.meta = meta;\n     }\n \n \n-    public static RemoteExecutionException create(String host, NamedList errResponse) {\n+    public static RemoteExecutionException create(String host, @SuppressWarnings({\"rawtypes\"})NamedList errResponse) {\n       Object errObj = errResponse.get(\"error\");\n       if (errObj != null) {\n         Number code = (Number) getObjectByPath(errObj, true, Collections.singletonList(\"code\"));\n", "next_change": {"commit": "1c74faf0943da286f77ba2aab2cd5d0e400883f8", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\nindex 594e7f3e7a6..6a5edc96d65 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\n", "chunk": "@@ -64,9 +63,6 @@ public abstract class BaseHttpSolrClient extends SolrClient {\n       if (errObj != null) {\n         Number code = (Number) getObjectByPath(errObj, true, Collections.singletonList(\"code\"));\n         String msg = (String) getObjectByPath(errObj, true, Collections.singletonList(\"msg\"));\n-        if(msg == null) msg = \"\";\n-        msg+= Utils.toJSONString(errObj);\n-\n         return new RemoteExecutionException(host, code == null ? ErrorCode.UNKNOWN.code : code.intValue(),\n             msg == null ? \"Unknown Error\" : msg, errResponse);\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\nindex 08b5ff1d700..6a5edc96d65 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\n", "chunk": "@@ -50,22 +49,20 @@ public abstract class BaseHttpSolrClient extends SolrClient {\n    * it sends a proper payload back to the client\n    */\n   public static class RemoteExecutionException extends RemoteSolrException {\n+    @SuppressWarnings({\"rawtypes\"})\n     private NamedList meta;\n \n-    public RemoteExecutionException(String remoteHost, int code, String msg, NamedList meta) {\n+    public RemoteExecutionException(String remoteHost, int code, String msg, @SuppressWarnings({\"rawtypes\"})NamedList meta) {\n       super(remoteHost, code, msg, null);\n       this.meta = meta;\n     }\n \n \n-    public static RemoteExecutionException create(String host, NamedList errResponse) {\n+    public static RemoteExecutionException create(String host, @SuppressWarnings({\"rawtypes\"})NamedList errResponse) {\n       Object errObj = errResponse.get(\"error\");\n       if (errObj != null) {\n         Number code = (Number) getObjectByPath(errObj, true, Collections.singletonList(\"code\"));\n         String msg = (String) getObjectByPath(errObj, true, Collections.singletonList(\"msg\"));\n-        if(msg == null) msg = \"\";\n-        msg+= Utils.toJSONString(errObj);\n-\n         return new RemoteExecutionException(host, code == null ? ErrorCode.UNKNOWN.code : code.intValue(),\n             msg == null ? \"Unknown Error\" : msg, errResponse);\n \n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\ndeleted file mode 100644\nindex 6a5edc96d65..00000000000\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseHttpSolrClient.java\n+++ /dev/null\n", "chunk": "@@ -1,82 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.client.solrj.impl;\n-\n-import java.util.Collections;\n-\n-import org.apache.solr.client.solrj.SolrClient;\n-import org.apache.solr.common.SolrException;\n-import org.apache.solr.common.util.NamedList;\n-\n-import static org.apache.solr.common.util.Utils.getObjectByPath;\n-\n-public abstract class BaseHttpSolrClient extends SolrClient {\n-\n-  /**\n-   * Subclass of SolrException that allows us to capture an arbitrary HTTP\n-   * status code that may have been returned by the remote server or a\n-   * proxy along the way.\n-   */\n-  public static class RemoteSolrException extends SolrException {\n-    /**\n-     * @param remoteHost the host the error was received from\n-     * @param code Arbitrary HTTP status code\n-     * @param msg Exception Message\n-     * @param th Throwable to wrap with this Exception\n-     */\n-    public RemoteSolrException(String remoteHost, int code, String msg, Throwable th) {\n-      super(code, \"Error from server at \" + remoteHost + \": \" + msg, th);\n-    }\n-  }\n-\n-  /**\n-   * This should be thrown when a server has an error in executing the request and\n-   * it sends a proper payload back to the client\n-   */\n-  public static class RemoteExecutionException extends RemoteSolrException {\n-    @SuppressWarnings({\"rawtypes\"})\n-    private NamedList meta;\n-\n-    public RemoteExecutionException(String remoteHost, int code, String msg, @SuppressWarnings({\"rawtypes\"})NamedList meta) {\n-      super(remoteHost, code, msg, null);\n-      this.meta = meta;\n-    }\n-\n-\n-    public static RemoteExecutionException create(String host, @SuppressWarnings({\"rawtypes\"})NamedList errResponse) {\n-      Object errObj = errResponse.get(\"error\");\n-      if (errObj != null) {\n-        Number code = (Number) getObjectByPath(errObj, true, Collections.singletonList(\"code\"));\n-        String msg = (String) getObjectByPath(errObj, true, Collections.singletonList(\"msg\"));\n-        return new RemoteExecutionException(host, code == null ? ErrorCode.UNKNOWN.code : code.intValue(),\n-            msg == null ? \"Unknown Error\" : msg, errResponse);\n-\n-      } else {\n-        throw new RuntimeException(\"No error\");\n-      }\n-\n-    }\n-\n-    @SuppressWarnings({\"rawtypes\"})\n-    public NamedList getMetaData() {\n-\n-      return meta;\n-    }\n-  }\n-\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "d88264ba72840bc9529bc65b894cc8ef71a8baf0", "committedDate": "2021-02-03 16:27:47 +0100", "message": "SOLR-14234: Unhelpful message in RemoteExecutionException."}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MzMyMA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409693320", "body": "this is a fairly long test and was somewhat hard to follow, can we break it up into smaller pieces?", "bodyText": "this is a fairly long test and was somewhat hard to follow, can we break it up into smaller pieces?", "bodyHTML": "<p dir=\"auto\">this is a fairly long test and was somewhat hard to follow, can we break it up into smaller pieces?</p>", "author": "madrob", "createdAt": "2020-04-16T16:33:30Z", "path": "solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.client.solrj.SolrClient;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.impl.BaseHttpSolrClient;\n+import org.apache.solr.client.solrj.request.V2Request;\n+import org.apache.solr.client.solrj.request.beans.Package;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.client.solrj.response.V2Response;\n+import org.apache.solr.cloud.MiniSolrCloudCluster;\n+import org.apache.solr.cloud.SolrCloudTestCase;\n+import org.apache.solr.common.NavigableObject;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.filestore.PackageStoreAPI;\n+import org.apache.solr.filestore.TestDistribPackageStore;\n+import org.apache.solr.pkg.TestPackages;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.Collections.singletonMap;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n+import static org.apache.solr.client.solrj.SolrRequest.METHOD.POST;\n+import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n+import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n+import static org.hamcrest.CoreMatchers.containsString;\n+\n+public class TestContainerPlugin extends SolrCloudTestCase {\n+\n+  @Before\n+  public void setup() {\n+    System.setProperty(\"enable.packages\", \"true\");\n+  }\n+\n+  @After\n+  public void teardown() {\n+    System.clearProperty(\"enable.packages\");\n+  }\n+\n+  @Test\n+  public void testApi() throws Exception {\n+    MiniSolrCloudCluster cluster =\n+        configureCluster(4)\n+            .withJettyConfig(jetty -> jetty.enableV2(true))\n+            .configure();\n+    String errPath = \"/error/details[0]/errorMessages[0]\";\n+    try {\n+      PluginMeta plugin = new PluginMeta();\n+      plugin.name = \"testplugin\";\n+      plugin.klass = C2.class.getName();\n+      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(POST)\n+          .withPayload(singletonMap(\"add\", plugin))\n+          .build();\n+      expectError(req, cluster.getSolrClient(), errPath, \"Must have a no-arg constructor or CoreContainer constructor and it must not be a non static inner class\");\n+\n+      plugin.klass = C1.class.getName();\n+      expectError(req, cluster.getSolrClient(), errPath, \"Invalid class, no @EndPoint annotation\");\n+\n+      plugin.klass = C3.class.getName();\n+      req.process(cluster.getSolrClient());\n+\n+      V2Response rsp = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient());\n+      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n+\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/plugin/my/plugin\")\n+              .forceV2(true)\n+              .withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\"/testkey\", \"testval\"));\n+\n+      new V2Request.Builder(\"/cluster/plugin\")\n+          .withMethod(POST)\n+          .forceV2(true)\n+          .withPayload(\"{remove : testplugin}\")\n+          .build()\n+          .process(cluster.getSolrClient());\n+\n+      rsp = new V2Request.Builder(\"/cluster/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient());\n+      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n+\n+    } finally {\n+      cluster.shutdown();\n+    }\n+  }\n+  @Test\n+  public void testApiFromPackage() throws Exception {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzNzU3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426237573", "bodyText": "Splitting these tests will create another cluster and slow down the test execution further. I shall try to add inline comments to make it more clear as to what it is doing", "author": "noblepaul", "createdAt": "2020-05-17T09:16:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MzMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex bcdfe9a1483..a95c6e045c2 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -109,13 +115,33 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n           .build()\n           .process(cluster.getSolrClient());\n \n-      rsp = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(GET)\n-          .build()\n-          .process(cluster.getSolrClient());\n+      //verify it is removed\n+      rsp = readPluginState.process(cluster.getSolrClient());\n       assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n \n+      //test with a class  @EndPoint methods. This also uses a template in the path name\n+      plugin.klass = C4.class.getName();\n+      plugin.name = \"my-random-name\";\n+      req.process(cluster.getSolrClient());\n+\n+      //let's test the plugin\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/plugin/my-random-name/my/plugin\")\n+              .forceV2(true)\n+              .withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\"/method.name\", \"m1\"));\n+\n+  TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/plugin/my-random-name/their/plugin\")\n+              .forceV2(true)\n+              .withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\"/method.name\", \"m2\"));\n+\n+\n+\n+\n     } finally {\n       cluster.shutdown();\n     }\n", "next_change": {"commit": "4818edf01bae0b50c48a0e48bd3170eccb43e828", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex a95c6e045c2..d819ba2e6b9 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -121,27 +124,27 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n \n       //test with a class  @EndPoint methods. This also uses a template in the path name\n       plugin.klass = C4.class.getName();\n+      plugin.name = \"collections\";\n+      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n+\n       plugin.name = \"my-random-name\";\n       req.process(cluster.getSolrClient());\n \n       //let's test the plugin\n       TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/plugin/my-random-name/my/plugin\")\n+          () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n               .forceV2(true)\n               .withMethod(GET)\n               .build().process(cluster.getSolrClient()),\n           ImmutableMap.of(\"/method.name\", \"m1\"));\n \n   TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/plugin/my-random-name/their/plugin\")\n+          () -> new V2Request.Builder(\"/my-random-name/their/plugin\")\n               .forceV2(true)\n               .withMethod(GET)\n               .build().process(cluster.getSolrClient()),\n           ImmutableMap.of(\"/method.name\", \"m2\"));\n \n-\n-\n-\n     } finally {\n       cluster.shutdown();\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex bcdfe9a1483..2d417e149b1 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -109,13 +117,33 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n           .build()\n           .process(cluster.getSolrClient());\n \n-      rsp = new V2Request.Builder(\"/cluster/plugin\")\n-          .forceV2(true)\n-          .withMethod(GET)\n-          .build()\n-          .process(cluster.getSolrClient());\n+      //verify it is removed\n+      rsp = readPluginState.process(cluster.getSolrClient());\n       assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n \n+      //test with a class  @EndPoint methods. This also uses a template in the path name\n+      plugin.klass = C4.class.getName();\n+      plugin.name = \"collections\";\n+      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n+\n+      plugin.name = \"my-random-name\";\n+      req.process(cluster.getSolrClient());\n+\n+      //let's test the plugin\n+      TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n+              .forceV2(true)\n+              .withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\"/method.name\", \"m1\"));\n+\n+  TestDistribPackageStore.assertResponseValues(10,\n+          () -> new V2Request.Builder(\"/my-random-name/their/plugin\")\n+              .forceV2(true)\n+              .withMethod(GET)\n+              .build().process(cluster.getSolrClient()),\n+          ImmutableMap.of(\"/method.name\", \"m2\"));\n+\n     } finally {\n       cluster.shutdown();\n     }\n", "next_change": {"commit": "2e60e1fbbd3f72526b2975398f3943c398637c21", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex 2d417e149b1..9bfe22e5b33 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -138,16 +148,45 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n           ImmutableMap.of(\"/method.name\", \"m1\"));\n \n   TestDistribPackageStore.assertResponseValues(10,\n-          () -> new V2Request.Builder(\"/my-random-name/their/plugin\")\n+          () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n               .forceV2(true)\n               .withMethod(GET)\n               .build().process(cluster.getSolrClient()),\n           ImmutableMap.of(\"/method.name\", \"m2\"));\n+      //now remove the plugin\n+      new V2Request.Builder(\"/cluster/plugin\")\n+          .withMethod(POST)\n+          .forceV2(true)\n+          .withPayload(\"{remove : my-random-name}\")\n+          .build()\n+          .process(cluster.getSolrClient());\n \n+      expectFail( () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient()));\n+      expectFail(() -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n+          .forceV2(true)\n+          .withMethod(GET)\n+          .build()\n+          .process(cluster.getSolrClient()));\n     } finally {\n       cluster.shutdown();\n     }\n   }\n+\n+  private void expectFail(ThrowingRunnable runnable) throws Exception {\n+    for(int i=0;i< 20;i++) {\n+      try {\n+        runnable.run();\n+      } catch (Throwable throwable) {\n+        return;\n+      }\n+      Thread.sleep(100);\n+    }\n+    fail(\"should have failed with an exception\");\n+  }\n   @Test\n   public void testApiFromPackage() throws Exception {\n     MiniSolrCloudCluster cluster =\n", "next_change": {"commit": "7ada4032180b516548fc0263f42da6a7a917f92b", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\nindex 9bfe22e5b33..fb63e0ead88 100644\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n", "chunk": "@@ -187,34 +276,40 @@ public class TestContainerPlugin extends SolrCloudTestCase {\n     }\n     fail(\"should have failed with an exception\");\n   }\n+\n   @Test\n   public void testApiFromPackage() throws Exception {\n     MiniSolrCloudCluster cluster =\n-        configureCluster(4)\n-            .withJettyConfig(jetty -> jetty.enableV2(true))\n-            .configure();\n+            configureCluster(4)\n+                    .withJettyConfig(jetty -> jetty.enableV2(true))\n+                    .configure();\n     String FILE1 = \"/myplugin/v1.jar\";\n     String FILE2 = \"/myplugin/v2.jar\";\n+    ContainerPluginsRegistry pluginsRegistry = cluster.getOpenOverseer().getCoreContainer().getContainerPluginsRegistry();\n+    pluginsRegistry.setPhaser(phaser);\n+\n+    int version = phaser.getPhase();\n+\n \n     String errPath = \"/error/details[0]/errorMessages[0]\";\n     try {\n       byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n-      uploadKey(derFile, PackageStoreAPI.KEYS_DIR+\"/pub_key512.der\", cluster);\n+      uploadKey(derFile, PackageStoreAPI.KEYS_DIR + \"/pub_key512.der\", cluster);\n       TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.1.jar.bin\", FILE1,\n-          \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n-     TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n-          \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n+              \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n+      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n+              \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n \n-     // We have two versions of the plugin in 2 different jar files. they are already uploaded to the package store\n+      // We have two versions of the plugin in 2 different jar files. they are already uploaded to the package store\n       Package.AddVersion add = new Package.AddVersion();\n       add.version = \"1.0\";\n       add.pkg = \"mypkg\";\n       add.files = singletonList(FILE1);\n       V2Request addPkgVersionReq = new V2Request.Builder(\"/cluster/package\")\n-          .forceV2(true)\n-          .withMethod(POST)\n-          .withPayload(singletonMap(\"add\", add))\n-          .build();\n+              .forceV2(true)\n+              .POST()\n+              .withPayload(singletonMap(\"add\", add))\n+              .build();\n       addPkgVersionReq.process(cluster.getSolrClient());\n \n       waitForAllNodesToSync(cluster, \"/cluster/package\", Utils.makeMap(\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java b/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\ndeleted file mode 100644\nindex fb63e0ead88..00000000000\n--- a/solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java\n+++ /dev/null\n", "chunk": "@@ -1,554 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.handler;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.util.Map;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.Phaser;\n-import java.util.concurrent.TimeUnit;\n-\n-import com.google.common.collect.ImmutableMap;\n-import org.apache.commons.io.IOUtils;\n-import org.apache.lucene.util.ResourceLoader;\n-import org.apache.lucene.util.ResourceLoaderAware;\n-import org.apache.solr.api.Command;\n-import org.apache.solr.api.ConfigurablePlugin;\n-import org.apache.solr.api.ContainerPluginsRegistry;\n-import org.apache.solr.api.EndPoint;\n-import org.apache.solr.client.solrj.SolrClient;\n-import org.apache.solr.client.solrj.SolrServerException;\n-import org.apache.solr.client.solrj.embedded.JettySolrRunner;\n-import org.apache.solr.client.solrj.impl.BaseHttpSolrClient.RemoteExecutionException;\n-import org.apache.solr.client.solrj.request.V2Request;\n-import org.apache.solr.client.solrj.request.beans.Package;\n-import org.apache.solr.client.solrj.request.beans.PluginMeta;\n-import org.apache.solr.client.solrj.response.V2Response;\n-import org.apache.solr.cloud.ClusterSingleton;\n-import org.apache.solr.cloud.MiniSolrCloudCluster;\n-import org.apache.solr.cloud.SolrCloudTestCase;\n-import org.apache.solr.common.NavigableObject;\n-import org.apache.solr.common.annotation.JsonProperty;\n-import org.apache.solr.common.util.ReflectMapWriter;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.core.CoreContainer;\n-import org.apache.solr.core.SolrResourceLoader;\n-import org.apache.solr.filestore.PackageStoreAPI;\n-import org.apache.solr.filestore.TestDistribPackageStore;\n-import org.apache.solr.filestore.TestDistribPackageStore.Fetcher;\n-import org.apache.solr.pkg.TestPackages;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.PermissionNameProvider;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import static java.util.Collections.singletonList;\n-import static java.util.Collections.singletonMap;\n-import static org.apache.solr.client.solrj.SolrRequest.METHOD.GET;\n-import static org.apache.solr.filestore.TestDistribPackageStore.readFile;\n-import static org.apache.solr.filestore.TestDistribPackageStore.uploadKey;\n-\n-public class TestContainerPlugin extends SolrCloudTestCase {\n-  private Phaser phaser;\n-\n-  @Before\n-  public void setup() {\n-    System.setProperty(\"enable.packages\", \"true\");\n-    phaser = new Phaser();\n-  }\n-\n-  @After\n-  public void teardown() {\n-    System.clearProperty(\"enable.packages\");\n-  }\n-\n-  @Test\n-  public void testApi() throws Exception {\n-    MiniSolrCloudCluster cluster =\n-            configureCluster(4)\n-                    .withJettyConfig(jetty -> jetty.enableV2(true))\n-                    .configure();\n-    ContainerPluginsRegistry pluginsRegistry = cluster.getOpenOverseer().getCoreContainer().getContainerPluginsRegistry();\n-    pluginsRegistry.setPhaser(phaser);\n-\n-    int version = phaser.getPhase();\n-\n-    String errPath = \"/error/details[0]/errorMessages[0]\";\n-    try {\n-      PluginMeta plugin = new PluginMeta();\n-      plugin.name = \"testplugin\";\n-      plugin.klass = C2.class.getName();\n-      //test with an invalid class\n-      V2Request req = new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"add\", plugin))\n-              .build();\n-      expectError(req, cluster.getSolrClient(), errPath, \"No method with @Command in class\");\n-\n-      //test with a valid class. This should succeed now\n-      plugin.klass = C3.class.getName();\n-      req.process(cluster.getSolrClient());\n-\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      //just check if the plugin is indeed registered\n-      V2Request readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .GET()\n-              .build();\n-      V2Response rsp = readPluginState.process(cluster.getSolrClient());\n-      assertEquals(C3.class.getName(), rsp._getStr(\"/plugin/testplugin/class\", null));\n-\n-      //let's test the plugin\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/plugin/my/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/testkey\", \"testval\"));\n-\n-      //now remove the plugin\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .POST()\n-              .forceV2(true)\n-              .withPayload(\"{remove : testplugin}\")\n-              .build()\n-              .process(cluster.getSolrClient());\n-\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      //verify it is removed\n-      rsp = readPluginState.process(cluster.getSolrClient());\n-      assertEquals(null, rsp._get(\"/plugin/testplugin/class\", null));\n-\n-      //test with a class  @EndPoint methods. This also uses a template in the path name\n-      plugin.klass = C4.class.getName();\n-      plugin.name = \"collections\";\n-      plugin.pathPrefix = \"collections\";\n-      expectError(req, cluster.getSolrClient(), errPath, \"path must not have a prefix: collections\");\n-\n-      plugin.name = \"my-random-name\";\n-      plugin.pathPrefix = \"my-random-prefix\";\n-\n-      req.process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      //let's test the plugin\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/my-random-name/my/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/method.name\", \"m1\"));\n-\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/method.name\", \"m2\"));\n-      //now remove the plugin\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .POST()\n-              .forceV2(true)\n-              .withPayload(\"{remove : my-random-name}\")\n-              .build()\n-              .process(cluster.getSolrClient());\n-\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      expectFail(() -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n-              .forceV2(true)\n-              .GET()\n-              .build()\n-              .process(cluster.getSolrClient()));\n-      expectFail(() -> new V2Request.Builder(\"/my-random-prefix/their/plugin\")\n-              .forceV2(true)\n-              .GET()\n-              .build()\n-              .process(cluster.getSolrClient()));\n-\n-      // test ClusterSingleton plugin\n-      plugin.name = \"clusterSingleton\";\n-      plugin.klass = C6.class.getName();\n-      req.process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-\n-        //just check if the plugin is indeed registered\n-      readPluginState = new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .GET()\n-              .build();\n-      rsp = readPluginState.process(cluster.getSolrClient());\n-      assertEquals(C6.class.getName(), rsp._getStr(\"/plugin/clusterSingleton/class\", null));\n-\n-      assertTrue(\"ccProvided\", C6.ccProvided);\n-      assertTrue(\"startCalled\", C6.startCalled);\n-      assertFalse(\"stopCalled\", C6.stopCalled);\n-\n-      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC()));\n-      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC1()));\n-      assertEquals(CConfig.class, ContainerPluginsRegistry.getConfigClass(new CC2()));\n-\n-      CConfig cfg = new CConfig();\n-      cfg.boolVal = Boolean.TRUE;\n-      cfg.strVal = \"Something\";\n-      cfg.longVal = 1234L;\n-      PluginMeta p = new PluginMeta();\n-      p.name = \"hello\";\n-      p.klass = CC.class.getName();\n-      p.config = cfg;\n-\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"add\", p))\n-              .build()\n-              .process(cluster.getSolrClient());\n-\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-        TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"hello/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/config/boolVal\", \"true\", \"/config/strVal\", \"Something\", \"/config/longVal\", \"1234\"));\n-\n-      cfg.strVal = \"Something else\";\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"update\", p))\n-              .build()\n-              .process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"hello/plugin\")\n-                      .forceV2(true)\n-                      .GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\"/config/boolVal\", \"true\", \"/config/strVal\", cfg.strVal, \"/config/longVal\", \"1234\"));\n-\n-      // kill the Overseer leader\n-      for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {\n-        if (!jetty.getCoreContainer().getZkController().getOverseer().isClosed()) {\n-          cluster.stopJettySolrRunner(jetty);\n-          cluster.waitForJettyToStop(jetty);\n-        }\n-      }\n-      assertTrue(\"stopCalled\", C6.stopCalled);\n-    } finally {\n-      cluster.shutdown();\n-    }\n-  }\n-\n-  private void expectFail(ThrowingRunnable runnable) throws Exception {\n-    for (int i = 0; i < 20; i++) {\n-      try {\n-        runnable.run();\n-      } catch (Throwable throwable) {\n-        return;\n-      }\n-      Thread.sleep(100);\n-    }\n-    fail(\"should have failed with an exception\");\n-  }\n-\n-  @Test\n-  public void testApiFromPackage() throws Exception {\n-    MiniSolrCloudCluster cluster =\n-            configureCluster(4)\n-                    .withJettyConfig(jetty -> jetty.enableV2(true))\n-                    .configure();\n-    String FILE1 = \"/myplugin/v1.jar\";\n-    String FILE2 = \"/myplugin/v2.jar\";\n-    ContainerPluginsRegistry pluginsRegistry = cluster.getOpenOverseer().getCoreContainer().getContainerPluginsRegistry();\n-    pluginsRegistry.setPhaser(phaser);\n-\n-    int version = phaser.getPhase();\n-\n-\n-    String errPath = \"/error/details[0]/errorMessages[0]\";\n-    try {\n-      byte[] derFile = readFile(\"cryptokeys/pub_key512.der\");\n-      uploadKey(derFile, PackageStoreAPI.KEYS_DIR + \"/pub_key512.der\", cluster);\n-      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.1.jar.bin\", FILE1,\n-              \"pmrmWCDafdNpYle2rueAGnU2J6NYlcAey9mkZYbqh+5RdYo2Ln+llLF9voyRj+DDivK9GV1XdtKvD9rgCxlD7Q==\");\n-      TestPackages.postFileAndWait(cluster, \"runtimecode/containerplugin.v.2.jar.bin\", FILE2,\n-              \"StR3DmqaUSL7qjDOeVEiCqE+ouiZAkW99fsL48F9oWG047o7NGgwwZ36iGgzDC3S2tPaFjRAd9Zg4UK7OZLQzg==\");\n-\n-      // We have two versions of the plugin in 2 different jar files. they are already uploaded to the package store\n-      Package.AddVersion add = new Package.AddVersion();\n-      add.version = \"1.0\";\n-      add.pkg = \"mypkg\";\n-      add.files = singletonList(FILE1);\n-      V2Request addPkgVersionReq = new V2Request.Builder(\"/cluster/package\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"add\", add))\n-              .build();\n-      addPkgVersionReq.process(cluster.getSolrClient());\n-\n-      waitForAllNodesToSync(cluster, \"/cluster/package\", Utils.makeMap(\n-              \":result:packages:mypkg[0]:version\", \"1.0\",\n-              \":result:packages:mypkg[0]:files[0]\", FILE1\n-      ));\n-\n-      // Now lets create a plugin using v1 jar file\n-      PluginMeta plugin = new PluginMeta();\n-      plugin.name = \"myplugin\";\n-      plugin.klass = \"mypkg:org.apache.solr.handler.MyPlugin\";\n-      plugin.version = add.version;\n-      final V2Request req1 = new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"add\", plugin))\n-              .build();\n-      req1.process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-        //verify the plugin creation\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/cluster/plugin\").\n-                      GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\n-                      \"/plugin/myplugin/class\", plugin.klass,\n-                      \"/plugin/myplugin/version\", plugin.version\n-              ));\n-      //let's test this now\n-      Callable<NavigableObject> invokePlugin = () -> new V2Request.Builder(\"/plugin/my/path\")\n-              .forceV2(true)\n-              .GET()\n-              .build().process(cluster.getSolrClient());\n-      TestDistribPackageStore.assertResponseValues(10,\n-              invokePlugin,\n-              ImmutableMap.of(\"/myplugin.version\", \"1.0\"));\n-\n-      //now let's upload the jar file for version 2.0 of the plugin\n-      add.version = \"2.0\";\n-      add.files = singletonList(FILE2);\n-      addPkgVersionReq.process(cluster.getSolrClient());\n-\n-      //here the plugin version is updated\n-      plugin.version = add.version;\n-      new V2Request.Builder(\"/cluster/plugin\")\n-              .forceV2(true)\n-              .POST()\n-              .withPayload(singletonMap(\"update\", plugin))\n-              .build()\n-              .process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-\n-      //now verify if it is indeed updated\n-      TestDistribPackageStore.assertResponseValues(10,\n-              () -> new V2Request.Builder(\"/cluster/plugin\").\n-                      GET()\n-                      .build().process(cluster.getSolrClient()),\n-              ImmutableMap.of(\n-                      \"/plugin/myplugin/class\", plugin.klass,\n-                      \"/plugin/myplugin/version\", \"2.0\"\n-              ));\n-      // invoke the plugin and test thye output\n-      TestDistribPackageStore.assertResponseValues(10,\n-              invokePlugin,\n-              ImmutableMap.of(\"/myplugin.version\", \"2.0\"));\n-\n-      plugin.name = \"plugin2\";\n-      plugin.klass = \"mypkg:\" + C5.class.getName();\n-      plugin.version = \"2.0\";\n-      req1.process(cluster.getSolrClient());\n-      version = phaser.awaitAdvanceInterruptibly(version, 10, TimeUnit.SECONDS);\n-      assertNotNull(C5.classData);\n-      assertEquals(1452, C5.classData.limit());\n-    } finally {\n-      cluster.shutdown();\n-    }\n-  }\n-\n-  public static class CC1 extends CC {\n-\n-  }\n-\n-  public static class CC2 extends CC1 {\n-\n-  }\n-\n-  public static class CC implements ConfigurablePlugin<CConfig> {\n-    private CConfig cfg;\n-\n-\n-    @Override\n-    public void configure(CConfig cfg) {\n-      this.cfg = cfg;\n-\n-    }\n-\n-    @EndPoint(method = GET,\n-            path = \"/hello/plugin\",\n-            permission = PermissionNameProvider.Name.READ_PERM)\n-    public void m2(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"config\", cfg);\n-    }\n-\n-  }\n-\n-  public static class CConfig implements ReflectMapWriter {\n-\n-    @JsonProperty\n-    public String strVal;\n-\n-    @JsonProperty\n-    public Long longVal;\n-\n-    @JsonProperty\n-    public Boolean boolVal;\n-  }\n-\n-  public static class C6 implements ClusterSingleton {\n-    static boolean startCalled = false;\n-    static boolean stopCalled = false;\n-    static boolean ccProvided = false;\n-\n-    private State state = State.STOPPED;\n-\n-    public C6(CoreContainer cc) {\n-      if (cc != null) {\n-        ccProvided = true;\n-      }\n-    }\n-\n-    @Override\n-    public String getName() {\n-      return \"C6\";\n-    }\n-\n-    @Override\n-    public void start() throws Exception {\n-      state = State.STARTING;\n-      startCalled = true;\n-      state = State.RUNNING;\n-    }\n-\n-    @Override\n-    public State getState() {\n-      return state;\n-    }\n-\n-    @Override\n-    public void stop() {\n-      state = State.STOPPING;\n-      stopCalled = true;\n-      state = State.STOPPED;\n-    }\n-  }\n-\n-\n-  public static class C5 implements ResourceLoaderAware {\n-    static ByteBuffer classData;\n-    private SolrResourceLoader resourceLoader;\n-\n-    @Override\n-    public void inform(ResourceLoader loader) throws IOException {\n-      this.resourceLoader = (SolrResourceLoader) loader;\n-      try {\n-        InputStream is = resourceLoader.openResource(\"org/apache/solr/handler/MyPlugin.class\");\n-        byte[] buf = new byte[1024 * 5];\n-        int sz = IOUtils.read(is, buf);\n-        classData = ByteBuffer.wrap(buf, 0, sz);\n-      } catch (IOException e) {\n-        //do not do anything\n-      }\n-    }\n-\n-    @EndPoint(method = GET,\n-            path = \"/$plugin-name/m2\",\n-            permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-    public void m2() {\n-\n-\n-    }\n-\n-  }\n-\n-  public static class C1 {\n-\n-  }\n-\n-  @EndPoint(\n-          method = GET,\n-          path = \"/plugin/my/plugin\",\n-          permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-  public class C2 {\n-\n-\n-  }\n-\n-  @EndPoint(\n-          method = GET,\n-          path = \"/plugin/my/plugin\",\n-          permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-  public static class C3 {\n-    @Command\n-    public void read(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"testkey\", \"testval\");\n-    }\n-\n-  }\n-\n-  public static class C4 {\n-\n-    @EndPoint(method = GET,\n-            path = \"$plugin-name/my/plugin\",\n-            permission = PermissionNameProvider.Name.READ_PERM)\n-    public void m1(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"method.name\", \"m1\");\n-    }\n-\n-    @EndPoint(method = GET,\n-            path = \"$path-prefix/their/plugin\",\n-            permission = PermissionNameProvider.Name.READ_PERM)\n-    public void m2(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      rsp.add(\"method.name\", \"m2\");\n-    }\n-\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static void waitForAllNodesToSync(MiniSolrCloudCluster cluster, String path, Map<String, Object> expected) throws Exception {\n-    for (JettySolrRunner jettySolrRunner : cluster.getJettySolrRunners()) {\n-      String baseUrl = jettySolrRunner.getBaseUrl().toString().replace(\"/solr\", \"/api\");\n-      String url = baseUrl + path + \"?wt=javabin\";\n-      TestDistribPackageStore.assertResponseValues(10, new Fetcher(url, jettySolrRunner), expected);\n-    }\n-  }\n-\n-  private void expectError(V2Request req, SolrClient client, String errPath, String expectErrorMsg) throws IOException, SolrServerException {\n-    RemoteExecutionException e = expectThrows(RemoteExecutionException.class, () -> req.process(client));\n-    String msg = e.getMetaData()._getStr(errPath, \"\");\n-    assertTrue(expectErrorMsg, msg.contains(expectErrorMsg));\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "584e4d5f3c954e02ac16437366ed84b75eeee2c5", "committedDate": "2020-06-28 15:22:42 +1000", "message": "syncing with branch_8x"}, {"oid": "d883cd69fc2884352e0a363b98e3d5a37142dd52", "committedDate": "2020-06-29 14:03:17 +1000", "message": "SOLR-14481: use classloader to open resource"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "ccdfee2cf06a77da81f9bd7566d028d4093fb607", "committedDate": "2020-07-02 12:24:05 +0530", "message": "Remove Redundant Import in TestContainerPlugin"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "e826b1f3446cf5ac2e95b205dfec442f6719ec25", "committedDate": "2020-10-22 12:35:47 +1100", "message": "refactor method names"}, {"oid": "052efd62aec3262744049a9b6002348df1d6e1c4", "committedDate": "2020-10-22 15:25:31 +1100", "message": "Revert \"refactor method names\""}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}, {"oid": "73d5e7ae77d8953cb9be35a7cbcebe3a516dd04a", "committedDate": "2020-11-17 00:19:50 +1100", "message": "SOLR-14977 :  ContainerPlugins should be configurable (#2065)"}, {"oid": "cced5078ea13797a49658cdf76f693a79788c533", "committedDate": "2020-12-06 14:51:10 +0100", "message": "SOLR-15016: Replica placement plugins should use container plugins API / configs."}, {"oid": "7ada4032180b516548fc0263f42da6a7a917f92b", "committedDate": "2021-03-09 16:58:29 +0100", "message": "SOLR-14749: Make sure the plugin config is reloaded on Overseer."}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5NDYwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r409694609", "body": "There's a minor inconsistency here between edit/read and write/read, maybe we can standardize on one?", "bodyText": "There's a minor inconsistency here between edit/read and write/read, maybe we can standardize on one?", "bodyHTML": "<p dir=\"auto\">There's a minor inconsistency here between edit/read and write/read, maybe we can standardize on one?</p>", "author": "madrob", "createdAt": "2020-04-16T16:35:37Z", "path": "solr/core/src/java/org/apache/solr/core/CoreContainer.java", "diffHunk": "@@ -648,8 +655,8 @@ public void load() {\n       pkiAuthenticationPlugin.initializeMetrics(solrMetricsContext, \"/authentication/pki\");\n       TracerConfigurator.loadTracer(loader, cfg.getTracerConfiguratorPluginInfo(), getZkController().getZkStateReader());\n       packageLoader = new PackageLoader(this);\n-      containerHandlers.getApiBag().register(new AnnotatedApi(packageLoader.getPackageAPI().editAPI), Collections.EMPTY_MAP);\n-      containerHandlers.getApiBag().register(new AnnotatedApi(packageLoader.getPackageAPI().readAPI), Collections.EMPTY_MAP);\n+      containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().editAPI);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c53c4a1a83963e6c9275e2dcae732274b4fb5c2c", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java\nindex 03769d90caa..cc10da55190 100644\n--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java\n+++ b/solr/core/src/java/org/apache/solr/core/CoreContainer.java\n", "chunk": "@@ -657,6 +682,9 @@ public class CoreContainer {\n       packageLoader = new PackageLoader(this);\n       containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().editAPI);\n       containerHandlers.getApiBag().registerObject (packageLoader.getPackageAPI().readAPI);\n+      ZookeeperReadAPI zookeeperReadAPI = new ZookeeperReadAPI(this);\n+      containerHandlers.getApiBag().registerObject(zookeeperReadAPI);\n+\n     }\n \n     MDCLoggingContext.setNode(this);\n", "next_change": {"commit": "e26789532073430cca6a8a89c66a78b866cce2d4", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java\nindex cc10da55190..894378066c3 100644\n--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java\n+++ b/solr/core/src/java/org/apache/solr/core/CoreContainer.java\n", "chunk": "@@ -681,10 +685,9 @@ public class CoreContainer {\n       TracerConfigurator.loadTracer(loader, cfg.getTracerConfiguratorPluginInfo(), getZkController().getZkStateReader());\n       packageLoader = new PackageLoader(this);\n       containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().editAPI);\n-      containerHandlers.getApiBag().registerObject (packageLoader.getPackageAPI().readAPI);\n+      containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().readAPI);\n       ZookeeperReadAPI zookeeperReadAPI = new ZookeeperReadAPI(this);\n       containerHandlers.getApiBag().registerObject(zookeeperReadAPI);\n-\n     }\n \n     MDCLoggingContext.setNode(this);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java\nindex 03769d90caa..1ce510086b8 100644\n--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java\n+++ b/solr/core/src/java/org/apache/solr/core/CoreContainer.java\n", "chunk": "@@ -656,7 +703,9 @@ public class CoreContainer {\n       TracerConfigurator.loadTracer(loader, cfg.getTracerConfiguratorPluginInfo(), getZkController().getZkStateReader());\n       packageLoader = new PackageLoader(this);\n       containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().editAPI);\n-      containerHandlers.getApiBag().registerObject (packageLoader.getPackageAPI().readAPI);\n+      containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().readAPI);\n+      ZookeeperReadAPI zookeeperReadAPI = new ZookeeperReadAPI(this);\n+      containerHandlers.getApiBag().registerObject(zookeeperReadAPI);\n     }\n \n     MDCLoggingContext.setNode(this);\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/core/CoreContainer.java b/solr/core/src/java/org/apache/solr/core/CoreContainer.java\ndeleted file mode 100644\nindex 1ce510086b8..00000000000\n--- a/solr/core/src/java/org/apache/solr/core/CoreContainer.java\n+++ /dev/null\n", "chunk": "@@ -1,2141 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.solr.core;\n-\n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.spec.InvalidKeySpecException;\n-import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Properties;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.function.Supplier;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.Maps;\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.http.auth.AuthSchemeProvider;\n-import org.apache.http.client.CredentialsProvider;\n-import org.apache.http.config.Lookup;\n-import org.apache.lucene.index.CorruptIndexException;\n-import org.apache.lucene.index.IndexWriter;\n-import org.apache.lucene.search.IndexSearcher;\n-import org.apache.lucene.store.Directory;\n-import org.apache.solr.api.CustomContainerPlugins;\n-import org.apache.solr.client.solrj.SolrClient;\n-import org.apache.solr.client.solrj.cloud.SolrCloudManager;\n-import org.apache.solr.client.solrj.embedded.EmbeddedSolrServer;\n-import org.apache.solr.client.solrj.impl.CloudSolrClient;\n-import org.apache.solr.client.solrj.impl.HttpClientUtil;\n-import org.apache.solr.client.solrj.impl.SolrHttpClientBuilder;\n-import org.apache.solr.client.solrj.impl.SolrHttpClientContextBuilder;\n-import org.apache.solr.client.solrj.impl.SolrHttpClientContextBuilder.AuthSchemeRegistryProvider;\n-import org.apache.solr.client.solrj.impl.SolrHttpClientContextBuilder.CredentialsProviderProvider;\n-import org.apache.solr.client.solrj.io.SolrClientCache;\n-import org.apache.solr.client.solrj.util.SolrIdentifierValidator;\n-import org.apache.solr.cloud.CloudDescriptor;\n-import org.apache.solr.cloud.OverseerTaskQueue;\n-import org.apache.solr.cloud.ZkController;\n-import org.apache.solr.cloud.autoscaling.AutoScalingHandler;\n-import org.apache.solr.common.AlreadyClosedException;\n-import org.apache.solr.common.SolrException;\n-import org.apache.solr.common.SolrException.ErrorCode;\n-import org.apache.solr.common.cloud.DocCollection;\n-import org.apache.solr.common.cloud.Replica;\n-import org.apache.solr.common.cloud.Replica.State;\n-import org.apache.solr.common.cloud.SolrZkClient;\n-import org.apache.solr.common.cloud.ZkStateReader;\n-import org.apache.solr.common.util.ExecutorUtil;\n-import org.apache.solr.common.util.IOUtils;\n-import org.apache.solr.common.util.ObjectCache;\n-import org.apache.solr.common.util.SolrNamedThreadFactory;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.core.DirectoryFactory.DirContext;\n-import org.apache.solr.core.backup.repository.BackupRepository;\n-import org.apache.solr.core.backup.repository.BackupRepositoryFactory;\n-import org.apache.solr.filestore.PackageStoreAPI;\n-import org.apache.solr.handler.RequestHandlerBase;\n-import org.apache.solr.handler.SnapShooter;\n-import org.apache.solr.handler.admin.AutoscalingHistoryHandler;\n-import org.apache.solr.handler.admin.CollectionsHandler;\n-import org.apache.solr.handler.admin.ConfigSetsHandler;\n-import org.apache.solr.handler.admin.ContainerPluginsApi;\n-import org.apache.solr.handler.admin.CoreAdminHandler;\n-import org.apache.solr.handler.admin.HealthCheckHandler;\n-import org.apache.solr.handler.admin.InfoHandler;\n-import org.apache.solr.handler.admin.MetricsCollectorHandler;\n-import org.apache.solr.handler.admin.MetricsHandler;\n-import org.apache.solr.handler.admin.MetricsHistoryHandler;\n-import org.apache.solr.handler.admin.SecurityConfHandler;\n-import org.apache.solr.handler.admin.SecurityConfHandlerLocal;\n-import org.apache.solr.handler.admin.SecurityConfHandlerZk;\n-import org.apache.solr.handler.admin.ZookeeperInfoHandler;\n-import org.apache.solr.handler.admin.ZookeeperReadAPI;\n-import org.apache.solr.handler.admin.ZookeeperStatusHandler;\n-import org.apache.solr.handler.component.ShardHandlerFactory;\n-import org.apache.solr.handler.sql.CalciteSolrDriver;\n-import org.apache.solr.logging.LogWatcher;\n-import org.apache.solr.logging.MDCLoggingContext;\n-import org.apache.solr.metrics.SolrCoreMetricManager;\n-import org.apache.solr.metrics.SolrMetricManager;\n-import org.apache.solr.metrics.SolrMetricProducer;\n-import org.apache.solr.metrics.SolrMetricsContext;\n-import org.apache.solr.pkg.PackageLoader;\n-import org.apache.solr.request.SolrRequestHandler;\n-import org.apache.solr.request.SolrRequestInfo;\n-import org.apache.solr.search.SolrFieldCacheBean;\n-import org.apache.solr.security.AuditLoggerPlugin;\n-import org.apache.solr.security.AuthenticationPlugin;\n-import org.apache.solr.security.AuthorizationPlugin;\n-import org.apache.solr.security.HttpClientBuilderPlugin;\n-import org.apache.solr.security.PKIAuthenticationPlugin;\n-import org.apache.solr.security.PublicKeyHandler;\n-import org.apache.solr.security.SecurityPluginHolder;\n-import org.apache.solr.update.SolrCoreState;\n-import org.apache.solr.update.UpdateShardHandler;\n-import org.apache.solr.util.OrderedExecutor;\n-import org.apache.solr.util.RefCounted;\n-import org.apache.solr.util.stats.MetricUtils;\n-import org.apache.zookeeper.KeeperException;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static java.util.Objects.requireNonNull;\n-import static org.apache.solr.common.params.CommonParams.AUTHC_PATH;\n-import static org.apache.solr.common.params.CommonParams.AUTHZ_PATH;\n-import static org.apache.solr.common.params.CommonParams.AUTOSCALING_HISTORY_PATH;\n-import static org.apache.solr.common.params.CommonParams.COLLECTIONS_HANDLER_PATH;\n-import static org.apache.solr.common.params.CommonParams.CONFIGSETS_HANDLER_PATH;\n-import static org.apache.solr.common.params.CommonParams.CORES_HANDLER_PATH;\n-import static org.apache.solr.common.params.CommonParams.INFO_HANDLER_PATH;\n-import static org.apache.solr.common.params.CommonParams.METRICS_HISTORY_PATH;\n-import static org.apache.solr.common.params.CommonParams.METRICS_PATH;\n-import static org.apache.solr.common.params.CommonParams.ZK_PATH;\n-import static org.apache.solr.common.params.CommonParams.ZK_STATUS_PATH;\n-import static org.apache.solr.core.CorePropertiesLocator.PROPERTIES_FILENAME;\n-import static org.apache.solr.security.AuthenticationPlugin.AUTHENTICATION_PLUGIN_PROP;\n-\n-/**\n- * @since solr 1.3\n- */\n-public class CoreContainer {\n-\n-  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-  final SolrCores solrCores = new SolrCores(this);\n-\n-  public static class CoreLoadFailure {\n-\n-    public final CoreDescriptor cd;\n-    public final Exception exception;\n-\n-    public CoreLoadFailure(CoreDescriptor cd, Exception loadFailure) {\n-      this.cd = new CoreDescriptor(cd.getName(), cd);\n-      this.exception = loadFailure;\n-    }\n-  }\n-\n-  private volatile PluginBag<SolrRequestHandler> containerHandlers = new PluginBag<>(SolrRequestHandler.class, null);\n-\n-  /**\n-   * Minimize exposure to CoreContainer. Mostly only ZK interface is required\n-   */\n-  public final Supplier<SolrZkClient> zkClientSupplier = () -> getZkController().getZkClient();\n-\n-  private final CustomContainerPlugins customContainerPlugins =  new CustomContainerPlugins(this, containerHandlers.getApiBag());\n-\n-  protected final Map<String, CoreLoadFailure> coreInitFailures = new ConcurrentHashMap<>();\n-\n-  protected volatile CoreAdminHandler coreAdminHandler = null;\n-  protected volatile CollectionsHandler collectionsHandler = null;\n-  protected volatile HealthCheckHandler healthCheckHandler = null;\n-\n-  private volatile InfoHandler infoHandler;\n-  protected volatile ConfigSetsHandler configSetsHandler = null;\n-\n-  private volatile PKIAuthenticationPlugin pkiAuthenticationPlugin;\n-\n-  protected volatile Properties containerProperties;\n-\n-  private volatile ConfigSetService coreConfigService;\n-\n-  protected final ZkContainer zkSys = new ZkContainer();\n-  protected volatile ShardHandlerFactory shardHandlerFactory;\n-\n-  private volatile UpdateShardHandler updateShardHandler;\n-\n-  private volatile ExecutorService coreContainerWorkExecutor = ExecutorUtil.newMDCAwareCachedThreadPool(\n-      new SolrNamedThreadFactory(\"coreContainerWorkExecutor\"));\n-\n-  private final OrderedExecutor replayUpdatesExecutor;\n-\n-  @SuppressWarnings({\"rawtypes\"})\n-  protected volatile LogWatcher logging = null;\n-\n-  private volatile CloserThread backgroundCloser = null;\n-  protected final NodeConfig cfg;\n-  protected final SolrResourceLoader loader;\n-\n-  protected final Path solrHome;\n-\n-  protected final CoresLocator coresLocator;\n-\n-  private volatile String hostName;\n-\n-  private final BlobRepository blobRepository = new BlobRepository(this);\n-\n-  private volatile boolean asyncSolrCoreLoad;\n-\n-  protected volatile SecurityConfHandler securityConfHandler;\n-\n-  private volatile SecurityPluginHolder<AuthorizationPlugin> authorizationPlugin;\n-\n-  private volatile SecurityPluginHolder<AuthenticationPlugin> authenticationPlugin;\n-\n-  private volatile SecurityPluginHolder<AuditLoggerPlugin> auditloggerPlugin;\n-\n-  private volatile BackupRepositoryFactory backupRepoFactory;\n-\n-  protected volatile SolrMetricManager metricManager;\n-\n-  protected volatile String metricTag = SolrMetricProducer.getUniqueMetricTag(this, null);\n-\n-  protected volatile SolrMetricsContext solrMetricsContext;\n-\n-  protected MetricsHandler metricsHandler;\n-\n-  protected volatile MetricsHistoryHandler metricsHistoryHandler;\n-\n-  protected volatile MetricsCollectorHandler metricsCollectorHandler;\n-\n-  protected volatile AutoscalingHistoryHandler autoscalingHistoryHandler;\n-\n-  private volatile SolrClientCache solrClientCache;\n-\n-  private final ObjectCache objectCache = new ObjectCache();\n-\n-  private PackageStoreAPI packageStoreAPI;\n-  private PackageLoader packageLoader;\n-\n-  private Set<Path> allowPaths;\n-\n-  // Bits for the state variable.\n-  public final static long LOAD_COMPLETE = 0x1L;\n-  public final static long CORE_DISCOVERY_COMPLETE = 0x2L;\n-  public final static long INITIAL_CORE_LOAD_COMPLETE = 0x4L;\n-  private volatile long status = 0L;\n-\n-  protected volatile AutoScalingHandler autoScalingHandler;\n-\n-  private ExecutorService coreContainerAsyncTaskExecutor = ExecutorUtil.newMDCAwareCachedThreadPool(\"Core Container Async Task\");\n-\n-  private enum CoreInitFailedAction {fromleader, none}\n-\n-  /**\n-   * This method instantiates a new instance of {@linkplain BackupRepository}.\n-   *\n-   * @param repositoryName The name of the backup repository (Optional).\n-   *                       If not specified, a default implementation is used.\n-   * @return a new instance of {@linkplain BackupRepository}.\n-   */\n-  public BackupRepository newBackupRepository(Optional<String> repositoryName) {\n-    BackupRepository repository;\n-    if (repositoryName.isPresent()) {\n-      repository = backupRepoFactory.newInstance(getResourceLoader(), repositoryName.get());\n-    } else {\n-      repository = backupRepoFactory.newInstance(getResourceLoader());\n-    }\n-    return repository;\n-  }\n-\n-  public ExecutorService getCoreZkRegisterExecutorService() {\n-    return zkSys.getCoreZkRegisterExecutorService();\n-  }\n-\n-  public SolrRequestHandler getRequestHandler(String path) {\n-    return RequestHandlerBase.getRequestHandler(path, containerHandlers);\n-  }\n-\n-  public PluginBag<SolrRequestHandler> getRequestHandlers() {\n-    return this.containerHandlers;\n-  }\n-\n-  {\n-    if (log.isDebugEnabled()) {\n-      log.debug(\"New CoreContainer {}\", System.identityHashCode(this));\n-    }\n-  }\n-\n-  /**\n-   * Create a new CoreContainer using the given solr home directory.  The container's\n-   * cores are not loaded.\n-   *\n-   * @param solrHome a String containing the path to the solr home directory\n-   * @param properties substitutable properties (alternative to Sys props)\n-   * @see #load()\n-   */\n-  public CoreContainer(Path solrHome, Properties properties) {\n-    this(SolrXmlConfig.fromSolrHome(solrHome, properties));\n-  }\n-\n-  /**\n-   * Create a new CoreContainer using the given SolrResourceLoader,\n-   * configuration and CoresLocator.  The container's cores are\n-   * not loaded.\n-   *\n-   * @param config a ConfigSolr representation of this container's configuration\n-   * @see #load()\n-   */\n-  public CoreContainer(NodeConfig config) {\n-    this(config, new CorePropertiesLocator(config.getCoreRootDirectory()));\n-  }\n-\n-  public CoreContainer(NodeConfig config, boolean asyncSolrCoreLoad) {\n-    this(config, new CorePropertiesLocator(config.getCoreRootDirectory()), asyncSolrCoreLoad);\n-  }\n-\n-  public CoreContainer(NodeConfig config, CoresLocator locator) {\n-    this(config, locator, false);\n-  }\n-\n-  public CoreContainer(NodeConfig config, CoresLocator locator, boolean asyncSolrCoreLoad) {\n-    this.loader = config.getSolrResourceLoader();\n-    this.solrHome = config.getSolrHome();\n-    this.cfg = requireNonNull(config);\n-    try {\n-      containerHandlers.put(PublicKeyHandler.PATH, new PublicKeyHandler(cfg.getCloudConfig()));\n-    } catch (IOException | InvalidKeySpecException e) {\n-      throw new RuntimeException(\"Bad PublicKeyHandler configuration.\", e);\n-    }\n-    if (null != this.cfg.getBooleanQueryMaxClauseCount()) {\n-      IndexSearcher.setMaxClauseCount(this.cfg.getBooleanQueryMaxClauseCount());\n-    }\n-    this.coresLocator = locator;\n-    this.containerProperties = new Properties(config.getSolrProperties());\n-    this.asyncSolrCoreLoad = asyncSolrCoreLoad;\n-    this.replayUpdatesExecutor = new OrderedExecutor(\n-        cfg.getReplayUpdatesThreads(),\n-        ExecutorUtil.newMDCAwareCachedThreadPool(\n-            cfg.getReplayUpdatesThreads(),\n-            new SolrNamedThreadFactory(\"replayUpdatesExecutor\")));\n-\n-    this.allowPaths = new java.util.HashSet<>();\n-    this.allowPaths.add(cfg.getSolrHome());\n-    this.allowPaths.add(cfg.getCoreRootDirectory());\n-    if (cfg.getSolrDataHome() != null) {\n-      this.allowPaths.add(cfg.getSolrDataHome());\n-    }\n-    if (!cfg.getAllowPaths().isEmpty()) {\n-      this.allowPaths.addAll(cfg.getAllowPaths());\n-      if (log.isInfoEnabled()) {\n-        log.info(\"Allowing use of paths: {}\", cfg.getAllowPaths());\n-      }\n-    }\n-  }\n-\n-  @SuppressWarnings({\"unchecked\"})\n-  private synchronized void initializeAuthorizationPlugin(Map<String, Object> authorizationConf) {\n-    authorizationConf = Utils.getDeepCopy(authorizationConf, 4);\n-    int newVersion = readVersion(authorizationConf);\n-    //Initialize the Authorization module\n-    SecurityPluginHolder<AuthorizationPlugin> old = authorizationPlugin;\n-    SecurityPluginHolder<AuthorizationPlugin> authorizationPlugin = null;\n-    if (authorizationConf != null) {\n-      String klas = (String) authorizationConf.get(\"class\");\n-      if (klas == null) {\n-        throw new SolrException(ErrorCode.SERVER_ERROR, \"class is required for authorization plugin\");\n-      }\n-      if (old != null && old.getZnodeVersion() == newVersion && newVersion > 0) {\n-        log.debug(\"Authorization config not modified\");\n-        return;\n-      }\n-      log.info(\"Initializing authorization plugin: {}\", klas);\n-      authorizationPlugin = new SecurityPluginHolder<>(newVersion,\n-          getResourceLoader().newInstance(klas, AuthorizationPlugin.class));\n-\n-      // Read and pass the authorization context to the plugin\n-      authorizationPlugin.plugin.init(authorizationConf);\n-    } else {\n-      log.debug(\"Security conf doesn't exist. Skipping setup for authorization module.\");\n-    }\n-    this.authorizationPlugin = authorizationPlugin;\n-    if (old != null) {\n-      try {\n-        old.plugin.close();\n-      } catch (Exception e) {\n-        log.error(\"Exception while attempting to close old authorization plugin\", e);\n-      }\n-    }\n-  }\n-\n-  @SuppressWarnings({\"unchecked\"})\n-  private void initializeAuditloggerPlugin(Map<String, Object> auditConf) {\n-    auditConf = Utils.getDeepCopy(auditConf, 4);\n-    int newVersion = readVersion(auditConf);\n-    //Initialize the Auditlog module\n-    SecurityPluginHolder<AuditLoggerPlugin> old = auditloggerPlugin;\n-    SecurityPluginHolder<AuditLoggerPlugin> newAuditloggerPlugin = null;\n-    if (auditConf != null) {\n-      String klas = (String) auditConf.get(\"class\");\n-      if (klas == null) {\n-        throw new SolrException(ErrorCode.SERVER_ERROR, \"class is required for auditlogger plugin\");\n-      }\n-      if (old != null && old.getZnodeVersion() == newVersion && newVersion > 0) {\n-        log.debug(\"Auditlogger config not modified\");\n-        return;\n-      }\n-      log.info(\"Initializing auditlogger plugin: {}\", klas);\n-      newAuditloggerPlugin = new SecurityPluginHolder<>(newVersion,\n-          getResourceLoader().newInstance(klas, AuditLoggerPlugin.class));\n-\n-      newAuditloggerPlugin.plugin.init(auditConf);\n-      newAuditloggerPlugin.plugin.initializeMetrics(solrMetricsContext, \"/auditlogging\");\n-    } else {\n-      log.debug(\"Security conf doesn't exist. Skipping setup for audit logging module.\");\n-    }\n-    this.auditloggerPlugin = newAuditloggerPlugin;\n-    if (old != null) {\n-      try {\n-        old.plugin.close();\n-      } catch (Exception e) {\n-        log.error(\"Exception while attempting to close old auditlogger plugin\", e);\n-      }\n-    }\n-  }\n-\n-\n-  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-  private synchronized void initializeAuthenticationPlugin(Map<String, Object> authenticationConfig) {\n-    authenticationConfig = Utils.getDeepCopy(authenticationConfig, 4);\n-    int newVersion = readVersion(authenticationConfig);\n-    String pluginClassName = null;\n-    if (authenticationConfig != null) {\n-      if (authenticationConfig.containsKey(\"class\")) {\n-        pluginClassName = String.valueOf(authenticationConfig.get(\"class\"));\n-      } else {\n-        throw new SolrException(ErrorCode.SERVER_ERROR, \"No 'class' specified for authentication in ZK.\");\n-      }\n-    }\n-\n-    if (pluginClassName != null) {\n-      log.debug(\"Authentication plugin class obtained from security.json: {}\", pluginClassName);\n-    } else if (System.getProperty(AUTHENTICATION_PLUGIN_PROP) != null) {\n-      pluginClassName = System.getProperty(AUTHENTICATION_PLUGIN_PROP);\n-      log.debug(\"Authentication plugin class obtained from system property '{}': {}\"\n-          , AUTHENTICATION_PLUGIN_PROP, pluginClassName);\n-    } else {\n-      log.debug(\"No authentication plugin used.\");\n-    }\n-    SecurityPluginHolder<AuthenticationPlugin> old = authenticationPlugin;\n-    SecurityPluginHolder<AuthenticationPlugin> authenticationPlugin = null;\n-\n-    if (old != null && old.getZnodeVersion() == newVersion && newVersion > 0) {\n-      log.debug(\"Authentication config not modified\");\n-      return;\n-    }\n-\n-    // Initialize the plugin\n-    if (pluginClassName != null) {\n-      log.info(\"Initializing authentication plugin: {}\", pluginClassName);\n-      authenticationPlugin = new SecurityPluginHolder<>(newVersion,\n-          getResourceLoader().newInstance(pluginClassName,\n-              AuthenticationPlugin.class,\n-              null,\n-              new Class[]{CoreContainer.class},\n-              new Object[]{this}));\n-    }\n-    if (authenticationPlugin != null) {\n-      authenticationPlugin.plugin.init(authenticationConfig);\n-      setupHttpClientForAuthPlugin(authenticationPlugin.plugin);\n-      authenticationPlugin.plugin.initializeMetrics(solrMetricsContext, \"/authentication\");\n-    }\n-    this.authenticationPlugin = authenticationPlugin;\n-    try {\n-      if (old != null) old.plugin.close();\n-    } catch (Exception e) {\n-      log.error(\"Exception while attempting to close old authentication plugin\", e);\n-    }\n-\n-  }\n-\n-  private void setupHttpClientForAuthPlugin(Object authcPlugin) {\n-    if (authcPlugin instanceof HttpClientBuilderPlugin) {\n-      // Setup HttpClient for internode communication\n-      HttpClientBuilderPlugin builderPlugin = ((HttpClientBuilderPlugin) authcPlugin);\n-      SolrHttpClientBuilder builder = builderPlugin.getHttpClientBuilder(HttpClientUtil.getHttpClientBuilder());\n-      shardHandlerFactory.setSecurityBuilder(builderPlugin);\n-      updateShardHandler.setSecurityBuilder(builderPlugin);\n-\n-      // The default http client of the core container's shardHandlerFactory has already been created and\n-      // configured using the default httpclient configurer. We need to reconfigure it using the plugin's\n-      // http client configurer to set it up for internode communication.\n-      log.debug(\"Reconfiguring HttpClient settings.\");\n-\n-      SolrHttpClientContextBuilder httpClientBuilder = new SolrHttpClientContextBuilder();\n-      if (builder.getCredentialsProviderProvider() != null) {\n-        httpClientBuilder.setDefaultCredentialsProvider(new CredentialsProviderProvider() {\n-\n-          @Override\n-          public CredentialsProvider getCredentialsProvider() {\n-            return builder.getCredentialsProviderProvider().getCredentialsProvider();\n-          }\n-        });\n-      }\n-      if (builder.getAuthSchemeRegistryProvider() != null) {\n-        httpClientBuilder.setAuthSchemeRegistryProvider(new AuthSchemeRegistryProvider() {\n-\n-          @Override\n-          public Lookup<AuthSchemeProvider> getAuthSchemeRegistry() {\n-            return builder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry();\n-          }\n-        });\n-      }\n-\n-      HttpClientUtil.setHttpClientRequestContextBuilder(httpClientBuilder);\n-    }\n-    // Always register PKI auth interceptor, which will then delegate the decision of who should secure\n-    // each request to the configured authentication plugin.\n-    if (pkiAuthenticationPlugin != null && !pkiAuthenticationPlugin.isInterceptorRegistered()) {\n-      pkiAuthenticationPlugin.getHttpClientBuilder(HttpClientUtil.getHttpClientBuilder());\n-      shardHandlerFactory.setSecurityBuilder(pkiAuthenticationPlugin);\n-      updateShardHandler.setSecurityBuilder(pkiAuthenticationPlugin);\n-    }\n-  }\n-\n-  @SuppressWarnings({\"rawtypes\"})\n-  private static int readVersion(Map<String, Object> conf) {\n-    if (conf == null) return -1;\n-    Map meta = (Map) conf.get(\"\");\n-    if (meta == null) return -1;\n-    Number v = (Number) meta.get(\"v\");\n-    return v == null ? -1 : v.intValue();\n-  }\n-\n-  /**\n-   * This method allows subclasses to construct a CoreContainer\n-   * without any default init behavior.\n-   *\n-   * @param testConstructor pass (Object)null.\n-   * @lucene.experimental\n-   */\n-  protected CoreContainer(Object testConstructor) {\n-    solrHome = null;\n-    loader = null;\n-    coresLocator = null;\n-    cfg = null;\n-    containerProperties = null;\n-    replayUpdatesExecutor = null;\n-  }\n-\n-  public static CoreContainer createAndLoad(Path solrHome) {\n-    return createAndLoad(solrHome, solrHome.resolve(SolrXmlConfig.SOLR_XML_FILE));\n-  }\n-\n-  /**\n-   * Create a new CoreContainer and load its cores\n-   *\n-   * @param solrHome   the solr home directory\n-   * @param configFile the file containing this container's configuration\n-   * @return a loaded CoreContainer\n-   */\n-  public static CoreContainer createAndLoad(Path solrHome, Path configFile) {\n-    CoreContainer cc = new CoreContainer(SolrXmlConfig.fromFile(solrHome, configFile, new Properties()));\n-    try {\n-      cc.load();\n-    } catch (Exception e) {\n-      cc.shutdown();\n-      throw e;\n-    }\n-    return cc;\n-  }\n-\n-  public Properties getContainerProperties() {\n-    return containerProperties;\n-  }\n-\n-  public PKIAuthenticationPlugin getPkiAuthenticationPlugin() {\n-    return pkiAuthenticationPlugin;\n-  }\n-\n-  public SolrMetricManager getMetricManager() {\n-    return metricManager;\n-  }\n-\n-  public MetricsHandler getMetricsHandler() {\n-    return metricsHandler;\n-  }\n-\n-  public MetricsHistoryHandler getMetricsHistoryHandler() {\n-    return metricsHistoryHandler;\n-  }\n-\n-  public OrderedExecutor getReplayUpdatesExecutor() {\n-    return replayUpdatesExecutor;\n-  }\n-\n-  public PackageLoader getPackageLoader() {\n-    return packageLoader;\n-  }\n-\n-  public PackageStoreAPI getPackageStoreAPI() {\n-    return packageStoreAPI;\n-  }\n-\n-  public SolrClientCache getSolrClientCache() {\n-    return solrClientCache;\n-  }\n-\n-  public ObjectCache getObjectCache() {\n-    return objectCache;\n-  }\n-\n-  //-------------------------------------------------------------------\n-  // Initialization / Cleanup\n-  //-------------------------------------------------------------------\n-\n-  /**\n-   * Load the cores defined for this CoreContainer\n-   */\n-  public void load() {\n-    if (log.isDebugEnabled()) {\n-      log.debug(\"Loading cores into CoreContainer [instanceDir={}]\", getSolrHome());\n-    }\n-\n-    // Always add $SOLR_HOME/lib to the shared resource loader\n-    Set<String> libDirs = new LinkedHashSet<>();\n-    libDirs.add(\"lib\");\n-\n-    if (!StringUtils.isBlank(cfg.getSharedLibDirectory())) {\n-      List<String> sharedLibs = Arrays.asList(cfg.getSharedLibDirectory().split(\"\\\\s*,\\\\s*\"));\n-      libDirs.addAll(sharedLibs);\n-    }\n-\n-    boolean modified = false;\n-    // add the sharedLib to the shared resource loader before initializing cfg based plugins\n-    for (String libDir : libDirs) {\n-      Path libPath = Paths.get(getSolrHome()).resolve(libDir);\n-      if (Files.exists(libPath)) {\n-        try {\n-          loader.addToClassLoader(SolrResourceLoader.getURLs(libPath));\n-          modified = true;\n-        } catch (IOException e) {\n-          throw new SolrException(ErrorCode.SERVER_ERROR, \"Couldn't load libs: \" + e, e);\n-        }\n-      }\n-    }\n-    if (modified) {\n-      loader.reloadLuceneSPI();\n-    }\n-\n-    packageStoreAPI = new PackageStoreAPI(this);\n-    containerHandlers.getApiBag().registerObject(packageStoreAPI.readAPI);\n-    containerHandlers.getApiBag().registerObject(packageStoreAPI.writeAPI);\n-\n-    metricManager = new SolrMetricManager(loader, cfg.getMetricsConfig());\n-    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.node);\n-    solrMetricsContext = new SolrMetricsContext(metricManager, registryName, metricTag);\n-\n-    coreContainerWorkExecutor = MetricUtils.instrumentedExecutorService(\n-        coreContainerWorkExecutor, null,\n-        metricManager.registry(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node)),\n-        SolrMetricManager.mkName(\"coreContainerWorkExecutor\", SolrInfoBean.Category.CONTAINER.toString(), \"threadPool\"));\n-\n-    shardHandlerFactory = ShardHandlerFactory.newInstance(cfg.getShardHandlerFactoryPluginInfo(), loader);\n-    if (shardHandlerFactory instanceof SolrMetricProducer) {\n-      SolrMetricProducer metricProducer = (SolrMetricProducer) shardHandlerFactory;\n-      metricProducer.initializeMetrics(solrMetricsContext, \"httpShardHandler\");\n-    }\n-\n-    updateShardHandler = new UpdateShardHandler(cfg.getUpdateShardHandlerConfig());\n-    updateShardHandler.initializeMetrics(solrMetricsContext, \"updateShardHandler\");\n-\n-    solrClientCache = new SolrClientCache(updateShardHandler.getDefaultHttpClient());\n-\n-    // initialize CalciteSolrDriver instance to use this solrClientCache\n-    CalciteSolrDriver.INSTANCE.setSolrClientCache(solrClientCache);\n-\n-    solrCores.load(loader);\n-\n-\n-    logging = LogWatcher.newRegisteredLogWatcher(cfg.getLogWatcherConfig(), loader);\n-\n-    hostName = cfg.getNodeName();\n-\n-    zkSys.initZooKeeper(this, cfg.getCloudConfig());\n-    if (isZooKeeperAware()) {\n-      pkiAuthenticationPlugin = new PKIAuthenticationPlugin(this, zkSys.getZkController().getNodeName(),\n-          (PublicKeyHandler) containerHandlers.get(PublicKeyHandler.PATH));\n-      // use deprecated API for back-compat, remove in 9.0\n-      pkiAuthenticationPlugin.initializeMetrics(solrMetricsContext, \"/authentication/pki\");\n-      TracerConfigurator.loadTracer(loader, cfg.getTracerConfiguratorPluginInfo(), getZkController().getZkStateReader());\n-      packageLoader = new PackageLoader(this);\n-      containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().editAPI);\n-      containerHandlers.getApiBag().registerObject(packageLoader.getPackageAPI().readAPI);\n-      ZookeeperReadAPI zookeeperReadAPI = new ZookeeperReadAPI(this);\n-      containerHandlers.getApiBag().registerObject(zookeeperReadAPI);\n-    }\n-\n-    MDCLoggingContext.setNode(this);\n-\n-    securityConfHandler = isZooKeeperAware() ? new SecurityConfHandlerZk(this) : new SecurityConfHandlerLocal(this);\n-    reloadSecurityProperties();\n-    warnUsersOfInsecureSettings();\n-    this.backupRepoFactory = new BackupRepositoryFactory(cfg.getBackupRepositoryPlugins());\n-\n-    createHandler(ZK_PATH, ZookeeperInfoHandler.class.getName(), ZookeeperInfoHandler.class);\n-    createHandler(ZK_STATUS_PATH, ZookeeperStatusHandler.class.getName(), ZookeeperStatusHandler.class);\n-    collectionsHandler = createHandler(COLLECTIONS_HANDLER_PATH, cfg.getCollectionsHandlerClass(), CollectionsHandler.class);\n-    infoHandler = createHandler(INFO_HANDLER_PATH, cfg.getInfoHandlerClass(), InfoHandler.class);\n-    coreAdminHandler = createHandler(CORES_HANDLER_PATH, cfg.getCoreAdminHandlerClass(), CoreAdminHandler.class);\n-    configSetsHandler = createHandler(CONFIGSETS_HANDLER_PATH, cfg.getConfigSetsHandlerClass(), ConfigSetsHandler.class);\n-\n-    // metricsHistoryHandler uses metricsHandler, so create it first\n-    metricsHandler = new MetricsHandler(this);\n-    containerHandlers.put(METRICS_PATH, metricsHandler);\n-    metricsHandler.initializeMetrics(solrMetricsContext, METRICS_PATH);\n-\n-    createMetricsHistoryHandler();\n-\n-    autoscalingHistoryHandler = createHandler(AUTOSCALING_HISTORY_PATH, AutoscalingHistoryHandler.class.getName(), AutoscalingHistoryHandler.class);\n-    metricsCollectorHandler = createHandler(MetricsCollectorHandler.HANDLER_PATH, MetricsCollectorHandler.class.getName(), MetricsCollectorHandler.class);\n-    // may want to add some configuration here in the future\n-    metricsCollectorHandler.init(null);\n-\n-    containerHandlers.put(AUTHZ_PATH, securityConfHandler);\n-    securityConfHandler.initializeMetrics(solrMetricsContext, AUTHZ_PATH);\n-    containerHandlers.put(AUTHC_PATH, securityConfHandler);\n-\n-\n-    PluginInfo[] metricReporters = cfg.getMetricsConfig().getMetricReporters();\n-    metricManager.loadReporters(metricReporters, loader, this, null, null, SolrInfoBean.Group.node);\n-    metricManager.loadReporters(metricReporters, loader, this, null, null, SolrInfoBean.Group.jvm);\n-    metricManager.loadReporters(metricReporters, loader, this, null, null, SolrInfoBean.Group.jetty);\n-\n-    coreConfigService = ConfigSetService.createConfigSetService(cfg, loader, zkSys.zkController);\n-\n-    containerProperties.putAll(cfg.getSolrProperties());\n-\n-    // initialize gauges for reporting the number of cores and disk total/free\n-\n-    solrMetricsContext.gauge(() -> solrCores.getCores().size(),\n-        true, \"loaded\", SolrInfoBean.Category.CONTAINER.toString(), \"cores\");\n-    solrMetricsContext.gauge(() -> solrCores.getLoadedCoreNames().size() - solrCores.getCores().size(),\n-        true, \"lazy\", SolrInfoBean.Category.CONTAINER.toString(), \"cores\");\n-    solrMetricsContext.gauge(() -> solrCores.getAllCoreNames().size() - solrCores.getLoadedCoreNames().size(),\n-        true, \"unloaded\", SolrInfoBean.Category.CONTAINER.toString(), \"cores\");\n-    Path dataHome = cfg.getSolrDataHome() != null ? cfg.getSolrDataHome() : cfg.getCoreRootDirectory();\n-    solrMetricsContext.gauge(() -> dataHome.toFile().getTotalSpace(),\n-        true, \"totalSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\");\n-    solrMetricsContext.gauge(() -> dataHome.toFile().getUsableSpace(),\n-        true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\");\n-    solrMetricsContext.gauge(() -> dataHome.toString(),\n-        true, \"path\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\");\n-    solrMetricsContext.gauge(() -> {\n-          try {\n-            return org.apache.lucene.util.IOUtils.spins(dataHome);\n-          } catch (IOException e) {\n-            // default to spinning\n-            return true;\n-          }\n-        },\n-        true, \"spins\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\");\n-    solrMetricsContext.gauge(() -> cfg.getCoreRootDirectory().toFile().getTotalSpace(),\n-        true, \"totalSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n-    solrMetricsContext.gauge(() -> cfg.getCoreRootDirectory().toFile().getUsableSpace(),\n-        true, \"usableSpace\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n-    solrMetricsContext.gauge(() -> cfg.getCoreRootDirectory().toString(),\n-        true, \"path\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n-    solrMetricsContext.gauge(() -> {\n-          try {\n-            return org.apache.lucene.util.IOUtils.spins(cfg.getCoreRootDirectory());\n-          } catch (IOException e) {\n-            // default to spinning\n-            return true;\n-          }\n-        },\n-        true, \"spins\", SolrInfoBean.Category.CONTAINER.toString(), \"fs\", \"coreRoot\");\n-    // add version information\n-    solrMetricsContext.gauge(() -> this.getClass().getPackage().getSpecificationVersion(),\n-        true, \"specification\", SolrInfoBean.Category.CONTAINER.toString(), \"version\");\n-    solrMetricsContext.gauge(() -> this.getClass().getPackage().getImplementationVersion(),\n-        true, \"implementation\", SolrInfoBean.Category.CONTAINER.toString(), \"version\");\n-\n-    SolrFieldCacheBean fieldCacheBean = new SolrFieldCacheBean();\n-    fieldCacheBean.initializeMetrics(solrMetricsContext, null);\n-\n-    if (isZooKeeperAware()) {\n-      metricManager.loadClusterReporters(metricReporters, this);\n-    }\n-\n-\n-    // setup executor to load cores in parallel\n-    ExecutorService coreLoadExecutor = MetricUtils.instrumentedExecutorService(\n-        ExecutorUtil.newMDCAwareFixedThreadPool(\n-            cfg.getCoreLoadThreadCount(isZooKeeperAware()),\n-            new SolrNamedThreadFactory(\"coreLoadExecutor\")), null,\n-        metricManager.registry(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node)),\n-        SolrMetricManager.mkName(\"coreLoadExecutor\", SolrInfoBean.Category.CONTAINER.toString(), \"threadPool\"));\n-    final List<Future<SolrCore>> futures = new ArrayList<>();\n-    try {\n-      List<CoreDescriptor> cds = coresLocator.discover(this);\n-      cds = CoreSorter.sortCores(this, cds);\n-      checkForDuplicateCoreNames(cds);\n-      status |= CORE_DISCOVERY_COMPLETE;\n-\n-      for (final CoreDescriptor cd : cds) {\n-        if (cd.isTransient() || !cd.isLoadOnStartup()) {\n-          solrCores.addCoreDescriptor(cd);\n-        } else if (asyncSolrCoreLoad) {\n-          solrCores.markCoreAsLoading(cd);\n-        }\n-        if (cd.isLoadOnStartup()) {\n-          futures.add(coreLoadExecutor.submit(() -> {\n-            SolrCore core;\n-            try {\n-              if (zkSys.getZkController() != null) {\n-                zkSys.getZkController().throwErrorIfReplicaReplaced(cd);\n-              }\n-              solrCores.waitAddPendingCoreOps(cd.getName());\n-              core = createFromDescriptor(cd, false, false);\n-            } finally {\n-              solrCores.removeFromPendingOps(cd.getName());\n-              if (asyncSolrCoreLoad) {\n-                solrCores.markCoreAsNotLoading(cd);\n-              }\n-            }\n-            try {\n-              zkSys.registerInZk(core, true, false);\n-            } catch (RuntimeException e) {\n-              SolrException.log(log, \"Error registering SolrCore\", e);\n-            }\n-            return core;\n-          }));\n-        }\n-      }\n-\n-\n-      // Start the background thread\n-      backgroundCloser = new CloserThread(this, solrCores, cfg);\n-      backgroundCloser.start();\n-\n-    } finally {\n-      if (asyncSolrCoreLoad && futures != null) {\n-\n-        coreContainerWorkExecutor.submit(() -> {\n-          try {\n-            for (Future<SolrCore> future : futures) {\n-              try {\n-                future.get();\n-              } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-              } catch (ExecutionException e) {\n-                log.error(\"Error waiting for SolrCore to be loaded on startup\", e.getCause());\n-              }\n-            }\n-          } finally {\n-            ExecutorUtil.shutdownAndAwaitTermination(coreLoadExecutor);\n-          }\n-        });\n-      } else {\n-        ExecutorUtil.shutdownAndAwaitTermination(coreLoadExecutor);\n-      }\n-    }\n-\n-    if (isZooKeeperAware()) {\n-      customContainerPlugins.refresh();\n-      getZkController().zkStateReader.registerClusterPropertiesListener(customContainerPlugins);\n-      ContainerPluginsApi containerPluginsApi = new ContainerPluginsApi(this);\n-      containerHandlers.getApiBag().registerObject(containerPluginsApi.readAPI);\n-      containerHandlers.getApiBag().registerObject(containerPluginsApi.editAPI);\n-      zkSys.getZkController().checkOverseerDesignate();\n-      // initialize this handler here when SolrCloudManager is ready\n-      autoScalingHandler = new AutoScalingHandler(getZkController().getSolrCloudManager(), loader);\n-      containerHandlers.put(AutoScalingHandler.HANDLER_PATH, autoScalingHandler);\n-      autoScalingHandler.initializeMetrics(solrMetricsContext, AutoScalingHandler.HANDLER_PATH);\n-    }\n-    // This is a bit redundant but these are two distinct concepts for all they're accomplished at the same time.\n-    status |= LOAD_COMPLETE | INITIAL_CORE_LOAD_COMPLETE;\n-  }\n-\n-  // MetricsHistoryHandler supports both cloud and standalone configs\n-  @SuppressWarnings({\"unchecked\"})\n-  private void createMetricsHistoryHandler() {\n-    PluginInfo plugin = cfg.getMetricsConfig().getHistoryHandler();\n-    Map<String, Object> initArgs;\n-    if (plugin != null && plugin.initArgs != null) {\n-      initArgs = plugin.initArgs.asMap(5);\n-      initArgs.put(MetricsHistoryHandler.ENABLE_PROP, plugin.isEnabled());\n-    } else {\n-      initArgs = new HashMap<>();\n-    }\n-    String name;\n-    SolrCloudManager cloudManager;\n-    SolrClient client;\n-    if (isZooKeeperAware()) {\n-      name = getZkController().getNodeName();\n-      cloudManager = getZkController().getSolrCloudManager();\n-      client = new CloudSolrClient.Builder(Collections.singletonList(getZkController().getZkServerAddress()), Optional.empty())\n-          .withSocketTimeout(30000).withConnectionTimeout(15000)\n-          .withHttpClient(updateShardHandler.getDefaultHttpClient()).build();\n-    } else {\n-      name = getNodeConfig().getNodeName();\n-      if (name == null || name.isEmpty()) {\n-        name = \"localhost\";\n-      }\n-      cloudManager = null;\n-      client = new EmbeddedSolrServer(this, null) {\n-        @Override\n-        public void close() throws IOException {\n-          // do nothing - we close the container ourselves\n-        }\n-      };\n-      // enable local metrics unless specifically set otherwise\n-      if (!initArgs.containsKey(MetricsHistoryHandler.ENABLE_NODES_PROP)) {\n-        initArgs.put(MetricsHistoryHandler.ENABLE_NODES_PROP, true);\n-      }\n-      if (!initArgs.containsKey(MetricsHistoryHandler.ENABLE_REPLICAS_PROP)) {\n-        initArgs.put(MetricsHistoryHandler.ENABLE_REPLICAS_PROP, true);\n-      }\n-    }\n-    metricsHistoryHandler = new MetricsHistoryHandler(name, metricsHandler,\n-        client, cloudManager, initArgs);\n-    containerHandlers.put(METRICS_HISTORY_PATH, metricsHistoryHandler);\n-    metricsHistoryHandler.initializeMetrics(solrMetricsContext, METRICS_HISTORY_PATH);\n-  }\n-\n-  public void securityNodeChanged() {\n-    log.info(\"Security node changed, reloading security.json\");\n-    reloadSecurityProperties();\n-  }\n-\n-  /**\n-   * Make sure securityConfHandler is initialized\n-   */\n-  @SuppressWarnings({\"unchecked\"})\n-  private void reloadSecurityProperties() {\n-    SecurityConfHandler.SecurityConfig securityConfig = securityConfHandler.getSecurityConfig(false);\n-    initializeAuthorizationPlugin((Map<String, Object>) securityConfig.getData().get(\"authorization\"));\n-    initializeAuthenticationPlugin((Map<String, Object>) securityConfig.getData().get(\"authentication\"));\n-    initializeAuditloggerPlugin((Map<String, Object>) securityConfig.getData().get(\"auditlogging\"));\n-  }\n-\n-  private void warnUsersOfInsecureSettings() {\n-    if (authenticationPlugin == null || authorizationPlugin == null) {\n-      log.warn(\"Not all security plugins configured!  authentication={} authorization={}.  Solr is only as secure as \" +\n-          \"you make it. Consider configuring authentication/authorization before exposing Solr to users internal or \" +\n-          \"external.  See https://s.apache.org/solrsecurity for more info\",\n-            (authenticationPlugin != null) ? \"enabled\" : \"disabled\",\n-            (authorizationPlugin != null) ? \"enabled\" : \"disabled\");\n-    }\n-\n-    if (authenticationPlugin !=null && StringUtils.isNotEmpty(System.getProperty(\"solr.jetty.https.port\"))) {\n-      log.warn(\"Solr authentication is enabled, but SSL is off.  Consider enabling SSL to protect user credentials and data with encryption.\");\n-    }\n-  }\n-\n-  private static void checkForDuplicateCoreNames(List<CoreDescriptor> cds) {\n-    Map<String, Path> addedCores = Maps.newHashMap();\n-    for (CoreDescriptor cd : cds) {\n-      final String name = cd.getName();\n-      if (addedCores.containsKey(name))\n-        throw new SolrException(ErrorCode.SERVER_ERROR,\n-            String.format(Locale.ROOT, \"Found multiple cores with the name [%s], with instancedirs [%s] and [%s]\",\n-                name, addedCores.get(name), cd.getInstanceDir()));\n-      addedCores.put(name, cd.getInstanceDir());\n-    }\n-  }\n-\n-  private volatile boolean isShutDown = false;\n-\n-  public boolean isShutDown() {\n-    return isShutDown;\n-  }\n-\n-  public void shutdown() {\n-\n-    ZkController zkController = getZkController();\n-    if (zkController != null) {\n-      OverseerTaskQueue overseerCollectionQueue = zkController.getOverseerCollectionQueue();\n-      overseerCollectionQueue.allowOverseerPendingTasksToComplete();\n-    }\n-    if (log.isInfoEnabled()) {\n-      log.info(\"Shutting down CoreContainer instance={}\", System.identityHashCode(this));\n-    }\n-\n-    ExecutorUtil.shutdownAndAwaitTermination(coreContainerAsyncTaskExecutor);\n-    ExecutorService customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"closeThreadPool\"));\n-\n-    isShutDown = true;\n-    try {\n-      if (isZooKeeperAware()) {\n-        cancelCoreRecoveries();\n-        zkSys.zkController.preClose();\n-      }\n-\n-      ExecutorUtil.shutdownAndAwaitTermination(coreContainerWorkExecutor);\n-\n-      // First wake up the closer thread, it'll terminate almost immediately since it checks isShutDown.\n-      synchronized (solrCores.getModifyLock()) {\n-        solrCores.getModifyLock().notifyAll(); // wake up anyone waiting\n-      }\n-      if (backgroundCloser != null) { // Doesn't seem right, but tests get in here without initializing the core.\n-        try {\n-          while (true) {\n-            backgroundCloser.join(15000);\n-            if (backgroundCloser.isAlive()) {\n-              synchronized (solrCores.getModifyLock()) {\n-                solrCores.getModifyLock().notifyAll(); // there is a race we have to protect against\n-              }\n-            } else {\n-              break;\n-            }\n-          }\n-        } catch (InterruptedException e) {\n-          Thread.currentThread().interrupt();\n-          if (log.isDebugEnabled()) {\n-            log.debug(\"backgroundCloser thread was interrupted before finishing\");\n-          }\n-        }\n-      }\n-      // Now clear all the cores that are being operated upon.\n-      solrCores.close();\n-\n-      objectCache.clear();\n-\n-      // It's still possible that one of the pending dynamic load operation is waiting, so wake it up if so.\n-      // Since all the pending operations queues have been drained, there should be nothing to do.\n-      synchronized (solrCores.getModifyLock()) {\n-        solrCores.getModifyLock().notifyAll(); // wake up the thread\n-      }\n-\n-      customThreadPool.submit(() -> {\n-        replayUpdatesExecutor.shutdownAndAwaitTermination();\n-      });\n-\n-      if (metricsHistoryHandler != null) {\n-        metricsHistoryHandler.close();\n-        IOUtils.closeQuietly(metricsHistoryHandler.getSolrClient());\n-      }\n-\n-      if (metricManager != null) {\n-        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node));\n-        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm));\n-        metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty));\n-\n-        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.node), metricTag);\n-        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jvm), metricTag);\n-        metricManager.unregisterGauges(SolrMetricManager.getRegistryName(SolrInfoBean.Group.jetty), metricTag);\n-      }\n-\n-      if (isZooKeeperAware()) {\n-        cancelCoreRecoveries();\n-\n-        if (metricManager != null) {\n-          metricManager.closeReporters(SolrMetricManager.getRegistryName(SolrInfoBean.Group.cluster));\n-        }\n-      }\n-\n-      try {\n-        if (coreAdminHandler != null) {\n-          customThreadPool.submit(() -> {\n-            coreAdminHandler.shutdown();\n-          });\n-        }\n-      } catch (Exception e) {\n-        log.warn(\"Error shutting down CoreAdminHandler. Continuing to close CoreContainer.\", e);\n-      }\n-      if (solrClientCache != null) {\n-        solrClientCache.close();\n-      }\n-\n-    } finally {\n-      try {\n-        if (shardHandlerFactory != null) {\n-          customThreadPool.submit(() -> {\n-            shardHandlerFactory.close();\n-          });\n-        }\n-      } finally {\n-        try {\n-          if (updateShardHandler != null) {\n-            customThreadPool.submit(() -> Collections.singleton(shardHandlerFactory).parallelStream().forEach(c -> {\n-              updateShardHandler.close();\n-            }));\n-          }\n-        } finally {\n-          try {\n-            // we want to close zk stuff last\n-            zkSys.close();\n-          } finally {\n-            ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n-          }\n-        }\n-\n-      }\n-    }\n-\n-    // It should be safe to close the authorization plugin at this point.\n-    try {\n-      if (authorizationPlugin != null) {\n-        authorizationPlugin.plugin.close();\n-      }\n-    } catch (IOException e) {\n-      log.warn(\"Exception while closing authorization plugin.\", e);\n-    }\n-\n-    // It should be safe to close the authentication plugin at this point.\n-    try {\n-      if (authenticationPlugin != null) {\n-        authenticationPlugin.plugin.close();\n-        authenticationPlugin = null;\n-      }\n-    } catch (Exception e) {\n-      log.warn(\"Exception while closing authentication plugin.\", e);\n-    }\n-\n-    // It should be safe to close the auditlogger plugin at this point.\n-    try {\n-      if (auditloggerPlugin != null) {\n-        auditloggerPlugin.plugin.close();\n-        auditloggerPlugin = null;\n-      }\n-    } catch (Exception e) {\n-      log.warn(\"Exception while closing auditlogger plugin.\", e);\n-    }\n-\n-    if(packageLoader != null){\n-      org.apache.lucene.util.IOUtils.closeWhileHandlingException(packageLoader);\n-    }\n-    org.apache.lucene.util.IOUtils.closeWhileHandlingException(loader); // best effort\n-  }\n-\n-  public void cancelCoreRecoveries() {\n-\n-    List<SolrCore> cores = solrCores.getCores();\n-\n-    // we must cancel without holding the cores sync\n-    // make sure we wait for any recoveries to stop\n-    for (SolrCore core : cores) {\n-      try {\n-        core.getSolrCoreState().cancelRecovery();\n-      } catch (Exception e) {\n-        SolrException.log(log, \"Error canceling recovery for core\", e);\n-      }\n-    }\n-  }\n-\n-  public CoresLocator getCoresLocator() {\n-    return coresLocator;\n-  }\n-\n-  protected SolrCore registerCore(CoreDescriptor cd, SolrCore core, boolean registerInZk, boolean skipRecovery) {\n-    if (core == null) {\n-      throw new RuntimeException(\"Can not register a null core.\");\n-    }\n-\n-    if (isShutDown) {\n-      core.close();\n-      throw new IllegalStateException(\"This CoreContainer has been closed\");\n-    }\n-    SolrCore old = solrCores.putCore(cd, core);\n-    /*\n-     * set both the name of the descriptor and the name of the\n-     * core, since the descriptors name is used for persisting.\n-     */\n-\n-    core.setName(cd.getName());\n-\n-    coreInitFailures.remove(cd.getName());\n-\n-    if (old == null || old == core) {\n-      if (log.isDebugEnabled()) {\n-        log.debug(\"registering core: {}\", cd.getName());\n-      }\n-      if (registerInZk) {\n-        zkSys.registerInZk(core, false, skipRecovery);\n-      }\n-      return null;\n-    } else {\n-      if (log.isDebugEnabled()) {\n-        log.debug(\"replacing core: {}\", cd.getName());\n-      }\n-      old.close();\n-      if (registerInZk) {\n-        zkSys.registerInZk(core, false, skipRecovery);\n-      }\n-      return old;\n-    }\n-  }\n-\n-  /**\n-   * Creates a new core, publishing the core state to the cluster\n-   *\n-   * @param coreName   the core name\n-   * @param parameters the core parameters\n-   * @return the newly created core\n-   */\n-  public SolrCore create(String coreName, Map<String, String> parameters) {\n-    return create(coreName, cfg.getCoreRootDirectory().resolve(coreName), parameters, false);\n-  }\n-\n-  /**\n-   * Creates a new core in a specified instance directory, publishing the core state to the cluster\n-   *\n-   * @param coreName     the core name\n-   * @param instancePath the instance directory\n-   * @param parameters   the core parameters\n-   * @return the newly created core\n-   */\n-  public SolrCore create(String coreName, Path instancePath, Map<String, String> parameters, boolean newCollection) {\n-\n-    CoreDescriptor cd = new CoreDescriptor(coreName, instancePath, parameters, getContainerProperties(), getZkController());\n-\n-    // TODO: There's a race here, isn't there?\n-    // Since the core descriptor is removed when a core is unloaded, it should never be anywhere when a core is created.\n-    if (getAllCoreNames().contains(coreName)) {\n-      log.warn(\"Creating a core with existing name is not allowed\");\n-      // TODO: Shouldn't this be a BAD_REQUEST?\n-      throw new SolrException(ErrorCode.SERVER_ERROR, \"Core with name '\" + coreName + \"' already exists.\");\n-    }\n-\n-    // Validate paths are relative to known locations to avoid path traversal\n-    assertPathAllowed(cd.getInstanceDir());\n-    assertPathAllowed(Paths.get(cd.getDataDir()));\n-\n-    boolean preExisitingZkEntry = false;\n-    try {\n-      if (getZkController() != null) {\n-        if (cd.getCloudDescriptor().getCoreNodeName() == null) {\n-          throw new SolrException(ErrorCode.SERVER_ERROR, \"coreNodeName missing \" + parameters.toString());\n-        }\n-        preExisitingZkEntry = getZkController().checkIfCoreNodeNameAlreadyExists(cd);\n-      }\n-\n-      // Much of the logic in core handling pre-supposes that the core.properties file already exists, so create it\n-      // first and clean it up if there's an error.\n-      coresLocator.create(this, cd);\n-\n-      SolrCore core = null;\n-      try {\n-        solrCores.waitAddPendingCoreOps(cd.getName());\n-        core = createFromDescriptor(cd, true, newCollection);\n-        coresLocator.persist(this, cd); // Write out the current core properties in case anything changed when the core was created\n-      } finally {\n-        solrCores.removeFromPendingOps(cd.getName());\n-      }\n-\n-      return core;\n-    } catch (Exception ex) {\n-      // First clean up any core descriptor, there should never be an existing core.properties file for any core that\n-      // failed to be created on-the-fly.\n-      coresLocator.delete(this, cd);\n-      if (isZooKeeperAware() && !preExisitingZkEntry) {\n-        try {\n-          getZkController().unregister(coreName, cd);\n-        } catch (InterruptedException e) {\n-          Thread.currentThread().interrupt();\n-          SolrException.log(log, null, e);\n-        } catch (KeeperException e) {\n-          SolrException.log(log, null, e);\n-        } catch (Exception e) {\n-          SolrException.log(log, null, e);\n-        }\n-      }\n-\n-      Throwable tc = ex;\n-      Throwable c = null;\n-      do {\n-        tc = tc.getCause();\n-        if (tc != null) {\n-          c = tc;\n-        }\n-      } while (tc != null);\n-\n-      String rootMsg = \"\";\n-      if (c != null) {\n-        rootMsg = \" Caused by: \" + c.getMessage();\n-      }\n-\n-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-          \"Error CREATEing SolrCore '\" + coreName + \"': \" + ex.getMessage() + rootMsg, ex);\n-    }\n-  }\n-\n-  /**\n-   * Checks that the given path is relative to SOLR_HOME, SOLR_DATA_HOME, coreRootDirectory or one of the paths\n-   * specified in solr.xml's allowPaths element. Delegates to {@link SolrPaths#assertPathAllowed(Path, Set)}\n-   * @param pathToAssert path to check\n-   * @throws SolrException if path is outside allowed paths\n-   */\n-  public void assertPathAllowed(Path pathToAssert) throws SolrException {\n-    SolrPaths.assertPathAllowed(pathToAssert, allowPaths);\n-  }\n-\n-  /**\n-   * <p>Return the file system paths that should be allowed for various API requests.\n-   * This list is compiled at startup from SOLR_HOME, SOLR_DATA_HOME and the\n-   * <code>allowPaths</code> configuration of solr.xml.\n-   * These paths are used by the {@link #assertPathAllowed(Path)} method call.</p>\n-   * <p><b>NOTE:</b></p> This method is currently only in use in tests in order to\n-   * modify the mutable Set directly. Please treat this as a private method.\n-   */\n-  @VisibleForTesting\n-  public Set<Path> getAllowPaths() {\n-    return allowPaths;\n-  }\n-\n-  /**\n-   * Creates a new core based on a CoreDescriptor.\n-   *\n-   * @param dcore        a core descriptor\n-   * @param publishState publish core state to the cluster if true\n-   *                     <p>\n-   *                     WARNING: Any call to this method should be surrounded by a try/finally block\n-   *                     that calls solrCores.waitAddPendingCoreOps(...) and solrCores.removeFromPendingOps(...)\n-   *\n-   *                     <pre>\n-   *                                                               <code>\n-   *                                                               try {\n-   *                                                                  solrCores.waitAddPendingCoreOps(dcore.getName());\n-   *                                                                  createFromDescriptor(...);\n-   *                                                               } finally {\n-   *                                                                  solrCores.removeFromPendingOps(dcore.getName());\n-   *                                                               }\n-   *                                                               </code>\n-   *                                                             </pre>\n-   *                     <p>\n-   *                     Trying to put the waitAddPending... in this method results in Bad Things Happening due to race conditions.\n-   *                     getCore() depends on getting the core returned _if_ it's in the pending list due to some other thread opening it.\n-   *                     If the core is not in the pending list and not loaded, then getCore() calls this method. Anything that called\n-   *                     to check if the core was loaded _or_ in pending ops and, based on the return called createFromDescriptor would\n-   *                     introduce a race condition, see getCore() for the place it would be a problem\n-   * @return the newly created core\n-   */\n-  @SuppressWarnings(\"resource\")\n-  private SolrCore createFromDescriptor(CoreDescriptor dcore, boolean publishState, boolean newCollection) {\n-\n-    if (isShutDown) {\n-      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Solr has been shutdown.\");\n-    }\n-\n-    SolrCore core = null;\n-    try {\n-      MDCLoggingContext.setCoreDescriptor(this, dcore);\n-      SolrIdentifierValidator.validateCoreName(dcore.getName());\n-      if (zkSys.getZkController() != null) {\n-        zkSys.getZkController().preRegister(dcore, publishState);\n-      }\n-\n-      ConfigSet coreConfig = coreConfigService.loadConfigSet(dcore);\n-      dcore.setConfigSetTrusted(coreConfig.isTrusted());\n-      if (log.isInfoEnabled()) {\n-        log.info(\"Creating SolrCore '{}' using configuration from {}, trusted={}\", dcore.getName(), coreConfig.getName(), dcore.isConfigSetTrusted());\n-      }\n-      try {\n-        core = new SolrCore(this, dcore, coreConfig);\n-      } catch (SolrException e) {\n-        core = processCoreCreateException(e, dcore, coreConfig);\n-      }\n-\n-      // always kick off recovery if we are in non-Cloud mode\n-      if (!isZooKeeperAware() && core.getUpdateHandler().getUpdateLog() != null) {\n-        core.getUpdateHandler().getUpdateLog().recoverFromLog();\n-      }\n-\n-      registerCore(dcore, core, publishState, newCollection);\n-\n-      return core;\n-    } catch (Exception e) {\n-      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n-      if (e instanceof ZkController.NotInClusterStateException && !newCollection) {\n-        // this mostly happen when the core is deleted when this node is down\n-        unload(dcore.getName(), true, true, true);\n-        throw e;\n-      }\n-      solrCores.removeCoreDescriptor(dcore);\n-      final SolrException solrException = new SolrException(ErrorCode.SERVER_ERROR, \"Unable to create core [\" + dcore.getName() + \"]\", e);\n-      if (core != null && !core.isClosed())\n-        IOUtils.closeQuietly(core);\n-      throw solrException;\n-    } catch (Throwable t) {\n-      SolrException e = new SolrException(ErrorCode.SERVER_ERROR, \"JVM Error creating core [\" + dcore.getName() + \"]: \" + t.getMessage(), t);\n-      coreInitFailures.put(dcore.getName(), new CoreLoadFailure(dcore, e));\n-      solrCores.removeCoreDescriptor(dcore);\n-      if (core != null && !core.isClosed())\n-        IOUtils.closeQuietly(core);\n-      throw t;\n-    } finally {\n-      MDCLoggingContext.clear();\n-    }\n-  }\n-\n-  public boolean isSharedFs(CoreDescriptor cd) {\n-    try (SolrCore core = this.getCore(cd.getName())) {\n-      if (core != null) {\n-        return core.getDirectoryFactory().isSharedStorage();\n-      } else {\n-        ConfigSet configSet = coreConfigService.loadConfigSet(cd);\n-        return DirectoryFactory.loadDirectoryFactory(configSet.getSolrConfig(), this, null).isSharedStorage();\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Take action when we failed to create a SolrCore. If error is due to corrupt index, try to recover. Various recovery\n-   * strategies can be specified via system properties \"-DCoreInitFailedAction={fromleader, none}\"\n-   *\n-   * @param original   the problem seen when loading the core the first time.\n-   * @param dcore      core descriptor for the core to create\n-   * @param coreConfig core config for the core to create\n-   * @return if possible\n-   * @throws SolrException rethrows the original exception if we will not attempt to recover, throws a new SolrException with the\n-   *                       original exception as a suppressed exception if there is a second problem creating the solr core.\n-   * @see CoreInitFailedAction\n-   */\n-  private SolrCore processCoreCreateException(SolrException original, CoreDescriptor dcore, ConfigSet coreConfig) {\n-    // Traverse full chain since CIE may not be root exception\n-    Throwable cause = original;\n-    while ((cause = cause.getCause()) != null) {\n-      if (cause instanceof CorruptIndexException) {\n-        break;\n-      }\n-    }\n-\n-    // If no CorruptIndexException, nothing we can try here\n-    if (cause == null) throw original;\n-\n-    CoreInitFailedAction action = CoreInitFailedAction.valueOf(System.getProperty(CoreInitFailedAction.class.getSimpleName(), \"none\"));\n-    log.debug(\"CorruptIndexException while creating core, will attempt to repair via {}\", action);\n-\n-    switch (action) {\n-      case fromleader: // Recovery from leader on a CorruptedIndexException\n-        if (isZooKeeperAware()) {\n-          CloudDescriptor desc = dcore.getCloudDescriptor();\n-          try {\n-            Replica leader = getZkController().getClusterState()\n-                .getCollection(desc.getCollectionName())\n-                .getSlice(desc.getShardId())\n-                .getLeader();\n-            if (leader != null && leader.getState() == State.ACTIVE) {\n-              log.info(\"Found active leader, will attempt to create fresh core and recover.\");\n-              resetIndexDirectory(dcore, coreConfig);\n-              // the index of this core is emptied, its term should be set to 0\n-              getZkController().getShardTerms(desc.getCollectionName(), desc.getShardId()).setTermToZero(desc.getCoreNodeName());\n-              return new SolrCore(this, dcore, coreConfig);\n-            }\n-          } catch (SolrException se) {\n-            se.addSuppressed(original);\n-            throw se;\n-          }\n-        }\n-        throw original;\n-      case none:\n-        throw original;\n-      default:\n-        log.warn(\"Failed to create core, and did not recognize specified 'CoreInitFailedAction': [{}]. Valid options are {}.\",\n-            action, Arrays.asList(CoreInitFailedAction.values()));\n-        throw original;\n-    }\n-  }\n-\n-  /**\n-   * Write a new index directory for the a SolrCore, but do so without loading it.\n-   */\n-  private void resetIndexDirectory(CoreDescriptor dcore, ConfigSet coreConfig) {\n-    SolrConfig config = coreConfig.getSolrConfig();\n-\n-    String registryName = SolrMetricManager.getRegistryName(SolrInfoBean.Group.core, dcore.getName());\n-    DirectoryFactory df = DirectoryFactory.loadDirectoryFactory(config, this, registryName);\n-    String dataDir = SolrCore.findDataDir(df, null, config, dcore);\n-\n-    String tmpIdxDirName = \"index.\" + new SimpleDateFormat(SnapShooter.DATE_FMT, Locale.ROOT).format(new Date());\n-    SolrCore.modifyIndexProps(df, dataDir, config, tmpIdxDirName);\n-\n-    // Free the directory object that we had to create for this\n-    Directory dir = null;\n-    try {\n-      dir = df.get(dataDir, DirContext.META_DATA, config.indexConfig.lockType);\n-    } catch (IOException e) {\n-      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n-    } finally {\n-      try {\n-        df.release(dir);\n-        df.doneWithDirectory(dir);\n-      } catch (IOException e) {\n-        SolrException.log(log, e);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * @return a Collection of registered SolrCores\n-   */\n-  public Collection<SolrCore> getCores() {\n-    return solrCores.getCores();\n-  }\n-\n-  /**\n-   * Gets the cores that are currently loaded, i.e. cores that have\n-   * 1: loadOnStartup=true and are either not-transient or, if transient, have been loaded and have not been aged out\n-   * 2: loadOnStartup=false and have been loaded but are either non-transient or have not been aged out.\n-   * <p>\n-   * Put another way, this will not return any names of cores that are lazily loaded but have not been called for yet\n-   * or are transient and either not loaded or have been swapped out.\n-   */\n-  public Collection<String> getLoadedCoreNames() {\n-    return solrCores.getLoadedCoreNames();\n-  }\n-\n-  /**\n-   * This method is currently experimental.\n-   *\n-   * @return a Collection of the names that a specific core object is mapped to, there are more than one.\n-   */\n-  public Collection<String> getNamesForCore(SolrCore core) {\n-    return solrCores.getNamesForCore(core);\n-  }\n-\n-  /**\n-   * get a list of all the cores that are currently known, whether currently loaded or not\n-   *\n-   * @return a list of all the available core names in either permanent or transient cores\n-   */\n-  public Collection<String> getAllCoreNames() {\n-    return solrCores.getAllCoreNames();\n-\n-  }\n-\n-  /**\n-   * Returns an immutable Map of Exceptions that occurred when initializing\n-   * SolrCores (either at startup, or do to runtime requests to create cores)\n-   * keyed off of the name (String) of the SolrCore that had the Exception\n-   * during initialization.\n-   * <p>\n-   * While the Map returned by this method is immutable and will not change\n-   * once returned to the client, the source data used to generate this Map\n-   * can be changed as various SolrCore operations are performed:\n-   * </p>\n-   * <ul>\n-   * <li>Failed attempts to create new SolrCores will add new Exceptions.</li>\n-   * <li>Failed attempts to re-create a SolrCore using a name already contained in this Map will replace the Exception.</li>\n-   * <li>Failed attempts to reload a SolrCore will cause an Exception to be added to this list -- even though the existing SolrCore with that name will continue to be available.</li>\n-   * <li>Successful attempts to re-created a SolrCore using a name already contained in this Map will remove the Exception.</li>\n-   * <li>Registering an existing SolrCore with a name already contained in this Map (ie: ALIAS or SWAP) will remove the Exception.</li>\n-   * </ul>\n-   */\n-  public Map<String, CoreLoadFailure> getCoreInitFailures() {\n-    return ImmutableMap.copyOf(coreInitFailures);\n-  }\n-\n-  // ---------------- Core name related methods ---------------\n-\n-  private CoreDescriptor reloadCoreDescriptor(CoreDescriptor oldDesc) {\n-    if (oldDesc == null) {\n-      return null;\n-    }\n-\n-    CorePropertiesLocator cpl = new CorePropertiesLocator(null);\n-    CoreDescriptor ret = cpl.buildCoreDescriptor(oldDesc.getInstanceDir().resolve(PROPERTIES_FILENAME), this);\n-\n-    // Ok, this little jewel is all because we still create core descriptors on the fly from lists of properties\n-    // in tests particularly. Theoretically, there should be _no_ way to create a CoreDescriptor in the new world\n-    // of core discovery without writing the core.properties file out first.\n-    //\n-    // TODO: remove core.properties from the conf directory in test files, it's in a bad place there anyway.\n-    if (ret == null) {\n-      oldDesc.loadExtraProperties(); // there may be changes to extra properties that we need to pick up.\n-      return oldDesc;\n-\n-    }\n-    // The CloudDescriptor bit here is created in a very convoluted way, requiring access to private methods\n-    // in ZkController. When reloading, this behavior is identical to what used to happen where a copy of the old\n-    // CoreDescriptor was just re-used.\n-\n-    if (ret.getCloudDescriptor() != null) {\n-      ret.getCloudDescriptor().reload(oldDesc.getCloudDescriptor());\n-    }\n-\n-    return ret;\n-  }\n-\n-  /**\n-   * Recreates a SolrCore.\n-   * While the new core is loading, requests will continue to be dispatched to\n-   * and processed by the old core\n-   *\n-   * @param name the name of the SolrCore to reload\n-   */\n-  public void reload(String name) {\n-    if (isShutDown) {\n-      throw new AlreadyClosedException();\n-    }\n-    SolrCore newCore = null;\n-    SolrCore core = solrCores.getCoreFromAnyList(name, false);\n-    if (core != null) {\n-\n-      // The underlying core properties files may have changed, we don't really know. So we have a (perhaps) stale\n-      // CoreDescriptor and we need to reload it from the disk files\n-      CoreDescriptor cd = reloadCoreDescriptor(core.getCoreDescriptor());\n-      solrCores.addCoreDescriptor(cd);\n-      Closeable oldCore = null;\n-      boolean success = false;\n-      try {\n-        solrCores.waitAddPendingCoreOps(cd.getName());\n-        ConfigSet coreConfig = coreConfigService.loadConfigSet(cd);\n-        if (log.isInfoEnabled()) {\n-          log.info(\"Reloading SolrCore '{}' using configuration from {}\", cd.getName(), coreConfig.getName());\n-        }\n-        newCore = core.reload(coreConfig);\n-\n-        DocCollection docCollection = null;\n-        if (getZkController() != null) {\n-          docCollection = getZkController().getClusterState().getCollection(cd.getCollectionName());\n-          // turn off indexing now, before the new core is registered\n-          if (docCollection.getBool(ZkStateReader.READ_ONLY, false)) {\n-            newCore.readOnly = true;\n-          }\n-        }\n-\n-        registerCore(cd, newCore, false, false);\n-\n-        // force commit on old core if the new one is readOnly and prevent any new updates\n-        if (newCore.readOnly) {\n-          RefCounted<IndexWriter> iwRef = core.getSolrCoreState().getIndexWriter(null);\n-          if (iwRef != null) {\n-            IndexWriter iw = iwRef.get();\n-            // switch old core to readOnly\n-            core.readOnly = true;\n-            try {\n-              if (iw != null) {\n-                iw.commit();\n-              }\n-            } finally {\n-              iwRef.decref();\n-            }\n-          }\n-        }\n-\n-\n-        if (docCollection != null) {\n-          Replica replica = docCollection.getReplica(cd.getCloudDescriptor().getCoreNodeName());\n-          assert replica != null;\n-          if (replica.getType() == Replica.Type.TLOG) { // TODO: needed here?\n-            getZkController().stopReplicationFromLeader(core.getName());\n-            if (!cd.getCloudDescriptor().isLeader()) {\n-              getZkController().startReplicationFromLeader(newCore.getName(), true);\n-            }\n-\n-          } else if (replica.getType() == Replica.Type.PULL) {\n-            getZkController().stopReplicationFromLeader(core.getName());\n-            getZkController().startReplicationFromLeader(newCore.getName(), false);\n-          }\n-        }\n-        success = true;\n-      } catch (SolrCoreState.CoreIsClosedException e) {\n-        throw e;\n-      } catch (Exception e) {\n-        coreInitFailures.put(cd.getName(), new CoreLoadFailure(cd, e));\n-        throw new SolrException(ErrorCode.SERVER_ERROR, \"Unable to reload core [\" + cd.getName() + \"]\", e);\n-      } finally {\n-        if (!success && newCore != null && newCore.getOpenCount() > 0) {\n-          IOUtils.closeQuietly(newCore);\n-        }\n-        solrCores.removeFromPendingOps(cd.getName());\n-      }\n-    } else {\n-      CoreLoadFailure clf = coreInitFailures.get(name);\n-      if (clf != null) {\n-        try {\n-          solrCores.waitAddPendingCoreOps(clf.cd.getName());\n-          createFromDescriptor(clf.cd, true, false);\n-        } finally {\n-          solrCores.removeFromPendingOps(clf.cd.getName());\n-        }\n-      } else {\n-        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No such core: \" + name);\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Swaps two SolrCore descriptors.\n-   */\n-  public void swap(String n0, String n1) {\n-    if (n0 == null || n1 == null) {\n-      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Can not swap unnamed cores.\");\n-    }\n-    solrCores.swap(n0, n1);\n-\n-    coresLocator.swap(this, solrCores.getCoreDescriptor(n0), solrCores.getCoreDescriptor(n1));\n-\n-    log.info(\"swapped: {} with {}\", n0, n1);\n-  }\n-\n-  /**\n-   * Unload a core from this container, leaving all files on disk\n-   *\n-   * @param name the name of the core to unload\n-   */\n-  public void unload(String name) {\n-    unload(name, false, false, false);\n-  }\n-\n-  /**\n-   * Unload a core from this container, optionally removing the core's data and configuration\n-   *\n-   * @param name              the name of the core to unload\n-   * @param deleteIndexDir    if true, delete the core's index on close\n-   * @param deleteDataDir     if true, delete the core's data directory on close\n-   * @param deleteInstanceDir if true, delete the core's instance directory on close\n-   */\n-  public void unload(String name, boolean deleteIndexDir, boolean deleteDataDir, boolean deleteInstanceDir) {\n-\n-    CoreDescriptor cd = solrCores.getCoreDescriptor(name);\n-\n-    if (name != null) {\n-      // check for core-init errors first\n-      CoreLoadFailure loadFailure = coreInitFailures.remove(name);\n-      if (loadFailure != null) {\n-        // getting the index directory requires opening a DirectoryFactory with a SolrConfig, etc,\n-        // which we may not be able to do because of the init error.  So we just go with what we\n-        // can glean from the CoreDescriptor - datadir and instancedir\n-        SolrCore.deleteUnloadedCore(loadFailure.cd, deleteDataDir, deleteInstanceDir);\n-        // If last time around we didn't successfully load, make sure that all traces of the coreDescriptor are gone.\n-        if (cd != null) {\n-          solrCores.removeCoreDescriptor(cd);\n-          coresLocator.delete(this, cd);\n-        }\n-        return;\n-      }\n-    }\n-\n-    if (cd == null) {\n-      throw new SolrException(ErrorCode.BAD_REQUEST, \"Cannot unload non-existent core [\" + name + \"]\");\n-    }\n-\n-    boolean close = solrCores.isLoadedNotPendingClose(name);\n-    SolrCore core = solrCores.remove(name);\n-\n-    solrCores.removeCoreDescriptor(cd);\n-    coresLocator.delete(this, cd);\n-    if (core == null) {\n-      // transient core\n-      SolrCore.deleteUnloadedCore(cd, deleteDataDir, deleteInstanceDir);\n-      return;\n-    }\n-\n-    // delete metrics specific to this core\n-    metricManager.removeRegistry(core.getCoreMetricManager().getRegistryName());\n-\n-    if (zkSys.getZkController() != null) {\n-      // cancel recovery in cloud mode\n-      core.getSolrCoreState().cancelRecovery();\n-      if (cd.getCloudDescriptor().getReplicaType() == Replica.Type.PULL\n-          || cd.getCloudDescriptor().getReplicaType() == Replica.Type.TLOG) {\n-        // Stop replication if this is part of a pull/tlog replica before closing the core\n-        zkSys.getZkController().stopReplicationFromLeader(name);\n-      }\n-    }\n-\n-    core.unloadOnClose(cd, deleteIndexDir, deleteDataDir, deleteInstanceDir);\n-    if (close)\n-      core.closeAndWait();\n-\n-    if (zkSys.getZkController() != null) {\n-      try {\n-        zkSys.getZkController().unregister(name, cd);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        throw new SolrException(ErrorCode.SERVER_ERROR, \"Interrupted while unregistering core [\" + name + \"] from cloud state\");\n-      } catch (KeeperException e) {\n-        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n-      } catch (Exception e) {\n-        throw new SolrException(ErrorCode.SERVER_ERROR, \"Error unregistering core [\" + name + \"] from cloud state\", e);\n-      }\n-    }\n-  }\n-\n-  public void rename(String name, String toName) {\n-    SolrIdentifierValidator.validateCoreName(toName);\n-    try (SolrCore core = getCore(name)) {\n-      if (core != null) {\n-        String oldRegistryName = core.getCoreMetricManager().getRegistryName();\n-        String newRegistryName = SolrCoreMetricManager.createRegistryName(core, toName);\n-        metricManager.swapRegistries(oldRegistryName, newRegistryName);\n-        // The old coreDescriptor is obsolete, so remove it. registerCore will put it back.\n-        CoreDescriptor cd = core.getCoreDescriptor();\n-        solrCores.removeCoreDescriptor(cd);\n-        cd.setProperty(\"name\", toName);\n-        solrCores.addCoreDescriptor(cd);\n-        core.setName(toName);\n-        registerCore(cd, core, true, false);\n-        SolrCore old = solrCores.remove(name);\n-\n-        coresLocator.rename(this, old.getCoreDescriptor(), core.getCoreDescriptor());\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Get the CoreDescriptors for all cores managed by this container\n-   *\n-   * @return a List of CoreDescriptors\n-   */\n-  public List<CoreDescriptor> getCoreDescriptors() {\n-    return solrCores.getCoreDescriptors();\n-  }\n-\n-  public CoreDescriptor getCoreDescriptor(String coreName) {\n-    return solrCores.getCoreDescriptor(coreName);\n-  }\n-\n-  /** Where cores are created (absolute). */\n-  public Path getCoreRootDirectory() {\n-    return cfg.getCoreRootDirectory();\n-  }\n-\n-  /**\n-   * Gets a core by name and increase its refcount.\n-   *\n-   * @param name the core name\n-   * @return the core if found, null if a SolrCore by this name does not exist\n-   * @throws SolrCoreInitializationException if a SolrCore with this name failed to be initialized\n-   * @see SolrCore#close()\n-   */\n-  public SolrCore getCore(String name) {\n-\n-    // Do this in two phases since we don't want to lock access to the cores over a load.\n-    SolrCore core = solrCores.getCoreFromAnyList(name, true);\n-\n-    // If a core is loaded, we're done just return it.\n-    if (core != null) {\n-      return core;\n-    }\n-\n-    // If it's not yet loaded, we can check if it's had a core init failure and \"do the right thing\"\n-    CoreDescriptor desc = solrCores.getCoreDescriptor(name);\n-\n-    // if there was an error initializing this core, throw a 500\n-    // error with the details for clients attempting to access it.\n-    CoreLoadFailure loadFailure = getCoreInitFailures().get(name);\n-    if (null != loadFailure) {\n-      throw new SolrCoreInitializationException(name, loadFailure.exception);\n-    }\n-    // This is a bit of awkwardness where SolrCloud and transient cores don't play nice together. For transient cores,\n-    // we have to allow them to be created at any time there hasn't been a core load failure (use reload to cure that).\n-    // But for TestConfigSetsAPI.testUploadWithScriptUpdateProcessor, this needs to _not_ try to load the core if\n-    // the core is null and there was an error. If you change this, be sure to run both TestConfiSetsAPI and\n-    // TestLazyCores\n-    if (desc == null || zkSys.getZkController() != null) return null;\n-\n-    // This will put an entry in pending core ops if the core isn't loaded. Here's where moving the\n-    // waitAddPendingCoreOps to createFromDescriptor would introduce a race condition.\n-    core = solrCores.waitAddPendingCoreOps(name);\n-\n-    if (isShutDown) return null; // We're quitting, so stop. This needs to be after the wait above since we may come off\n-    // the wait as a consequence of shutting down.\n-    try {\n-      if (core == null) {\n-        if (zkSys.getZkController() != null) {\n-          zkSys.getZkController().throwErrorIfReplicaReplaced(desc);\n-        }\n-        core = createFromDescriptor(desc, true, false); // This should throw an error if it fails.\n-      }\n-      core.open();\n-    } finally {\n-      solrCores.removeFromPendingOps(name);\n-    }\n-\n-    return core;\n-  }\n-\n-  public BlobRepository getBlobRepository() {\n-    return blobRepository;\n-  }\n-\n-  /**\n-   * If using asyncSolrCoreLoad=true, calling this after {@link #load()} will\n-   * not return until all cores have finished loading.\n-   *\n-   * @param timeoutMs timeout, upon which method simply returns\n-   */\n-  public void waitForLoadingCoresToFinish(long timeoutMs) {\n-    solrCores.waitForLoadingCoresToFinish(timeoutMs);\n-  }\n-\n-  public void waitForLoadingCore(String name, long timeoutMs) {\n-    solrCores.waitForLoadingCoreToFinish(name, timeoutMs);\n-  }\n-\n-  // ---------------- CoreContainer request handlers --------------\n-\n-  @SuppressWarnings({\"rawtypes\"})\n-  protected <T> T createHandler(String path, String handlerClass, Class<T> clazz) {\n-    T handler = loader.newInstance(handlerClass, clazz, null, new Class[]{CoreContainer.class}, new Object[]{this});\n-    if (handler instanceof SolrRequestHandler) {\n-      containerHandlers.put(path, (SolrRequestHandler) handler);\n-    }\n-    if (handler instanceof SolrMetricProducer) {\n-      ((SolrMetricProducer) handler).initializeMetrics(solrMetricsContext, path);\n-    }\n-    return handler;\n-  }\n-\n-  public CoreAdminHandler getMultiCoreHandler() {\n-    return coreAdminHandler;\n-  }\n-\n-  public CollectionsHandler getCollectionsHandler() {\n-    return collectionsHandler;\n-  }\n-\n-  public HealthCheckHandler getHealthCheckHandler() {\n-    return healthCheckHandler;\n-  }\n-\n-  public InfoHandler getInfoHandler() {\n-    return infoHandler;\n-  }\n-\n-  public ConfigSetsHandler getConfigSetsHandler() {\n-    return configSetsHandler;\n-  }\n-\n-  public String getHostName() {\n-    return this.hostName;\n-  }\n-\n-  /**\n-   * Gets the alternate path for multicore handling:\n-   * This is used in case there is a registered unnamed core (aka name is \"\") to\n-   * declare an alternate way of accessing named cores.\n-   * This can also be used in a pseudo single-core environment so admins can prepare\n-   * a new version before swapping.\n-   */\n-  public String getManagementPath() {\n-    return cfg.getManagementPath();\n-  }\n-\n-  @SuppressWarnings({\"rawtypes\"})\n-  public LogWatcher getLogging() {\n-    return logging;\n-  }\n-\n-  /**\n-   * Determines whether the core is already loaded or not but does NOT load the core\n-   */\n-  public boolean isLoaded(String name) {\n-    return solrCores.isLoaded(name);\n-  }\n-\n-  public boolean isLoadedNotPendingClose(String name) {\n-    return solrCores.isLoadedNotPendingClose(name);\n-  }\n-\n-  // Primarily for transient cores when a core is aged out.\n-  public void queueCoreToClose(SolrCore coreToClose) {\n-    solrCores.queueCoreToClose(coreToClose);\n-  }\n-\n-  /**\n-   * Gets a solr core descriptor for a core that is not loaded. Note that if the caller calls this on a\n-   * loaded core, the unloaded descriptor will be returned.\n-   *\n-   * @param cname - name of the unloaded core descriptor to load. NOTE:\n-   * @return a coreDescriptor. May return null\n-   */\n-  public CoreDescriptor getUnloadedCoreDescriptor(String cname) {\n-    return solrCores.getUnloadedCoreDescriptor(cname);\n-  }\n-\n-  /** The primary path of a Solr server's config, cores, and misc things. Absolute. */\n-  //TODO return Path\n-  public String getSolrHome() {\n-    return solrHome.toString();\n-  }\n-\n-  public boolean isZooKeeperAware() {\n-    return zkSys.getZkController() != null;\n-  }\n-\n-  public ZkController getZkController() {\n-    return zkSys.getZkController();\n-  }\n-\n-  public NodeConfig getConfig() {\n-    return cfg;\n-  }\n-\n-  /**\n-   * The default ShardHandlerFactory used to communicate with other solr instances\n-   */\n-  public ShardHandlerFactory getShardHandlerFactory() {\n-    return shardHandlerFactory;\n-  }\n-\n-  public UpdateShardHandler getUpdateShardHandler() {\n-    return updateShardHandler;\n-  }\n-\n-  public SolrResourceLoader getResourceLoader() {\n-    return loader;\n-  }\n-\n-  public boolean isCoreLoading(String name) {\n-    return solrCores.isCoreLoading(name);\n-  }\n-\n-  public AuthorizationPlugin getAuthorizationPlugin() {\n-    return authorizationPlugin == null ? null : authorizationPlugin.plugin;\n-  }\n-\n-  public AuthenticationPlugin getAuthenticationPlugin() {\n-    return authenticationPlugin == null ? null : authenticationPlugin.plugin;\n-  }\n-\n-  public AuditLoggerPlugin getAuditLoggerPlugin() {\n-    return auditloggerPlugin == null ? null : auditloggerPlugin.plugin;\n-  }\n-\n-  public NodeConfig getNodeConfig() {\n-    return cfg;\n-  }\n-\n-  public long getStatus() {\n-    return status;\n-  }\n-\n-  // Occasionally we need to access the transient cache handler in places other than coreContainer.\n-  public TransientSolrCoreCache getTransientCache() {\n-    return solrCores.getTransientCacheHandler();\n-  }\n-\n-  /**\n-   * @param solrCore the core against which we check if there has been a tragic exception\n-   * @return whether this Solr core has tragic exception\n-   * @see org.apache.lucene.index.IndexWriter#getTragicException()\n-   */\n-  public boolean checkTragicException(SolrCore solrCore) {\n-    Throwable tragicException;\n-    try {\n-      tragicException = solrCore.getSolrCoreState().getTragicException();\n-    } catch (IOException e) {\n-      // failed to open an indexWriter\n-      tragicException = e;\n-    }\n-\n-    if (tragicException != null && isZooKeeperAware()) {\n-      getZkController().giveupLeadership(solrCore.getCoreDescriptor(), tragicException);\n-    }\n-\n-    return tragicException != null;\n-  }\n-\n-  public CustomContainerPlugins getCustomContainerPlugins(){\n-    return customContainerPlugins;\n-  }\n-\n-  static {\n-    ExecutorUtil.addThreadLocalProvider(SolrRequestInfo.getInheritableThreadLocalProvider());\n-  }\n-\n-  /**\n-   * Run an arbitrary task in it's own thread. This is an expert option and is\n-   * a method you should use with great care. It would be bad to run something that never stopped\n-   * or run something that took a very long time. Typically this is intended for actions that take\n-   * a few seconds, and therefore would be bad to wait for within a request, or actions that need to happen\n-   * when a core has zero references, but but would not pose a significant hindrance to server shut down times.\n-   * It is not intended for long running tasks and if you are using a Runnable with a loop in it, you are\n-   * almost certainly doing it wrong.\n-   * <p><br>\n-   * WARNING: Solr wil not be able to shut down gracefully until this task completes!\n-   * <p><br>\n-   * A significant upside of using this method vs creating your own ExecutorService is that your code\n-   * does not have to properly shutdown executors which typically is risky from a unit testing\n-   * perspective since the test framework will complain if you don't carefully ensure the executor\n-   * shuts down before the end of the test. Also the threads running this task are sure to have\n-   * a proper MDC for logging.\n-   * <p><br>\n-   * Normally, one uses {@link SolrCore#runAsync(Runnable)} if possible, but in some cases\n-   * you might need to execute a task asynchronously when you could be running on a node with no\n-   * cores, and then use of this method is indicated.\n-   *\n-   * @param r the task to run\n-   */\n-  public void runAsync(Runnable r) {\n-    coreContainerAsyncTaskExecutor.submit(r);\n-  }\n-}\n-\n-class CloserThread extends Thread {\n-  CoreContainer container;\n-  SolrCores solrCores;\n-  NodeConfig cfg;\n-\n-\n-  CloserThread(CoreContainer container, SolrCores solrCores, NodeConfig cfg) {\n-    this.container = container;\n-    this.solrCores = solrCores;\n-    this.cfg = cfg;\n-  }\n-\n-  // It's important that this be the _only_ thread removing things from pendingDynamicCloses!\n-  // This is single-threaded, but I tried a multi-threaded approach and didn't see any performance gains, so\n-  // there's no good justification for the complexity. I suspect that the locking on things like DefaultSolrCoreState\n-  // essentially create a single-threaded process anyway.\n-  @Override\n-  public void run() {\n-    while (!container.isShutDown()) {\n-      synchronized (solrCores.getModifyLock()) { // need this so we can wait and be awoken.\n-        try {\n-          solrCores.getModifyLock().wait();\n-        } catch (InterruptedException e) {\n-          // Well, if we've been told to stop, we will. Otherwise, continue on and check to see if there are\n-          // any cores to close.\n-        }\n-      }\n-      for (SolrCore removeMe = solrCores.getCoreToClose();\n-           removeMe != null && !container.isShutDown();\n-           removeMe = solrCores.getCoreToClose()) {\n-        try {\n-          removeMe.close();\n-        } finally {\n-          solrCores.removeFromPendingOps(removeMe.getName());\n-        }\n-      }\n-    }\n-  }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "3000bbd05aeff0d821b276a912ec481a3411f2ab", "committedDate": "2020-06-25 00:18:58 -0400", "message": "SOLR Move \"userfiles\" stuff from SolrPaths to CoreContainer. (#1600)"}, {"oid": "d0864a19c7c039d49be3c8635252c42cebb48dfb", "committedDate": "2020-07-01 22:07:59 -0400", "message": "SOLR-14523: Enhance gradle logging calls validation: eliminate getMessage()"}, {"oid": "e9568c347316552c38137c5bef8fafcb14defd6b", "committedDate": "2020-07-02 23:56:17 -0400", "message": "SOLR-10742: SolrCores.getNamesForCore is quite inefficient and blocks other core operations"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "cc0c111949d5039a0c7cb67cad55c63e2f761298", "committedDate": "2020-07-20 17:47:01 +0530", "message": "SOLR-14656: Removing Autoscaling Framework"}, {"oid": "5295007022b524160b76a7afc55b76d1eee26541", "committedDate": "2020-07-25 01:08:23 -0400", "message": "SOLR-14652: SolrCore should hold its own CoreDescriptor (#1675)"}, {"oid": "a3624029ad262489b091d9a474430359f782d307", "committedDate": "2020-07-28 16:46:27 -0400", "message": "SOLR-14651: Metrics History could disable better (#1672)"}, {"oid": "a6515ca38f9813730d16f1d8eaba953e4cd130ca", "committedDate": "2020-08-12 18:44:02 -0400", "message": "SOLR-14748: Correct condition on startup auth/ssl logging"}, {"oid": "59d087f0b391b740491839acb48390f3d08030de", "committedDate": "2020-08-28 15:59:56 -0700", "message": "SOLR-14774: Create HealthCheckHandler in CoreContainer (#1774)"}, {"oid": "95ab98c920833f286608846188d69302b478f80a", "committedDate": "2020-09-08 09:58:42 +1000", "message": "SOLR-14151: Bug fixes (#1815)"}, {"oid": "c902837bb237e579f9fdd0db0a8b35680b294ad1", "committedDate": "2020-09-09 09:19:48 -0500", "message": "SOLR-14846 Clean up Optional use (#1843)"}, {"oid": "27a14fe48139019a4c09ba072751e093fc5cb5f1", "committedDate": "2020-09-14 12:22:58 +1000", "message": "Revert \"SOLR-14151: Bug fixes (#1815)\""}, {"oid": "7b8e72e5531f3678242e1106d528ec835ac33959", "committedDate": "2020-09-16 18:06:43 +1000", "message": "SOLR-14871 Use Annotations for v2 APIs in/cluster path (#1878)"}, {"oid": "6b87cfb88c1ad428f3b6affb53aef1ed49949ab8", "committedDate": "2020-09-16 19:19:45 +1000", "message": "Merge branch 'master' of github.com:apache/lucene-solr"}, {"oid": "cbb1659640cd51be8b403eda8399c527af1c848e", "committedDate": "2020-09-17 11:19:21 +1000", "message": "Revert \"Revert \"SOLR-14151: Bug fixes (#1815)\"\""}, {"oid": "73c06e35e8bfd341042b14c309ce734b38221cee", "committedDate": "2020-09-21 15:08:23 +1000", "message": "SOLR-14881: ManagedSchemaRoundRobinCloudTest test failures"}, {"oid": "fd0c08615df9440061e5ae664dcfa3f5a7600568", "committedDate": "2020-09-23 21:55:51 +1000", "message": "SOLR-14890: Refactor code to use annotations for configset API (#1911)"}, {"oid": "565c5b1ac4ac0b7beca0361607846119f5902af4", "committedDate": "2020-09-24 12:37:12 +1000", "message": "SOLR-14894: Use annotations to implement V2 collection APIs"}, {"oid": "a65e9dd31149bba33aec361b1e7f9fd877141d66", "committedDate": "2020-09-29 15:37:47 +1000", "message": "SOLR-14151: cleanup"}, {"oid": "2a3da99e2dc006701d0799d84480183c9a81cd3e", "committedDate": "2020-10-15 10:14:16 +0200", "message": "SOLR-14914: Add option to disable metrics collection."}, {"oid": "85b58c262a7516ad8f708f44308ec16d7e04d458", "committedDate": "2020-10-17 10:55:35 -0400", "message": "LUCENE-9576: nuke SSD detection, modernize CMS defaults"}, {"oid": "9ab9d208c7272126d76cf72d6a642bb0f97e0c35", "committedDate": "2020-10-19 11:50:08 +0200", "message": "SOLR-14944: Remove the \"spins\" metrics."}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "706f284c467becb5f002c05455808ee31aee3465", "committedDate": "2020-10-24 17:39:00 +0530", "message": "SOLR-14942: Reduce leader election time on node shutdown (#2004)"}, {"oid": "2c49c4a27d99316c9d962a50171f728de58bfa2a", "committedDate": "2020-10-31 19:34:09 -0400", "message": "SOLR-14969: Prevent creating multiple cores with the same name which leads to instabilities (race condition)"}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}, {"oid": "be19432b750b94c4703ee7b19ef681ebf771a95a", "committedDate": "2020-11-09 08:16:43 -0500", "message": "SOLR-14969: Prevent creating multiple cores with the same name which leads to instabilities (race condition) changed error code"}, {"oid": "67f9245ce30bb21d3976c05548856c81cf7ee8a1", "committedDate": "2020-11-11 11:37:45 +0100", "message": "SOLR-14975: Optimize CoreContainer.getAllCoreNames and getLoadedCoreNames. Also optimize getCoreDescriptors."}, {"oid": "cced5078ea13797a49658cdf76f693a79788c533", "committedDate": "2020-12-06 14:51:10 +0100", "message": "SOLR-15016: Replica placement plugins should use container plugins API / configs."}, {"oid": "bf7b438f12d65904b461e595594fc9a64cfcc899", "committedDate": "2020-12-15 15:54:40 -0600", "message": "SOLR-15029 Trigger leader election on index writer tragedy"}, {"oid": "b3350346154303f6d39e83788bd79e81f2471072", "committedDate": "2021-01-28 15:04:15 -0600", "message": "Require Thread Names in Solr (#2264)"}, {"oid": "0d4769e174aad3eede7e7b281d14682bab483468", "committedDate": "2021-01-29 10:20:16 -0600", "message": "SOLR-15120 Reduce duplicated core creation work (#2266)"}, {"oid": "715caaae52ab3ab548d37e18a173b7d744054257", "committedDate": "2021-01-29 11:15:22 -0600", "message": "SOLR-15085 Prevent EmbeddedSolrServer calling shutdown on a CoreContainer that was passed to it"}, {"oid": "e89fba6fe7739cb213560b94b6a4a76e40c2e4a5", "committedDate": "2021-02-08 10:11:58 -0500", "message": "SOLR-15118: Convert /v2/collections APIs to annotations (#2281)"}, {"oid": "f993c392f10eb8b145ebac5b103217308fa57fda", "committedDate": "2021-02-15 07:04:05 -0500", "message": "SOLR-15101: Add list/delete APIs for incremental backups (#2336)"}, {"oid": "8b443420b878f236c78973ec546d1988ac6b7bdb", "committedDate": "2021-03-01 22:27:37 -0500", "message": "SOLR-15100: make ConfigSetService configurable in solr.xml (#2343)"}, {"oid": "d822a38a48b8cc1844baad2e1e20088e90603847", "committedDate": "2021-03-02 13:44:24 +0000", "message": "SOLR-15206: improve CoreContainer constructor javadocs (#2443)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzM4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412493389", "body": "prefer Collections.emptyMap()", "bodyText": "prefer Collections.emptyMap()", "bodyHTML": "<p dir=\"auto\">prefer Collections.emptyMap()</p>", "author": "madrob", "createdAt": "2020-04-21T21:09:39Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);\n+      }\n+\n+      ApiInfo apiInfo = null;\n+      try {\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+      } catch (Exception ex) {\n+        log.error(\"unable to instantiate apiInfo \", ex);\n+        continue;\n+      }\n+\n+      String path = pluginNameVsPath.get(e.getKey());\n+      if (path == null) {\n+        // there is a new apiInfo . let's register it\n+        try {\n+          apiInfo.init();\n+          ApiHolder holder = new ApiHolder(apiInfo);\n+          plugins.put(holder.key, holder);\n+          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n+          containerApiBag.register(holder, Collections.EMPTY_MAP);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,151 +49,141 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n   private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n   private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n-\n-\n-    private AnnotatedApi delegate;\n+    Object instance;\n \n \n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "677d84f7be7665a748d8d94ab5eee952dac60926", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex ba84655cb01..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -186,6 +188,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     Object instance;\n \n \n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,153 +50,145 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n-  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private final ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private final Map<String, ApiInfo> currentPlugins = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n-  private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+  private static class ApiHolder extends Api {\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  @SuppressWarnings({\"rawtypes\"})\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n+    Object instance;\n \n \n-    private AnnotatedApi delegate;\n-\n-\n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": {"commit": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6536276e294 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -187,6 +210,17 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     private Class klas;\n     Object instance;\n \n+    ApiHolder get(EndPoint endPoint) {\n+      for (ApiHolder holder : holders) {\n+        EndPoint e = holder.api.getEndPoint();\n+        if(Objects.equals(endPoint.method()[0] , e.method()[0]) &&\n+            Objects.equals(endPoint.path()[0], e.path()[0])) {\n+          return holder;\n+        }\n+      }\n+      return null;\n+    }\n+\n \n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 6536276e294..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -225,12 +225,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n-      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n-      pkg = klassInfo.first();\n+      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n+      pkg = klassInfo.pkg;\n       if (pkg != null) {\n         PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n         if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.first());\n+          errs.add(\"Invalid package \" + klassInfo.pkg);\n           return;\n         }\n         this.pkgVersion = p.getVersion(info.version);\n", "next_change": {"commit": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex f24626bbf08..ef33c3e2a4c 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -228,16 +229,23 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n       PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n       pkg = klassInfo.pkg;\n       if (pkg != null) {\n-        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n-        if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.pkg);\n-          return;\n+        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n+        if (ver.isEmpty()) {\n+          //may be we are a bit early. Do a refresh and try again\n+         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n+         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n         }\n-        this.pkgVersion = p.getVersion(info.version);\n-        if (pkgVersion == null) {\n-          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n-          return;\n+        if (ver.isEmpty()) {\n+          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+          if (p == null) {\n+            errs.add(\"Invalid package \" + klassInfo.pkg);\n+            return;\n+          } else {\n+            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+            return;\n+          }\n         }\n+        this.pkgVersion = ver.get();\n         try {\n           klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5MzQxNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412493416", "body": "This parameter is unused?", "bodyText": "This parameter is unused?", "bodyHTML": "<p dir=\"auto\">This parameter is unused?</p>", "author": "madrob", "createdAt": "2020-04-21T21:09:42Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f051b497f549762a727ce4b1248a0fc5fa513d24", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..a07c88abdf4 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -76,7 +77,8 @@ public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListe\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n", "next_change": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex a07c88abdf4..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,33 +49,26 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n   private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  //a unique path name such as POST a/b/c vs. APIs\n-   private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n     refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh() {\n+  public synchronized void refresh() {\n     Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n", "next_change": null}, {"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex a07c88abdf4..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -85,119 +76,114 @@ public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListe\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"Could not initialize Plugin\", exception);\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n   private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n-\n-\n-    private AnnotatedApi delegate;\n+    Object instance;\n \n \n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "677d84f7be7665a748d8d94ab5eee952dac60926", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex ba84655cb01..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -186,6 +188,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     Object instance;\n \n \n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,153 +50,145 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n-  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private final ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private final Map<String, ApiInfo> currentPlugins = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n-  private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+  private static class ApiHolder extends Api {\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  @SuppressWarnings({\"rawtypes\"})\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n+    Object instance;\n \n \n-    private AnnotatedApi delegate;\n-\n-\n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": {"commit": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6536276e294 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -187,6 +210,17 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     private Class klas;\n     Object instance;\n \n+    ApiHolder get(EndPoint endPoint) {\n+      for (ApiHolder holder : holders) {\n+        EndPoint e = holder.api.getEndPoint();\n+        if(Objects.equals(endPoint.method()[0] , e.method()[0]) &&\n+            Objects.equals(endPoint.path()[0], e.path()[0])) {\n+          return holder;\n+        }\n+      }\n+      return null;\n+    }\n+\n \n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 6536276e294..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -225,12 +225,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n-      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n-      pkg = klassInfo.first();\n+      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n+      pkg = klassInfo.pkg;\n       if (pkg != null) {\n         PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n         if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.first());\n+          errs.add(\"Invalid package \" + klassInfo.pkg);\n           return;\n         }\n         this.pkgVersion = p.getVersion(info.version);\n", "next_change": {"commit": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex f24626bbf08..ef33c3e2a4c 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -228,16 +229,23 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n       PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n       pkg = klassInfo.pkg;\n       if (pkg != null) {\n-        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n-        if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.pkg);\n-          return;\n+        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n+        if (ver.isEmpty()) {\n+          //may be we are a bit early. Do a refresh and try again\n+         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n+         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n         }\n-        this.pkgVersion = p.getVersion(info.version);\n-        if (pkgVersion == null) {\n-          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n-          return;\n+        if (ver.isEmpty()) {\n+          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+          if (p == null) {\n+            errs.add(\"Invalid package \" + klassInfo.pkg);\n+            return;\n+          } else {\n+            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+            return;\n+          }\n         }\n+        this.pkgVersion = ver.get();\n         try {\n           klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTIwMw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412495203", "body": "This feels like a super klunky API writing errors to a string in a constructor argument? Why can't we just throw exceptions here?", "bodyText": "This feels like a super klunky API writing errors to a string in a constructor argument? Why can't we just throw exceptions here?", "bodyHTML": "<p dir=\"auto\">This feels like a super klunky API writing errors to a string in a constructor argument? Why can't we just throw exceptions here?</p>", "author": "madrob", "createdAt": "2020-04-21T21:12:34Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);\n+      }\n+\n+      ApiInfo apiInfo = null;\n+      try {\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+      } catch (Exception ex) {\n+        log.error(\"unable to instantiate apiInfo \", ex);\n+        continue;\n+      }\n+\n+      String path = pluginNameVsPath.get(e.getKey());\n+      if (path == null) {\n+        // there is a new apiInfo . let's register it\n+        try {\n+          apiInfo.init();\n+          ApiHolder holder = new ApiHolder(apiInfo);\n+          plugins.put(holder.key, holder);\n+          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n+          containerApiBag.register(holder, Collections.EMPTY_MAP);\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+        }\n+      } else {\n+        ApiHolder old = plugins.get(apiInfo.key);\n+        if (path.equals(apiInfo.key)) {\n+          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n+            //this plugin uses the same version. No need to update\n+            continue;\n+          }\n+          //this apiInfo existed at the same path but uses a newer version of the package\n+          //refresh the existing Api holder\n+          try {\n+            apiInfo.init();\n+          } catch (Exception exception) {\n+            log.error(\"COuld not inititlaize Plugin\", exception);\n+          }\n+          plugins.get(apiInfo.key).refresh(apiInfo);\n+        } else {// the path is changed for the same apiInfo. it's not allowed\n+          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n+        }\n+      }\n+    }\n+    Set<String> toBeRemoved = new HashSet<>();\n+    for (String s : pluginNameVsPath.keySet()) {\n+      if (!pluginInfos.containsKey(s)) {\n+        toBeRemoved.add(s);\n+      }\n+    }\n+    for (String s : toBeRemoved) {\n+      String pathKey = pluginNameVsPath.remove(s);\n+      ApiHolder holder = plugins.remove(pathKey);\n+      if (holder != null) {\n+        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n+        if (old instanceof Closeable) {\n+          closeWhileHandlingException((Closeable) old);\n+        }\n+\n+      }\n+    }\n+  }\n+\n+  private class ApiHolder extends Api {\n+    private final String key;\n+    private ApiInfo apiInfo;\n+\n+    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n+      super(apiInfo.delegate);\n+      this.apiInfo = apiInfo;\n+      this.key = apiInfo.key;\n+    }\n+\n+    @Override\n+    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      apiInfo.delegate.call(req, rsp);\n+    }\n+\n+    void refresh(ApiInfo info) {\n+      this.apiInfo = info;\n+      super.spec = info.delegate;\n+    }\n+  }\n+\n+  public class ApiInfo implements ReflectMapWriter  {\n+    /*This is the path at which this handler is\n+     *\n+     */\n+    @JsonProperty\n+    public String key;\n+    @JsonProperty\n+    private final PluginMeta info;\n+\n+    @JsonProperty(value = \"package\")\n+    public final String pkg;\n+    private PackageLoader.Package.Version pkgVersion;\n+    EndPoint endPoint;\n+\n+    private Class klas;\n+\n+\n+    private AnnotatedApi delegate;\n+\n+\n+    public ApiInfo(PluginMeta info, List<String> errs) {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIwOTYxMA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r426209610", "bodyText": "The objective is to collect multiple errors and eventually throw one single Exception whihc contains all of them", "author": "noblepaul", "createdAt": "2020-05-17T02:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTIwMw=="}], "type": "inlineReview", "revised_code": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,151 +49,141 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n   private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n   private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n-\n-\n-    private AnnotatedApi delegate;\n+    Object instance;\n \n \n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "677d84f7be7665a748d8d94ab5eee952dac60926", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex ba84655cb01..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -186,6 +188,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     Object instance;\n \n \n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,153 +50,145 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n-  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private final ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private final Map<String, ApiInfo> currentPlugins = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n-  private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+  private static class ApiHolder extends Api {\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  @SuppressWarnings({\"rawtypes\"})\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n+    Object instance;\n \n \n-    private AnnotatedApi delegate;\n-\n-\n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": {"commit": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6536276e294 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -187,6 +210,17 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     private Class klas;\n     Object instance;\n \n+    ApiHolder get(EndPoint endPoint) {\n+      for (ApiHolder holder : holders) {\n+        EndPoint e = holder.api.getEndPoint();\n+        if(Objects.equals(endPoint.method()[0] , e.method()[0]) &&\n+            Objects.equals(endPoint.path()[0], e.path()[0])) {\n+          return holder;\n+        }\n+      }\n+      return null;\n+    }\n+\n \n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 6536276e294..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -225,12 +225,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n-      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n-      pkg = klassInfo.first();\n+      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n+      pkg = klassInfo.pkg;\n       if (pkg != null) {\n         PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n         if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.first());\n+          errs.add(\"Invalid package \" + klassInfo.pkg);\n           return;\n         }\n         this.pkgVersion = p.getVersion(info.version);\n", "next_change": {"commit": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex f24626bbf08..ef33c3e2a4c 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -228,16 +229,23 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n       PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n       pkg = klassInfo.pkg;\n       if (pkg != null) {\n-        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n-        if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.pkg);\n-          return;\n+        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n+        if (ver.isEmpty()) {\n+          //may be we are a bit early. Do a refresh and try again\n+         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n+         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n         }\n-        this.pkgVersion = p.getVersion(info.version);\n-        if (pkgVersion == null) {\n-          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n-          return;\n+        if (ver.isEmpty()) {\n+          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+          if (p == null) {\n+            errs.add(\"Invalid package \" + klassInfo.pkg);\n+            return;\n+          } else {\n+            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+            return;\n+          }\n         }\n+        this.pkgVersion = ver.get();\n         try {\n           klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTI5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412495299", "body": "nit: raw types", "bodyText": "nit: raw types", "bodyHTML": "<p dir=\"auto\">nit: raw types</p>", "author": "madrob", "createdAt": "2020-04-21T21:12:45Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);\n+      }\n+\n+      ApiInfo apiInfo = null;\n+      try {\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+      } catch (Exception ex) {\n+        log.error(\"unable to instantiate apiInfo \", ex);\n+        continue;\n+      }\n+\n+      String path = pluginNameVsPath.get(e.getKey());\n+      if (path == null) {\n+        // there is a new apiInfo . let's register it\n+        try {\n+          apiInfo.init();\n+          ApiHolder holder = new ApiHolder(apiInfo);\n+          plugins.put(holder.key, holder);\n+          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n+          containerApiBag.register(holder, Collections.EMPTY_MAP);\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+        }\n+      } else {\n+        ApiHolder old = plugins.get(apiInfo.key);\n+        if (path.equals(apiInfo.key)) {\n+          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n+            //this plugin uses the same version. No need to update\n+            continue;\n+          }\n+          //this apiInfo existed at the same path but uses a newer version of the package\n+          //refresh the existing Api holder\n+          try {\n+            apiInfo.init();\n+          } catch (Exception exception) {\n+            log.error(\"COuld not inititlaize Plugin\", exception);\n+          }\n+          plugins.get(apiInfo.key).refresh(apiInfo);\n+        } else {// the path is changed for the same apiInfo. it's not allowed\n+          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n+        }\n+      }\n+    }\n+    Set<String> toBeRemoved = new HashSet<>();\n+    for (String s : pluginNameVsPath.keySet()) {\n+      if (!pluginInfos.containsKey(s)) {\n+        toBeRemoved.add(s);\n+      }\n+    }\n+    for (String s : toBeRemoved) {\n+      String pathKey = pluginNameVsPath.remove(s);\n+      ApiHolder holder = plugins.remove(pathKey);\n+      if (holder != null) {\n+        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n+        if (old instanceof Closeable) {\n+          closeWhileHandlingException((Closeable) old);\n+        }\n+\n+      }\n+    }\n+  }\n+\n+  private class ApiHolder extends Api {\n+    private final String key;\n+    private ApiInfo apiInfo;\n+\n+    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n+      super(apiInfo.delegate);\n+      this.apiInfo = apiInfo;\n+      this.key = apiInfo.key;\n+    }\n+\n+    @Override\n+    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      apiInfo.delegate.call(req, rsp);\n+    }\n+\n+    void refresh(ApiInfo info) {\n+      this.apiInfo = info;\n+      super.spec = info.delegate;\n+    }\n+  }\n+\n+  public class ApiInfo implements ReflectMapWriter  {\n+    /*This is the path at which this handler is\n+     *\n+     */\n+    @JsonProperty\n+    public String key;\n+    @JsonProperty\n+    private final PluginMeta info;\n+\n+    @JsonProperty(value = \"package\")\n+    public final String pkg;\n+    private PackageLoader.Package.Version pkgVersion;\n+    EndPoint endPoint;\n+\n+    private Class klas;", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,151 +49,141 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n   private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n   private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n-\n-\n-    private AnnotatedApi delegate;\n+    Object instance;\n \n \n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "677d84f7be7665a748d8d94ab5eee952dac60926", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex ba84655cb01..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -186,6 +188,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     Object instance;\n \n \n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,153 +50,145 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n-  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private final ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private final Map<String, ApiInfo> currentPlugins = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n-  private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+  private static class ApiHolder extends Api {\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  @SuppressWarnings({\"rawtypes\"})\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n+    Object instance;\n \n \n-    private AnnotatedApi delegate;\n-\n-\n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": {"commit": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6536276e294 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -187,6 +210,17 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     private Class klas;\n     Object instance;\n \n+    ApiHolder get(EndPoint endPoint) {\n+      for (ApiHolder holder : holders) {\n+        EndPoint e = holder.api.getEndPoint();\n+        if(Objects.equals(endPoint.method()[0] , e.method()[0]) &&\n+            Objects.equals(endPoint.path()[0], e.path()[0])) {\n+          return holder;\n+        }\n+      }\n+      return null;\n+    }\n+\n \n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 6536276e294..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -225,12 +225,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n-      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n-      pkg = klassInfo.first();\n+      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n+      pkg = klassInfo.pkg;\n       if (pkg != null) {\n         PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n         if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.first());\n+          errs.add(\"Invalid package \" + klassInfo.pkg);\n           return;\n         }\n         this.pkgVersion = p.getVersion(info.version);\n", "next_change": {"commit": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex f24626bbf08..ef33c3e2a4c 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -228,16 +229,23 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n       PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n       pkg = klassInfo.pkg;\n       if (pkg != null) {\n-        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n-        if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.pkg);\n-          return;\n+        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n+        if (ver.isEmpty()) {\n+          //may be we are a bit early. Do a refresh and try again\n+         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n+         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n         }\n-        this.pkgVersion = p.getVersion(info.version);\n-        if (pkgVersion == null) {\n-          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n-          return;\n+        if (ver.isEmpty()) {\n+          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+          if (p == null) {\n+            errs.add(\"Invalid package \" + klassInfo.pkg);\n+            return;\n+          } else {\n+            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+            return;\n+          }\n         }\n+        this.pkgVersion = ver.get();\n         try {\n           klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTgzNQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412495835", "body": "should this have a `continue`?", "bodyText": "should this have a continue?", "bodyHTML": "<p dir=\"auto\">should this have a <code>continue</code>?</p>", "author": "madrob", "createdAt": "2020-04-21T21:13:36Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjI2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r433002266", "bodyText": "fixed", "author": "noblepaul", "createdAt": "2020-06-01T00:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTgzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,151 +49,141 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n   private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n   private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n-\n-\n-    private AnnotatedApi delegate;\n+    Object instance;\n \n \n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "677d84f7be7665a748d8d94ab5eee952dac60926", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex ba84655cb01..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -186,6 +188,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     Object instance;\n \n \n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,153 +50,145 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n-  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private final ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private final Map<String, ApiInfo> currentPlugins = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n-  private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+  private static class ApiHolder extends Api {\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  @SuppressWarnings({\"rawtypes\"})\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n+    Object instance;\n \n \n-    private AnnotatedApi delegate;\n-\n-\n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": {"commit": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6536276e294 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -187,6 +210,17 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     private Class klas;\n     Object instance;\n \n+    ApiHolder get(EndPoint endPoint) {\n+      for (ApiHolder holder : holders) {\n+        EndPoint e = holder.api.getEndPoint();\n+        if(Objects.equals(endPoint.method()[0] , e.method()[0]) &&\n+            Objects.equals(endPoint.path()[0], e.path()[0])) {\n+          return holder;\n+        }\n+      }\n+      return null;\n+    }\n+\n \n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 6536276e294..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -225,12 +225,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n-      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n-      pkg = klassInfo.first();\n+      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n+      pkg = klassInfo.pkg;\n       if (pkg != null) {\n         PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n         if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.first());\n+          errs.add(\"Invalid package \" + klassInfo.pkg);\n           return;\n         }\n         this.pkgVersion = p.getVersion(info.version);\n", "next_change": {"commit": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex f24626bbf08..ef33c3e2a4c 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -228,16 +229,23 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n       PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n       pkg = klassInfo.pkg;\n       if (pkg != null) {\n-        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n-        if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.pkg);\n-          return;\n+        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n+        if (ver.isEmpty()) {\n+          //may be we are a bit early. Do a refresh and try again\n+         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n+         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n         }\n-        this.pkgVersion = p.getVersion(info.version);\n-        if (pkgVersion == null) {\n-          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n-          return;\n+        if (ver.isEmpty()) {\n+          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+          if (p == null) {\n+            errs.add(\"Invalid package \" + klassInfo.pkg);\n+            return;\n+          } else {\n+            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+            return;\n+          }\n         }\n+        this.pkgVersion = ver.get();\n         try {\n           klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjE3MA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412496170", "body": "`refresh(properties)`?", "bodyText": "refresh(properties)?", "bodyHTML": "<p dir=\"auto\"><code>refresh(properties)</code>?</p>", "author": "madrob", "createdAt": "2020-04-21T21:14:09Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwMjIxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r433002219", "bodyText": "cleaned up", "author": "noblepaul", "createdAt": "2020-06-01T00:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjE3MA=="}], "type": "inlineReview", "revised_code": {"commit": "f051b497f549762a727ce4b1248a0fc5fa513d24", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..a07c88abdf4 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -57,12 +57,13 @@ public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListe\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  //a unique path name such as POST a/b/c vs. APIs\n+   private Map<String, ApiHolder> plugins = new HashMap<>();\n   private Map<String, String> pluginNameVsPath = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n \n", "next_change": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex a07c88abdf4..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,33 +49,26 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n   private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  //a unique path name such as POST a/b/c vs. APIs\n-   private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n     refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh() {\n+  public synchronized void refresh() {\n     Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,153 +50,145 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n-  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private final ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private final Map<String, ApiInfo> currentPlugins = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n-  private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+  private static class ApiHolder extends Api {\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  @SuppressWarnings({\"rawtypes\"})\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n+    Object instance;\n \n \n-    private AnnotatedApi delegate;\n-\n-\n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": {"commit": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6536276e294 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -187,6 +210,17 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     private Class klas;\n     Object instance;\n \n+    ApiHolder get(EndPoint endPoint) {\n+      for (ApiHolder holder : holders) {\n+        EndPoint e = holder.api.getEndPoint();\n+        if(Objects.equals(endPoint.method()[0] , e.method()[0]) &&\n+            Objects.equals(endPoint.path()[0], e.path()[0])) {\n+          return holder;\n+        }\n+      }\n+      return null;\n+    }\n+\n \n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 6536276e294..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -225,12 +225,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n-      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n-      pkg = klassInfo.first();\n+      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n+      pkg = klassInfo.pkg;\n       if (pkg != null) {\n         PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n         if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.first());\n+          errs.add(\"Invalid package \" + klassInfo.pkg);\n           return;\n         }\n         this.pkgVersion = p.getVersion(info.version);\n", "next_change": {"commit": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex f24626bbf08..ef33c3e2a4c 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -228,16 +229,23 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n       PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n       pkg = klassInfo.pkg;\n       if (pkg != null) {\n-        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n-        if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.pkg);\n-          return;\n+        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n+        if (ver.isEmpty()) {\n+          //may be we are a bit early. Do a refresh and try again\n+         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n+         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n         }\n-        this.pkgVersion = p.getVersion(info.version);\n-        if (pkgVersion == null) {\n-          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n-          return;\n+        if (ver.isEmpty()) {\n+          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+          if (p == null) {\n+            errs.add(\"Invalid package \" + klassInfo.pkg);\n+            return;\n+          } else {\n+            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+            return;\n+          }\n         }\n+        this.pkgVersion = ver.get();\n         try {\n           klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5ODMwMw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412498303", "body": "why do we need to iterate twice here? ", "bodyText": "why do we need to iterate twice here?", "bodyHTML": "<p dir=\"auto\">why do we need to iterate twice here?</p>", "author": "madrob", "createdAt": "2020-04-21T21:17:57Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+  private Map<String, ApiHolder> plugins = new HashMap<>();\n+  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh(null);\n+    return false;\n+  }\n+\n+  @Override\n+  public void writeMap(EntryWriter ew) {\n+    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n+  }\n+\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public void refresh(Map<String, Object> pluginInfos) {\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    if(pluginInfos.isEmpty()) return;\n+\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      PluginMeta info = null;\n+      try {\n+        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n+      } catch (IOException ioException) {\n+        log.error(\"Invalid apiInfo configuration :\", ioException);\n+      }\n+\n+      ApiInfo apiInfo = null;\n+      try {\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+      } catch (Exception ex) {\n+        log.error(\"unable to instantiate apiInfo \", ex);\n+        continue;\n+      }\n+\n+      String path = pluginNameVsPath.get(e.getKey());\n+      if (path == null) {\n+        // there is a new apiInfo . let's register it\n+        try {\n+          apiInfo.init();\n+          ApiHolder holder = new ApiHolder(apiInfo);\n+          plugins.put(holder.key, holder);\n+          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n+          containerApiBag.register(holder, Collections.EMPTY_MAP);\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+        }\n+      } else {\n+        ApiHolder old = plugins.get(apiInfo.key);\n+        if (path.equals(apiInfo.key)) {\n+          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n+            //this plugin uses the same version. No need to update\n+            continue;\n+          }\n+          //this apiInfo existed at the same path but uses a newer version of the package\n+          //refresh the existing Api holder\n+          try {\n+            apiInfo.init();\n+          } catch (Exception exception) {\n+            log.error(\"COuld not inititlaize Plugin\", exception);\n+          }\n+          plugins.get(apiInfo.key).refresh(apiInfo);\n+        } else {// the path is changed for the same apiInfo. it's not allowed\n+          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n+        }\n+      }\n+    }\n+    Set<String> toBeRemoved = new HashSet<>();\n+    for (String s : pluginNameVsPath.keySet()) {\n+      if (!pluginInfos.containsKey(s)) {\n+        toBeRemoved.add(s);\n+      }\n+    }\n+    for (String s : toBeRemoved) {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,151 +49,141 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n   private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n   private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n-\n-\n-    private AnnotatedApi delegate;\n+    Object instance;\n \n \n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "677d84f7be7665a748d8d94ab5eee952dac60926", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex ba84655cb01..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -186,6 +188,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     Object instance;\n \n \n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,153 +50,145 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n-  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private final ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private final Map<String, ApiInfo> currentPlugins = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n-  private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+  private static class ApiHolder extends Api {\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  @SuppressWarnings({\"rawtypes\"})\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n+    Object instance;\n \n \n-    private AnnotatedApi delegate;\n-\n-\n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": {"commit": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6536276e294 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -187,6 +210,17 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     private Class klas;\n     Object instance;\n \n+    ApiHolder get(EndPoint endPoint) {\n+      for (ApiHolder holder : holders) {\n+        EndPoint e = holder.api.getEndPoint();\n+        if(Objects.equals(endPoint.method()[0] , e.method()[0]) &&\n+            Objects.equals(endPoint.path()[0], e.path()[0])) {\n+          return holder;\n+        }\n+      }\n+      return null;\n+    }\n+\n \n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 6536276e294..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -225,12 +225,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n-      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n-      pkg = klassInfo.first();\n+      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n+      pkg = klassInfo.pkg;\n       if (pkg != null) {\n         PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n         if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.first());\n+          errs.add(\"Invalid package \" + klassInfo.pkg);\n           return;\n         }\n         this.pkgVersion = p.getVersion(info.version);\n", "next_change": {"commit": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex f24626bbf08..ef33c3e2a4c 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -228,16 +229,23 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n       PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n       pkg = klassInfo.pkg;\n       if (pkg != null) {\n-        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n-        if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.pkg);\n-          return;\n+        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n+        if (ver.isEmpty()) {\n+          //may be we are a bit early. Do a refresh and try again\n+         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n+         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n         }\n-        this.pkgVersion = p.getVersion(info.version);\n-        if (pkgVersion == null) {\n-          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n-          return;\n+        if (ver.isEmpty()) {\n+          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+          if (p == null) {\n+            errs.add(\"Invalid package \" + klassInfo.pkg);\n+            return;\n+          } else {\n+            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+            return;\n+          }\n         }\n+        this.pkgVersion = ver.get();\n         try {\n           klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5ODY2Ng==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412498666", "body": "there's a lot of nested classes here, can any of those be split out into their own files?", "bodyText": "there's a lot of nested classes here, can any of those be split out into their own files?", "bodyHTML": "<p dir=\"auto\">there's a lot of nested classes here, can any of those be split out into their own files?</p>", "author": "madrob", "createdAt": "2020-04-21T21:18:35Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.Pair;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..ba84655cb01 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,151 +49,141 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n   private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n   private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n-\n-\n-    private AnnotatedApi delegate;\n+    Object instance;\n \n \n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "677d84f7be7665a748d8d94ab5eee952dac60926", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex ba84655cb01..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -186,6 +188,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     Object instance;\n \n \n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0bbebbc65de..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -51,153 +50,145 @@ import org.slf4j.LoggerFactory;\n \n import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n \n-public class CustomContainerPlugins implements MapWriter, ClusterPropertiesListener {\n-  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private final ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   final CoreContainer coreContainer;\n   final ApiBag containerApiBag;\n-  private Map<String, ApiHolder> plugins = new HashMap<>();\n-  private Map<String, String> pluginNameVsPath = new HashMap<>();\n+\n+  private final Map<String, ApiInfo> currentPlugins = new HashMap<>();\n \n   @Override\n   public boolean onChange(Map<String, Object> properties) {\n-    refresh(null);\n+    refresh();\n     return false;\n   }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) {\n-    plugins.forEach((s, apiHolder) -> ew.putNoEx(s, apiHolder.apiInfo));\n-  }\n-\n   public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n     this.coreContainer = coreContainer;\n     this.containerApiBag = apiBag;\n   }\n \n-  public void refresh(Map<String, Object> pluginInfos) {\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n     try {\n       pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n     } catch (IOException e) {\n       log.error(\"Could not read plugins data\", e);\n       return;\n     }\n-    if(pluginInfos.isEmpty()) return;\n-\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n     for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n-      PluginMeta info = null;\n       try {\n-        info = mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class);\n-      } catch (IOException ioException) {\n-        log.error(\"Invalid apiInfo configuration :\", ioException);\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n       }\n+    }\n \n-      ApiInfo apiInfo = null;\n-      try {\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n         List<String> errs = new ArrayList<>();\n         apiInfo = new ApiInfo(info, errs);\n         if (!errs.isEmpty()) {\n           log.error(StrUtils.join(errs, ','));\n           continue;\n         }\n-      } catch (Exception ex) {\n-        log.error(\"unable to instantiate apiInfo \", ex);\n-        continue;\n-      }\n-\n-      String path = pluginNameVsPath.get(e.getKey());\n-      if (path == null) {\n-        // there is a new apiInfo . let's register it\n         try {\n           apiInfo.init();\n-          ApiHolder holder = new ApiHolder(apiInfo);\n-          plugins.put(holder.key, holder);\n-          pluginNameVsPath.put(apiInfo.info.name, holder.key);\n-          containerApiBag.register(holder, Collections.EMPTY_MAP);\n         } catch (Exception exp) {\n           log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n         }\n-      } else {\n-        ApiHolder old = plugins.get(apiInfo.key);\n-        if (path.equals(apiInfo.key)) {\n-          if (Objects.equals(info.version, old.apiInfo.info.version)) {\n-            //this plugin uses the same version. No need to update\n-            continue;\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n           }\n-          //this apiInfo existed at the same path but uses a newer version of the package\n-          //refresh the existing Api holder\n-          try {\n-            apiInfo.init();\n-          } catch (Exception exception) {\n-            log.error(\"COuld not inititlaize Plugin\", exception);\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n           }\n-          plugins.get(apiInfo.key).refresh(apiInfo);\n-        } else {// the path is changed for the same apiInfo. it's not allowed\n-          log.error(\"Cannot register the same apiInfo at a different path old path: \" + path + \"new path : \" + apiInfo.key);\n         }\n       }\n-    }\n-    Set<String> toBeRemoved = new HashSet<>();\n-    for (String s : pluginNameVsPath.keySet()) {\n-      if (!pluginInfos.containsKey(s)) {\n-        toBeRemoved.add(s);\n-      }\n-    }\n-    for (String s : toBeRemoved) {\n-      String pathKey = pluginNameVsPath.remove(s);\n-      ApiHolder holder = plugins.remove(pathKey);\n-      if (holder != null) {\n-        Api old = containerApiBag.unregister(holder.apiInfo.endPoint.method()[0], holder.apiInfo.endPoint.path()[0]);\n-        if (old instanceof Closeable) {\n-          closeWhileHandlingException((Closeable) old);\n-        }\n \n-      }\n     }\n   }\n \n-  private class ApiHolder extends Api {\n-    private final String key;\n-    private ApiInfo apiInfo;\n+  private static class ApiHolder extends Api {\n+    final AnnotatedApi api;\n \n-    protected ApiHolder(ApiInfo apiInfo) throws Exception {\n-      super(apiInfo.delegate);\n-      this.apiInfo = apiInfo;\n-      this.key = apiInfo.key;\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n     }\n \n     @Override\n     public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-      apiInfo.delegate.call(req, rsp);\n+      api.call(req, rsp);\n     }\n \n-    void refresh(ApiInfo info) {\n-      this.apiInfo = info;\n-      super.spec = info.delegate;\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n     }\n   }\n \n-  public class ApiInfo implements ReflectMapWriter  {\n-    /*This is the path at which this handler is\n-     *\n-     */\n-    @JsonProperty\n-    public String key;\n+  @SuppressWarnings({\"rawtypes\"})\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n     @JsonProperty\n     private final PluginMeta info;\n \n     @JsonProperty(value = \"package\")\n     public final String pkg;\n-    private PackageLoader.Package.Version pkgVersion;\n-    EndPoint endPoint;\n \n+    private PackageLoader.Package.Version pkgVersion;\n     private Class klas;\n+    Object instance;\n \n \n-    private AnnotatedApi delegate;\n-\n-\n+    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n       Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n", "next_change": {"commit": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6536276e294 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -187,6 +210,17 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     private Class klas;\n     Object instance;\n \n+    ApiHolder get(EndPoint endPoint) {\n+      for (ApiHolder holder : holders) {\n+        EndPoint e = holder.api.getEndPoint();\n+        if(Objects.equals(endPoint.method()[0] , e.method()[0]) &&\n+            Objects.equals(endPoint.path()[0], e.path()[0])) {\n+          return holder;\n+        }\n+      }\n+      return null;\n+    }\n+\n \n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 6536276e294..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -225,12 +225,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n     @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n     public ApiInfo(PluginMeta info, List<String> errs) {\n       this.info = info;\n-      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n-      pkg = klassInfo.first();\n+      PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n+      pkg = klassInfo.pkg;\n       if (pkg != null) {\n         PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n         if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.first());\n+          errs.add(\"Invalid package \" + klassInfo.pkg);\n           return;\n         }\n         this.pkgVersion = p.getVersion(info.version);\n", "next_change": {"commit": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex f24626bbf08..ef33c3e2a4c 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -228,16 +229,23 @@ public class CustomContainerPlugins implements ClusterPropertiesListener, MapWri\n       PluginInfo.ClassName klassInfo = new PluginInfo.ClassName(info.klass);\n       pkg = klassInfo.pkg;\n       if (pkg != null) {\n-        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n-        if (p == null) {\n-          errs.add(\"Invalid package \" + klassInfo.pkg);\n-          return;\n+        Optional<PackageLoader.Package.Version> ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n+        if (ver.isEmpty()) {\n+          //may be we are a bit early. Do a refresh and try again\n+         coreContainer.getPackageLoader().getPackageAPI().refreshPackages(null);\n+         ver = coreContainer.getPackageLoader().getPackageVersion(pkg, info.version);\n         }\n-        this.pkgVersion = p.getVersion(info.version);\n-        if (pkgVersion == null) {\n-          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n-          return;\n+        if (ver.isEmpty()) {\n+          PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+          if (p == null) {\n+            errs.add(\"Invalid package \" + klassInfo.pkg);\n+            return;\n+          } else {\n+            errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+            return;\n+          }\n         }\n+        this.pkgVersion = ver.get();\n         try {\n           klas = pkgVersion.getLoader().findClass(klassInfo.className, Object.class);\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5OTYwNg==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r412499606", "body": "nit: raw types on Map", "bodyText": "nit: raw types on Map", "bodyHTML": "<p dir=\"auto\">nit: raw types on Map</p>", "author": "madrob", "createdAt": "2020-04-21T21:20:11Z", "path": "solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.handler.admin;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.apache.solr.api.AnnotatedApi;\n+import org.apache.solr.api.Command;\n+import org.apache.solr.api.CustomContainerPlugins;\n+import org.apache.solr.api.EndPoint;\n+import org.apache.solr.api.PayloadObj;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.cloud.SolrZkClient;\n+import org.apache.solr.common.cloud.ZkStateReader;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.security.PermissionNameProvider;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+\n+public class ContainerPluginsApi {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String PLUGIN = \"plugin\";\n+  private final Supplier<SolrZkClient> zkClientSupplier;\n+  private final CoreContainer coreContainer;\n+  public final Read readAPI = new Read();\n+  public final Edit editAPI = new Edit();\n+\n+  public ContainerPluginsApi(CoreContainer coreContainer) {\n+    this.zkClientSupplier = coreContainer.zkClientSupplier;\n+    this.coreContainer = coreContainer;\n+  }\n+\n+  @EndPoint(method = METHOD.GET,\n+      path = \"/cluster/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_READ_PERM)\n+  public class Read {\n+\n+    @Command\n+    public void list(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n+      rsp.add(PLUGIN, plugins(zkClientSupplier));\n+    }\n+  }\n+\n+  @EndPoint(method = METHOD.POST,\n+      path = \"/cluster/plugin\",\n+      permission = PermissionNameProvider.Name.COLL_EDIT_PERM)\n+  public class Edit {\n+\n+    @Command(name = \"add\")\n+    public void add(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta> payload) throws IOException {\n+      PluginMeta info = payload.get();\n+      validateConfig(payload, info);\n+      if(payload.hasError()) return;\n+      persistPlugins(map -> {\n+        if (map.containsKey(info.name)) {\n+          payload.addError(info.name + \" already exists\");\n+          return null;\n+        }\n+        map.put(info.name, info);\n+        return map;\n+      });\n+    }\n+\n+    @Command(name = \"remove\")\n+    public void remove(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<String> payload) throws IOException {\n+      persistPlugins(map -> {\n+        if (map.remove(payload.get()) == null) {\n+          payload.addError(\"No such plugin: \" + payload.get());\n+          return null;\n+        }\n+        return map;\n+      });\n+    }\n+\n+    @Command(name = \"update\")\n+    public void update(SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta> payload) throws IOException {\n+      PluginMeta info = payload.get();\n+      validateConfig(payload, info);\n+      if(payload.hasError()) return;\n+      persistPlugins(map -> {\n+        Map existing = (Map) map.get(info.name);\n+        if (existing == null) {\n+          payload.addError(\"No such plugin: \" + info.name);\n+          return null;\n+        } else {\n+          map.put(info.name, info);\n+          return map;\n+        }\n+      });\n+    }\n+  }\n+\n+  private void validateConfig(PayloadObj<PluginMeta> payload, PluginMeta info) {\n+    if (info.klass.indexOf(':') > 0) {\n+      if (info.version == null) {\n+        payload.addError(\"Using package. must provide a packageVersion\");\n+        return;\n+      }\n+    }\n+    List<String> errs = new ArrayList<>();\n+    CustomContainerPlugins.ApiInfo apiInfo = coreContainer.getCustomContainerPlugins().createInfo(info, errs);\n+    if (!errs.isEmpty()) {\n+      for (String err : errs) payload.addError(err);\n+      return;\n+    }\n+    AnnotatedApi api = null ;\n+    try {\n+      api =  apiInfo.init();\n+    } catch (Exception e) {\n+      log.error(\"Error instantiating plugin \", e);\n+      errs.add(e.getMessage());\n+      return;\n+    } finally {\n+      closeWhileHandlingException(api);\n+    }\n+  }\n+\n+  public static Map<String, Object> plugins(Supplier<SolrZkClient> zkClientSupplier) throws IOException {\n+    SolrZkClient zkClient = zkClientSupplier.get();\n+    try {\n+      Map<String, Object> clusterPropsJson = (Map<String, Object>) Utils.fromJSON(zkClient.getData(ZkStateReader.CLUSTER_PROPS, null, new Stat(), true));\n+      return (Map<String, Object>) clusterPropsJson.computeIfAbsent(PLUGIN, Utils.NEW_LINKED_HASHMAP_FUN);\n+    } catch (KeeperException.NoNodeException e) {\n+      return new LinkedHashMap<>();\n+    } catch (KeeperException | InterruptedException e) {\n+      throw new IOException(\"Error reading cluster property\", SolrZkClient.checkInterrupted(e));\n+    }\n+  }\n+\n+  private void persistPlugins(Function<Map, Map> modifier) throws IOException {", "originalCommit": "82bcd38bb851274c0b2fba85190f29b46400640f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2be5efec94c5f914fee2558ac3731b3c0854988", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\nindex 088b008f316..068d7f5d7a6 100644\n--- a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n+++ b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n", "chunk": "@@ -159,7 +159,7 @@ public class ContainerPluginsApi {\n     }\n   }\n \n-  private void persistPlugins(Function<Map, Map> modifier) throws IOException {\n+  private void persistPlugins(Function<Map<String,Object>, Map<String,Object>> modifier) throws IOException {\n     try {\n       zkClientSupplier.get().atomicUpdate(ZkStateReader.CLUSTER_PROPS, bytes -> {\n         Map rawJson = bytes == null ? new LinkedHashMap() :\n", "next_change": {"commit": "d1a22c8e84c9df8a5fb633ca829c9fbedf27de6b", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\nindex 068d7f5d7a6..21c16e344d2 100644\n--- a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n+++ b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n", "chunk": "@@ -159,6 +159,7 @@ public class ContainerPluginsApi {\n     }\n   }\n \n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n   private void persistPlugins(Function<Map<String,Object>, Map<String,Object>> modifier) throws IOException {\n     try {\n       zkClientSupplier.get().atomicUpdate(ZkStateReader.CLUSTER_PROPS, bytes -> {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\nindex 088b008f316..21c16e344d2 100644\n--- a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n+++ b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n", "chunk": "@@ -159,7 +159,8 @@ public class ContainerPluginsApi {\n     }\n   }\n \n-  private void persistPlugins(Function<Map, Map> modifier) throws IOException {\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+  private void persistPlugins(Function<Map<String,Object>, Map<String,Object>> modifier) throws IOException {\n     try {\n       zkClientSupplier.get().atomicUpdate(ZkStateReader.CLUSTER_PROPS, bytes -> {\n         Map rawJson = bytes == null ? new LinkedHashMap() :\n", "next_change": {"commit": "f71ba62d4ae3100ffe54bdf5df8254e2bbf6ec9d", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\nindex 21c16e344d2..0c7a48726cd 100644\n--- a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n+++ b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n", "chunk": "@@ -165,7 +165,7 @@ public class ContainerPluginsApi {\n       zkClientSupplier.get().atomicUpdate(ZkStateReader.CLUSTER_PROPS, bytes -> {\n         Map rawJson = bytes == null ? new LinkedHashMap() :\n             (Map) Utils.fromJSON(bytes);\n-        Map pluginsModified = modifier.apply((Map) rawJson.computeIfAbsent(PLUGIN, Utils.NEW_LINKED_HASHMAP_FUN));\n+        Map pluginsModified = modifier.apply((Map) rawJson.computeIfAbsent(PLUGIN, o -> new LinkedHashMap<>()));\n         if (pluginsModified == null) return null;\n         rawJson.put(PLUGIN, pluginsModified);\n         return Utils.toJSON(rawJson);\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java b/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\ndeleted file mode 100644\nindex 0c7a48726cd..00000000000\n--- a/solr/core/src/java/org/apache/solr/handler/admin/ContainerPluginsApi.java\n+++ /dev/null\n", "chunk": "@@ -1,179 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.handler.admin;\n-\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-\n-import org.apache.solr.api.AnnotatedApi;\n-import org.apache.solr.api.Command;\n-import org.apache.solr.api.CustomContainerPlugins;\n-import org.apache.solr.api.EndPoint;\n-import org.apache.solr.api.PayloadObj;\n-import org.apache.solr.client.solrj.SolrRequest.METHOD;\n-import org.apache.solr.client.solrj.request.beans.PluginMeta;\n-import org.apache.solr.common.cloud.SolrZkClient;\n-import org.apache.solr.common.cloud.ZkStateReader;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.core.CoreContainer;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.PermissionNameProvider;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.data.Stat;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n-\n-\n-public class ContainerPluginsApi {\n-  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-  public static final String PLUGIN = \"plugin\";\n-  private final Supplier<SolrZkClient> zkClientSupplier;\n-  private final CoreContainer coreContainer;\n-  public final Read readAPI = new Read();\n-  public final Edit editAPI = new Edit();\n-\n-  public ContainerPluginsApi(CoreContainer coreContainer) {\n-    this.zkClientSupplier = coreContainer.zkClientSupplier;\n-    this.coreContainer = coreContainer;\n-  }\n-\n-  public class Read {\n-    @EndPoint(method = METHOD.GET,\n-        path = \"/cluster/plugin\",\n-        permission = PermissionNameProvider.Name.COLL_READ_PERM)\n-    public void list(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException {\n-      rsp.add(PLUGIN, plugins(zkClientSupplier));\n-    }\n-  }\n-\n-  @EndPoint(method = METHOD.POST,\n-      path = \"/cluster/plugin\",\n-      permission = PermissionNameProvider.Name.COLL_EDIT_PERM)\n-  public class Edit {\n-\n-    @Command(name = \"add\")\n-    public void add(PayloadObj<PluginMeta> payload) throws IOException {\n-      PluginMeta info = payload.get();\n-      validateConfig(payload, info);\n-      if(payload.hasError()) return;\n-      persistPlugins(map -> {\n-        if (map.containsKey(info.name)) {\n-          payload.addError(info.name + \" already exists\");\n-          return null;\n-        }\n-        map.put(info.name, info);\n-        return map;\n-      });\n-    }\n-\n-    @Command(name = \"remove\")\n-    public void remove(PayloadObj<String> payload) throws IOException {\n-      persistPlugins(map -> {\n-        if (map.remove(payload.get()) == null) {\n-          payload.addError(\"No such plugin: \" + payload.get());\n-          return null;\n-        }\n-        return map;\n-      });\n-    }\n-\n-    @Command(name = \"update\")\n-    @SuppressWarnings(\"unchecked\")\n-    public void update(PayloadObj<PluginMeta> payload) throws IOException {\n-      PluginMeta info = payload.get();\n-      validateConfig(payload, info);\n-      if(payload.hasError()) return;\n-      persistPlugins(map -> {\n-        Map<String, Object> existing = (Map<String, Object>) map.get(info.name);\n-        if (existing == null) {\n-          payload.addError(\"No such plugin: \" + info.name);\n-          return null;\n-        } else {\n-          map.put(info.name, info);\n-          return map;\n-        }\n-      });\n-    }\n-  }\n-\n-  private void validateConfig(PayloadObj<PluginMeta> payload, PluginMeta info) {\n-    if (info.klass.indexOf(':') > 0) {\n-      if (info.version == null) {\n-        payload.addError(\"Using package. must provide a packageVersion\");\n-        return;\n-      }\n-    }\n-    List<String> errs = new ArrayList<>();\n-    CustomContainerPlugins.ApiInfo apiInfo = coreContainer.getCustomContainerPlugins().createInfo(info, errs);\n-    if (!errs.isEmpty()) {\n-      for (String err : errs) payload.addError(err);\n-      return;\n-    }\n-    AnnotatedApi api = null ;\n-    try {\n-      apiInfo.init();\n-    } catch (Exception e) {\n-      log.error(\"Error instantiating plugin \", e);\n-      errs.add(e.getMessage());\n-      return;\n-    } finally {\n-      closeWhileHandlingException(api);\n-    }\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static Map<String, Object> plugins(Supplier<SolrZkClient> zkClientSupplier) throws IOException {\n-    SolrZkClient zkClient = zkClientSupplier.get();\n-    try {\n-      Map<String, Object> clusterPropsJson = (Map<String, Object>) Utils.fromJSON(zkClient.getData(ZkStateReader.CLUSTER_PROPS, null, new Stat(), true));\n-      return (Map<String, Object>) clusterPropsJson.computeIfAbsent(PLUGIN, o -> new LinkedHashMap<>());\n-    } catch (KeeperException.NoNodeException e) {\n-      return new LinkedHashMap<>();\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IOException(\"Error reading cluster property\", SolrZkClient.checkInterrupted(e));\n-    }\n-  }\n-\n-  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-  private void persistPlugins(Function<Map<String,Object>, Map<String,Object>> modifier) throws IOException {\n-    try {\n-      zkClientSupplier.get().atomicUpdate(ZkStateReader.CLUSTER_PROPS, bytes -> {\n-        Map rawJson = bytes == null ? new LinkedHashMap() :\n-            (Map) Utils.fromJSON(bytes);\n-        Map pluginsModified = modifier.apply((Map) rawJson.computeIfAbsent(PLUGIN, o -> new LinkedHashMap<>()));\n-        if (pluginsModified == null) return null;\n-        rawJson.put(PLUGIN, pluginsModified);\n-        return Utils.toJSON(rawJson);\n-      });\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IOException(\"Error reading cluster property\", SolrZkClient.checkInterrupted(e));\n-    }\n-  }\n-\n-\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "f71ba62d4ae3100ffe54bdf5df8254e2bbf6ec9d", "committedDate": "2020-09-05 09:19:45 -0400", "message": "SOLR-14579: Comment SolrJ 'Utils' generic map functions"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}, {"oid": "73d5e7ae77d8953cb9be35a7cbcebe3a516dd04a", "committedDate": "2020-11-17 00:19:50 +1100", "message": "SOLR-14977 :  ContainerPlugins should be configurable (#2065)"}, {"oid": "3df72502ccb72c2775db72b3347e99dc621d2d6b", "committedDate": "2020-12-01 20:07:08 +0100", "message": "SOLR-15004: tests for the replica placement API + placement plugin fixes and light refactoring (#2110)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"oid": "f051b497f549762a727ce4b1248a0fc5fa513d24", "url": "https://github.com/apache/lucene-solr/commit/f051b497f549762a727ce4b1248a0fc5fa513d24", "message": "resolving conflicts and incorporating some review comments", "committedDate": "2020-05-18T01:32:20Z", "type": "commit"}, {"oid": "c28707df2d3611ac5e425c2848997b3b034ea1b0", "url": "https://github.com/apache/lucene-solr/commit/c28707df2d3611ac5e425c2848997b3b034ea1b0", "message": "Added support for multiple @EndPoint per plugin and tests", "committedDate": "2020-05-18T08:49:36Z", "type": "commit"}, {"oid": "c53c4a1a83963e6c9275e2dcae732274b4fb5c2c", "url": "https://github.com/apache/lucene-solr/commit/c53c4a1a83963e6c9275e2dcae732274b4fb5c2c", "message": "Merge branch 'master' into jira/solr14404", "committedDate": "2020-05-18T08:54:56Z", "type": "commit"}, {"oid": "7f010d4c4f0196b4e0aff3562c1bb9ff3f2aebff", "url": "https://github.com/apache/lucene-solr/commit/7f010d4c4f0196b4e0aff3562c1bb9ff3f2aebff", "message": "removed unused imports", "committedDate": "2020-06-01T00:37:20Z", "type": "commit"}, {"oid": "4818edf01bae0b50c48a0e48bd3170eccb43e828", "url": "https://github.com/apache/lucene-solr/commit/4818edf01bae0b50c48a0e48bd3170eccb43e828", "message": "support any path other than collection, cores, cluster, node", "committedDate": "2020-06-01T04:33:31Z", "type": "commit"}, {"oid": "a0b81a57822cb232c434d20ef6764d7e00871629", "url": "https://github.com/apache/lucene-solr/commit/a0b81a57822cb232c434d20ef6764d7e00871629", "message": "moved the custom plugin detection to the end", "committedDate": "2020-06-09T23:57:52Z", "type": "commit"}, {"oid": "e5f2651a59283d8ba5127c86c3fc988bea014665", "url": "https://github.com/apache/lucene-solr/commit/e5f2651a59283d8ba5127c86c3fc988bea014665", "message": "merged changes from master", "committedDate": "2020-06-10T00:01:22Z", "type": "commit"}, {"oid": "bec449cc4da5cb9343cbb936c7bf8d2ec8a382a7", "url": "https://github.com/apache/lucene-solr/commit/bec449cc4da5cb9343cbb936c7bf8d2ec8a382a7", "message": "Merge branch 'master' into jira/solr14404", "committedDate": "2020-06-10T01:24:22Z", "type": "commit"}, {"oid": "e26789532073430cca6a8a89c66a78b866cce2d4", "url": "https://github.com/apache/lucene-solr/commit/e26789532073430cca6a8a89c66a78b866cce2d4", "message": "merging with master", "committedDate": "2020-06-10T01:45:29Z", "type": "commit"}, {"oid": "35c057fdd1ba4154c4c453250ef59766473e3d96", "url": "https://github.com/apache/lucene-solr/commit/35c057fdd1ba4154c4c453250ef59766473e3d96", "message": "Merge branch 'master' into jira/solr14404", "committedDate": "2020-06-21T00:59:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NDY1NQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443254655", "body": "Our code style is to put java.* up front.  See https://github.com/apache/lucene-solr/blob/aa5b26f6c40e6f6ac78d4574448ab0241c1b68b0/dev-tools/idea/.idea/codeStyleSettings.xml#L25\r\n\r\nPlease update your IDE settings accordingly.", "bodyText": "Our code style is to put java.* up front.  See \n  \n    \n      lucene-solr/dev-tools/idea/.idea/codeStyleSettings.xml\n    \n    \n         Line 25\n      in\n      aa5b26f\n    \n    \n    \n    \n\n        \n          \n           <option name=\"IMPORT_LAYOUT_TABLE\"> \n        \n    \n  \n\n\nPlease update your IDE settings accordingly.", "bodyHTML": "<p dir=\"auto\">Our code style is to put java.* up front.  See <div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/apache/lucene-solr/blob/aa5b26f6c40e6f6ac78d4574448ab0241c1b68b0/dev-tools/idea/.idea/codeStyleSettings.xml#L25\">lucene-solr/dev-tools/idea/.idea/codeStyleSettings.xml</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n         Line 25\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/apache/lucene-solr/commit/aa5b26f6c40e6f6ac78d4574448ab0241c1b68b0\">aa5b26f</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L25\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"25\"></td>\n          <td id=\"LC25\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> &lt;<span class=\"pl-ent\">option</span> <span class=\"pl-e\">name</span>=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>IMPORT_LAYOUT_TABLE<span class=\"pl-pds\">\"</span></span>&gt; </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<p dir=\"auto\">Please update your IDE settings accordingly.</p>", "author": "dsmiley", "createdAt": "2020-06-21T20:36:16Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -48,6 +34,12 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.Closeable;", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\nindex 0f6d126194d..b3d65d05cb7 100644\n--- a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n+++ b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n", "chunk": "@@ -34,12 +50,6 @@ import org.apache.solr.util.SolrJacksonAnnotationInspector;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.*;\n-import java.util.*;\n-\n /**\n  * This class implements an Api just from  an annotated java class\n  * The class must have an annotation {@link EndPoint}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\nindex 0f6d126194d..b3d65d05cb7 100644\n--- a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n+++ b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n", "chunk": "@@ -34,12 +50,6 @@ import org.apache.solr.util.SolrJacksonAnnotationInspector;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.*;\n-import java.util.*;\n-\n /**\n  * This class implements an Api just from  an annotated java class\n  * The class must have an annotation {@link EndPoint}\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\ndeleted file mode 100644\nindex b3d65d05cb7..00000000000\n--- a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n+++ /dev/null\n", "chunk": "@@ -1,342 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.api;\n-\n-\n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import org.apache.solr.client.solrj.SolrRequest;\n-import org.apache.solr.common.SolrException;\n-import org.apache.solr.common.SpecProvider;\n-import org.apache.solr.common.util.CommandOperation;\n-import org.apache.solr.common.util.JsonSchemaCreator;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.common.util.ValidatingJsonMap;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.AuthorizationContext;\n-import org.apache.solr.security.PermissionNameProvider;\n-import org.apache.solr.util.SolrJacksonAnnotationInspector;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * This class implements an Api just from  an annotated java class\n- * The class must have an annotation {@link EndPoint}\n- * Each method must have an annotation {@link Command}\n- * The methods that implement a command should have the first 2 parameters\n- * {@link SolrQueryRequest} and {@link SolrQueryResponse} or it may optionally\n- * have a third parameter which could be a java class annotated with jackson annotations.\n- * The third parameter is only valid if it is using a json command payload\n- */\n-\n-public class AnnotatedApi extends Api implements PermissionNameProvider , Closeable {\n-  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-  public static final String ERR = \"Error executing commands :\";\n-  private EndPoint endPoint;\n-  private final Map<String, Cmd> commands ;\n-  private final Cmd singletonCommand;\n-  private final Api fallback;\n-\n-  @Override\n-  public void close() throws IOException {\n-    for (Cmd value : commands.values()) {\n-      if (value.obj instanceof Closeable) {\n-        ((Closeable) value.obj).close();\n-      }\n-      break;// all objects are same so close only one\n-    }\n-\n-  }\n-\n-  public EndPoint getEndPoint() {\n-    return endPoint;\n-  }\n-\n-  public static List<Api> getApis(Object obj) {\n-    return getApis(obj.getClass(), obj);\n-  }\n-  public static List<Api> getApis(Class<? extends Object> klas , Object obj) {\n-    if (!Modifier.isPublic(klas.getModifiers())) {\n-      throw new RuntimeException(klas.getName() + \" is not public\");\n-    }\n-\n-    if (klas.getAnnotation(EndPoint.class) != null) {\n-      EndPoint endPoint = klas.getAnnotation(EndPoint.class);\n-      List<Method> methods = new ArrayList<>();\n-      Map<String, Cmd> commands = new HashMap<>();\n-      for (Method m : klas.getDeclaredMethods()) {\n-        Command command = m.getAnnotation(Command.class);\n-        if (command != null) {\n-          methods.add(m);\n-          if (commands.containsKey(command.name())) {\n-            throw new RuntimeException(\"Duplicate commands \" + command.name());\n-          }\n-          commands.put(command.name(), new Cmd(command.name(), obj, m));\n-        }\n-      }\n-      if (commands.isEmpty()) {\n-        throw new RuntimeException(\"No method with @Command in class: \" + klas.getName());\n-      }\n-      SpecProvider specProvider = readSpec(endPoint, methods);\n-      return Collections.singletonList(new AnnotatedApi(specProvider, endPoint, commands, null));\n-    } else {\n-      List<Api> apis = new ArrayList<>();\n-      for (Method m : klas.getDeclaredMethods()) {\n-        EndPoint endPoint = m.getAnnotation(EndPoint.class);\n-        if (endPoint == null) continue;\n-        if (!Modifier.isPublic(m.getModifiers())) {\n-          throw new RuntimeException(\"Non public method \" + m.toGenericString());\n-        }\n-        Cmd cmd = new Cmd(\"\", obj, m);\n-        SpecProvider specProvider = readSpec(endPoint, Collections.singletonList(m));\n-        apis.add(new AnnotatedApi(specProvider, endPoint, Collections.singletonMap(\"\", cmd), null));\n-      }\n-      if (apis.isEmpty()) {\n-        throw new RuntimeException(\"Invalid Class : \" + klas.getName() + \" No @EndPoints\");\n-      }\n-\n-      return apis;\n-    }\n-  }\n-\n-\n-  private AnnotatedApi(SpecProvider specProvider, EndPoint endPoint, Map<String, Cmd> commands, Api fallback) {\n-    super(specProvider);\n-    this.endPoint = endPoint;\n-    this.fallback = fallback;\n-    this.commands = commands;\n-    this.singletonCommand = commands.get(\"\");\n-  }\n-\n-  @Override\n-  public Name getPermissionName(AuthorizationContext request) {\n-    return endPoint.permission();\n-  }\n-\n-  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-  private static SpecProvider readSpec(EndPoint endPoint, List<Method> m) {\n-    return () -> {\n-      Map map = new LinkedHashMap();\n-      List<String> methods = new ArrayList<>();\n-      for (SolrRequest.METHOD method : endPoint.method()) {\n-        methods.add(method.name());\n-      }\n-      map.put(\"methods\", methods);\n-      map.put(\"url\", new ValidatingJsonMap(Collections.singletonMap(\"paths\", Arrays.asList(endPoint.path()))));\n-      Map<String, Object> cmds = new HashMap<>();\n-\n-      for (Method method : m) {\n-        Command command = method.getAnnotation(Command.class);\n-        if (command != null && !command.name().isEmpty()) {\n-          cmds.put(command.name(), AnnotatedApi.createSchema(method));\n-        }\n-      }\n-      if (!cmds.isEmpty()) {\n-        map.put(\"commands\", cmds);\n-      }\n-      return new ValidatingJsonMap(map);\n-    };\n-\n-  }\n-\n-\n-  @Override\n-  public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-    if (singletonCommand != null) {\n-      singletonCommand.invoke(req, rsp, null);\n-      return;\n-    }\n-\n-    List<CommandOperation> cmds = req.getCommands(true);\n-    boolean allExists = true;\n-    for (CommandOperation cmd : cmds) {\n-      if (!commands.containsKey(cmd.name)) {\n-        cmd.addError(\"No such command supported: \" + cmd.name);\n-        allExists = false;\n-      }\n-    }\n-    if (!allExists) {\n-      if (fallback != null) {\n-        fallback.call(req, rsp);\n-        return;\n-      } else {\n-        throw new ApiBag.ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error processing commands\",\n-            CommandOperation.captureErrors(cmds));\n-      }\n-    }\n-\n-    for (CommandOperation cmd : cmds) {\n-      commands.get(cmd.name).invoke(req, rsp, cmd);\n-    }\n-\n-    @SuppressWarnings({\"rawtypes\"})\n-    List<Map> errs = CommandOperation.captureErrors(cmds);\n-    if (!errs.isEmpty()) {\n-      log.error(\"{}{}\", ERR, Utils.toJSONString(errs));\n-      throw new ApiBag.ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, ERR, errs);\n-    }\n-\n-  }\n-\n-  static class Cmd {\n-    final String command;\n-    final Method method;\n-    final Object obj;\n-    ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n-    int paramsCount;\n-    @SuppressWarnings({\"rawtypes\"})\n-    Class c;\n-    boolean isWrappedInPayloadObj = false;\n-\n-\n-    Cmd(String command, Object obj, Method method) {\n-      if (Modifier.isPublic(method.getModifiers())) {\n-        this.command = command;\n-        this.obj = obj;\n-        this.method = method;\n-        Class<?>[] parameterTypes = method.getParameterTypes();\n-        paramsCount = parameterTypes.length;\n-        if (parameterTypes.length == 1) {\n-          readPayloadType(method.getGenericParameterTypes()[0]);\n-        } else if (parameterTypes.length == 3) {\n-          if (parameterTypes[0] != SolrQueryRequest.class || parameterTypes[1] != SolrQueryResponse.class) {\n-            throw new RuntimeException(\"Invalid params for method \" + method);\n-          }\n-          Type t = method.getGenericParameterTypes()[2];\n-          readPayloadType(t);\n-        }\n-        if (parameterTypes.length > 3) {\n-          throw new RuntimeException(\"Invalid params count for method \" + method);\n-        }\n-      } else {\n-        throw new RuntimeException(method.toString() + \" is not a public static method\");\n-      }\n-\n-    }\n-\n-    private void readPayloadType(Type t) {\n-      if (t instanceof ParameterizedType) {\n-        ParameterizedType typ = (ParameterizedType) t;\n-        if (typ.getRawType() == PayloadObj.class) {\n-          isWrappedInPayloadObj = true;\n-          if(typ.getActualTypeArguments().length == 0){\n-            //this is a raw type\n-            c = Map.class;\n-            return;\n-          }\n-          Type t1 = typ.getActualTypeArguments()[0];\n-          if (t1 instanceof ParameterizedType) {\n-            ParameterizedType parameterizedType = (ParameterizedType) t1;\n-            c = (Class) parameterizedType.getRawType();\n-          } else {\n-            c = (Class) typ.getActualTypeArguments()[0];\n-          }\n-        }\n-      } else {\n-        c = (Class) t;\n-      }\n-    }\n-\n-\n-    @SuppressWarnings({\"unchecked\"})\n-    void invoke(SolrQueryRequest req, SolrQueryResponse rsp, CommandOperation cmd) {\n-      try {\n-        if(paramsCount ==1) {\n-          Object o = cmd.getCommandData();\n-          if (o instanceof Map && c != null && c != Map.class) {\n-            o = mapper.readValue(Utils.toJSONString(o), c);\n-          }\n-          PayloadObj<Object> payloadObj = new PayloadObj<>(cmd.name, cmd.getCommandData(), o, req, rsp);\n-          cmd = payloadObj;\n-          method.invoke(obj, payloadObj);\n-          checkForErrorInPayload(cmd);\n-        } else if (paramsCount == 2) {\n-          method.invoke(obj, req, rsp);\n-        } else {\n-          Object o = cmd.getCommandData();\n-          if (o instanceof Map && c != null) {\n-            o = mapper.readValue(Utils.toJSONString(o), c);\n-          }\n-          if (isWrappedInPayloadObj) {\n-            PayloadObj<Object> payloadObj = new PayloadObj<>(cmd.name, cmd.getCommandData(), o, req, rsp);\n-            cmd = payloadObj;\n-            method.invoke(obj, req, rsp, payloadObj);\n-          } else {\n-            method.invoke(obj, req, rsp, o);\n-          }\n-          checkForErrorInPayload(cmd);\n-        }\n-\n-\n-      } catch (SolrException se) {\n-        log.error(\"Error executing command  \", se);\n-        throw se;\n-      } catch (InvocationTargetException ite) {\n-        log.error(\"Error executing command \", ite);\n-        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, ite.getCause());\n-      } catch (Exception e) {\n-        log.error(\"Error executing command : \", e);\n-        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n-      }\n-\n-    }\n-\n-    private void checkForErrorInPayload(CommandOperation cmd) {\n-      if (cmd.hasError()) {\n-        throw new ApiBag.ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error executing command\",\n-            CommandOperation.captureErrors(Collections.singletonList(cmd)));\n-      }\n-    }\n-  }\n-\n-  public static Map<String, Object> createSchema(Method m) {\n-    Type[] types = m.getGenericParameterTypes();\n-    Type t = null;\n-    if (types.length == 3) t = types[2]; // (SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta>)\n-    if(types.length == 1) t = types[0];// (PayloadObj<PluginMeta>)\n-    if (t != null) {\n-      if (t instanceof ParameterizedType) {\n-        ParameterizedType typ = (ParameterizedType) t;\n-        if (typ.getRawType() == PayloadObj.class) {\n-          t = typ.getActualTypeArguments()[0];\n-        }\n-      }\n-      return JsonSchemaCreator.getSchema(t);\n-\n-    }\n-    return null;\n-  }\n-\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "20c1fdbf7e4573948434cfa82e1f7b0fc4d54b31", "committedDate": "2020-06-30 22:40:26 +1000", "message": "SOLR-14404: use MethodHandles in AnnotatedAPI (#1624)"}, {"oid": "7b8e72e5531f3678242e1106d528ec835ac33959", "committedDate": "2020-09-16 18:06:43 +1000", "message": "SOLR-14871 Use Annotations for v2 APIs in/cluster path (#1878)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "73d5e7ae77d8953cb9be35a7cbcebe3a516dd04a", "committedDate": "2020-11-17 00:19:50 +1100", "message": "SOLR-14977 :  ContainerPlugins should be configurable (#2065)"}, {"oid": "94c69f43851e284804849b0d7a38d18427386114", "committedDate": "2020-12-15 14:18:09 +1100", "message": "SOLR-14977: improved plugin configuration (#2099)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NDk0NQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443254945", "body": "Could use a comment here as to what types \"looks like\"; seems several possibilities.", "bodyText": "Could use a comment here as to what types \"looks like\"; seems several possibilities.", "bodyHTML": "<p dir=\"auto\">Could use a comment here as to what types \"looks like\"; seems several possibilities.</p>", "author": "dsmiley", "createdAt": "2020-06-21T20:40:18Z", "path": "solr/core/src/java/org/apache/solr/api/AnnotatedApi.java", "diffHunk": "@@ -274,12 +302,21 @@ void invoke(SolrQueryRequest req, SolrQueryResponse rsp, CommandOperation cmd) {\n       }\n \n     }\n+\n+    private void checkForErrorInPayload(CommandOperation cmd) {\n+      if (cmd.hasError()) {\n+        throw new ApiBag.ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error executing command\",\n+            CommandOperation.captureErrors(Collections.singletonList(cmd)));\n+      }\n+    }\n   }\n \n   public static Map<String, Object> createSchema(Method m) {\n     Type[] types = m.getGenericParameterTypes();\n-    if (types.length == 3) {\n-      Type t = types[2];\n+    Type t = null;", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\nindex 0f6d126194d..b3d65d05cb7 100644\n--- a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n+++ b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n", "chunk": "@@ -314,8 +324,8 @@ public class AnnotatedApi extends Api implements PermissionNameProvider , Closea\n   public static Map<String, Object> createSchema(Method m) {\n     Type[] types = m.getGenericParameterTypes();\n     Type t = null;\n-    if (types.length == 3) t = types[2];\n-    if(types.length == 1) t = types[0];\n+    if (types.length == 3) t = types[2]; // (SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta>)\n+    if(types.length == 1) t = types[0];// (PayloadObj<PluginMeta>)\n     if (t != null) {\n       if (t instanceof ParameterizedType) {\n         ParameterizedType typ = (ParameterizedType) t;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\nindex 0f6d126194d..b3d65d05cb7 100644\n--- a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n+++ b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n", "chunk": "@@ -314,8 +324,8 @@ public class AnnotatedApi extends Api implements PermissionNameProvider , Closea\n   public static Map<String, Object> createSchema(Method m) {\n     Type[] types = m.getGenericParameterTypes();\n     Type t = null;\n-    if (types.length == 3) t = types[2];\n-    if(types.length == 1) t = types[0];\n+    if (types.length == 3) t = types[2]; // (SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta>)\n+    if(types.length == 1) t = types[0];// (PayloadObj<PluginMeta>)\n     if (t != null) {\n       if (t instanceof ParameterizedType) {\n         ParameterizedType typ = (ParameterizedType) t;\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java b/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\ndeleted file mode 100644\nindex b3d65d05cb7..00000000000\n--- a/solr/core/src/java/org/apache/solr/api/AnnotatedApi.java\n+++ /dev/null\n", "chunk": "@@ -1,342 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.api;\n-\n-\n-import java.io.Closeable;\n-import java.io.IOException;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import org.apache.solr.client.solrj.SolrRequest;\n-import org.apache.solr.common.SolrException;\n-import org.apache.solr.common.SpecProvider;\n-import org.apache.solr.common.util.CommandOperation;\n-import org.apache.solr.common.util.JsonSchemaCreator;\n-import org.apache.solr.common.util.Utils;\n-import org.apache.solr.common.util.ValidatingJsonMap;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-import org.apache.solr.security.AuthorizationContext;\n-import org.apache.solr.security.PermissionNameProvider;\n-import org.apache.solr.util.SolrJacksonAnnotationInspector;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * This class implements an Api just from  an annotated java class\n- * The class must have an annotation {@link EndPoint}\n- * Each method must have an annotation {@link Command}\n- * The methods that implement a command should have the first 2 parameters\n- * {@link SolrQueryRequest} and {@link SolrQueryResponse} or it may optionally\n- * have a third parameter which could be a java class annotated with jackson annotations.\n- * The third parameter is only valid if it is using a json command payload\n- */\n-\n-public class AnnotatedApi extends Api implements PermissionNameProvider , Closeable {\n-  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-  public static final String ERR = \"Error executing commands :\";\n-  private EndPoint endPoint;\n-  private final Map<String, Cmd> commands ;\n-  private final Cmd singletonCommand;\n-  private final Api fallback;\n-\n-  @Override\n-  public void close() throws IOException {\n-    for (Cmd value : commands.values()) {\n-      if (value.obj instanceof Closeable) {\n-        ((Closeable) value.obj).close();\n-      }\n-      break;// all objects are same so close only one\n-    }\n-\n-  }\n-\n-  public EndPoint getEndPoint() {\n-    return endPoint;\n-  }\n-\n-  public static List<Api> getApis(Object obj) {\n-    return getApis(obj.getClass(), obj);\n-  }\n-  public static List<Api> getApis(Class<? extends Object> klas , Object obj) {\n-    if (!Modifier.isPublic(klas.getModifiers())) {\n-      throw new RuntimeException(klas.getName() + \" is not public\");\n-    }\n-\n-    if (klas.getAnnotation(EndPoint.class) != null) {\n-      EndPoint endPoint = klas.getAnnotation(EndPoint.class);\n-      List<Method> methods = new ArrayList<>();\n-      Map<String, Cmd> commands = new HashMap<>();\n-      for (Method m : klas.getDeclaredMethods()) {\n-        Command command = m.getAnnotation(Command.class);\n-        if (command != null) {\n-          methods.add(m);\n-          if (commands.containsKey(command.name())) {\n-            throw new RuntimeException(\"Duplicate commands \" + command.name());\n-          }\n-          commands.put(command.name(), new Cmd(command.name(), obj, m));\n-        }\n-      }\n-      if (commands.isEmpty()) {\n-        throw new RuntimeException(\"No method with @Command in class: \" + klas.getName());\n-      }\n-      SpecProvider specProvider = readSpec(endPoint, methods);\n-      return Collections.singletonList(new AnnotatedApi(specProvider, endPoint, commands, null));\n-    } else {\n-      List<Api> apis = new ArrayList<>();\n-      for (Method m : klas.getDeclaredMethods()) {\n-        EndPoint endPoint = m.getAnnotation(EndPoint.class);\n-        if (endPoint == null) continue;\n-        if (!Modifier.isPublic(m.getModifiers())) {\n-          throw new RuntimeException(\"Non public method \" + m.toGenericString());\n-        }\n-        Cmd cmd = new Cmd(\"\", obj, m);\n-        SpecProvider specProvider = readSpec(endPoint, Collections.singletonList(m));\n-        apis.add(new AnnotatedApi(specProvider, endPoint, Collections.singletonMap(\"\", cmd), null));\n-      }\n-      if (apis.isEmpty()) {\n-        throw new RuntimeException(\"Invalid Class : \" + klas.getName() + \" No @EndPoints\");\n-      }\n-\n-      return apis;\n-    }\n-  }\n-\n-\n-  private AnnotatedApi(SpecProvider specProvider, EndPoint endPoint, Map<String, Cmd> commands, Api fallback) {\n-    super(specProvider);\n-    this.endPoint = endPoint;\n-    this.fallback = fallback;\n-    this.commands = commands;\n-    this.singletonCommand = commands.get(\"\");\n-  }\n-\n-  @Override\n-  public Name getPermissionName(AuthorizationContext request) {\n-    return endPoint.permission();\n-  }\n-\n-  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-  private static SpecProvider readSpec(EndPoint endPoint, List<Method> m) {\n-    return () -> {\n-      Map map = new LinkedHashMap();\n-      List<String> methods = new ArrayList<>();\n-      for (SolrRequest.METHOD method : endPoint.method()) {\n-        methods.add(method.name());\n-      }\n-      map.put(\"methods\", methods);\n-      map.put(\"url\", new ValidatingJsonMap(Collections.singletonMap(\"paths\", Arrays.asList(endPoint.path()))));\n-      Map<String, Object> cmds = new HashMap<>();\n-\n-      for (Method method : m) {\n-        Command command = method.getAnnotation(Command.class);\n-        if (command != null && !command.name().isEmpty()) {\n-          cmds.put(command.name(), AnnotatedApi.createSchema(method));\n-        }\n-      }\n-      if (!cmds.isEmpty()) {\n-        map.put(\"commands\", cmds);\n-      }\n-      return new ValidatingJsonMap(map);\n-    };\n-\n-  }\n-\n-\n-  @Override\n-  public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n-    if (singletonCommand != null) {\n-      singletonCommand.invoke(req, rsp, null);\n-      return;\n-    }\n-\n-    List<CommandOperation> cmds = req.getCommands(true);\n-    boolean allExists = true;\n-    for (CommandOperation cmd : cmds) {\n-      if (!commands.containsKey(cmd.name)) {\n-        cmd.addError(\"No such command supported: \" + cmd.name);\n-        allExists = false;\n-      }\n-    }\n-    if (!allExists) {\n-      if (fallback != null) {\n-        fallback.call(req, rsp);\n-        return;\n-      } else {\n-        throw new ApiBag.ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error processing commands\",\n-            CommandOperation.captureErrors(cmds));\n-      }\n-    }\n-\n-    for (CommandOperation cmd : cmds) {\n-      commands.get(cmd.name).invoke(req, rsp, cmd);\n-    }\n-\n-    @SuppressWarnings({\"rawtypes\"})\n-    List<Map> errs = CommandOperation.captureErrors(cmds);\n-    if (!errs.isEmpty()) {\n-      log.error(\"{}{}\", ERR, Utils.toJSONString(errs));\n-      throw new ApiBag.ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, ERR, errs);\n-    }\n-\n-  }\n-\n-  static class Cmd {\n-    final String command;\n-    final Method method;\n-    final Object obj;\n-    ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n-    int paramsCount;\n-    @SuppressWarnings({\"rawtypes\"})\n-    Class c;\n-    boolean isWrappedInPayloadObj = false;\n-\n-\n-    Cmd(String command, Object obj, Method method) {\n-      if (Modifier.isPublic(method.getModifiers())) {\n-        this.command = command;\n-        this.obj = obj;\n-        this.method = method;\n-        Class<?>[] parameterTypes = method.getParameterTypes();\n-        paramsCount = parameterTypes.length;\n-        if (parameterTypes.length == 1) {\n-          readPayloadType(method.getGenericParameterTypes()[0]);\n-        } else if (parameterTypes.length == 3) {\n-          if (parameterTypes[0] != SolrQueryRequest.class || parameterTypes[1] != SolrQueryResponse.class) {\n-            throw new RuntimeException(\"Invalid params for method \" + method);\n-          }\n-          Type t = method.getGenericParameterTypes()[2];\n-          readPayloadType(t);\n-        }\n-        if (parameterTypes.length > 3) {\n-          throw new RuntimeException(\"Invalid params count for method \" + method);\n-        }\n-      } else {\n-        throw new RuntimeException(method.toString() + \" is not a public static method\");\n-      }\n-\n-    }\n-\n-    private void readPayloadType(Type t) {\n-      if (t instanceof ParameterizedType) {\n-        ParameterizedType typ = (ParameterizedType) t;\n-        if (typ.getRawType() == PayloadObj.class) {\n-          isWrappedInPayloadObj = true;\n-          if(typ.getActualTypeArguments().length == 0){\n-            //this is a raw type\n-            c = Map.class;\n-            return;\n-          }\n-          Type t1 = typ.getActualTypeArguments()[0];\n-          if (t1 instanceof ParameterizedType) {\n-            ParameterizedType parameterizedType = (ParameterizedType) t1;\n-            c = (Class) parameterizedType.getRawType();\n-          } else {\n-            c = (Class) typ.getActualTypeArguments()[0];\n-          }\n-        }\n-      } else {\n-        c = (Class) t;\n-      }\n-    }\n-\n-\n-    @SuppressWarnings({\"unchecked\"})\n-    void invoke(SolrQueryRequest req, SolrQueryResponse rsp, CommandOperation cmd) {\n-      try {\n-        if(paramsCount ==1) {\n-          Object o = cmd.getCommandData();\n-          if (o instanceof Map && c != null && c != Map.class) {\n-            o = mapper.readValue(Utils.toJSONString(o), c);\n-          }\n-          PayloadObj<Object> payloadObj = new PayloadObj<>(cmd.name, cmd.getCommandData(), o, req, rsp);\n-          cmd = payloadObj;\n-          method.invoke(obj, payloadObj);\n-          checkForErrorInPayload(cmd);\n-        } else if (paramsCount == 2) {\n-          method.invoke(obj, req, rsp);\n-        } else {\n-          Object o = cmd.getCommandData();\n-          if (o instanceof Map && c != null) {\n-            o = mapper.readValue(Utils.toJSONString(o), c);\n-          }\n-          if (isWrappedInPayloadObj) {\n-            PayloadObj<Object> payloadObj = new PayloadObj<>(cmd.name, cmd.getCommandData(), o, req, rsp);\n-            cmd = payloadObj;\n-            method.invoke(obj, req, rsp, payloadObj);\n-          } else {\n-            method.invoke(obj, req, rsp, o);\n-          }\n-          checkForErrorInPayload(cmd);\n-        }\n-\n-\n-      } catch (SolrException se) {\n-        log.error(\"Error executing command  \", se);\n-        throw se;\n-      } catch (InvocationTargetException ite) {\n-        log.error(\"Error executing command \", ite);\n-        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, ite.getCause());\n-      } catch (Exception e) {\n-        log.error(\"Error executing command : \", e);\n-        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);\n-      }\n-\n-    }\n-\n-    private void checkForErrorInPayload(CommandOperation cmd) {\n-      if (cmd.hasError()) {\n-        throw new ApiBag.ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error executing command\",\n-            CommandOperation.captureErrors(Collections.singletonList(cmd)));\n-      }\n-    }\n-  }\n-\n-  public static Map<String, Object> createSchema(Method m) {\n-    Type[] types = m.getGenericParameterTypes();\n-    Type t = null;\n-    if (types.length == 3) t = types[2]; // (SolrQueryRequest req, SolrQueryResponse rsp, PayloadObj<PluginMeta>)\n-    if(types.length == 1) t = types[0];// (PayloadObj<PluginMeta>)\n-    if (t != null) {\n-      if (t instanceof ParameterizedType) {\n-        ParameterizedType typ = (ParameterizedType) t;\n-        if (typ.getRawType() == PayloadObj.class) {\n-          t = typ.getActualTypeArguments()[0];\n-        }\n-      }\n-      return JsonSchemaCreator.getSchema(t);\n-\n-    }\n-    return null;\n-  }\n-\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "20c1fdbf7e4573948434cfa82e1f7b0fc4d54b31", "committedDate": "2020-06-30 22:40:26 +1000", "message": "SOLR-14404: use MethodHandles in AnnotatedAPI (#1624)"}, {"oid": "7b8e72e5531f3678242e1106d528ec835ac33959", "committedDate": "2020-09-16 18:06:43 +1000", "message": "SOLR-14871 Use Annotations for v2 APIs in/cluster path (#1878)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "73d5e7ae77d8953cb9be35a7cbcebe3a516dd04a", "committedDate": "2020-11-17 00:19:50 +1100", "message": "SOLR-14977 :  ContainerPlugins should be configurable (#2065)"}, {"oid": "94c69f43851e284804849b0d7a38d18427386114", "committedDate": "2020-12-15 14:18:09 +1100", "message": "SOLR-14977: improved plugin configuration (#2099)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NTI3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443255277", "body": "FWIW at this line and at some other lines, consider simply doing `e.toString()` thus capturing both the class name & message.  Long ago I once used `e.getMessage()` but I never call it any more because you're throwing away interesting info in the exception type.  For example a FileNotFoundException's message is simply the name of the file, giving no indication of what the problem is.", "bodyText": "FWIW at this line and at some other lines, consider simply doing e.toString() thus capturing both the class name & message.  Long ago I once used e.getMessage() but I never call it any more because you're throwing away interesting info in the exception type.  For example a FileNotFoundException's message is simply the name of the file, giving no indication of what the problem is.", "bodyHTML": "<p dir=\"auto\">FWIW at this line and at some other lines, consider simply doing <code>e.toString()</code> thus capturing both the class name &amp; message.  Long ago I once used <code>e.getMessage()</code> but I never call it any more because you're throwing away interesting info in the exception type.  For example a FileNotFoundException's message is simply the name of the file, giving no indication of what the problem is.</p>", "author": "dsmiley", "createdAt": "2020-06-21T20:45:06Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.*;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh();\n+    return false;\n+  }\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      try {\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n+      }\n+    }\n+\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+        try {\n+          apiInfo.init();\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n+        }\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n+          }\n+        }\n+      }\n+\n+    }\n+  }\n+\n+  private class ApiHolder extends Api {\n+    final AnnotatedApi api;\n+\n+    protected ApiHolder(AnnotatedApi api) {\n+      super(api);\n+      this.api = api;\n+    }\n+\n+    @Override\n+    public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n+      api.call(req, rsp);\n+    }\n+\n+    public String getPath(){\n+      return api.getEndPoint().path()[0];\n+    }\n+\n+    public SolrRequest.METHOD getMethod(){\n+      return api.getEndPoint().method()[0];\n+\n+    }\n+  }\n+\n+  public class ApiInfo implements ReflectMapWriter {\n+    List<ApiHolder> holders;\n+    @JsonProperty\n+    private final PluginMeta info;\n+\n+    @JsonProperty(value = \"package\")\n+    public final String pkg;\n+\n+    private PackageLoader.Package.Version pkgVersion;\n+    private Class klas;\n+    Object instance;\n+\n+\n+    public ApiInfo(PluginMeta info, List<String> errs) {\n+      this.info = info;\n+      Pair<String, String> klassInfo = org.apache.solr.core.PluginInfo.parseClassName(info.klass);\n+      pkg = klassInfo.first();\n+      if (pkg != null) {\n+        PackageLoader.Package p = coreContainer.getPackageLoader().getPackage(pkg);\n+        if (p == null) {\n+          errs.add(\"Invalid package \" + klassInfo.first());\n+          return;\n+        }\n+        this.pkgVersion = p.getVersion(info.version);\n+        if (pkgVersion == null) {\n+          errs.add(\"No such package version:\" + pkg + \":\" + info.version + \" . available versions :\" + p.allVersions());\n+          return;\n+        }\n+        try {\n+          klas = pkgVersion.getLoader().findClass(klassInfo.second(), Object.class);\n+        } catch (Exception e) {\n+          log.error(\"Error loading class\", e);\n+          errs.add(\"Error loading class \" + e.getMessage());", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0172bfb176d..f4f41c556cb 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -197,14 +206,14 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n           klas = pkgVersion.getLoader().findClass(klassInfo.second(), Object.class);\n         } catch (Exception e) {\n           log.error(\"Error loading class\", e);\n-          errs.add(\"Error loading class \" + e.getMessage());\n+          errs.add(\"Error loading class \" + e.toString());\n           return;\n         }\n       } else {\n         try {\n           klas = Class.forName(klassInfo.second());\n         } catch (ClassNotFoundException e) {\n-          errs.add(\"Error loading class \" + e.getMessage());\n+          errs.add(\"Error loading class \" + e.toString());\n           return;\n         }\n         pkgVersion = null;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0172bfb176d..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -197,14 +208,14 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n           klas = pkgVersion.getLoader().findClass(klassInfo.second(), Object.class);\n         } catch (Exception e) {\n           log.error(\"Error loading class\", e);\n-          errs.add(\"Error loading class \" + e.getMessage());\n+          errs.add(\"Error loading class \" + e.toString());\n           return;\n         }\n       } else {\n         try {\n           klas = Class.forName(klassInfo.second());\n         } catch (ClassNotFoundException e) {\n-          errs.add(\"Error loading class \" + e.getMessage());\n+          errs.add(\"Error loading class \" + e.toString());\n           return;\n         }\n         pkgVersion = null;\n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..f24626bbf08 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -213,7 +247,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n         }\n       } else {\n         try {\n-          klas = Class.forName(klassInfo.second());\n+          klas = Class.forName(klassInfo.className);\n         } catch (ClassNotFoundException e) {\n           errs.add(\"Error loading class \" + e.toString());\n           return;\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NTQ1MA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443255450", "body": "Please add at least one sentence javadoc to the class", "bodyText": "Please add at least one sentence javadoc to the class", "bodyHTML": "<p dir=\"auto\">Please add at least one sentence javadoc to the class</p>", "author": "dsmiley", "createdAt": "2020-06-21T20:47:18Z", "path": "solr/core/src/java/org/apache/solr/api/PayloadObj.java", "diffHunk": "@@ -18,18 +18,31 @@\n package org.apache.solr.api;\n \n import org.apache.solr.common.util.CommandOperation;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n \n-public  class PayloadObj<T> extends CommandOperation {\n+public class PayloadObj<T> extends CommandOperation {", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/PayloadObj.java b/solr/core/src/java/org/apache/solr/api/PayloadObj.java\nindex 5365e18aabe..7941304213d 100644\n--- a/solr/core/src/java/org/apache/solr/api/PayloadObj.java\n+++ b/solr/core/src/java/org/apache/solr/api/PayloadObj.java\n", "chunk": "@@ -21,8 +21,12 @@ import org.apache.solr.common.util.CommandOperation;\n import org.apache.solr.request.SolrQueryRequest;\n import org.apache.solr.response.SolrQueryResponse;\n \n+/**\n+ * Holds the deserialized object for each command and also holds request , response objects\n+ */\n public class PayloadObj<T> extends CommandOperation {\n \n+    //the deserialized object parameter\n     private T obj;\n     final SolrQueryRequest req;\n     final SolrQueryResponse rsp;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/PayloadObj.java b/solr/core/src/java/org/apache/solr/api/PayloadObj.java\nindex 5365e18aabe..7941304213d 100644\n--- a/solr/core/src/java/org/apache/solr/api/PayloadObj.java\n+++ b/solr/core/src/java/org/apache/solr/api/PayloadObj.java\n", "chunk": "@@ -21,8 +21,12 @@ import org.apache.solr.common.util.CommandOperation;\n import org.apache.solr.request.SolrQueryRequest;\n import org.apache.solr.response.SolrQueryResponse;\n \n+/**\n+ * Holds the deserialized object for each command and also holds request , response objects\n+ */\n public class PayloadObj<T> extends CommandOperation {\n \n+    //the deserialized object parameter\n     private T obj;\n     final SolrQueryRequest req;\n     final SolrQueryResponse rsp;\n", "next_change": {"commit": "7b8e72e5531f3678242e1106d528ec835ac33959", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/PayloadObj.java b/solr/core/src/java/org/apache/solr/api/PayloadObj.java\nindex 7941304213d..df4c1e40d55 100644\n--- a/solr/core/src/java/org/apache/solr/api/PayloadObj.java\n+++ b/solr/core/src/java/org/apache/solr/api/PayloadObj.java\n", "chunk": "@@ -31,8 +31,8 @@ public class PayloadObj<T> extends CommandOperation {\n     final SolrQueryRequest req;\n     final SolrQueryResponse rsp;\n \n-    public PayloadObj(String operationName, Object metaData, T obj, SolrQueryRequest req, SolrQueryResponse rsp) {\n-        super(operationName, metaData);\n+    public PayloadObj(String operationName, Object originalMetadata, T obj, SolrQueryRequest req, SolrQueryResponse rsp) {\n+        super(operationName, originalMetadata);\n         this.obj = obj;\n         this.req = req;\n         this.rsp = rsp;\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/PayloadObj.java b/solr/core/src/java/org/apache/solr/api/PayloadObj.java\ndeleted file mode 100644\nindex df4c1e40d55..00000000000\n--- a/solr/core/src/java/org/apache/solr/api/PayloadObj.java\n+++ /dev/null\n", "chunk": "@@ -1,52 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.api;\n-\n-import org.apache.solr.common.util.CommandOperation;\n-import org.apache.solr.request.SolrQueryRequest;\n-import org.apache.solr.response.SolrQueryResponse;\n-\n-/**\n- * Holds the deserialized object for each command and also holds request , response objects\n- */\n-public class PayloadObj<T> extends CommandOperation {\n-\n-    //the deserialized object parameter\n-    private T obj;\n-    final SolrQueryRequest req;\n-    final SolrQueryResponse rsp;\n-\n-    public PayloadObj(String operationName, Object originalMetadata, T obj, SolrQueryRequest req, SolrQueryResponse rsp) {\n-        super(operationName, originalMetadata);\n-        this.obj = obj;\n-        this.req = req;\n-        this.rsp = rsp;\n-    }\n-\n-    public T get() {\n-        return obj;\n-    }\n-\n-    public SolrQueryRequest getRequest() {\n-        return req;\n-    }\n-\n-    public SolrQueryResponse getResponse() {\n-        return rsp;\n-    }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "7b8e72e5531f3678242e1106d528ec835ac33959", "committedDate": "2020-09-16 18:06:43 +1000", "message": "SOLR-14871 Use Annotations for v2 APIs in/cluster path (#1878)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NjM4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443256385", "body": "should be static; maybe other inner classes here too?", "bodyText": "should be static; maybe other inner classes here too?", "bodyHTML": "<p dir=\"auto\">should be static; maybe other inner classes here too?</p>", "author": "dsmiley", "createdAt": "2020-06-21T20:59:33Z", "path": "solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.api;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.request.beans.PluginMeta;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.cloud.ClusterPropertiesListener;\n+import org.apache.solr.common.util.*;\n+import org.apache.solr.core.CoreContainer;\n+import org.apache.solr.handler.admin.ContainerPluginsApi;\n+import org.apache.solr.pkg.PackageLoader;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.response.SolrQueryResponse;\n+import org.apache.solr.util.SolrJacksonAnnotationInspector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import static org.apache.lucene.util.IOUtils.closeWhileHandlingException;\n+\n+public class CustomContainerPlugins implements ClusterPropertiesListener {\n+  private ObjectMapper mapper = SolrJacksonAnnotationInspector.createObjectMapper();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  final CoreContainer coreContainer;\n+  final ApiBag containerApiBag;\n+\n+  private Map<String, ApiInfo> currentPlugins = new HashMap();\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    refresh();\n+    return false;\n+  }\n+  public CustomContainerPlugins(CoreContainer coreContainer, ApiBag apiBag) {\n+    this.coreContainer = coreContainer;\n+    this.containerApiBag = apiBag;\n+  }\n+\n+  public synchronized void refresh() {\n+    Map<String, Object> pluginInfos = null;\n+    try {\n+      pluginInfos = ContainerPluginsApi.plugins(coreContainer.zkClientSupplier);\n+    } catch (IOException e) {\n+      log.error(\"Could not read plugins data\", e);\n+      return;\n+    }\n+    Map<String,PluginMeta> newState = new HashMap<>(pluginInfos.size());\n+    for (Map.Entry<String, Object> e : pluginInfos.entrySet()) {\n+      try {\n+        newState.put(e.getKey(),\n+            mapper.readValue(Utils.toJSON(e.getValue()), PluginMeta.class));\n+      } catch (Exception exp) {\n+        log.error(\"Invalid apiInfo configuration :\", exp);\n+      }\n+    }\n+\n+    Map<String, PluginMeta> currentState = new HashMap<>();\n+    for (Map.Entry<String, ApiInfo> e : currentPlugins.entrySet()) {\n+      currentState.put(e.getKey(), e.getValue().info);\n+    }\n+    Map<String, Diff> diff = compareMaps(currentState, newState);\n+    if (diff == null) return;//nothing has changed\n+    for (Map.Entry<String, Diff> e : diff.entrySet()) {\n+      if (e.getValue() == Diff.UNCHANGED) continue;\n+      if (e.getValue() == Diff.REMOVED) {\n+        ApiInfo apiInfo = currentPlugins.remove(e.getKey());\n+        if (apiInfo == null) continue;\n+        for (ApiHolder holder : apiInfo.holders) {\n+          Api old = containerApiBag.unregister(holder.api.getEndPoint().method()[0], holder.api.getEndPoint().path()[0]);\n+          if (old instanceof Closeable) {\n+            closeWhileHandlingException((Closeable) old);\n+          }\n+        }\n+      } else {\n+        //ADDED or UPDATED\n+        PluginMeta info = newState.get(e.getKey());\n+        ApiInfo apiInfo = null;\n+        List<String> errs = new ArrayList<>();\n+        apiInfo = new ApiInfo(info, errs);\n+        if (!errs.isEmpty()) {\n+          log.error(StrUtils.join(errs, ','));\n+          continue;\n+        }\n+        try {\n+          apiInfo.init();\n+        } catch (Exception exp) {\n+          log.error(\"Cannot install apiInfo \", exp);\n+          continue;\n+        }\n+        if (e.getValue() == Diff.ADDED) {\n+          for (ApiHolder holder : apiInfo.holders) {\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          currentPlugins.put(e.getKey(), apiInfo);\n+        } else {\n+          ApiInfo old = currentPlugins.put(e.getKey(), apiInfo);\n+          List<ApiHolder> replaced = new ArrayList<>();\n+          for (ApiHolder holder : apiInfo.holders) {\n+            Api oldApi = containerApiBag.lookup(holder.getPath(),\n+                holder.getMethod().toString(), null);\n+            if (oldApi instanceof ApiHolder) {\n+              replaced.add((ApiHolder) oldApi);\n+            }\n+            containerApiBag.register(holder, Collections.singletonMap(\"plugin-name\", e.getKey()));\n+          }\n+          if (old != null) {\n+            for (ApiHolder holder : old.holders) {\n+              if (replaced.contains(holder)) continue;// this path is present in the new one as well. so it already got replaced\n+              containerApiBag.unregister(holder.getMethod(), holder.getPath());\n+            }\n+            if (old instanceof Closeable) {\n+              closeWhileHandlingException((Closeable) old);\n+            }\n+          }\n+        }\n+      }\n+\n+    }\n+  }\n+\n+  private class ApiHolder extends Api {", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0172bfb176d..f4f41c556cb 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -142,7 +151,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     }\n   }\n \n-  private class ApiHolder extends Api {\n+  private static class ApiHolder extends Api {\n     final AnnotatedApi api;\n \n     protected ApiHolder(AnnotatedApi api) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 0172bfb176d..9246dacb79b 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -142,7 +151,7 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     }\n   }\n \n-  private class ApiHolder extends Api {\n+  private static class ApiHolder extends Api {\n     final AnnotatedApi api;\n \n     protected ApiHolder(AnnotatedApi api) {\n", "next_change": {"commit": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\nindex 9246dacb79b..6e2e0fbc7c1 100644\n--- a/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n+++ b/solr/core/src/java/org/apache/solr/api/CustomContainerPlugins.java\n", "chunk": "@@ -151,6 +153,12 @@ public class CustomContainerPlugins implements ClusterPropertiesListener {\n     }\n   }\n \n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+  private static  Map<String, String> getTemplateVars(PluginMeta pluginMeta) {\n+    Map result = makeMap(\"plugin-name\", pluginMeta.name, \"path-prefix\", pluginMeta.pathPrefix);\n+    return result;\n+  }\n+\n   private static class ApiHolder extends Api {\n     final AnnotatedApi api;\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "2e60e1fbbd3f72526b2975398f3943c398637c21", "committedDate": "2020-07-02 15:44:16 +1000", "message": "SOLR-14404: Unregister was not working for plugins with $path-prefix"}, {"oid": "3642aa3d4e1a92e46c916445feb7eabc88eb4bcd", "committedDate": "2020-07-05 16:28:35 +1000", "message": "SOLR-14404: update was not working"}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "4087958d31829ee36ddda0bd884ea303ae9a1a61", "committedDate": "2020-09-22 11:20:49 +1000", "message": "SOLR-14884: TestContainerPlugin.testApiFromPackage jenkins failures"}, {"oid": "5e617ccc33d91998a992a87ae258de43ef75242e", "committedDate": "2020-09-28 16:49:28 +0900", "message": "LUCENE-9317: Clean up split package in analyzers-common (#1836)"}, {"oid": "67ecd8ff9ad3640016424ded86bfaaadd815b96d", "committedDate": "2020-10-21 17:22:44 +0200", "message": "SOLR-14749: Improve support for arbitrary container-level plugins. Add ClusterSingleton support for plugins that require only one active instance in the cluster."}, {"oid": "bdc6e8247fdb162902c794b73fdc228d526a3a6e", "committedDate": "2020-11-05 12:18:05 +0100", "message": "SOLR-14749: Provide a clean API for cluster-level event processing."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NjgxNw==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443256817", "body": "No; it was correct before.  Internally, setCore can accept null and doesn't require the caller to care if core is null.  Furthermore, PackageListeners.core will never be null.  It ought to be declared final as well; it's only set in the constructor.", "bodyText": "No; it was correct before.  Internally, setCore can accept null and doesn't require the caller to care if core is null.  Furthermore, PackageListeners.core will never be null.  It ought to be declared final as well; it's only set in the constructor.", "bodyHTML": "<p dir=\"auto\">No; it was correct before.  Internally, setCore can accept null and doesn't require the caller to care if core is null.  Furthermore, PackageListeners.core will never be null.  It ought to be declared final as well; it's only set in the constructor.</p>", "author": "dsmiley", "createdAt": "2020-06-21T21:05:21Z", "path": "solr/core/src/java/org/apache/solr/pkg/PackageListeners.java", "diffHunk": "@@ -69,7 +69,7 @@ synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n         invokeListeners(pkgInfo);\n       }\n     } finally {\n-      MDCLoggingContext.clear();\n+      if(core != null) MDCLoggingContext.clear();", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MzQ0NA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443953444", "bodyText": "PackageListeners.core will never be null\n\nNow it's not.\nThe schema plugins will no more be associated with a core. They will have it as null. I don't need to deal with it in this. So, I'll remove the null check now. PackageListeners is not used in ContainerPlugins", "author": "noblepaul", "createdAt": "2020-06-23T04:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NjgxNw=="}], "type": "inlineReview", "revised_code": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\nindex 8a10101ce97..9094ae9d2f4 100644\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n", "chunk": "@@ -69,7 +70,7 @@ public class PackageListeners {\n         invokeListeners(pkgInfo);\n       }\n     } finally {\n-      if(core != null) MDCLoggingContext.clear();\n+      MDCLoggingContext.clear();\n     }\n   }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\nindex 8a10101ce97..b5b295f156f 100644\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n", "chunk": "@@ -69,7 +69,7 @@ public class PackageListeners {\n         invokeListeners(pkgInfo);\n       }\n     } finally {\n-      if(core != null) MDCLoggingContext.clear();\n+      MDCLoggingContext.clear();\n     }\n   }\n \n", "next_change": {"commit": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\nindex b5b295f156f..1895b6d3069 100644\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n", "chunk": "@@ -64,21 +65,23 @@ public class PackageListeners {\n \n   synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n     MDCLoggingContext.setCore(core);\n+    Listener.Ctx ctx = new Listener.Ctx();\n     try {\n       for (PackageLoader.Package pkgInfo : pkgs) {\n-        invokeListeners(pkgInfo);\n+        invokeListeners(pkgInfo, ctx);\n       }\n     } finally {\n+      ctx.runLaterTasks(core::runAsync);\n       MDCLoggingContext.clear();\n     }\n   }\n \n-  private synchronized void invokeListeners(PackageLoader.Package pkg) {\n+  private synchronized void invokeListeners(PackageLoader.Package pkg, Listener.Ctx ctx) {\n     for (Reference<Listener> ref : listeners) {\n       Listener listener = ref.get();\n       if(listener == null) continue;\n       if (listener.packageName() == null || listener.packageName().equals(pkg.name())) {\n-        listener.changed(pkg);\n+        listener.changed(pkg, ctx);\n       }\n     }\n   }\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java b/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\ndeleted file mode 100644\nindex 1895b6d3069..00000000000\n--- a/solr/core/src/java/org/apache/solr/pkg/PackageListeners.java\n+++ /dev/null\n", "chunk": "@@ -1,139 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.pkg;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.ref.Reference;\n-import java.lang.ref.SoftReference;\n-import java.util.*;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.function.Consumer;\n-\n-import org.apache.solr.common.MapWriter;\n-import org.apache.solr.core.PluginInfo;\n-import org.apache.solr.core.SolrCore;\n-import org.apache.solr.logging.MDCLoggingContext;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class PackageListeners {\n-  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n-\n-  public static final String PACKAGE_VERSIONS = \"PKG_VERSIONS\";\n-  private final SolrCore core;\n-\n-  public PackageListeners(SolrCore core) {\n-    this.core = core;\n-  }\n-\n-  // this registry only keeps a weak reference because it does not want to\n-  // cause a memory leak if the listener forgets to unregister itself\n-  private List<Reference<Listener>> listeners = new CopyOnWriteArrayList<>();\n-\n-  public synchronized void addListener(Listener listener) {\n-    listeners.add(new SoftReference<>(listener));\n-\n-  }\n-\n-  public synchronized void removeListener(Listener listener) {\n-    Iterator<Reference<Listener>> it = listeners.iterator();\n-    while (it.hasNext()) {\n-      Reference<Listener> ref = it.next();\n-      Listener pkgListener = ref.get();\n-      if (pkgListener == null || pkgListener == listener) {\n-        it.remove();\n-      }\n-\n-    }\n-\n-  }\n-\n-  synchronized void packagesUpdated(List<PackageLoader.Package> pkgs) {\n-    MDCLoggingContext.setCore(core);\n-    Listener.Ctx ctx = new Listener.Ctx();\n-    try {\n-      for (PackageLoader.Package pkgInfo : pkgs) {\n-        invokeListeners(pkgInfo, ctx);\n-      }\n-    } finally {\n-      ctx.runLaterTasks(core::runAsync);\n-      MDCLoggingContext.clear();\n-    }\n-  }\n-\n-  private synchronized void invokeListeners(PackageLoader.Package pkg, Listener.Ctx ctx) {\n-    for (Reference<Listener> ref : listeners) {\n-      Listener listener = ref.get();\n-      if(listener == null) continue;\n-      if (listener.packageName() == null || listener.packageName().equals(pkg.name())) {\n-        listener.changed(pkg, ctx);\n-      }\n-    }\n-  }\n-\n-  public List<Listener> getListeners() {\n-    List<Listener> result = new ArrayList<>();\n-    for (Reference<Listener> ref : listeners) {\n-      Listener l = ref.get();\n-      if (l != null) {\n-        result.add(l);\n-      }\n-    }\n-    return result;\n-  }\n-\n-\n-  public interface Listener {\n-    /**Name of the package or null to listen to all package changes */\n-    String packageName();\n-\n-    PluginInfo pluginInfo();\n-\n-    /**A callback when the package is updated */\n-    void changed(PackageLoader.Package pkg, Ctx ctx);\n-\n-    default MapWriter getPackageVersion(PluginInfo.ClassName cName) {\n-      return null;\n-    }\n-    class Ctx {\n-      private Map<String, Runnable> runLater;\n-\n-      /**\n-       * If there are multiple packages to be updated and there are multiple listeners,\n-       * This is executed after all of the {@link Listener#changed(PackageLoader.Package, Ctx)}\n-       * calls are invoked. The name is a unique identifier that can be used by consumers to avoid duplicate\n-       * If no deduplication is required, use null as the name\n-       */\n-      public void runLater(String name, Runnable runnable) {\n-        if (runLater == null) runLater = new LinkedHashMap<>();\n-        if (name == null) {\n-          name = runnable.getClass().getSimpleName() + \"@\" + runnable.hashCode();\n-        }\n-        runLater.put(name, runnable);\n-      }\n-\n-      private void runLaterTasks(Consumer<Runnable> runnableExecutor) {\n-        if (runLater == null) return;\n-        for (Runnable r : runLater.values()) {\n-          runnableExecutor.accept(r);\n-        }\n-      }\n-    }\n-\n-  }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "03d658a7bc306370cfce6ef92f34f151db7ad3dc", "committedDate": "2020-07-16 16:05:24 +1000", "message": "SOLR-14151 Make schema components load from packages (#1669)"}, {"oid": "9466af576a4a9d3cd750438123063928329fbb46", "committedDate": "2021-01-13 22:28:01 +1100", "message": "SOLR-14155: Load all other SolrCore plugins from packages (#1666)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NzMwMQ==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443257301", "body": "Add at least one line of javadoc for every public class", "bodyText": "Add at least one line of javadoc for every public class", "bodyHTML": "<p dir=\"auto\">Add at least one line of javadoc for every public class</p>", "author": "dsmiley", "createdAt": "2020-06-21T21:12:15Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.request.beans;\n+\n+import java.util.Objects;\n+\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+\n+public class PluginMeta implements ReflectMapWriter {", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\nindex ec264b90939..ae090271aa2 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n", "chunk": "@@ -22,6 +22,9 @@ import java.util.Objects;\n import org.apache.solr.common.annotation.JsonProperty;\n import org.apache.solr.common.util.ReflectMapWriter;\n \n+/**\n+ * POJO for a plugin metadata used in container plugins\n+ */\n public class PluginMeta implements ReflectMapWriter {\n   @JsonProperty(required = true)\n   public String name;\n", "next_change": {"commit": "9c1e5aa599893bf5fa653af7f282bb8d3b8e49c4", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\nindex ae090271aa2..cb4f0aa85cf 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n", "chunk": "@@ -25,6 +25,7 @@ import org.apache.solr.common.util.ReflectMapWriter;\n /**\n  * POJO for a plugin metadata used in container plugins\n  */\n+@SuppressWarnings({\"overrides\"})\n public class PluginMeta implements ReflectMapWriter {\n   @JsonProperty(required = true)\n   public String name;\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\nindex ec264b90939..cb4f0aa85cf 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n", "chunk": "@@ -22,6 +22,10 @@ import java.util.Objects;\n import org.apache.solr.common.annotation.JsonProperty;\n import org.apache.solr.common.util.ReflectMapWriter;\n \n+/**\n+ * POJO for a plugin metadata used in container plugins\n+ */\n+@SuppressWarnings({\"overrides\"})\n public class PluginMeta implements ReflectMapWriter {\n   @JsonProperty(required = true)\n   public String name;\n", "next_change": {"commit": "11538e52a276956cd782e0a8946fdd2c950b5439", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\nindex cb4f0aa85cf..f06c8492a20 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n", "chunk": "@@ -25,7 +25,6 @@ import org.apache.solr.common.util.ReflectMapWriter;\n /**\n  * POJO for a plugin metadata used in container plugins\n  */\n-@SuppressWarnings({\"overrides\"})\n public class PluginMeta implements ReflectMapWriter {\n   @JsonProperty(required = true)\n   public String name;\n", "next_change": {"commit": "cced5078ea13797a49658cdf76f693a79788c533", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\nindex f06c8492a20..bab68b2cc72 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n", "chunk": "@@ -26,21 +26,33 @@ import org.apache.solr.common.util.ReflectMapWriter;\n  * POJO for a plugin metadata used in container plugins\n  */\n public class PluginMeta implements ReflectMapWriter {\n+  /** Unique plugin name, required. */\n   @JsonProperty(required = true)\n   public String name;\n \n+  /** Plugin implementation class, required. */\n   @JsonProperty(value = \"class\", required = true)\n   public String klass;\n \n+  /** Plugin version. */\n   @JsonProperty\n   public String version;\n \n+  /** Plugin API path prefix, optional. */\n+  @JsonProperty(\"path-prefix\")\n+  public String pathPrefix;\n+\n+  /** Plugin configuration object, optional. */\n+  @JsonProperty\n+  public Object config;\n+\n \n   public PluginMeta copy() {\n     PluginMeta result = new PluginMeta();\n     result.name = name;\n     result.klass = klass;\n     result.version = version;\n+    result.config = config;\n     return result;\n   }\n \n", "next_change": {"commit": "94c69f43851e284804849b0d7a38d18427386114", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\nindex bab68b2cc72..5aa85325d58 100644\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n", "chunk": "@@ -56,6 +58,12 @@ public class PluginMeta implements ReflectMapWriter {\n     return result;\n   }\n \n+  @Override\n+  public void writeMap(EntryWriter ew) throws IOException {\n+    ReflectMapWriter.super.writeMap(ew);\n+    ew.putIfNotNull(\"config\", config);\n+  }\n+\n   @Override\n   public boolean equals(Object obj) {\n     if (obj instanceof PluginMeta) {\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java b/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\ndeleted file mode 100644\nindex 5aa85325d58..00000000000\n--- a/solr/solrj/src/java/org/apache/solr/client/solrj/request/beans/PluginMeta.java\n+++ /dev/null\n", "chunk": "@@ -1,88 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.client.solrj.request.beans;\n-\n-import java.io.IOException;\n-import java.util.Objects;\n-\n-import org.apache.solr.common.MapWriter;\n-import org.apache.solr.common.annotation.JsonProperty;\n-import org.apache.solr.common.util.ReflectMapWriter;\n-\n-/**\n- * POJO for a plugin metadata used in container plugins\n- */\n-public class PluginMeta implements ReflectMapWriter {\n-  /** Unique plugin name, required. */\n-  @JsonProperty(required = true)\n-  public String name;\n-\n-  /** Plugin implementation class, required. */\n-  @JsonProperty(value = \"class\", required = true)\n-  public String klass;\n-\n-  /** Plugin version. */\n-  @JsonProperty\n-  public String version;\n-\n-  /** Plugin API path prefix, optional. */\n-  @JsonProperty(\"path-prefix\")\n-  public String pathPrefix;\n-\n-  /** Plugin configuration object, optional. */\n-  public MapWriter config;\n-\n-\n-\n-  public PluginMeta copy() {\n-    PluginMeta result = new PluginMeta();\n-    result.name = name;\n-    result.klass = klass;\n-    result.version = version;\n-    result.config = config;\n-    return result;\n-  }\n-\n-  @Override\n-  public void writeMap(EntryWriter ew) throws IOException {\n-    ReflectMapWriter.super.writeMap(ew);\n-    ew.putIfNotNull(\"config\", config);\n-  }\n-\n-  @Override\n-  public boolean equals(Object obj) {\n-    if (obj instanceof PluginMeta) {\n-      PluginMeta that = (PluginMeta) obj;\n-      return Objects.equals(this.name, that.name) &&\n-          Objects.equals(this.klass, that.klass) &&\n-          Objects.equals(this.version, that.version) &&\n-\n-          Objects.equals(this.config, that.config);\n-    }\n-    return false;\n-  }\n-  @Override\n-  public int hashCode() {\n-    return Objects.hash(name, version, klass);\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return jsonStr();\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "11538e52a276956cd782e0a8946fdd2c950b5439", "committedDate": "2020-06-25 16:35:56 -0400", "message": "SOLR-14541: Ensure classes that implement equals implement hashCode or suppress warnings"}, {"oid": "1590ed56bb4a4fec9ffb27a42b81106a934ac898", "committedDate": "2020-06-28 14:49:06 +1000", "message": "SOLR-14404: support for openResource() in PackageResourceLoader & path-prefix for container plugins"}, {"oid": "cced5078ea13797a49658cdf76f693a79788c533", "committedDate": "2020-12-06 14:51:10 +0100", "message": "SOLR-15016: Replica placement plugins should use container plugins API / configs."}, {"oid": "94c69f43851e284804849b0d7a38d18427386114", "committedDate": "2020-12-15 14:18:09 +1100", "message": "SOLR-14977: improved plugin configuration (#2099)"}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NzQ3NA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443257474", "body": "I think the name \"unregister\" would only make sense if there was a corresponding \"register\" method.  How about a more generic \"remove\"?", "bodyText": "I think the name \"unregister\" would only make sense if there was a corresponding \"register\" method.  How about a more generic \"remove\"?", "bodyHTML": "<p dir=\"auto\">I think the name \"unregister\" would only make sense if there was a corresponding \"register\" method.  How about a more generic \"remove\"?</p>", "author": "dsmiley", "createdAt": "2020-06-21T21:14:16Z", "path": "solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java", "diffHunk": "@@ -82,6 +80,22 @@ public boolean add(String s) {\n     return parts;\n   }\n \n+  public T unregister(List<String> path) {", "originalCommit": "35c057fdd1ba4154c4c453250ef59766473e3d96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1NDc0NA==", "url": "https://github.com/apache/lucene-solr/pull/1432#discussion_r443954744", "bodyText": "yeah, remove() is better for insert()", "author": "noblepaul", "createdAt": "2020-06-23T04:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI1NzQ3NA=="}], "type": "inlineReview", "revised_code": {"commit": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java b/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java\nindex fec146e5cb7..621fb217b4d 100644\n--- a/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java\n+++ b/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java\n", "chunk": "@@ -80,7 +84,7 @@ public class PathTrie<T> {\n     return parts;\n   }\n \n-  public T unregister(List<String> path) {\n+  public T remove(List<String> path) {\n     Node node = root.lookupNode(path, 0, null, null);\n     T result = null;\n     if (node != null) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "57a892f896f543913d6b22a81577f69184cd94b6", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java b/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java\nindex fec146e5cb7..621fb217b4d 100644\n--- a/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java\n+++ b/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java\n", "chunk": "@@ -80,7 +84,7 @@ public class PathTrie<T> {\n     return parts;\n   }\n \n-  public T unregister(List<String> path) {\n+  public T remove(List<String> path) {\n     Node node = root.lookupNode(path, 0, null, null);\n     T result = null;\n     if (node != null) {\n", "next_change": {"commit": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "changed_code": [{"header": "diff --git a/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java b/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java\ndeleted file mode 100644\nindex 621fb217b4d..00000000000\n--- a/solr/solrj/src/java/org/apache/solr/common/util/PathTrie.java\n+++ /dev/null\n", "chunk": "@@ -1,245 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.solr.common.util;\n-\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import static java.util.Collections.emptyList;\n-\n-/**\n- * A utility class to efficiently parse/store/lookup hierarchical paths which are templatized\n- * like /collections/{collection}/shards/{shard}/{replica}\n- */\n-public class PathTrie<T> {\n-  private final Set<String> reserved = new HashSet<>();\n-  Node root = new Node(emptyList(), null, null);\n-\n-  public PathTrie() {\n-  }\n-\n-  public PathTrie(Set<String> reserved) {\n-    this.reserved.addAll(reserved);\n-  }\n-\n-\n-  public void insert(String path, Map<String, String> replacements, T o) {\n-    List<String> parts = getPathSegments(path);\n-    insert(parts, replacements, o);\n-  }\n-\n-  public void insert(List<String> parts, Map<String, String> replacements, T o) {\n-    if (parts.isEmpty()) {\n-      root.obj = o;\n-      return;\n-    }\n-    replaceTemplates(parts, replacements);\n-    root.insert(parts, o);\n-  }\n-\n-  public static void replaceTemplates(List<String> parts, Map<String, String> replacements) {\n-    for (int i = 0; i < parts.size(); i++) {\n-      String part = parts.get(i);\n-      if (part.charAt(0) == '$') {\n-        String replacement = replacements.get(part.substring(1));\n-        if (replacement == null) {\n-          throw new RuntimeException(part + \" is not provided\");\n-        }\n-        replacement = replacement.charAt(0) == '/' ? replacement.substring(1) : replacement;\n-        parts.set(i, replacement);\n-      }\n-    }\n-  }\n-\n-  // /a/b/c will be returned as [\"a\",\"b\",\"c\"]\n-  public static List<String> getPathSegments(String path) {\n-    if (path == null || path.isEmpty()) return emptyList();\n-    List<String> parts = new ArrayList<>() {\n-      @Override\n-      public boolean add(String s) {\n-        if (s == null || s.isEmpty()) return false;\n-        return super.add(s);\n-      }\n-    };\n-    StrUtils.splitSmart(path, '/', parts);\n-    return parts;\n-  }\n-\n-  public T remove(List<String> path) {\n-    Node node = root.lookupNode(path, 0, null, null);\n-    T result = null;\n-    if (node != null) {\n-      result = node.obj;\n-      node.obj = null;\n-      if (node.children == null || node.children.isEmpty()) {\n-        if (node.parent != null) {\n-          node.parent.children.remove(node.name);\n-        }\n-      }\n-      return result;\n-    }\n-    return result;\n-\n-  }\n-\n-  public T lookup(String path, Map<String, String> templateValues) {\n-    return root.lookup(getPathSegments(path), 0, templateValues);\n-  }\n-\n-  public T lookup(List<String> path, Map<String, String> templateValues) {\n-    return root.lookup(path, 0, templateValues);\n-  }\n-\n-  public T lookup(String path, Map<String, String> templateValues, Set<String> paths) {\n-    return root.lookup(getPathSegments(path), 0, templateValues, paths);\n-  }\n-\n-  public static String templateName(String templateStr) {\n-    return templateStr.startsWith(\"{\") && templateStr.endsWith(\"}\") ?\n-        templateStr.substring(1, templateStr.length() - 1) :\n-        null;\n-\n-  }\n-\n-  class Node {\n-    String name;\n-    Map<String, Node> children;\n-    T obj;\n-    String templateName;\n-    final Node parent;\n-\n-    Node(List<String> path, T o, Node parent) {\n-      this.parent = parent;\n-      if (path.isEmpty()) {\n-        obj = o;\n-        return;\n-      }\n-      String part = path.get(0);\n-      templateName = templateName(part);\n-      name = part;\n-      if (path.isEmpty()) obj = o;\n-    }\n-\n-\n-    private synchronized void insert(List<String> path, T o) {\n-      String part = path.get(0);\n-      Node matchedChild = null;\n-      if (\"*\".equals(name)) {\n-        return;\n-      }\n-      if (children == null) children = new ConcurrentHashMap<>();\n-\n-      String varName = templateName(part);\n-      String key = varName == null ? part : \"\";\n-\n-      matchedChild = children.get(key);\n-      if (matchedChild == null) {\n-        children.put(key, matchedChild = new Node(path, o, this));\n-      }\n-      if (varName != null) {\n-        if (!matchedChild.templateName.equals(varName)) {\n-          throw new RuntimeException(\"wildcard name must be \" + matchedChild.templateName);\n-        }\n-      }\n-      path.remove(0);\n-      if (!path.isEmpty()) {\n-        matchedChild.insert(path, o);\n-      } else {\n-        matchedChild.obj = o;\n-      }\n-\n-    }\n-\n-\n-    void findAvailableChildren(String path, Set<String> availableSubPaths) {\n-      if (availableSubPaths == null) return;\n-      if (children != null) {\n-        for (Node node : children.values()) {\n-          if (node.obj != null) {\n-            String s = path + \"/\" + node.name;\n-            availableSubPaths.add(s);\n-          }\n-        }\n-\n-        for (Node node : children.values()) {\n-          node.findAvailableChildren(path + \"/\" + node.name, availableSubPaths);\n-        }\n-      }\n-    }\n-\n-\n-    public T lookup(List<String> pieces, int i, Map<String, String> templateValues) {\n-      return lookup(pieces, i, templateValues, null);\n-\n-    }\n-\n-    /**\n-     * @param pathSegments      pieces in the url /a/b/c has pieces as 'a' , 'b' , 'c'\n-     * @param index             current index of the pieces that we are looking at in /a/b/c 0='a' and 1='b'\n-     * @param templateVariables The mapping of template variable to its value\n-     * @param availableSubPaths If not null , available sub paths will be returned in this set\n-     */\n-    public T lookup(List<String> pathSegments, int index, Map<String, String> templateVariables, Set<String> availableSubPaths) {\n-      Node node = lookupNode(pathSegments, index, templateVariables, availableSubPaths);\n-      return node == null ? null : node.obj;\n-    }\n-\n-    Node lookupNode(List<String> pathSegments, int index, Map<String, String> templateVariables, Set<String> availableSubPaths) {\n-      if (templateName != null && templateVariables != null)\n-        templateVariables.put(templateName, pathSegments.get(index - 1));\n-      if (pathSegments.size() < index + 1) {\n-        findAvailableChildren(\"\", availableSubPaths);\n-        if (obj == null) {//this is not a leaf node\n-          Node n = children.get(\"*\");\n-          if (n != null) {\n-            return n;\n-          }\n-\n-        }\n-        return this;\n-      }\n-      String piece = pathSegments.get(index);\n-      if (children == null) {\n-        return null;\n-      }\n-      Node n = children.get(piece);\n-      if (n == null && !reserved.contains(piece)) n = children.get(\"\");\n-      if (n == null) {\n-        n = children.get(\"*\");\n-        if (n != null) {\n-          StringBuffer sb = new StringBuffer();\n-          for (int i = index; i < pathSegments.size(); i++) {\n-            sb.append(\"/\").append(pathSegments.get(i));\n-          }\n-          if (templateVariables != null) templateVariables.put(\"*\", sb.toString());\n-          return n;\n-\n-        }\n-      }\n-      if (n == null) {\n-        return null;\n-      }\n-      return n.lookupNode(pathSegments, index + 1, templateVariables, availableSubPaths);\n-    }\n-  }\n-\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "57a892f896f543913d6b22a81577f69184cd94b6", "message": "Merge commit", "committedDate": null}, {"oid": "fa22dd1969b8a8c5dd2ccf1bb1e88c3e5c956c51", "committedDate": "2021-03-10 09:22:31 +0100", "message": "SOLR-14762: wipe master branch after the split point."}]}, {"oid": "6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "url": "https://github.com/apache/lucene-solr/commit/6dcbc20b0de7e0aec048ce406f7c0b4fd2355400", "message": "implemented feedback comments", "committedDate": "2020-06-23T04:39:17Z", "type": "commit"}, {"oid": "a71602f2c6690df5afe77445d0361581b511aa3f", "url": "https://github.com/apache/lucene-solr/commit/a71602f2c6690df5afe77445d0361581b511aa3f", "message": "Update sig.txt", "committedDate": "2020-06-23T05:00:41Z", "type": "commit"}, {"oid": "0a552d83c7a472eda5233ff881ce75f5969e46a2", "url": "https://github.com/apache/lucene-solr/commit/0a552d83c7a472eda5233ff881ce75f5969e46a2", "message": "CHANGES.txt", "committedDate": "2020-06-24T00:22:01Z", "type": "commit"}, {"oid": "9c1e5aa599893bf5fa653af7f282bb8d3b8e49c4", "url": "https://github.com/apache/lucene-solr/commit/9c1e5aa599893bf5fa653af7f282bb8d3b8e49c4", "message": "no hashCode", "committedDate": "2020-06-24T00:34:25Z", "type": "commit"}, {"oid": "f2be5efec94c5f914fee2558ac3731b3c0854988", "url": "https://github.com/apache/lucene-solr/commit/f2be5efec94c5f914fee2558ac3731b3c0854988", "message": "no hashCode", "committedDate": "2020-06-24T02:04:36Z", "type": "commit"}, {"oid": "6d1ca0cbbdc1a2fd0bd336bd2eb51c7253fce1df", "url": "https://github.com/apache/lucene-solr/commit/6d1ca0cbbdc1a2fd0bd336bd2eb51c7253fce1df", "message": "javadocs", "committedDate": "2020-06-24T02:07:45Z", "type": "commit"}, {"oid": "677d84f7be7665a748d8d94ab5eee952dac60926", "url": "https://github.com/apache/lucene-solr/commit/677d84f7be7665a748d8d94ab5eee952dac60926", "message": "  @SuppressWarnings", "committedDate": "2020-06-24T04:54:51Z", "type": "commit"}, {"oid": "0422611a07865c85f89db5c81e9fc6b5ee08a4f0", "url": "https://github.com/apache/lucene-solr/commit/0422611a07865c85f89db5c81e9fc6b5ee08a4f0", "message": "  @SuppressWarnings", "committedDate": "2020-06-24T04:56:02Z", "type": "commit"}, {"oid": "67fe4666c91d6f5220538c35e76ceadc169155e1", "url": "https://github.com/apache/lucene-solr/commit/67fe4666c91d6f5220538c35e76ceadc169155e1", "message": "merging with upstream", "committedDate": "2020-06-24T05:03:26Z", "type": "commit"}, {"oid": "4b412de64321d6eb2059e9f300c0e3a1393b7578", "url": "https://github.com/apache/lucene-solr/commit/4b412de64321d6eb2059e9f300c0e3a1393b7578", "message": "merging with upstream", "committedDate": "2020-06-24T05:25:31Z", "type": "commit"}, {"oid": "6d7db166aa2f61b43b6f114e4bc89c1a0cbb3f3a", "url": "https://github.com/apache/lucene-solr/commit/6d7db166aa2f61b43b6f114e4bc89c1a0cbb3f3a", "message": "merging with master", "committedDate": "2020-06-24T05:31:42Z", "type": "commit"}, {"oid": "a9dbd36ead985ddc220e8e326407f9f57220531a", "url": "https://github.com/apache/lucene-solr/commit/a9dbd36ead985ddc220e8e326407f9f57220531a", "message": "merging with origin", "committedDate": "2020-06-24T05:38:52Z", "type": "commit"}, {"oid": "92871f6547af30e6cb9fb4e1a60298e7432739f6", "url": "https://github.com/apache/lucene-solr/commit/92871f6547af30e6cb9fb4e1a60298e7432739f6", "message": "merging with origin", "committedDate": "2020-06-24T05:41:31Z", "type": "commit"}, {"oid": "fb07c1b3a55a432281c8b9125a356010c648a5f9", "url": "https://github.com/apache/lucene-solr/commit/fb07c1b3a55a432281c8b9125a356010c648a5f9", "message": "CHANGES.txt", "committedDate": "2020-06-24T05:46:17Z", "type": "commit"}, {"oid": "d1a22c8e84c9df8a5fb633ca829c9fbedf27de6b", "url": "https://github.com/apache/lucene-solr/commit/d1a22c8e84c9df8a5fb633ca829c9fbedf27de6b", "message": "SuppressWarnings", "committedDate": "2020-06-24T06:01:42Z", "type": "commit"}, {"oid": "b1e4dee970a87c9a77c09b706ad1674358b5dbf8", "url": "https://github.com/apache/lucene-solr/commit/b1e4dee970a87c9a77c09b706ad1674358b5dbf8", "message": "CHANGES.txt", "committedDate": "2020-06-25T01:35:56Z", "type": "commit"}, {"oid": "c9c17577b051e0e9e7158944004d3d72a71e0bbd", "url": "https://github.com/apache/lucene-solr/commit/c9c17577b051e0e9e7158944004d3d72a71e0bbd", "message": "Merge remote-tracking branch 'origin/master' into jira/solr14404\n\nmerge with master", "committedDate": "2020-06-25T01:36:02Z", "type": "commit"}, {"oid": "1c74faf0943da286f77ba2aab2cd5d0e400883f8", "url": "https://github.com/apache/lucene-solr/commit/1c74faf0943da286f77ba2aab2cd5d0e400883f8", "message": "merging with master", "committedDate": "2020-06-25T01:46:04Z", "type": "commit"}, {"oid": "cda8390a5edb21e978da618eb8b68ad8f43f28ef", "url": "https://github.com/apache/lucene-solr/commit/cda8390a5edb21e978da618eb8b68ad8f43f28ef", "message": "merging with master", "committedDate": "2020-06-25T01:48:01Z", "type": "commit"}, {"oid": "55ef0ebee05ef9b127125da69dcd5de21fc7101a", "url": "https://github.com/apache/lucene-solr/commit/55ef0ebee05ef9b127125da69dcd5de21fc7101a", "message": "merging with master", "committedDate": "2020-06-25T01:50:58Z", "type": "commit"}, {"oid": "371c92b54587d90c376929ae99dfc9d2acc15a5e", "url": "https://github.com/apache/lucene-solr/commit/371c92b54587d90c376929ae99dfc9d2acc15a5e", "message": "SuppressWarnings", "committedDate": "2020-06-25T02:34:39Z", "type": "commit"}, {"oid": "227743a2c383eb4245f56ca7204897111553f382", "url": "https://github.com/apache/lucene-solr/commit/227743a2c383eb4245f56ca7204897111553f382", "message": "SuppressWarnings", "committedDate": "2020-06-25T02:48:56Z", "type": "commit"}]}