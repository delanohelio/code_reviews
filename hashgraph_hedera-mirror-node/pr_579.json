{"pr_number": 579, "pr_title": "Prepare RecordFileParser for file init/complete logic.", "pr_createdAt": "2020-03-02T23:46:27Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/579", "timeline": [{"oid": "f1c762c3b2c9c53c921d90cc55b3617c13ea1f7d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f1c762c3b2c9c53c921d90cc55b3617c13ea1f7d", "message": "Prepare RecordFileParser for file init/complete logic.\n\n- Right now record file init/complete logic is in RecordFileLogger. In new design, we want to move\n  it to RecordFileParser.\n- This change (part 1 of 2) refactors RFP so that actual logic move (followup, part 2 of 2) can be neat.\n- New functions - initFile, closeFileAndCommit, rollback - are where the logic will be moved to.\n- Make loadRecordFile filesystem agnostic.\n- Although a lot of code being touched here can be improved in many other ways, keeping this PR refactor only for easy review\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-03-02T23:43:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMDA4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/579#discussion_r386720088", "bodyText": "these 3 functions look funny right now. In followup, the logic from RFLogger will move to these functions.", "author": "apeksharma", "createdAt": "2020-03-02T23:48:09Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -120,37 +123,45 @@ public static String readPrevFileHash(String fileName) {\n         return null;\n     }\n \n+    private RecordFileLogger.INIT_RESULT initFile(String filename) {", "originalCommit": "f1c762c3b2c9c53c921d90cc55b3617c13ea1f7d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMDM5Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/579#discussion_r386720393", "bodyText": "moved filesystem dependent code to one level up.", "author": "apeksharma", "createdAt": "2020-03-02T23:49:09Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -120,37 +123,45 @@ public static String readPrevFileHash(String fileName) {\n         return null;\n     }\n \n+    private RecordFileLogger.INIT_RESULT initFile(String filename) {\n+        return RecordFileLogger.initFile(filename);\n+    }\n+\n+    private void closeFileAndCommit(String fileHash, String previousHash) throws SQLException {\n+        RecordFileLogger.completeFile(fileHash, previousHash);\n+    }\n+\n+    private void rollback() {\n+        RecordFileLogger.rollback();\n+    }\n+\n     /**\n      * Given a service record name, read and parse and return as a list of service record pair\n      *\n-     * @param fileName         the name of record file to read\n-     * @param previousFileHash the hash of the previous record file in the series\n-     * @param thisFileHash     the hash of this file\n+     * @param fileName             the name of record file to read\n+     * @param expectedPrevFileHash the hash of the previous record file in the series\n+     * @param thisFileHash         the hash of this file\n      * @return return boolean indicating method success\n      * @throws Exception\n      */\n-    private boolean loadRecordFile(String fileName, String previousFileHash, String thisFileHash) throws Exception {\n-\n-        File file = new File(fileName);", "originalCommit": "f1c762c3b2c9c53c921d90cc55b3617c13ea1f7d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "692c537573715dfe5b96cdb02dd0989143645c54", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\nindex db983d6f..c68188e3 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\n", "chunk": "@@ -139,6 +139,7 @@ public class RecordFileParser implements FileParser {\n      * Given a service record name, read and parse and return as a list of service record pair\n      *\n      * @param fileName             the name of record file to read\n+     * @param inputStream          input stream of bytes in the record file\n      * @param expectedPrevFileHash the hash of the previous record file in the series\n      * @param thisFileHash         the hash of this file\n      * @return return boolean indicating method success\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMTQzMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/579#discussion_r386721430", "bodyText": "re-aligning is throwing the differ off, and results in big lumps of red and green.\nKeeping it un-aligned explicitly for easy review.\nOn approval, will push a commit to shift code left.", "author": "apeksharma", "createdAt": "2020-03-02T23:52:15Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -120,37 +123,45 @@ public static String readPrevFileHash(String fileName) {\n         return null;\n     }\n \n+    private RecordFileLogger.INIT_RESULT initFile(String filename) {\n+        return RecordFileLogger.initFile(filename);\n+    }\n+\n+    private void closeFileAndCommit(String fileHash, String previousHash) throws SQLException {\n+        RecordFileLogger.completeFile(fileHash, previousHash);\n+    }\n+\n+    private void rollback() {\n+        RecordFileLogger.rollback();\n+    }\n+\n     /**\n      * Given a service record name, read and parse and return as a list of service record pair\n      *\n-     * @param fileName         the name of record file to read\n-     * @param previousFileHash the hash of the previous record file in the series\n-     * @param thisFileHash     the hash of this file\n+     * @param fileName             the name of record file to read\n+     * @param expectedPrevFileHash the hash of the previous record file in the series\n+     * @param thisFileHash         the hash of this file\n      * @return return boolean indicating method success\n      * @throws Exception\n      */\n-    private boolean loadRecordFile(String fileName, String previousFileHash, String thisFileHash) throws Exception {\n-\n-        File file = new File(fileName);\n-        String newFileHash = \"\";\n-\n-        if (file.exists() == false) {\n-            log.warn(\"File does not exist {}\", fileName);\n+    private boolean loadRecordFile(String fileName, InputStream inputStream, String expectedPrevFileHash,\n+                                   String thisFileHash) {\n+        var result = initFile(fileName);\n+        if (result == RecordFileLogger.INIT_RESULT.SKIP) {\n+            return true; // skip this fle\n+        } else if (result == RecordFileLogger.INIT_RESULT.FAIL) {\n             return false;\n         }\n         long counter = 0;\n-        byte[] readFileHash = new byte[48];\n-        RecordFileLogger.INIT_RESULT initFileResult = RecordFileLogger.initFile(fileName);\n         Stopwatch stopwatch = Stopwatch.createStarted();\n         Integer recordFileVersion = 0;\n         Boolean success = false;\n \n-        if (initFileResult == RecordFileLogger.INIT_RESULT.OK) {\n-            try (DataInputStream dis = new DataInputStream(new FileInputStream(file))) {\n+            try (DataInputStream dis = new DataInputStream(inputStream)) {", "originalCommit": "f1c762c3b2c9c53c921d90cc55b3617c13ea1f7d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "692c537573715dfe5b96cdb02dd0989143645c54", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\nindex db983d6f..c68188e3 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\n", "chunk": "@@ -157,120 +158,120 @@ public class RecordFileParser implements FileParser {\n         Integer recordFileVersion = 0;\n         Boolean success = false;\n \n-            try (DataInputStream dis = new DataInputStream(inputStream)) {\n-                recordFileVersion = dis.readInt();\n-                int version = dis.readInt();\n-\n-                log.info(\"Loading version {} record file: {}\", recordFileVersion, fileName);\n-\n-                while (dis.available() != 0) {\n-\n-                    try {\n-                        byte typeDelimiter = dis.readByte();\n-\n-                        switch (typeDelimiter) {\n-                            case FileDelimiter.RECORD_TYPE_PREV_HASH:\n-                                byte[] readFileHash = new byte[48];\n-                                dis.read(readFileHash);\n-\n-                                if (Utility.hashIsEmpty(expectedPrevFileHash)) {\n-                                    log.error(\"Previous file hash not available\");\n-                                    expectedPrevFileHash = Hex.encodeHexString(readFileHash);\n-                                }\n-\n-                                String actualPrevFileHash = Hex.encodeHexString(readFileHash);\n-                                log.trace(\"actual file hash = {}, expected file hash = {}\", actualPrevFileHash,\n-                                        expectedPrevFileHash);\n-                                if (!actualPrevFileHash.contentEquals(expectedPrevFileHash)) {\n-                                    if (applicationStatusRepository\n-                                            .findByStatusCode(ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER)\n-                                            .compareTo(Utility.getFileName(fileName)) < 0) {\n-                                        // last file for which mismatch is allowed is in the past\n-                                        log.error(\"Hash mismatch for file {}. Actual = {}, Expected = {}\", fileName,\n-                                                expectedPrevFileHash, actualPrevFileHash);\n-                                        rollback();\n-                                        return false;\n-                                    }\n+        try (DataInputStream dis = new DataInputStream(inputStream)) {\n+            recordFileVersion = dis.readInt();\n+            int version = dis.readInt();\n+\n+            log.info(\"Loading version {} record file: {}\", recordFileVersion, fileName);\n+\n+            while (dis.available() != 0) {\n+\n+                try {\n+                    byte typeDelimiter = dis.readByte();\n+\n+                    switch (typeDelimiter) {\n+                        case FileDelimiter.RECORD_TYPE_PREV_HASH:\n+                            byte[] readFileHash = new byte[48];\n+                            dis.read(readFileHash);\n+\n+                            if (Utility.hashIsEmpty(expectedPrevFileHash)) {\n+                                log.error(\"Previous file hash not available\");\n+                                expectedPrevFileHash = Hex.encodeHexString(readFileHash);\n+                            }\n+\n+                            String actualPrevFileHash = Hex.encodeHexString(readFileHash);\n+                            log.trace(\"actual file hash = {}, expected file hash = {}\", actualPrevFileHash,\n+                                    expectedPrevFileHash);\n+                            if (!actualPrevFileHash.contentEquals(expectedPrevFileHash)) {\n+                                if (applicationStatusRepository\n+                                        .findByStatusCode(ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER)\n+                                        .compareTo(Utility.getFileName(fileName)) < 0) {\n+                                    // last file for which mismatch is allowed is in the past\n+                                    log.error(\"Hash mismatch for file {}. Actual = {}, Expected = {}\", fileName,\n+                                            expectedPrevFileHash, actualPrevFileHash);\n+                                    rollback();\n+                                    return false;\n                                 }\n-                                break;\n-                            case FileDelimiter.RECORD_TYPE_RECORD:\n-                                counter++;\n-\n-                                int byteLength = dis.readInt();\n-                                byte[] rawBytes = new byte[byteLength];\n-                                dis.readFully(rawBytes);\n-                                Transaction transaction = Transaction.parseFrom(rawBytes);\n-\n-                                byteLength = dis.readInt();\n-                                rawBytes = new byte[byteLength];\n-                                dis.readFully(rawBytes);\n-                                TransactionRecord txRecord = TransactionRecord.parseFrom(rawBytes);\n-\n-                                try {\n-                                    if (log.isTraceEnabled()) {\n-                                        log.trace(\"Transaction = {}, Record = {}\", Utility\n-                                                .printProtoMessage(transaction), Utility.printProtoMessage(txRecord));\n-                                    } else {\n-                                        log.debug(\"Storing transaction with consensus timestamp {}\", () -> Utility\n-                                                .printProtoMessage(txRecord.getConsensusTimestamp()));\n-                                    }\n-\n-                                    RecordFileLogger.storeRecord(transaction, txRecord, rawBytes);\n-                                } finally {\n-                                    // TODO: Refactor to not parse TransactionBody twice\n-                                    DataCase dc = Utility.getTransactionBody(transaction).getDataCase();\n-                                    String type = dc != null && dc != DataCase.DATA_NOT_SET ? dc.name() : \"UNKNOWN\";\n-                                    transactionSizeMetric.tag(\"type\", type)\n-                                            .register(meterRegistry)\n-                                            .record(rawBytes.length);\n-\n-                                    Instant consensusTimestamp = Utility\n-                                            .convertToInstant(txRecord.getConsensusTimestamp());\n-                                    transactionLatencyMetric.tag(\"type\", type)\n-                                            .register(meterRegistry)\n-                                            .record(Duration.between(consensusTimestamp, Instant.now()));\n+                            }\n+                            break;\n+                        case FileDelimiter.RECORD_TYPE_RECORD:\n+                            counter++;\n+\n+                            int byteLength = dis.readInt();\n+                            byte[] rawBytes = new byte[byteLength];\n+                            dis.readFully(rawBytes);\n+                            Transaction transaction = Transaction.parseFrom(rawBytes);\n+\n+                            byteLength = dis.readInt();\n+                            rawBytes = new byte[byteLength];\n+                            dis.readFully(rawBytes);\n+                            TransactionRecord txRecord = TransactionRecord.parseFrom(rawBytes);\n+\n+                            try {\n+                                if (log.isTraceEnabled()) {\n+                                    log.trace(\"Transaction = {}, Record = {}\", Utility\n+                                            .printProtoMessage(transaction), Utility.printProtoMessage(txRecord));\n+                                } else {\n+                                    log.debug(\"Storing transaction with consensus timestamp {}\", () -> Utility\n+                                            .printProtoMessage(txRecord.getConsensusTimestamp()));\n                                 }\n-                                break;\n-                            case FileDelimiter.RECORD_TYPE_SIGNATURE:\n-                                int sigLength = dis.readInt();\n-                                byte[] sigBytes = new byte[sigLength];\n-                                dis.readFully(sigBytes);\n-                                log.trace(\"File {} has signature {}\", fileName, Hex.encodeHexString(sigBytes));\n-                                break;\n-\n-                            default:\n-                                log.error(\"Unknown record file delimiter {} for file {}\", typeDelimiter, fileName);\n-                                rollback();\n-                                return false;\n-                        }\n-                    } catch (Exception e) {\n-                        log.error(\"Exception {}\", e);\n-                        rollback();\n-                        return false;\n+\n+                                RecordFileLogger.storeRecord(transaction, txRecord, rawBytes);\n+                            } finally {\n+                                // TODO: Refactor to not parse TransactionBody twice\n+                                DataCase dc = Utility.getTransactionBody(transaction).getDataCase();\n+                                String type = dc != null && dc != DataCase.DATA_NOT_SET ? dc.name() : \"UNKNOWN\";\n+                                transactionSizeMetric.tag(\"type\", type)\n+                                        .register(meterRegistry)\n+                                        .record(rawBytes.length);\n+\n+                                Instant consensusTimestamp = Utility\n+                                        .convertToInstant(txRecord.getConsensusTimestamp());\n+                                transactionLatencyMetric.tag(\"type\", type)\n+                                        .register(meterRegistry)\n+                                        .record(Duration.between(consensusTimestamp, Instant.now()));\n+                            }\n+                            break;\n+                        case FileDelimiter.RECORD_TYPE_SIGNATURE:\n+                            int sigLength = dis.readInt();\n+                            byte[] sigBytes = new byte[sigLength];\n+                            dis.readFully(sigBytes);\n+                            log.trace(\"File {} has signature {}\", fileName, Hex.encodeHexString(sigBytes));\n+                            break;\n+\n+                        default:\n+                            log.error(\"Unknown record file delimiter {} for file {}\", typeDelimiter, fileName);\n+                            rollback();\n+                            return false;\n                     }\n+                } catch (Exception e) {\n+                    log.error(\"Exception {}\", e);\n+                    rollback();\n+                    return false;\n                 }\n+            }\n \n-                log.trace(\"Calculated file hash for the current file {}\", thisFileHash);\n-                closeFileAndCommit(thisFileHash, expectedPrevFileHash);\n+            log.trace(\"Calculated file hash for the current file {}\", thisFileHash);\n+            closeFileAndCommit(thisFileHash, expectedPrevFileHash);\n \n-                if (!Utility.hashIsEmpty(thisFileHash)) {\n-                    applicationStatusRepository\n-                            .updateStatusValue(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH, thisFileHash);\n-                }\n-                success = true;\n-            } catch (Exception e) {\n-                log.error(\"Error parsing record file {} after {}\", fileName, stopwatch, e);\n-                rollback();\n-            } finally {\n-                log.info(\"Finished parsing {} transactions from record file {} in {}\", counter, fileName, stopwatch);\n-\n-                parseDurationMetric.tag(\"type\", \"record\")\n-                        .tag(\"success\", success.toString())\n-                        .tag(\"version\", recordFileVersion.toString())\n-                        .register(meterRegistry)\n-                        .record(stopwatch.elapsed());\n+            if (!Utility.hashIsEmpty(thisFileHash)) {\n+                applicationStatusRepository\n+                        .updateStatusValue(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH, thisFileHash);\n             }\n-            return success;\n+            success = true;\n+        } catch (Exception e) {\n+            log.error(\"Error parsing record file {} after {}\", fileName, stopwatch, e);\n+            rollback();\n+        } finally {\n+            log.info(\"Finished parsing {} transactions from record file {} in {}\", counter, fileName, stopwatch);\n+\n+            parseDurationMetric.tag(\"type\", \"record\")\n+                    .tag(\"success\", success.toString())\n+                    .tag(\"version\", recordFileVersion.toString())\n+                    .register(meterRegistry)\n+                    .record(stopwatch.elapsed());\n+        }\n+        return success;\n     }\n \n     /**\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA5OTU3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/579#discussion_r387099578", "bodyText": "nit: missing inputStream", "author": "Nana-EC", "createdAt": "2020-03-03T15:31:04Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -120,37 +123,45 @@ public static String readPrevFileHash(String fileName) {\n         return null;\n     }\n \n+    private RecordFileLogger.INIT_RESULT initFile(String filename) {\n+        return RecordFileLogger.initFile(filename);\n+    }\n+\n+    private void closeFileAndCommit(String fileHash, String previousHash) throws SQLException {\n+        RecordFileLogger.completeFile(fileHash, previousHash);\n+    }\n+\n+    private void rollback() {\n+        RecordFileLogger.rollback();\n+    }\n+\n     /**\n      * Given a service record name, read and parse and return as a list of service record pair\n      *\n-     * @param fileName         the name of record file to read\n-     * @param previousFileHash the hash of the previous record file in the series\n-     * @param thisFileHash     the hash of this file\n+     * @param fileName             the name of record file to read\n+     * @param expectedPrevFileHash the hash of the previous record file in the series", "originalCommit": "f1c762c3b2c9c53c921d90cc55b3617c13ea1f7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzIzMzgwMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/579#discussion_r387233803", "bodyText": "done.", "author": "apeksharma", "createdAt": "2020-03-03T19:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA5OTU3OA=="}], "type": "inlineReview", "revised_code": {"commit": "692c537573715dfe5b96cdb02dd0989143645c54", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\nindex db983d6f..c68188e3 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java\n", "chunk": "@@ -139,6 +139,7 @@ public class RecordFileParser implements FileParser {\n      * Given a service record name, read and parse and return as a list of service record pair\n      *\n      * @param fileName             the name of record file to read\n+     * @param inputStream          input stream of bytes in the record file\n      * @param expectedPrevFileHash the hash of the previous record file in the series\n      * @param thisFileHash         the hash of this file\n      * @return return boolean indicating method success\n", "next_change": null}]}}, {"oid": "692c537573715dfe5b96cdb02dd0989143645c54", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/692c537573715dfe5b96cdb02dd0989143645c54", "message": "add @param. realign 'try' block in loadRecordFile\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-03-03T19:11:39Z", "type": "commit"}]}