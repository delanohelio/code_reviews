{"pr_number": 2018, "pr_title": "Recurring Actions XMLRPC API", "pr_author": "parlt91", "pr_createdAt": "2020-03-16T11:08:14Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/2018", "timeline": [{"oid": "995f300b919f3e5067383d9fad41d3760901cc2c", "url": "https://github.com/uyuni-project/uyuni/commit/995f300b919f3e5067383d9fad41d3760901cc2c", "message": "Add recurring action creation\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-16T14:32:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NDQ2Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393074462", "body": "It's a good practice to throw a `FaultException` from the handlers. The `FaultException`s have an `errorCode` attribute, which can make it easier for the API consumers to reason about the error. For some well-known backend exceptions we even have their `Fault` counterparts. In case of listing recurring actions, it'd be good to catch the `PermissionException` and rethrow a `PermissionCheckFailureException` with correctly set `cause`.", "bodyText": "It's a good practice to throw a FaultException from the handlers. The FaultExceptions have an errorCode attribute, which can make it easier for the API consumers to reason about the error. For some well-known backend exceptions we even have their Fault counterparts. In case of listing recurring actions, it'd be good to catch the PermissionException and rethrow a PermissionCheckFailureException with correctly set cause.", "bodyHTML": "<p dir=\"auto\">It's a good practice to throw a <code>FaultException</code> from the handlers. The <code>FaultException</code>s have an <code>errorCode</code> attribute, which can make it easier for the API consumers to reason about the error. For some well-known backend exceptions we even have their <code>Fault</code> counterparts. In case of listing recurring actions, it'd be good to catch the <code>PermissionException</code> and rethrow a <code>PermissionCheckFailureException</code> with correctly set <code>cause</code>.</p>", "author": "hustodemon", "createdAt": "2020-03-16T14:39:16Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/org/OrgHandler.java", "diffHunk": "@@ -868,4 +870,23 @@ public Integer setContentStaging(User loggedInUser, Integer orgId,\n \n         return 1;\n     }\n+\n+    /**\n+     * Return a list of recurring actions for the given organization.\n+     *\n+     * @param loggedInUser The current user\n+     * @param orgId id of the organization\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for the given organization.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param(\"int\", \"orgId\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<OrgRecurringAction> listRecurringActions(User loggedInUser, Integer orgId) {\n+        return RecurringActionManager.listOrgRecurringActions(orgId, loggedInUser);", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3ODQ0Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393078446", "body": "I think that displaying user login would be enough in this case (`action.getCreator().getLogin()`) as there is no need to display the whole user data (`enabled` flag, uppercase version of the login.). Displaying login only would also be consistent with other API endpoints.\r\nPlease change also the `@xmlrpc.doc` tag above.", "bodyText": "I think that displaying user login would be enough in this case (action.getCreator().getLogin()) as there is no need to display the whole user data (enabled flag, uppercase version of the login.). Displaying login only would also be consistent with other API endpoints.\nPlease change also the @xmlrpc.doc tag above.", "bodyHTML": "<p dir=\"auto\">I think that displaying user login would be enough in this case (<code>action.getCreator().getLogin()</code>) as there is no need to display the whole user data (<code>enabled</code> flag, uppercase version of the login.). Displaying login only would also be consistent with other API endpoints.<br>\nPlease change also the <code>@xmlrpc.doc</code> tag above.</p>", "author": "hustodemon", "createdAt": "2020-03-16T14:44:43Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/serializer/RecurringActionSerializer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.serializer;\n+\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.frontend.xmlrpc.serializer.util.SerializerHelper;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import redstone.xmlrpc.XmlRpcException;\n+import redstone.xmlrpc.XmlRpcSerializer;\n+\n+/**\n+ * Serializer for {@link com.redhat.rhn.domain.recurringactions.RecurringAction} class and subclasses\n+ *\n+ * @xmlrpc.doc\n+ * #struct(\"Recurring Action information\")\n+ *   #prop(\"string\", \"name\")\n+ *   #prop(\"int\", \"entityId\")\n+ *   #prop(\"string\", \"type\")\n+ *   #prop(\"string\", \"frequency\")\n+ *   #prop(\"string\", \"created\")\n+ *   #prop(\"UserImpl\", \"creator\")\n+ *   #prop(\"boolean\", \"testMode\")\n+ *   #prop(\"boolean\", \"active\")\n+ * #struct_end()\n+ */\n+public class RecurringActionSerializer extends RhnXmlRpcCustomSerializer {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Class getSupportedClass() {\n+        return RecurringAction.class;\n+    }\n+\n+    @Override\n+    protected void doSerialize(Object obj, Writer writer, XmlRpcSerializer serializer)\n+            throws XmlRpcException, IOException {\n+        RecurringAction action = (RecurringAction) obj;\n+        SerializerHelper helper = new SerializerHelper(serializer);\n+\n+        helper.add(\"name\", action.getName());\n+        helper.add(\"entityId\", action.getEntityId());\n+        helper.add(\"type\", action.getType().toString());\n+        helper.add(\"frequency\", action.getCronExpr());\n+        helper.add(\"created\", action.getCreated());\n+        helper.add(\"creator\", action.getCreator());", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3OTUwMg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393079502", "body": "Same as in the `OrgHandler.listRecurringActions`.", "bodyText": "Same as in the OrgHandler.listRecurringActions.", "bodyHTML": "<p dir=\"auto\">Same as in the <code>OrgHandler.listRecurringActions</code>.</p>", "author": "hustodemon", "createdAt": "2020-03-16T14:46:07Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/system/SystemHandler.java", "diffHunk": "@@ -7066,4 +7068,23 @@ public Long scheduleApplyHighstate(User loggedInUser, Integer sid, Date earliest\n     public TaskomaticApi getTaskomaticApi() {\n         return taskomaticApi;\n     }\n+\n+    /**\n+     * Return a list of recurring actions for a given system.\n+     *\n+     * @param loggedInUser The current user\n+     * @param sid the id of the system\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given system.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param(\"int\", \"server_id)\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<MinionRecurringAction> listRecurringActions(User loggedInUser, Integer sid) {\n+        return RecurringActionManager.listMinionRecurringActions(sid, loggedInUser);", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3OTY3NA==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393079674", "body": "Same as in the `OrgHandler.listRecurringActions`.", "bodyText": "Same as in the OrgHandler.listRecurringActions.", "bodyHTML": "<p dir=\"auto\">Same as in the <code>OrgHandler.listRecurringActions</code>.</p>", "author": "hustodemon", "createdAt": "2020-03-16T14:46:22Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/systemgroup/ServerGroupHandler.java", "diffHunk": "@@ -513,4 +515,23 @@ private ServerGroup lookup(Integer id, User user) {\n             throw new TaskomaticApiException(e.getMessage());\n         }\n     }\n+\n+    /**\n+     * Return a list of recurring actions for a given system group.\n+     *\n+     * @param loggedInUser The current user\n+     * @param systemGroupId the id of the system group\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given system group.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param(\"int\", \"systemGroupId\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<GroupRecurringAction> listRecurringActions(User loggedInUser, Integer systemGroupId) {\n+        return RecurringActionManager.listGroupRecurringActions(systemGroupId, loggedInUser);", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3OTg4Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393079883", "body": "Should be `\"sid\"`.\r\nMoreover, if you want this to be a bit more user friendly, you can:\r\n- either rename `sid` to something more auto-descriptive (`serverId`),\r\n- or provide a description via `param_desc` (instead of the `param`): `#param_desc(\"int\", \"sid\", \"Server ID\")`", "bodyText": "Should be \"sid\".\nMoreover, if you want this to be a bit more user friendly, you can:\n\neither rename sid to something more auto-descriptive (serverId),\nor provide a description via param_desc (instead of the param): #param_desc(\"int\", \"sid\", \"Server ID\")", "bodyHTML": "<p dir=\"auto\">Should be <code>\"sid\"</code>.<br>\nMoreover, if you want this to be a bit more user friendly, you can:</p>\n<ul dir=\"auto\">\n<li>either rename <code>sid</code> to something more auto-descriptive (<code>serverId</code>),</li>\n<li>or provide a description via <code>param_desc</code> (instead of the <code>param</code>): <code>#param_desc(\"int\", \"sid\", \"Server ID\")</code></li>\n</ul>", "author": "hustodemon", "createdAt": "2020-03-16T14:46:39Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/system/SystemHandler.java", "diffHunk": "@@ -7066,4 +7068,23 @@ public Long scheduleApplyHighstate(User loggedInUser, Integer sid, Date earliest\n     public TaskomaticApi getTaskomaticApi() {\n         return taskomaticApi;\n     }\n+\n+    /**\n+     * Return a list of recurring actions for a given system.\n+     *\n+     * @param loggedInUser The current user\n+     * @param sid the id of the system\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given system.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param(\"int\", \"server_id)", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "114e0fe781f85a64e040d787bbd77fe439971cc2", "url": "https://github.com/uyuni-project/uyuni/commit/114e0fe781f85a64e040d787bbd77fe439971cc2", "message": "Add list recurring action by id\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-17T16:12:05Z", "type": "forcePushed"}, {"oid": "b9c72e360b9034172a71e8cde45cc668a34b8c48", "url": "https://github.com/uyuni-project/uyuni/commit/b9c72e360b9034172a71e8cde45cc668a34b8c48", "message": "Support deleting of actions\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-17T17:33:14Z", "type": "forcePushed"}, {"oid": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "url": "https://github.com/uyuni-project/uyuni/commit/4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "message": "Extract save method from create/update\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-18T07:59:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwMDY2Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394200662", "body": "It would be nice to mention the possible values `MINION, GROUP, ORG`. The docs are the only place where the user can see these values.", "bodyText": "It would be nice to mention the possible values MINION, GROUP, ORG. The docs are the only place where the user can see these values.", "bodyHTML": "<p dir=\"auto\">It would be nice to mention the possible values <code>MINION, GROUP, ORG</code>. The docs are the only place where the user can see these values.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:15:30Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwNDgzNw==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394204837", "body": "You can return the result here (and in the `GROUP` and `ORG` case) directly. This way you can get rid of `break`s and the `schedules` variable.", "bodyText": "You can return the result here (and in the GROUP and ORG case) directly. This way you can get rid of breaks and the schedules variable.", "bodyHTML": "<p dir=\"auto\">You can return the result here (and in the <code>GROUP</code> and <code>ORG</code> case) directly. This way you can get rid of <code>break</code>s and the <code>schedules</code> variable.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:22:37Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwNTA5Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394205096", "body": "This looks like a C&P error.", "bodyText": "This looks like a C&P error.", "bodyHTML": "<p dir=\"auto\">This looks like a C&amp;P error.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:23:05Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwODIzNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394208235", "body": "Nitpick: this should be `actionId`.", "bodyText": "Nitpick: this should be actionId.", "bodyHTML": "<p dir=\"auto\">Nitpick: this should be <code>actionId</code>.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:28:14Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMDkwNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394210906", "body": "This looks like improper use of `Optional` (accessing it and checking for `NoSuchElementException`).\r\nInstead of that, something like this could replace the whole method body:\r\n```java\r\nRecurringActionFactory.lookupById(actionId)\r\n    .filter(a -> a.canAccess(loggedInUser))\r\n    .orElseThrow(() -> new EntityNotExistsFaultException(\"Action blabla doesnt exist or is not accessible\"));\r\n\r\n```\r\n", "bodyText": "This looks like improper use of Optional (accessing it and checking for NoSuchElementException).\nInstead of that, something like this could replace the whole method body:\nRecurringActionFactory.lookupById(actionId)\n    .filter(a -> a.canAccess(loggedInUser))\n    .orElseThrow(() -> new EntityNotExistsFaultException(\"Action blabla doesnt exist or is not accessible\"));", "bodyHTML": "<p dir=\"auto\">This looks like improper use of <code>Optional</code> (accessing it and checking for <code>NoSuchElementException</code>).<br>\nInstead of that, something like this could replace the whole method body:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"RecurringActionFactory.lookupById(actionId)\n    .filter(a -&gt; a.canAccess(loggedInUser))\n    .orElseThrow(() -&gt; new EntityNotExistsFaultException(&quot;Action blabla doesnt exist or is not accessible&quot;));\n\"><pre><span class=\"pl-smi\">RecurringActionFactory</span><span class=\"pl-k\">.</span>lookupById(actionId)\n    .filter(a <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> a<span class=\"pl-k\">.</span>canAccess(loggedInUser))\n    .orElseThrow(() <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">EntityNotExistsFaultException</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Action blabla doesnt exist or is not accessible<span class=\"pl-pds\">\"</span></span>));\n</pre></div>", "author": "hustodemon", "createdAt": "2020-03-18T09:32:25Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMjIwMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394212201", "body": "`entity_id` should be passed as `\"int\"`. This'd be better since the serializer returns the entity IDs as numbers (so that data returned from the `list`/`lookup` can be reused for creating/updating actions.).", "bodyText": "entity_id should be passed as \"int\". This'd be better since the serializer returns the entity IDs as numbers (so that data returned from the list/lookup can be reused for creating/updating actions.).", "bodyHTML": "<p dir=\"auto\"><code>entity_id</code> should be passed as <code>\"int\"</code>. This'd be better since the serializer returns the entity IDs as numbers (so that data returned from the <code>list</code>/<code>lookup</code> can be reused for creating/updating actions.).</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:34:36Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMjM4MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394212381", "body": "Please also mention this that this field is optional.", "bodyText": "Please also mention this that this field is optional.", "bodyHTML": "<p dir=\"auto\">Please also mention this that this field is optional.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:34:54Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMjY2NA==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394212664", "body": "The declaration could be moved to the initialization below.", "bodyText": "The declaration could be moved to the initialization below.", "bodyHTML": "<p dir=\"auto\">The declaration could be moved to the initialization below.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:35:25Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMzU5Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394213596", "body": "There is already a method for validating such props maps: `validateMap`. It's even inherited from the `BaseHandler`.\r\nI think it does precisely this, so you could simply write:\r\n```java\r\nvalidateMap(Set.of(\"id\", \"entity_type\", \"entity_id\", ...), actionProps);\r\n```", "bodyText": "There is already a method for validating such props maps: validateMap. It's even inherited from the BaseHandler.\nI think it does precisely this, so you could simply write:\nvalidateMap(Set.of(\"id\", \"entity_type\", \"entity_id\", ...), actionProps);", "bodyHTML": "<p dir=\"auto\">There is already a method for validating such props maps: <code>validateMap</code>. It's even inherited from the <code>BaseHandler</code>.<br>\nI think it does precisely this, so you could simply write:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"validateMap(Set.of(&quot;id&quot;, &quot;entity_type&quot;, &quot;entity_id&quot;, ...), actionProps);\"><pre>validateMap(<span class=\"pl-smi\">Set</span><span class=\"pl-k\">.</span>of(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>id<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>entity_type<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>entity_id<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">...</span>), actionProps);</pre></div>", "author": "hustodemon", "createdAt": "2020-03-18T09:36:58Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI4MDIxMg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394280212", "bodyText": "Right, but this does only check if only valid keys are provided, not if valid keys are actually there. E.g. you could just omit the entity_id in your call and it would not complain.", "author": "parlt91", "createdAt": "2020-03-18T11:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMzU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMjUyNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394312525", "bodyText": "Ah, I see. It works the other way around: validating that the given map doesn't contain an \"invalid\" key.", "author": "hustodemon", "createdAt": "2020-03-18T12:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNDcyNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394214725", "body": "It'd be nice to catch the `EntityNotExistsException` here and translate it to its `Fault` counterpart.", "bodyText": "It'd be nice to catch the EntityNotExistsException here and translate it to its Fault counterpart.", "bodyHTML": "<p dir=\"auto\">It'd be nice to catch the <code>EntityNotExistsException</code> here and translate it to its <code>Fault</code> counterpart.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:38:55Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNTMwMA==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394215300", "body": "If you pass the `entity_id` as `\"int\"` (see above), you can just do something like this `((Integer) actionProps.get(\"entity_id\")).longValue()`.", "bodyText": "If you pass the entity_id as \"int\" (see above), you can just do something like this ((Integer) actionProps.get(\"entity_id\")).longValue().", "bodyHTML": "<p dir=\"auto\">If you pass the <code>entity_id</code> as <code>\"int\"</code> (see above), you can just do something like this <code>((Integer) actionProps.get(\"entity_id\")).longValue()</code>.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:39:59Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNTYyMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394215621", "body": "Similar case as the `entity_id`: this should be `\"int\"`.", "bodyText": "Similar case as the entity_id: this should be \"int\".", "bodyHTML": "<p dir=\"auto\">Similar case as the <code>entity_id</code>: this should be <code>\"int\"</code>.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:40:31Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNjc5Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394216796", "body": "The `action_Id` looks a bit weird. But anyway: neither type, nor name is needed here.\r\n```suggestion\r\n     * @xmlrpc.returntype The id of the recurring action\r\n```", "bodyText": "The action_Id looks a bit weird. But anyway: neither type, nor name is needed here.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @xmlrpc.returntype int action_Id - The action id of the recurring action\n          \n          \n            \n                 * @xmlrpc.returntype The id of the recurring action", "bodyHTML": "<p dir=\"auto\">The <code>action_Id</code> looks a bit weird. But anyway: neither type, nor name is needed here.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@xmlrpc</span><span class=\"pl-k\">.</span>returntype <span class=\"pl-k x x-first\">int</span><span class=\"x\"> action_Id </span><span class=\"pl-k x\">-</span><span class=\"x x-last\"> </span><span class=\"pl-smi\">The</span><span class=\"x x-first x-last\"> action</span> id of the recurring action</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@xmlrpc</span><span class=\"pl-k\">.</span>returntype <span class=\"pl-smi\">The</span> id of the recurring action</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "hustodemon", "createdAt": "2020-03-18T09:42:26Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action (optional)\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action (optional)\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode (optional)\")\n+     *      #prop_desc(\"boolean\", \"active\", \"Whether the action should be active (optional)\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_Id - The action id of the recurring action", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNzIzMg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394217232", "body": "Similar as `entity_id`, this could be typecast as Integer.", "bodyText": "Similar as entity_id, this could be typecast as Integer.", "bodyHTML": "<p dir=\"auto\">Similar as <code>entity_id</code>, this could be typecast as Integer.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:43:09Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action (optional)\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action (optional)\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode (optional)\")\n+     *      #prop_desc(\"boolean\", \"active\", \"Whether the action should be active (optional)\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_Id - The action id of the recurring action\n+     */\n+    public Long update(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = updateAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private  RecurringAction updateAction(Map<String, Object> actionProps, User user) {\n+        if (!actionProps.containsKey(\"id\")) {\n+            throw new InvalidArgsException(\"No action id provided\");\n+        }\n+        Integer id = Integer.parseInt((String) actionProps.get(\"id\"));", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxODA4MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394218081", "body": "I've just checked and it seems that this line is not needed. The XMLRPC backend seems **not** to swallow certain exceptions (the UI does it, apparently), so if we just rethrow the exception on the line below, the transaction will be rolled back automatically :)", "bodyText": "I've just checked and it seems that this line is not needed. The XMLRPC backend seems not to swallow certain exceptions (the UI does it, apparently), so if we just rethrow the exception on the line below, the transaction will be rolled back automatically :)", "bodyHTML": "<p dir=\"auto\">I've just checked and it seems that this line is not needed. The XMLRPC backend seems <strong>not</strong> to swallow certain exceptions (the UI does it, apparently), so if we just rethrow the exception on the line below, the transaction will be rolled back automatically :)</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:44:33Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action (optional)\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action (optional)\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode (optional)\")\n+     *      #prop_desc(\"boolean\", \"active\", \"Whether the action should be active (optional)\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_Id - The action id of the recurring action\n+     */\n+    public Long update(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = updateAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private  RecurringAction updateAction(Map<String, Object> actionProps, User user) {\n+        if (!actionProps.containsKey(\"id\")) {\n+            throw new InvalidArgsException(\"No action id provided\");\n+        }\n+        Integer id = Integer.parseInt((String) actionProps.get(\"id\"));\n+        RecurringAction action = lookupById(user, id);\n+\n+        if (actionProps.containsKey(\"name\")) {\n+            action.setName((String) actionProps.get(\"name\"));\n+        }\n+        if (actionProps.containsKey(\"cron_expr\")) {\n+            action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        }\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        if (actionProps.containsKey(\"active\")) {\n+            action.setActive(Boolean.parseBoolean(actionProps.get(\"active\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /* Helper method */\n+    private Long save(User loggedInUser, RecurringAction action) {\n+        try {\n+            RecurringActionManager.saveAndSchedule(action, loggedInUser);\n+        }\n+        catch (ValidatorException e) {\n+            throw new ValidationException(e.getMessage());\n+        }\n+        catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {\n+            HibernateFactory.rollbackTransaction();", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxODE4NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394218185", "body": "Same as above ^^^.", "bodyText": "Same as above ^^^.", "bodyHTML": "<p dir=\"auto\">Same as above ^^^.</p>", "author": "hustodemon", "createdAt": "2020-03-18T09:44:44Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action (optional)\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action (optional)\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode (optional)\")\n+     *      #prop_desc(\"boolean\", \"active\", \"Whether the action should be active (optional)\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_Id - The action id of the recurring action\n+     */\n+    public Long update(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = updateAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private  RecurringAction updateAction(Map<String, Object> actionProps, User user) {\n+        if (!actionProps.containsKey(\"id\")) {\n+            throw new InvalidArgsException(\"No action id provided\");\n+        }\n+        Integer id = Integer.parseInt((String) actionProps.get(\"id\"));\n+        RecurringAction action = lookupById(user, id);\n+\n+        if (actionProps.containsKey(\"name\")) {\n+            action.setName((String) actionProps.get(\"name\"));\n+        }\n+        if (actionProps.containsKey(\"cron_expr\")) {\n+            action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        }\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        if (actionProps.containsKey(\"active\")) {\n+            action.setActive(Boolean.parseBoolean(actionProps.get(\"active\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /* Helper method */\n+    private Long save(User loggedInUser, RecurringAction action) {\n+        try {\n+            RecurringActionManager.saveAndSchedule(action, loggedInUser);\n+        }\n+        catch (ValidatorException e) {\n+            throw new ValidationException(e.getMessage());\n+        }\n+        catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {\n+            HibernateFactory.rollbackTransaction();\n+            throw new TaskomaticApiException(e.getMessage());\n+        }\n+        return action.getId();\n+    }\n+\n+    /**\n+     * Delete recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return id of deleted action otherwise exception thrown\n+     *\n+     * @xmlrpc.doc Delete recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long delete(User loggedInUser, Integer actionId) {\n+        RecurringAction action = lookupById(loggedInUser, actionId);\n+        try {\n+            RecurringActionManager.deleteAndUnschedule(action, loggedInUser);\n+        }\n+        catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {\n+            HibernateFactory.rollbackTransaction();", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a80860ecd6c852580233c9a46101511319cb544", "url": "https://github.com/uyuni-project/uyuni/commit/7a80860ecd6c852580233c9a46101511319cb544", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-18T12:03:19Z", "type": "forcePushed"}, {"oid": "dff197fd073d2f9ba6312fc398092e2d77d96f17", "url": "https://github.com/uyuni-project/uyuni/commit/dff197fd073d2f9ba6312fc398092e2d77d96f17", "message": "Recurring Actions: Test for XMLRPC handler and Web controller", "committedDate": "2020-03-19T09:42:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxMTA5OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r395011098", "body": "I really like this approach a lot more :+1: ", "bodyText": "I really like this approach a lot more \ud83d\udc4d", "bodyHTML": "<p dir=\"auto\">I really like this approach a lot more <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">\ud83d\udc4d</g-emoji></p>", "author": "parlt91", "createdAt": "2020-03-19T13:08:07Z", "path": "java/code/src/com/suse/manager/webui/controllers/RecurringActionController.java", "diffHunk": "@@ -193,8 +193,8 @@ public static String save(Request request, Response response, User user) {\n         RecurringStateScheduleJson json = GSON.fromJson(request.body(), RecurringStateScheduleJson.class);\n \n         try {\n-            validate(json, user);\n             RecurringAction action = createOrGetAction(user, json);\n+            RecurringActionFactory.getSession().evict(action); // entity -> detached, prevent hibernate flushes", "originalCommit": "01ecc69454c749ccb766958b14374f9654a6f0db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f93373422dda35d746c6973957ccfd9244df13e4", "url": "https://github.com/uyuni-project/uyuni/commit/f93373422dda35d746c6973957ccfd9244df13e4", "message": "Fix checkstyle", "committedDate": "2020-03-20T07:52:11Z", "type": "forcePushed"}, {"oid": "e32bd0e8595ed60fdf10a16e5cc4bb370e1abfb2", "url": "https://github.com/uyuni-project/uyuni/commit/e32bd0e8595ed60fdf10a16e5cc4bb370e1abfb2", "message": "Fix checkstyle", "committedDate": "2020-03-23T10:16:55Z", "type": "forcePushed"}, {"oid": "a95563bf4224512e26129ae139c0fbd72f909601", "url": "https://github.com/uyuni-project/uyuni/commit/a95563bf4224512e26129ae139c0fbd72f909601", "message": "Add changelog\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-23T14:33:36Z", "type": "forcePushed"}, {"oid": "b55438dbd1e7a1a5752958c4f713d55c83d22a2a", "url": "https://github.com/uyuni-project/uyuni/commit/b55438dbd1e7a1a5752958c4f713d55c83d22a2a", "message": "Add changelog\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-23T14:51:37Z", "type": "forcePushed"}, {"oid": "4035ec10ff71837a1ad05c55b826b6a6083cac6d", "url": "https://github.com/uyuni-project/uyuni/commit/4035ec10ff71837a1ad05c55b826b6a6083cac6d", "message": "Add RecurringActionSerializer\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "d807d2f3e1b727c40f90517c1d1d1f7b0a65c3a2", "url": "https://github.com/uyuni-project/uyuni/commit/d807d2f3e1b727c40f90517c1d1d1f7b0a65c3a2", "message": "Add RecurringActionHandler\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "ca7f7e0fc6a1a6e05564fe7a571e53a04b453f6c", "url": "https://github.com/uyuni-project/uyuni/commit/ca7f7e0fc6a1a6e05564fe7a571e53a04b453f6c", "message": "Add listing actions by entity\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "33f308b9b0f4677a25d267bef212243d20556f49", "url": "https://github.com/uyuni-project/uyuni/commit/33f308b9b0f4677a25d267bef212243d20556f49", "message": "Create new action for given entity\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "c4be8d41265be6f1167b543fa5537b3da91fe494", "url": "https://github.com/uyuni-project/uyuni/commit/c4be8d41265be6f1167b543fa5537b3da91fe494", "message": "Updating recurring actions\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "8a4e48d8e8efe01c49f5bc16b935bbbb753e7511", "url": "https://github.com/uyuni-project/uyuni/commit/8a4e48d8e8efe01c49f5bc16b935bbbb753e7511", "message": "Add list recurring action by id\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "f61cf5d8c2e3555ccdbe659eb9d2e3783035b10b", "url": "https://github.com/uyuni-project/uyuni/commit/f61cf5d8c2e3555ccdbe659eb9d2e3783035b10b", "message": "Support deleting of actions\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "be08bd41516e67d9322f362fad5758b9b80d5b80", "url": "https://github.com/uyuni-project/uyuni/commit/be08bd41516e67d9322f362fad5758b9b80d5b80", "message": "Extract save method from create/update\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "86bea541f12f529b84aeae78b9009e14918f705f", "url": "https://github.com/uyuni-project/uyuni/commit/86bea541f12f529b84aeae78b9009e14918f705f", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "b5e3e53529ed70f0811e4e4022dbc6ed27bb9ccc", "url": "https://github.com/uyuni-project/uyuni/commit/b5e3e53529ed70f0811e4e4022dbc6ed27bb9ccc", "message": "Minor fix: check for null when looking up for Org", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "61e74c0ef8565b9e87cd6c0babed2c074a00920a", "url": "https://github.com/uyuni-project/uyuni/commit/61e74c0ef8565b9e87cd6c0babed2c074a00920a", "message": "Recurring Actions XMLRPC: Small improvement in the docs", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "b5e63b1b47d8719395d35745c2dd564ff8bfd381", "url": "https://github.com/uyuni-project/uyuni/commit/b5e63b1b47d8719395d35745c2dd564ff8bfd381", "message": "Recurring Actions: Forbid blank cron expression", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "fab991184f323b7498f9ce2d289c1c09e2ddf22e", "url": "https://github.com/uyuni-project/uyuni/commit/fab991184f323b7498f9ce2d289c1c09e2ddf22e", "message": "Recurring Actions XMLRPC: Return int instead of long as action identifier\n\nPreviously, on out-of-int-range values, the silent overflow happened.\nNow an exception is thrown on backend.", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "8770b0ad09c3a3645290d8ed6b144fa9cf1edc23", "url": "https://github.com/uyuni-project/uyuni/commit/8770b0ad09c3a3645290d8ed6b144fa9cf1edc23", "message": "Recurring Actions: Improve validation mechanism\n\nPreviously on validating updated recurring actions in the web UI, a\ntransient entity was created to check the updated values.\n\nNow the same entity (which is turned to the detached state beforehand)\nis used for the validation. This approach is now uniform for both the\nweb UI and XMLRPC API.", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "5091bbc80e3da91024348ca4c32512403b5d5322", "url": "https://github.com/uyuni-project/uyuni/commit/5091bbc80e3da91024348ca4c32512403b5d5322", "message": "Recurring Actions: Test for XMLRPC handler and Web controller", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "9a6f19749bdf566fb2fd0cc6394c058e82d29fb5", "url": "https://github.com/uyuni-project/uyuni/commit/9a6f19749bdf566fb2fd0cc6394c058e82d29fb5", "message": "Fix checkstyle", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "0fae407a3c62634d7c2866c0581ba7c81ec3e9e0", "url": "https://github.com/uyuni-project/uyuni/commit/0fae407a3c62634d7c2866c0581ba7c81ec3e9e0", "message": "Fix RecurringActionHandler XMLRPC doc", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "3d203eda0eba29234d948ef7e58238f24fd2c569", "url": "https://github.com/uyuni-project/uyuni/commit/3d203eda0eba29234d948ef7e58238f24fd2c569", "message": "Add changelog\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "3d203eda0eba29234d948ef7e58238f24fd2c569", "url": "https://github.com/uyuni-project/uyuni/commit/3d203eda0eba29234d948ef7e58238f24fd2c569", "message": "Add changelog\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "forcePushed"}]}