{"pr_number": 3097, "pr_title": "Fix double network failure handling", "pr_author": "surabujin", "pr_createdAt": "2020-01-08T17:24:07Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3097", "merge_commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "timeline": [{"oid": "237e1f090231481b2aa3fae832556654109d843f", "url": "https://github.com/telstra/open-kilda/commit/237e1f090231481b2aa3fae832556654109d843f", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T09:09:20Z", "type": "forcePushed"}, {"oid": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "url": "https://github.com/telstra/open-kilda/commit/d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T11:42:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5ODQwMg==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364698402", "body": "nit: wouldn't call it queue since you refactored that", "bodyText": "nit: wouldn't call it queue since you refactored that", "bodyHTML": "<p dir=\"auto\">nit: wouldn't call it queue since you refactored that</p>", "author": "timofei-durakov", "createdAt": "2020-01-09T11:50:53Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\nindex 3b2cfdbdb..8fb14df93 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n", "chunk": "@@ -15,12 +15,10 @@\n \n package org.openkilda.wfm.topology.flowhs.utils;\n \n-import org.openkilda.model.PathId;\n import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n \n-import java.util.HashSet;\n+import java.util.Collections;\n import java.util.Optional;\n-import java.util.Set;\n \n public class RerouteRetryQueue {\n     private FlowRerouteFact active = null;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\nindex 3b2cfdbdb..8fb14df93 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n", "chunk": "@@ -15,12 +15,10 @@\n \n package org.openkilda.wfm.topology.flowhs.utils;\n \n-import org.openkilda.model.PathId;\n import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n \n-import java.util.HashSet;\n+import java.util.Collections;\n import java.util.Optional;\n-import java.util.Set;\n \n public class RerouteRetryQueue {\n     private FlowRerouteFact active = null;\n", "next_change": {"commit": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\nindex 8fb14df93..26e12a965 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n", "chunk": "@@ -15,10 +15,12 @@\n \n package org.openkilda.wfm.topology.flowhs.utils;\n \n+import org.openkilda.model.IslEndpoint;\n import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n \n-import java.util.Collections;\n+import java.util.HashSet;\n import java.util.Optional;\n+import java.util.Set;\n \n public class RerouteRetryQueue {\n     private FlowRerouteFact active = null;\n", "next_change": {"commit": "f4698f82e37ba84b64ee028e4e0244d4eefee030", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\nindex 26e12a965..7c7f9beb5 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n", "chunk": "@@ -18,6 +18,7 @@ package org.openkilda.wfm.topology.flowhs.utils;\n import org.openkilda.model.IslEndpoint;\n import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n \n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.Optional;\n import java.util.Set;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "f4698f82e37ba84b64ee028e4e0244d4eefee030", "committedDate": "2020-01-29 12:28:25 +0200", "message": "Reroute affected flows on switch up event"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5OTc5MQ==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364699791", "body": "nit: why not to throw exception here? ", "bodyText": "nit: why not to throw exception here?", "bodyHTML": "<p dir=\"auto\">nit: why not to throw exception here?</p>", "author": "timofei-durakov", "createdAt": "2020-01-09T11:54:28Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;\n+    }\n+\n+    /**\n+     * Locate and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> peek(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n", "chunk": "@@ -40,9 +40,9 @@ public class RerouteRetryManager {\n     }\n \n     /**\n-     * Locate and return fist entry in queue.\n+     * Return \"active\" request.\n      */\n-    public Optional<FlowRerouteFact> peek(String flowId) {\n+    public Optional<FlowRerouteFact> read(String flowId) {\n         RerouteRetryQueue queue = queueByFlowId.get(flowId);\n         if (queue == null) {\n             return Optional.empty();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n", "chunk": "@@ -40,9 +40,9 @@ public class RerouteRetryManager {\n     }\n \n     /**\n-     * Locate and return fist entry in queue.\n+     * Return \"active\" request.\n      */\n-    public Optional<FlowRerouteFact> peek(String flowId) {\n+    public Optional<FlowRerouteFact> read(String flowId) {\n         RerouteRetryQueue queue = queueByFlowId.get(flowId);\n         if (queue == null) {\n             return Optional.empty();\n", "next_change": null}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMDI4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364700283", "body": "same", "bodyText": "same", "bodyHTML": "<p dir=\"auto\">same</p>", "author": "timofei-durakov", "createdAt": "2020-01-09T11:55:36Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;\n+    }\n+\n+    /**\n+     * Locate and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> peek(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();\n+        }\n+\n+        // use method raises exception on empty queue access, because queue can't be empty by used design\n+        return queue.get();\n+    }\n+\n+    /**\n+     * Locate, remove and return fist entry in queue.\n+     */\n+    public Optional<FlowRerouteFact> remove(String flowId) {\n+        RerouteRetryQueue queue = queueByFlowId.get(flowId);\n+        if (queue == null) {\n+            return Optional.empty();", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n", "chunk": "@@ -53,9 +53,9 @@ public class RerouteRetryManager {\n     }\n \n     /**\n-     * Locate, remove and return fist entry in queue.\n+     * Remove \"active\" request.\n      */\n-    public Optional<FlowRerouteFact> remove(String flowId) {\n+    public Optional<FlowRerouteFact> discard(String flowId) {\n         RerouteRetryQueue queue = queueByFlowId.get(flowId);\n         if (queue == null) {\n             return Optional.empty();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n", "chunk": "@@ -53,9 +53,9 @@ public class RerouteRetryManager {\n     }\n \n     /**\n-     * Locate, remove and return fist entry in queue.\n+     * Remove \"active\" request.\n      */\n-    public Optional<FlowRerouteFact> remove(String flowId) {\n+    public Optional<FlowRerouteFact> discard(String flowId) {\n         RerouteRetryQueue queue = queueByFlowId.get(flowId);\n         if (queue == null) {\n             return Optional.empty();\n", "next_change": null}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMTI4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364701286", "body": "let's rename it to `handlePostponedRequest`?", "bodyText": "let's rename it to handlePostponedRequest?", "bodyHTML": "<p dir=\"auto\">let's rename it to <code>handlePostponedRequest</code>?</p>", "author": "timofei-durakov", "createdAt": "2020-01-09T11:58:12Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -69,6 +73,16 @@ public FlowRerouteService(FlowRerouteHubCarrier carrier, PersistenceManager pers\n                 speakerCommandRetriesLimit);\n     }\n \n+    /**\n+     * Handle postponed reroute request.\n+     */\n+    public void handleRequest(FlowRerouteFact reroute) {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea3030ad2005623b88080eea0083e72050543e0c", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..36bafbd38 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -73,16 +73,6 @@ public class FlowRerouteService {\n                 speakerCommandRetriesLimit);\n     }\n \n-    /**\n-     * Handle postponed reroute request.\n-     */\n-    public void handleRequest(FlowRerouteFact reroute) {\n-        log.info(\"Handling postponed flow reroute request with key {} and flow ID: {}\",\n-                 reroute.getKey(), reroute.getFlowId());\n-        carrier.setupTimeoutCallback(reroute.getKey());\n-        initReroute(reroute);\n-    }\n-\n     /**\n      * Handles request for flow reroute.\n      *\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..87a22e568 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -73,16 +73,6 @@ public class FlowRerouteService {\n                 speakerCommandRetriesLimit);\n     }\n \n-    /**\n-     * Handle postponed reroute request.\n-     */\n-    public void handleRequest(FlowRerouteFact reroute) {\n-        log.info(\"Handling postponed flow reroute request with key {} and flow ID: {}\",\n-                 reroute.getKey(), reroute.getFlowId());\n-        carrier.setupTimeoutCallback(reroute.getKey());\n-        initReroute(reroute);\n-    }\n-\n     /**\n      * Handles request for flow reroute.\n      *\n", "next_change": {"commit": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 87a22e568..7cdf52c4a 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -75,30 +81,18 @@ public class FlowRerouteService {\n \n     /**\n      * Handles request for flow reroute.\n-     *\n-     * @param key command identifier.\n-     * @param flowId the flow to reroute.\n-     * @param pathsToReroute the flow paths to reroute.\n-     * @param forceReroute indicates that reroute must re-install paths even if they're the same.\n-     * @param rerouteReason the reroute for auto-initiated reroute\n      */\n-    public void handleRequest(String key, CommandContext commandContext, String flowId, Set<PathId> pathsToReroute,\n-                              boolean forceReroute, String rerouteReason) {\n+    public void handleRequest(FlowRerouteFact reroute) {\n+        final String key = reroute.getKey();\n+        final String flowId = reroute.getFlowId();\n         log.debug(\"Handling flow reroute request with key {} and flow ID: {}\", key, flowId);\n \n-        if (fsms.containsKey(key)) {\n-            log.error(\"Attempt to create a FSM with key {}, while there's another active FSM with the same key.\", key);\n-            return;\n-        }\n-\n-        FlowRerouteFact reroute = new FlowRerouteFact(\n-                key, commandContext, flowId, pathsToReroute, forceReroute, rerouteReason);\n         if (retryManager.record(reroute)) {\n             initReroute(reroute);\n         } else {\n             carrier.cancelTimeoutCallback(key);\n             log.warn(\"Postpone (queue/merge) reroute request for flow {} (key={}, reasod={})\",\n-                     flowId, key, rerouteReason);\n+                     flowId, key, reroute.getRerouteReason());\n         }\n     }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "d6915420578ea640bb69114cab4db697e44bf276", "committedDate": "2020-02-03 14:31:00 +0200", "message": "Add reroute retries when transit rules can't be installed or verified"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMjQ1Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364702453", "body": "this is a very strange return result for a method call, tbh I'd implement size here istead", "bodyText": "this is a very strange return result for a method call, tbh I'd implement size here istead", "bodyHTML": "<p dir=\"auto\">this is a very strange return result for a method call, tbh I'd implement size here istead</p>", "author": "timofei-durakov", "createdAt": "2020-01-09T12:01:28Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Slf4j\n+public class RerouteRetryManager {\n+    private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n+\n+    /**\n+     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n+     * postponed).\n+     */\n+    public boolean push(FlowRerouteFact entity) {\n+        RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n+                entity.getFlowId(), ignore -> new RerouteRetryQueue());\n+        queue.add(entity);\n+        log.info(\"Size of flow reroute queue for {} is {}\", entity.getFlowId(), queue.size());\n+        return queue.size() == 1;", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMjQ4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364712489", "bodyText": "+1", "author": "niksv", "createdAt": "2020-01-09T12:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwMjQ1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n", "chunk": "@@ -28,10 +28,10 @@ public class RerouteRetryManager {\n     private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n \n     /**\n-     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n-     * postponed).\n+     * Register request in retry \"queue\" and check is it can be processed now. Return true if this request can be\n+     * processed now.\n      */\n-    public boolean push(FlowRerouteFact entity) {\n+    public boolean record(FlowRerouteFact entity) {\n         RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n                 entity.getFlowId(), ignore -> new RerouteRetryQueue());\n         queue.add(entity);\n", "next_change": null}, {"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n", "chunk": "@@ -40,9 +40,9 @@ public class RerouteRetryManager {\n     }\n \n     /**\n-     * Locate and return fist entry in queue.\n+     * Return \"active\" request.\n      */\n-    public Optional<FlowRerouteFact> peek(String flowId) {\n+    public Optional<FlowRerouteFact> read(String flowId) {\n         RerouteRetryQueue queue = queueByFlowId.get(flowId);\n         if (queue == null) {\n             return Optional.empty();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n", "chunk": "@@ -28,10 +28,10 @@ public class RerouteRetryManager {\n     private final Map<String, RerouteRetryQueue> queueByFlowId = new HashMap<>();\n \n     /**\n-     * Save entry into retry queue. Return true if it is only entry for this flowId (i.e. operation should not be\n-     * postponed).\n+     * Register request in retry \"queue\" and check is it can be processed now. Return true if this request can be\n+     * processed now.\n      */\n-    public boolean push(FlowRerouteFact entity) {\n+    public boolean record(FlowRerouteFact entity) {\n         RerouteRetryQueue queue = queueByFlowId.computeIfAbsent(\n                 entity.getFlowId(), ignore -> new RerouteRetryQueue());\n         queue.add(entity);\n", "next_change": null}, {"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\nindex 248477f6c..1b8323374 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryManager.java\n", "chunk": "@@ -40,9 +40,9 @@ public class RerouteRetryManager {\n     }\n \n     /**\n-     * Locate and return fist entry in queue.\n+     * Return \"active\" request.\n      */\n-    public Optional<FlowRerouteFact> peek(String flowId) {\n+    public Optional<FlowRerouteFact> read(String flowId) {\n         RerouteRetryQueue queue = queueByFlowId.get(flowId);\n         if (queue == null) {\n             return Optional.empty();\n", "next_change": null}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwNjY2MA==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364706660", "body": "check queue size rather than push return value that is tight to 1 size", "bodyText": "check queue size rather than push return value that is tight to 1 size", "bodyHTML": "<p dir=\"auto\">check queue size rather than push return value that is tight to 1 size</p>", "author": "timofei-durakov", "createdAt": "2020-01-09T12:12:53Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -87,24 +101,15 @@ public void handleRequest(String key, CommandContext commandContext, String flow\n             return;\n         }\n \n-        String eventKey = commandContext.getCorrelationId();\n-        if (flowEventRepository.existsByTaskId(eventKey)) {\n-            log.error(\"Attempt to reuse key {}, but there's a history record(s) for it.\", eventKey);\n-            return;\n+        FlowRerouteFact reroute = new FlowRerouteFact(\n+                key, commandContext, flowId, pathsToReroute, forceReroute, rerouteReason);\n+        if (retryQueue.push(reroute)) {", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..87a22e568 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -103,7 +93,7 @@ public class FlowRerouteService {\n \n         FlowRerouteFact reroute = new FlowRerouteFact(\n                 key, commandContext, flowId, pathsToReroute, forceReroute, rerouteReason);\n-        if (retryQueue.push(reroute)) {\n+        if (retryManager.record(reroute)) {\n             initReroute(reroute);\n         } else {\n             carrier.cancelTimeoutCallback(key);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..87a22e568 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -103,7 +93,7 @@ public class FlowRerouteService {\n \n         FlowRerouteFact reroute = new FlowRerouteFact(\n                 key, commandContext, flowId, pathsToReroute, forceReroute, rerouteReason);\n-        if (retryQueue.push(reroute)) {\n+        if (retryManager.record(reroute)) {\n             initReroute(reroute);\n         } else {\n             carrier.cancelTimeoutCallback(key);\n", "next_change": {"commit": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 87a22e568..7cdf52c4a 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -75,30 +81,18 @@ public class FlowRerouteService {\n \n     /**\n      * Handles request for flow reroute.\n-     *\n-     * @param key command identifier.\n-     * @param flowId the flow to reroute.\n-     * @param pathsToReroute the flow paths to reroute.\n-     * @param forceReroute indicates that reroute must re-install paths even if they're the same.\n-     * @param rerouteReason the reroute for auto-initiated reroute\n      */\n-    public void handleRequest(String key, CommandContext commandContext, String flowId, Set<PathId> pathsToReroute,\n-                              boolean forceReroute, String rerouteReason) {\n+    public void handleRequest(FlowRerouteFact reroute) {\n+        final String key = reroute.getKey();\n+        final String flowId = reroute.getFlowId();\n         log.debug(\"Handling flow reroute request with key {} and flow ID: {}\", key, flowId);\n \n-        if (fsms.containsKey(key)) {\n-            log.error(\"Attempt to create a FSM with key {}, while there's another active FSM with the same key.\", key);\n-            return;\n-        }\n-\n-        FlowRerouteFact reroute = new FlowRerouteFact(\n-                key, commandContext, flowId, pathsToReroute, forceReroute, rerouteReason);\n         if (retryManager.record(reroute)) {\n             initReroute(reroute);\n         } else {\n             carrier.cancelTimeoutCallback(key);\n             log.warn(\"Postpone (queue/merge) reroute request for flow {} (key={}, reasod={})\",\n-                     flowId, key, rerouteReason);\n+                     flowId, key, reroute.getRerouteReason());\n         }\n     }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "d6915420578ea640bb69114cab4db697e44bf276", "committedDate": "2020-02-03 14:31:00 +0200", "message": "Add reroute retries when transit rules can't be installed or verified"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcwODI0Mw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364708243", "body": "will this exception be raised each time there are no pending reroutes in a queue?", "bodyText": "will this exception be raised each time there are no pending reroutes in a queue?", "bodyHTML": "<p dir=\"auto\">will this exception be raised each time there are no pending reroutes in a queue?</p>", "author": "timofei-durakov", "createdAt": "2020-01-09T12:16:36Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java", "diffHunk": "@@ -151,12 +156,54 @@ public void handleTimeout(String key) {\n         removeIfFinished(fsm, key);\n     }\n \n+    private void initReroute(FlowRerouteFact reroute) {\n+        final CommandContext commandContext = reroute.getCommandContext();\n+\n+        String eventKey = commandContext.getCorrelationId();\n+        if (flowEventRepository.existsByTaskId(eventKey)) {\n+            log.error(\"Attempt to reuse key {}, but there's a history record(s) for it.\", eventKey);\n+            return;\n+        }\n+\n+        final String flowId =  reroute.getFlowId();\n+        final String key = reroute.getKey();\n+        FlowRerouteFsm fsm = fsmFactory.newInstance(commandContext, flowId);\n+        fsms.put(key, fsm);\n+\n+        FlowRerouteContext context = FlowRerouteContext.builder()\n+                .flowId(flowId)\n+                .pathsToReroute(reroute.getPathsToReroute())\n+                .forceReroute(reroute.isForceReroute())\n+                .rerouteReason(reroute.getRerouteReason())\n+                .build();\n+        fsmExecutor.fire(fsm, Event.NEXT, context);\n+\n+        removeIfFinished(fsm, key);\n+    }\n+\n     private void removeIfFinished(FlowRerouteFsm fsm, String key) {\n         if (fsm.isTerminated()) {\n-            log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n-            fsms.remove(key);\n+            performHousekeeping(fsm, key);\n \n-            carrier.cancelTimeoutCallback(key);\n+            // use some sort of recursion here, because iterative way require too complex scheme to clean/use retryQueue\n+            retryQueue.peek(fsm.getFlowId()).ifPresent(carrier::injectRetry);\n+        }\n+    }\n+\n+    private void performHousekeeping(FlowRerouteFsm fsm, String key) {\n+        log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n+        fsms.remove(key);\n+\n+        carrier.cancelTimeoutCallback(key);\n+\n+        FlowRerouteFact reroute = retryQueue.remove(fsm.getFlowId())\n+                .orElseThrow(() -> new IllegalStateException(String.format(", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "324470bfb8bc878d94826c4b5b872985e5231092", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..87a22e568 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -196,7 +196,7 @@ public class FlowRerouteService {\n \n         carrier.cancelTimeoutCallback(key);\n \n-        FlowRerouteFact reroute = retryQueue.remove(fsm.getFlowId())\n+        FlowRerouteFact reroute = retryManager.discard(fsm.getFlowId())\n                 .orElseThrow(() -> new IllegalStateException(String.format(\n                         \"There is no current reroute into retry queue (flow=\\\"%s\\\", key=\\\"%s\\\")\",\n                         fsm.getFlowId(), key)));\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 023749449..87a22e568 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -196,7 +196,7 @@ public class FlowRerouteService {\n \n         carrier.cancelTimeoutCallback(key);\n \n-        FlowRerouteFact reroute = retryQueue.remove(fsm.getFlowId())\n+        FlowRerouteFact reroute = retryManager.discard(fsm.getFlowId())\n                 .orElseThrow(() -> new IllegalStateException(String.format(\n                         \"There is no current reroute into retry queue (flow=\\\"%s\\\", key=\\\"%s\\\")\",\n                         fsm.getFlowId(), key)));\n", "next_change": {"commit": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\nindex 87a22e568..7cdf52c4a 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteService.java\n", "chunk": "@@ -181,29 +179,49 @@ public class FlowRerouteService {\n         removeIfFinished(fsm, key);\n     }\n \n+    private void checkRequestsCollision(FlowRerouteFact reroute) {\n+        if (fsms.containsKey(reroute.getKey())) {\n+            throw new IllegalStateException(String.format(\n+                    \"Attempt to create a FSM with key %s, while there's another active FSM with the same key \"\n+                            + \"(flowId=\\\"%s\\\")\", reroute.getKey(), reroute.getFlowId()));\n+        }\n+\n+        String eventKey = reroute.getCommandContext().getCorrelationId();\n+        if (flowEventRepository.existsByTaskId(eventKey)) {\n+            throw new IllegalStateException(String.format(\n+                    \"Attempt to reuse history key %s, but there's a history record(s) for it (flowId=\\\"%s\\\")\",\n+                    eventKey, reroute.getFlowId()));\n+        }\n+    }\n+\n     private void removeIfFinished(FlowRerouteFsm fsm, String key) {\n         if (fsm.isTerminated()) {\n-            performHousekeeping(fsm, key);\n+            log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n+            performHousekeeping(fsm.getFlowId(), key);\n \n             // use some sort of recursion here, because iterative way require too complex scheme to clean/use retryQueue\n             retryManager.read(fsm.getFlowId()).ifPresent(carrier::injectRetry);\n         }\n     }\n \n-    private void performHousekeeping(FlowRerouteFsm fsm, String key) {\n-        log.debug(\"FSM with key {} is finished with state {}\", key, fsm.getCurrentState());\n+    private void performHousekeeping(String flowId, String key) {\n         fsms.remove(key);\n-\n         carrier.cancelTimeoutCallback(key);\n \n-        FlowRerouteFact reroute = retryManager.discard(fsm.getFlowId())\n+        FlowRerouteFact reroute = retryManager.discard(flowId)\n                 .orElseThrow(() -> new IllegalStateException(String.format(\n                         \"There is no current reroute into retry queue (flow=\\\"%s\\\", key=\\\"%s\\\")\",\n-                        fsm.getFlowId(), key)));\n+                        flowId, key)));\n         if (! reroute.getKey().equals(key)) {\n             log.error(\n                     \"Retry queue is broken, expect to remove record with key \\\"{}\\\" but got record with key=\\\"{}\\\" \"\n-                    + \"(flowId=\\\"{}\\\")\", key, reroute.getKey(), fsm.getFlowId());\n+                    + \"(flowId=\\\"{}\\\")\", key, reroute.getKey(), flowId);\n+        }\n+    }\n+\n+    private void fixFlowStatus(FlowRerouteFact reroute) {\n+        if (reroute.isEffectivelyDown()) {\n+            flowRepository.updateStatusSafe(reroute.getFlowId(), FlowStatus.DOWN);\n         }\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "d6915420578ea640bb69114cab4db697e44bf276", "committedDate": "2020-02-03 14:31:00 +0200", "message": "Add reroute retries when transit rules can't be installed or verified"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMTY0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364711646", "body": "As far as I can see state with `active == null and pending != null` is inconsistent for this structure. Maybe we should return only active Fact here for consistency with remove method?", "bodyText": "As far as I can see state with active == null and pending != null is inconsistent for this structure. Maybe we should return only active Fact here for consistency with remove method?", "bodyHTML": "<p dir=\"auto\">As far as I can see state with <code>active == null and pending != null</code> is inconsistent for this structure. Maybe we should return only active Fact here for consistency with remove method?</p>", "author": "rozdy", "createdAt": "2020-01-09T12:25:15Z", "path": "services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class RerouteRetryQueue {\n+    private FlowRerouteFact active = null;\n+    private FlowRerouteFact pending = null;\n+\n+    /**\n+     * Add request into \"queue\".\n+     */\n+    public void add(FlowRerouteFact reroute) {\n+        if (active == null) {\n+            active = reroute;\n+        } else if (pending == null) {\n+            pending = reroute;\n+        } else {\n+            pending = mergePending(pending, reroute);\n+        }\n+    }\n+\n+    /**\n+     * Return first/active queue entry.\n+     */\n+    public Optional<FlowRerouteFact> get() {\n+        FlowRerouteFact result = active;\n+        if (result == null) {\n+            result = pending;\n+        }", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNjg1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364716852", "bodyText": "or throw exception if active == null and pending != null", "author": "niksv", "createdAt": "2020-01-09T12:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxMTY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ea3030ad2005623b88080eea0083e72050543e0c", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\nindex 3b2cfdbdb..75a841c07 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n", "chunk": "@@ -43,11 +43,7 @@ public class RerouteRetryQueue {\n      * Return first/active queue entry.\n      */\n     public Optional<FlowRerouteFact> get() {\n-        FlowRerouteFact result = active;\n-        if (result == null) {\n-            result = pending;\n-        }\n-        return Optional.ofNullable(result);\n+        return Optional.ofNullable(active);\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\nindex 3b2cfdbdb..8fb14df93 100644\n--- a/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n+++ b/services/wfm/src/main/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueue.java\n", "chunk": "@@ -43,11 +41,7 @@ public class RerouteRetryQueue {\n      * Return first/active queue entry.\n      */\n     public Optional<FlowRerouteFact> get() {\n-        FlowRerouteFact result = active;\n-        if (result == null) {\n-            result = pending;\n-        }\n-        return Optional.ofNullable(result);\n+        return Optional.ofNullable(active);\n     }\n \n     /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "f4698f82e37ba84b64ee028e4e0244d4eefee030", "committedDate": "2020-01-29 12:28:25 +0200", "message": "Reroute affected flows on switch up event"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDcxNTcwNw==", "url": "https://github.com/telstra/open-kilda/pull/3097#discussion_r364715707", "body": "all 4 rerouteFact objects has same reason \"reason 1\". So check if we set right reason you need to have different reasons", "bodyText": "all 4 rerouteFact objects has same reason \"reason 1\". So check if we set right reason you need to have different reasons", "bodyHTML": "<p dir=\"auto\">all 4 rerouteFact objects has same reason \"reason 1\". So check if we set right reason you need to have different reasons</p>", "author": "niksv", "createdAt": "2020-01-09T12:36:07Z", "path": "services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.flowhs.utils;\n+\n+import org.openkilda.model.PathId;\n+import org.openkilda.wfm.CommandContext;\n+import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class RerouteRetryQueueTest {\n+    private final CommandContext context = new CommandContext();\n+    private final String flowId = \"flowA\";\n+    private final FlowRerouteFact rerouteEmpty = new FlowRerouteFact(\n+            \"empty\", context, flowId, null, false, \"reason 1\");\n+    private final FlowRerouteFact reroutePathA = new FlowRerouteFact(\n+            \"pathA\", context, flowId, Collections.singleton(new PathId(\"flowA-pathA\")), false, \"reason 1\");\n+    private final FlowRerouteFact reroutePathB = new FlowRerouteFact(\n+            \"pathB\", context, flowId, Collections.singleton(new PathId(\"flowA-pathB\")), false, \"reason 1\");\n+    private final FlowRerouteFact rerouteForced = new FlowRerouteFact(\n+            \"forced\", context, flowId, null, true, \"reason 1\");\n+\n+    @Test\n+    public void addAndSizeOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+\n+        Assert.assertEquals(0, queue.size());\n+        Assert.assertTrue(queue.isEmpty());\n+\n+        queue.add(rerouteEmpty);\n+        Assert.assertEquals(1, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+\n+        queue.add(reroutePathA);\n+        Assert.assertEquals(2, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+\n+        queue.add(reroutePathB);\n+        Assert.assertEquals(2, queue.size());\n+        Assert.assertFalse(queue.isEmpty());\n+    }\n+\n+    @Test\n+    public void removeAndSizeOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+\n+        // empty\n+        Assert.assertFalse(queue.remove().isPresent());\n+\n+        Optional<FlowRerouteFact> reroute;\n+\n+        // one entry\n+        queue.add(rerouteEmpty);\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        // two entry\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertEquals(1, queue.size());\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(reroutePathA, reroute.get());\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        Assert.assertFalse(queue.remove().isPresent());\n+\n+        // more than 2 entry\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(reroutePathB);\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+        Assert.assertEquals(1, queue.size());\n+\n+        reroute = queue.remove();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertNotEquals(reroutePathA, reroute.get());  // merged entry\n+        Assert.assertNotEquals(reroutePathB, reroute.get());  // merged entry\n+        Assert.assertFalse(queue.remove().isPresent());\n+        Assert.assertEquals(0, queue.size());\n+\n+        Assert.assertFalse(queue.remove().isPresent());\n+    }\n+\n+    @Test\n+    public void getOperations() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        Assert.assertFalse(queue.get().isPresent());\n+\n+        Optional<FlowRerouteFact> reroute;\n+        queue.add(rerouteEmpty);\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+\n+        queue.add(reroutePathA);\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(rerouteEmpty, reroute.get());\n+\n+        queue.remove();\n+        reroute = queue.get();\n+        Assert.assertTrue(reroute.isPresent());\n+        Assert.assertSame(reroutePathA, reroute.get());\n+    }\n+\n+    @Test\n+    public void mergeOperation() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(rerouteForced);\n+        queue.add(reroutePathB);\n+\n+        Optional<FlowRerouteFact> potential;\n+        queue.remove();\n+        potential = queue.get();\n+        Assert.assertTrue(potential.isPresent());\n+\n+        FlowRerouteFact reroute = potential.get();\n+        Assert.assertEquals(reroutePathB.getKey(), reroute.getKey());\n+        Assert.assertSame(reroutePathB.getCommandContext(), reroute.getCommandContext());\n+        Assert.assertEquals(reroutePathB.getFlowId(), reroute.getFlowId());\n+\n+        Set<PathId> expectedPaths = Stream.of(rerouteEmpty, reroutePathA, rerouteForced, reroutePathB)\n+                .map(FlowRerouteFact::getPathsToReroute)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .collect(Collectors.toSet());\n+        Assert.assertEquals(expectedPaths, reroute.getPathsToReroute());\n+        Assert.assertTrue(reroute.isForceReroute());\n+        Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());", "originalCommit": "d9e1fc356d9a198f8522db1b57fdf2c80cfbd067", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "changed_code": [{"header": "diff --git a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\nindex 55082e7e1..52d061cd1 100644\n--- a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n+++ b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n", "chunk": "@@ -155,11 +151,7 @@ public class RerouteRetryQueueTest {\n         Assert.assertSame(reroutePathB.getCommandContext(), reroute.getCommandContext());\n         Assert.assertEquals(reroutePathB.getFlowId(), reroute.getFlowId());\n \n-        Set<PathId> expectedPaths = Stream.of(rerouteEmpty, reroutePathA, rerouteForced, reroutePathB)\n-                .map(FlowRerouteFact::getPathsToReroute)\n-                .filter(Objects::nonNull)\n-                .flatMap(Collection::stream)\n-                .collect(Collectors.toSet());\n+        Set<PathId> expectedPaths = Collections.emptySet();\n         Assert.assertEquals(expectedPaths, reroute.getPathsToReroute());\n         Assert.assertTrue(reroute.isForceReroute());\n         Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());\n", "next_change": null}]}, "revised_code_in_main": {"commit": "7869516fa157befef6d4941ced5b3883e0bfd430", "changed_code": [{"header": "diff --git a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\nindex 55082e7e1..52d061cd1 100644\n--- a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n+++ b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n", "chunk": "@@ -155,11 +151,7 @@ public class RerouteRetryQueueTest {\n         Assert.assertSame(reroutePathB.getCommandContext(), reroute.getCommandContext());\n         Assert.assertEquals(reroutePathB.getFlowId(), reroute.getFlowId());\n \n-        Set<PathId> expectedPaths = Stream.of(rerouteEmpty, reroutePathA, rerouteForced, reroutePathB)\n-                .map(FlowRerouteFact::getPathsToReroute)\n-                .filter(Objects::nonNull)\n-                .flatMap(Collection::stream)\n-                .collect(Collectors.toSet());\n+        Set<PathId> expectedPaths = Collections.emptySet();\n         Assert.assertEquals(expectedPaths, reroute.getPathsToReroute());\n         Assert.assertTrue(reroute.isForceReroute());\n         Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());\n", "next_change": {"commit": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "changed_code": [{"header": "diff --git a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\nindex 52d061cd1..7542e7ec3 100644\n--- a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n+++ b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n", "chunk": "@@ -151,8 +155,11 @@ public class RerouteRetryQueueTest {\n         Assert.assertSame(reroutePathB.getCommandContext(), reroute.getCommandContext());\n         Assert.assertEquals(reroutePathB.getFlowId(), reroute.getFlowId());\n \n-        Set<PathId> expectedPaths = Collections.emptySet();\n-        Assert.assertEquals(expectedPaths, reroute.getPathsToReroute());\n+        Set<IslEndpoint> expectedIslEndpoints = new HashSet<>();\n+        expectedIslEndpoints.addAll(reroutePathA.getAffectedIsl());\n+        expectedIslEndpoints.addAll(reroutePathB.getAffectedIsl());\n+\n+        Assert.assertEquals(expectedIslEndpoints, reroute.getAffectedIsl());\n         Assert.assertTrue(reroute.isForceReroute());\n         Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());\n     }\n", "next_change": {"commit": "f4698f82e37ba84b64ee028e4e0244d4eefee030", "changed_code": [{"header": "diff --git a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\nindex 7542e7ec3..38f9c1a83 100644\n--- a/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n+++ b/services/wfm/src/test/java/org/openkilda/wfm/topology/flowhs/utils/RerouteRetryQueueTest.java\n", "chunk": "@@ -159,6 +158,30 @@ public class RerouteRetryQueueTest {\n         expectedIslEndpoints.addAll(reroutePathA.getAffectedIsl());\n         expectedIslEndpoints.addAll(reroutePathB.getAffectedIsl());\n \n+        Assert.assertEquals(expectedIslEndpoints, reroute.getAffectedIsl());\n+        Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());\n+    }\n+\n+    @Test\n+    public void mergeOperationWhenAffectedIslsEmpty() {\n+        RerouteRetryQueue queue = new RerouteRetryQueue();\n+        queue.add(rerouteEmpty);\n+        queue.add(reroutePathA);\n+        queue.add(rerouteForced);\n+        queue.add(reroutePathB);\n+\n+        Optional<FlowRerouteFact> potential;\n+        queue.remove();\n+        potential = queue.get();\n+        Assert.assertTrue(potential.isPresent());\n+\n+        FlowRerouteFact reroute = potential.get();\n+        Assert.assertEquals(reroutePathB.getKey(), reroute.getKey());\n+        Assert.assertSame(reroutePathB.getCommandContext(), reroute.getCommandContext());\n+        Assert.assertEquals(reroutePathB.getFlowId(), reroute.getFlowId());\n+\n+        Set<IslEndpoint> expectedIslEndpoints = Collections.emptySet();\n+\n         Assert.assertEquals(expectedIslEndpoints, reroute.getAffectedIsl());\n         Assert.assertTrue(reroute.isForceReroute());\n         Assert.assertEquals(reroutePathB.getRerouteReason(), reroute.getRerouteReason());\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "7869516fa157befef6d4941ced5b3883e0bfd430", "message": "Merge commit", "committedDate": null}, {"oid": "448f16bf48a6e2aac82bf4b7cec009e83cc426ca", "committedDate": "2020-01-13 15:18:08 +0200", "message": "Fix double network failure handling"}, {"oid": "f4698f82e37ba84b64ee028e4e0244d4eefee030", "committedDate": "2020-01-29 12:28:25 +0200", "message": "Reroute affected flows on switch up event"}, {"oid": "fee61c0a4b2c042acb3d2c6f65f0386a78fae659", "committedDate": "2020-02-05 12:06:38 +0200", "message": "Reorganize the project - regroup modules, intro Gradle, split WFM"}]}, {"oid": "ea3030ad2005623b88080eea0083e72050543e0c", "url": "https://github.com/telstra/open-kilda/commit/ea3030ad2005623b88080eea0083e72050543e0c", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T12:37:10Z", "type": "forcePushed"}, {"oid": "69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "url": "https://github.com/telstra/open-kilda/commit/69c9c42f410be58fe1cb21ff59a7accfd8c79d42", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-09T15:06:53Z", "type": "forcePushed"}, {"oid": "324470bfb8bc878d94826c4b5b872985e5231092", "url": "https://github.com/telstra/open-kilda/commit/324470bfb8bc878d94826c4b5b872985e5231092", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-10T08:19:26Z", "type": "commit"}, {"oid": "324470bfb8bc878d94826c4b5b872985e5231092", "url": "https://github.com/telstra/open-kilda/commit/324470bfb8bc878d94826c4b5b872985e5231092", "message": "Fix double network failure handling\n\nAdd queue in front of reroute \"handler\" so if reroute for the flow is\ngoing and new reroute request for this flow received (double network\nfailure case) second request will be postponed.\n\nAt the end of reroute request processing \"handler\" check presence of\npostponed request and handle them.", "committedDate": "2020-01-10T08:19:26Z", "type": "forcePushed"}]}