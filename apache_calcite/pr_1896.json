{"pr_number": 1896, "pr_title": "3877, 3892, 3814 and 3876", "pr_author": "julianhyde", "pr_createdAt": "2020-04-02T19:20:25Z", "pr_url": "https://github.com/apache/calcite/pull/1896", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxNzIxOQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402717219", "body": "Do we also need to prevent merging projects in RelBuilder when converting `SqlNode` to `RelNode`?\r\n\r\n```\r\nLogicalProject(EXPR$0=[ROW_NUMBER() OVER (ORDER BY ROW_NUMBER() OVER (ORDER BY $1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)])\r\n  JdbcTableScan(table=[[foodmart, product]])\r\n```\r\n", "bodyText": "Do we also need to prevent merging projects in RelBuilder when converting SqlNode to RelNode?\nLogicalProject(EXPR$0=[ROW_NUMBER() OVER (ORDER BY ROW_NUMBER() OVER (ORDER BY $1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)])\n  JdbcTableScan(table=[[foodmart, product]])", "bodyHTML": "<p dir=\"auto\">Do we also need to prevent merging projects in RelBuilder when converting <code>SqlNode</code> to <code>RelNode</code>?</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"LogicalProject(EXPR$0=[ROW_NUMBER() OVER (ORDER BY ROW_NUMBER() OVER (ORDER BY $1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)])\n  JdbcTableScan(table=[[foodmart, product]])\n\"><pre><code>LogicalProject(EXPR$0=[ROW_NUMBER() OVER (ORDER BY ROW_NUMBER() OVER (ORDER BY $1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)])\n  JdbcTableScan(table=[[foodmart, product]])\n</code></pre></div>", "author": "DonnyZone", "createdAt": "2020-04-03T03:28:43Z", "path": "core/src/main/java/org/apache/calcite/rel/rel2sql/SqlImplementor.java", "diffHunk": "@@ -1439,6 +1439,14 @@ private boolean needNewSubQuery(RelNode rel, Clause[] clauses) {\n         return true;\n       }\n \n+      if (rel instanceof Project", "originalCommit": "d22d59326c4a2a188cf5d852f576617b854cf71a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEzOTY5NQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403139695", "bodyText": "Yes, but that's covered in https://issues.apache.org/jira/browse/CALCITE-3079.", "author": "julianhyde", "createdAt": "2020-04-03T16:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxNzIxOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczNjcyMg==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402736722", "body": "What about we do not have any options for `OVER `, there would then has no reference for underlying inputs.", "bodyText": "What about we do not have any options for OVER , there would then has no reference for underlying inputs.", "bodyHTML": "<p dir=\"auto\">What about we do not have any options for <code>OVER </code>, there would then has no reference for underlying inputs.</p>", "author": "danny0405", "createdAt": "2020-04-03T04:56:15Z", "path": "core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java", "diffHunk": "@@ -2749,6 +2749,28 @@ private void checkLiteral2(String expression, String expected) {\n     sql(query).ok(expected);\n   }\n \n+  /** Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3876\">[CALCITE-3876]\n+   * RelToSqlConverter should not combine Projects when top Project contains\n+   * window function referencing window function from bottom Project</a>. */\n+  @Test public void testWindowOnWindowDoesNotCombineProjects() {\n+    final String query = \"SELECT ROW_NUMBER() OVER (ORDER BY rn)\\n\"\n+        + \"FROM (SELECT *,\\n\"\n+        + \"  ROW_NUMBER() OVER (ORDER BY \\\"product_id\\\") as rn\\n\"", "originalCommit": "e6d62e6286d27803295959993ebe569e265cf5a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMjY3Mw==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403402673", "bodyText": "I think ROW_NUMBER must have ORDER BY in its window, and if so, this concern is moot.", "author": "julianhyde", "createdAt": "2020-04-04T01:09:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczNjcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "9492dd4146f63ddc028010d6c4e86f6a5cb29a8d", "changed_code": [{"header": "diff --git a/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java b/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java\nindex dbea9688c..a7568223f 100644\n--- a/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java\n+++ b/core/src/test/java/org/apache/calcite/rel/rel2sql/RelToSqlConverterTest.java\n", "chunk": "@@ -2753,7 +2753,7 @@ private void checkLiteral2(String expression, String expected) {\n    * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3876\">[CALCITE-3876]\n    * RelToSqlConverter should not combine Projects when top Project contains\n    * window function referencing window function from bottom Project</a>. */\n-  @Test public void testWindowOnWindowDoesNotCombineProjects() {\n+  @Test void testWindowOnWindowDoesNotCombineProjects() {\n     final String query = \"SELECT ROW_NUMBER() OVER (ORDER BY rn)\\n\"\n         + \"FROM (SELECT *,\\n\"\n         + \"  ROW_NUMBER() OVER (ORDER BY \\\"product_id\\\") as rn\\n\"\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTQ2Mw==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402741463", "body": "This block seems not necessary.", "bodyText": "This block seems not necessary.", "bodyHTML": "<p dir=\"auto\">This block seems not necessary.</p>", "author": "danny0405", "createdAt": "2020-04-03T05:16:32Z", "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n+    } else if (sqlLowerBound == null && sqlUpperBound == null) {\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "originalCommit": "2ece8a122ff1fcd778a5849cb3c0899776e33e53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMzYyNQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403403625", "bodyText": "It is necessary - without it, there are failures in SqlToRelConverterTest.", "author": "julianhyde", "createdAt": "2020-04-04T01:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMDEyNw==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403420127", "bodyText": "Yeah, you are right, it is not equivalent with the following block.", "author": "danny0405", "createdAt": "2020-04-04T03:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTQ2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "df3e3c652e3499ec03a224468fb2918752bae461", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\nindex 6d5f33689..0c83a1802 100644\n--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n", "chunk": "@@ -1944,33 +1943,13 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope);\n+        validator.resolveWindow(windowOrRef, bb.scope, true);\n \n-    SqlNode sqlLowerBound = window.getLowerBound();\n-    SqlNode sqlUpperBound = window.getUpperBound();\n-    boolean rows = window.isRows();\n-    SqlNodeList orderList = window.getOrderList();\n-\n-    if (!aggCall.getOperator().allowsFraming()) {\n-      // If the operator does not allow framing, bracketing is implicitly\n-      // everything up to the current row.\n-      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n-      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n-      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-        // ROW_NUMBER() expects specific kind of framing.\n-        rows = true;\n-      }\n-    } else if (orderList.size() == 0) {\n-      // Without ORDER BY, there must be no bracketing.\n-      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n-      sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n-    } else if (sqlLowerBound == null && sqlUpperBound == null) {\n-      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n-      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n-    } else if (sqlUpperBound == null) {\n-      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n-    } else if (sqlLowerBound == null) {\n-      sqlLowerBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+    // ROW_NUMBER() expects specific kind of framing.\n+    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n+      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n+      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n     }\n     final SqlNodeList partitionList = window.getPartitionList();\n     final ImmutableList.Builder<RexNode> partitionKeys =\n", "next_change": {"commit": "ddda872b4922266c102f474042b4df27ba9a09be", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\nindex 0c83a1802..6d5f33689 100644\n--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n", "chunk": "@@ -1943,13 +1944,33 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n+    } else if (sqlLowerBound == null && sqlUpperBound == null) {\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+    } else if (sqlUpperBound == null) {\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+    } else if (sqlLowerBound == null) {\n+      sqlLowerBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n     }\n     final SqlNodeList partitionList = window.getPartitionList();\n     final ImmutableList.Builder<RexNode> partitionKeys =\n", "next_change": null}, {"header": "diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\nindex 0c83a1802..6d5f33689 100644\n--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n", "chunk": "@@ -1957,10 +1978,9 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n     for (SqlNode partition : partitionList) {\n       partitionKeys.add(bb.convertExpression(partition));\n     }\n-    RexNode lowerBound = bb.convertExpression(window.getLowerBound());\n-    RexNode upperBound = bb.convertExpression(window.getUpperBound());\n-    SqlNodeList orderList = window.getOrderList();\n-    if ((orderList.size() == 0) && !window.isRows()) {\n+    final RexNode lowerBound = bb.convertExpression(sqlLowerBound);\n+    final RexNode upperBound = bb.convertExpression(sqlUpperBound);\n+    if (orderList.size() == 0 && !rows) {\n       // A logical range requires an ORDER BY clause. Use the implicit\n       // ordering of this relation. There must be one, otherwise it would\n       // have failed validation.\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402742471", "body": "Is this true ? From the MS-SQL syntax, the `ORDER BY` has no relationship with `<ROW or RANGE clause>`, they can both exist separately. [1] \r\n\r\nhttps://docs.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql?view=sql-server-ver15", "bodyText": "Is this true ? From the MS-SQL syntax, the ORDER BY has no relationship with <ROW or RANGE clause>, they can both exist separately. [1]\nhttps://docs.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql?view=sql-server-ver15", "bodyHTML": "<p dir=\"auto\">Is this true ? From the MS-SQL syntax, the <code>ORDER BY</code> has no relationship with <code>&lt;ROW or RANGE clause&gt;</code>, they can both exist separately. [1]</p>\n<p dir=\"auto\"><a href=\"https://docs.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql?view=sql-server-ver15\" rel=\"nofollow\">https://docs.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql?view=sql-server-ver15</a></p>", "author": "danny0405", "createdAt": "2020-04-03T05:20:43Z", "path": "core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java", "diffHunk": "@@ -1943,24 +1944,43 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);", "originalCommit": "2ece8a122ff1fcd778a5849cb3c0899776e33e53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0MTQ3MQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403141471", "bodyText": "How can you say '5 ROWS PRECEDING' if you don't provide an ORDER BY clause to say by which criteria they are preceding?\nIf rows/range are present and there is no ORDER BY the validator doesn't throw (maybe it should) but we treat all rows as equal.", "author": "julianhyde", "createdAt": "2020-04-03T16:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMDk0Ng==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403420946", "bodyText": "I checked these for MS-SQL 2017\ncreate table t(\n  a int,\n  b int\n);\n\nselect max(a) over( rows 2 PRECEDING ) from t; -- syntax error throws\nselect max(a) over( order by b rows 2 PRECEDING ) from t; -- this works\n\nselect max(a) over(ROWS between UNBOUNDED PRECEDING and CURRENT ROW) from t; -- syntax error throws\nselect max(a) over(order by b ROWS between UNBOUNDED PRECEDING and CURRENT ROW) from t; -- this works", "author": "danny0405", "createdAt": "2020-04-04T04:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMTg1Mg==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403421852", "bodyText": "Show we throw for non-order by query ?", "author": "danny0405", "createdAt": "2020-04-04T04:10:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc1NTQzMg==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403755432", "bodyText": "I have logged https://issues.apache.org/jira/browse/CALCITE-3897. We should decide whether we want to fix it.", "author": "julianhyde", "createdAt": "2020-04-05T20:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MjQ3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "df3e3c652e3499ec03a224468fb2918752bae461", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\nindex 6d5f33689..0c83a1802 100644\n--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n", "chunk": "@@ -1944,33 +1943,13 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope);\n+        validator.resolveWindow(windowOrRef, bb.scope, true);\n \n-    SqlNode sqlLowerBound = window.getLowerBound();\n-    SqlNode sqlUpperBound = window.getUpperBound();\n-    boolean rows = window.isRows();\n-    SqlNodeList orderList = window.getOrderList();\n-\n-    if (!aggCall.getOperator().allowsFraming()) {\n-      // If the operator does not allow framing, bracketing is implicitly\n-      // everything up to the current row.\n-      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n-      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n-      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-        // ROW_NUMBER() expects specific kind of framing.\n-        rows = true;\n-      }\n-    } else if (orderList.size() == 0) {\n-      // Without ORDER BY, there must be no bracketing.\n-      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n-      sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n-    } else if (sqlLowerBound == null && sqlUpperBound == null) {\n-      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n-      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n-    } else if (sqlUpperBound == null) {\n-      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n-    } else if (sqlLowerBound == null) {\n-      sqlLowerBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+    // ROW_NUMBER() expects specific kind of framing.\n+    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n+      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n+      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n     }\n     final SqlNodeList partitionList = window.getPartitionList();\n     final ImmutableList.Builder<RexNode> partitionKeys =\n", "next_change": {"commit": "ddda872b4922266c102f474042b4df27ba9a09be", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\nindex 0c83a1802..6d5f33689 100644\n--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n", "chunk": "@@ -1943,13 +1944,33 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n \n     SqlNode windowOrRef = call.operand(1);\n     final SqlWindow window =\n-        validator.resolveWindow(windowOrRef, bb.scope, true);\n+        validator.resolveWindow(windowOrRef, bb.scope);\n \n-    // ROW_NUMBER() expects specific kind of framing.\n-    if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n-      window.setLowerBound(SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO));\n-      window.setUpperBound(SqlWindow.createCurrentRow(SqlParserPos.ZERO));\n-      window.setRows(SqlLiteral.createBoolean(true, SqlParserPos.ZERO));\n+    SqlNode sqlLowerBound = window.getLowerBound();\n+    SqlNode sqlUpperBound = window.getUpperBound();\n+    boolean rows = window.isRows();\n+    SqlNodeList orderList = window.getOrderList();\n+\n+    if (!aggCall.getOperator().allowsFraming()) {\n+      // If the operator does not allow framing, bracketing is implicitly\n+      // everything up to the current row.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+      if (aggCall.getKind() == SqlKind.ROW_NUMBER) {\n+        // ROW_NUMBER() expects specific kind of framing.\n+        rows = true;\n+      }\n+    } else if (orderList.size() == 0) {\n+      // Without ORDER BY, there must be no bracketing.\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createUnboundedFollowing(SqlParserPos.ZERO);\n+    } else if (sqlLowerBound == null && sqlUpperBound == null) {\n+      sqlLowerBound = SqlWindow.createUnboundedPreceding(SqlParserPos.ZERO);\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+    } else if (sqlUpperBound == null) {\n+      sqlUpperBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n+    } else if (sqlLowerBound == null) {\n+      sqlLowerBound = SqlWindow.createCurrentRow(SqlParserPos.ZERO);\n     }\n     final SqlNodeList partitionList = window.getPartitionList();\n     final ImmutableList.Builder<RexNode> partitionKeys =\n", "next_change": null}, {"header": "diff --git a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\nindex 0c83a1802..6d5f33689 100644\n--- a/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n+++ b/core/src/main/java/org/apache/calcite/sql2rel/SqlToRelConverter.java\n", "chunk": "@@ -1957,10 +1978,9 @@ private RexNode convertOver(Blackboard bb, SqlNode node) {\n     for (SqlNode partition : partitionList) {\n       partitionKeys.add(bb.convertExpression(partition));\n     }\n-    RexNode lowerBound = bb.convertExpression(window.getLowerBound());\n-    RexNode upperBound = bb.convertExpression(window.getUpperBound());\n-    SqlNodeList orderList = window.getOrderList();\n-    if ((orderList.size() == 0) && !window.isRows()) {\n+    final RexNode lowerBound = bb.convertExpression(sqlLowerBound);\n+    final RexNode upperBound = bb.convertExpression(sqlUpperBound);\n+    if (orderList.size() == 0 && !rows) {\n       // A logical range requires an ORDER BY clause. Use the implicit\n       // ordering of this relation. There must be one, otherwise it would\n       // have failed validation.\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402743867", "body": "Why this change ?", "bodyText": "Why this change ?", "bodyHTML": "<p dir=\"auto\">Why this change ?</p>", "author": "danny0405", "createdAt": "2020-04-03T05:26:28Z", "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n    * a given table, not applying any filters and projecting all columns,\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));", "originalCommit": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc3NjY4NA==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402776684", "bodyText": "I have the same question. If ImmutableList.of() is bad, then we should forbid its use, and move to Collections.emptyList().", "author": "vlsi", "createdAt": "2020-04-03T07:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0MjQ5NA==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403142494", "bodyText": "See the commit comment. That parameter to scan is mutable, always has been. The implementation calls List.removeIf on it. As of guava-28.2-jre, removeIf throws even if the list is empty. So, these calls were incorrect to pass an immutable list.", "author": "julianhyde", "createdAt": "2020-04-03T16:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NzA2Nw==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403197067", "bodyText": "@julianhyde , Collection.emptyList() supports removeIf just fine.", "author": "vlsi", "createdAt": "2020-04-03T17:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMjEyMQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403402121", "bodyText": "But it's not mutable. The contract calls to a mutable list.", "author": "julianhyde", "createdAt": "2020-04-04T01:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0NTY4Mg==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403445682", "bodyText": "If you think the contract is to treat the list as fully mutable, then, adjust the Javadoc, and adjust the implementation so it handles the mutations of the list.\nIn other words, for now you pass an ArrayList and expect it to be mutated. However, you seem to ignore the mutated value of the ArrayList, so the new code might result in invalid data being returned.", "author": "vlsi", "createdAt": "2020-04-04T08:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0Mzg2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "df3e3c652e3499ec03a224468fb2918752bae461", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/schema/Schemas.java b/core/src/main/java/org/apache/calcite/schema/Schemas.java\nindex 384a4cfd1..fe53d8342 100644\n--- a/core/src/main/java/org/apache/calcite/schema/Schemas.java\n+++ b/core/src/main/java/org/apache/calcite/schema/Schemas.java\n", "chunk": "@@ -232,7 +232,7 @@ public static DataContext createDataContext(\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, new ArrayList<>(),\n+    return table.scan(root, ImmutableList.of(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));\n   }\n \n", "next_change": {"commit": "f1b2d3c45f085b71c18a45392337989d0d474136", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/schema/Schemas.java b/core/src/main/java/org/apache/calcite/schema/Schemas.java\nindex fe53d8342..384a4cfd1 100644\n--- a/core/src/main/java/org/apache/calcite/schema/Schemas.java\n+++ b/core/src/main/java/org/apache/calcite/schema/Schemas.java\n", "chunk": "@@ -232,7 +232,7 @@ public static DataContext createDataContext(\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));\n   }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402780755", "body": "```suggestion\r\n    return table.scan(root, Collections.emptyList());\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return table.scan(root, new ArrayList<>());\n          \n          \n            \n                return table.scan(root, Collections.emptyList());", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"227\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">return</span> table<span class=\"pl-k\">.</span>scan(root, <span class=\"pl-k x x-first\">new</span><span class=\"x\"> </span><span class=\"pl-k x x-last\">ArrayList&lt;&gt;</span>());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"227\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">return</span> table<span class=\"pl-k\">.</span>scan(root, <span class=\"pl-smi x x-first\">Collections</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">emptyList</span>());</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vlsi", "createdAt": "2020-04-03T07:16:46Z", "path": "core/src/main/java/org/apache/calcite/schema/Schemas.java", "diffHunk": "@@ -224,15 +224,15 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());", "originalCommit": "82a4c89c702ad6d5cd1428294ccd6db0ae41d19e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0NTcwNQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403145705", "bodyText": "No. We need a mutable list. Try running with -Pguava.version=28.2-jre and you will see.", "author": "julianhyde", "createdAt": "2020-04-03T16:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTQxOQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403195419", "bodyText": "Why do you think mutable list is required here?\nIt was working with ImmutableList.of(), so it means it should be perfectly fine to pass Collections.emptyList().", "author": "vlsi", "createdAt": "2020-04-03T17:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMTQyMg==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403401422", "bodyText": "The javadoc says \"the list of filters is mutable\".", "author": "julianhyde", "createdAt": "2020-04-04T01:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTkyMw==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403435923", "bodyText": "javadoc does not say the implementation can add new filters to the list. So Collections.emptyList() is fine.", "author": "vlsi", "createdAt": "2020-04-04T07:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MDc1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "df3e3c652e3499ec03a224468fb2918752bae461", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/schema/Schemas.java b/core/src/main/java/org/apache/calcite/schema/Schemas.java\nindex 384a4cfd1..fe53d8342 100644\n--- a/core/src/main/java/org/apache/calcite/schema/Schemas.java\n+++ b/core/src/main/java/org/apache/calcite/schema/Schemas.java\n", "chunk": "@@ -224,7 +224,7 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, new ArrayList<>());\n+    return table.scan(root, ImmutableList.of());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n", "next_change": {"commit": "f1b2d3c45f085b71c18a45392337989d0d474136", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/schema/Schemas.java b/core/src/main/java/org/apache/calcite/schema/Schemas.java\nindex fe53d8342..384a4cfd1 100644\n--- a/core/src/main/java/org/apache/calcite/schema/Schemas.java\n+++ b/core/src/main/java/org/apache/calcite/schema/Schemas.java\n", "chunk": "@@ -224,7 +224,7 @@ public static DataContext createDataContext(\n    * array. */\n   public static Enumerable<Object[]> enumerable(final FilterableTable table,\n       final DataContext root) {\n-    return table.scan(root, ImmutableList.of());\n+    return table.scan(root, new ArrayList<>());\n   }\n \n   /** Returns an {@link org.apache.calcite.linq4j.Enumerable} over the rows of\n", "next_change": null}, {"header": "diff --git a/core/src/main/java/org/apache/calcite/schema/Schemas.java b/core/src/main/java/org/apache/calcite/schema/Schemas.java\nindex fe53d8342..384a4cfd1 100644\n--- a/core/src/main/java/org/apache/calcite/schema/Schemas.java\n+++ b/core/src/main/java/org/apache/calcite/schema/Schemas.java\n", "chunk": "@@ -232,7 +232,7 @@ public static DataContext createDataContext(\n    * representing each row as an object array. */\n   public static Enumerable<Object[]> enumerable(\n       final ProjectableFilterableTable table, final DataContext root) {\n-    return table.scan(root, ImmutableList.of(),\n+    return table.scan(root, new ArrayList<>(),\n         identity(table.getRowType(root.getTypeFactory()).getFieldCount()));\n   }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4ODc4OQ==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r402788789", "body": "This is invalid because it does not verify if `rows` vs `range` is in its default value.\r\n\r\nFor instance,\r\n`count(x) over (order by x RANGE between unbounded preceding and current row)` returns different values depending on RANGE vs ROW", "bodyText": "This is invalid because it does not verify if rows vs range is in its default value.\nFor instance,\ncount(x) over (order by x RANGE between unbounded preceding and current row) returns different values depending on RANGE vs ROW", "bodyHTML": "<p dir=\"auto\">This is invalid because it does not verify if <code>rows</code> vs <code>range</code> is in its default value.</p>\n<p dir=\"auto\">For instance,<br>\n<code>count(x) over (order by x RANGE between unbounded preceding and current row)</code> returns different values depending on RANGE vs ROW</p>", "author": "vlsi", "createdAt": "2020-04-03T07:33:05Z", "path": "core/src/main/java/org/apache/calcite/rel/core/Window.java", "diffHunk": "@@ -246,26 +244,38 @@ public String toString() {\n     }\n \n     private String computeString() {\n-      final StringBuilder buf = new StringBuilder();\n-      buf.append(\"window(partition \");\n-      buf.append(keys);\n-      buf.append(\" order by \");\n-      buf.append(orderKeys);\n-      buf.append(isRows ? \" rows \" : \" range \");\n-      if (lowerBound != null) {\n-        if (upperBound != null) {\n-          buf.append(\"between \");\n-          buf.append(lowerBound);\n-          buf.append(\" and \");\n-          buf.append(upperBound);\n-        } else {\n-          buf.append(lowerBound);\n-        }\n-      } else if (upperBound != null) {\n+      final StringBuilder buf = new StringBuilder(\"window(\");\n+      final int i = buf.length();\n+      if (!keys.isEmpty()) {\n+        buf.append(\"partition \");\n+        buf.append(keys);\n+      }\n+      if (!orderKeys.getFieldCollations().isEmpty()) {\n+        buf.append(buf.length() == i ? \"order by \" : \" order by \");\n+        buf.append(orderKeys);\n+      }\n+      if (orderKeys.getFieldCollations().isEmpty()\n+          && lowerBound.isUnbounded()\n+          && lowerBound.isPreceding()\n+          && upperBound.isUnbounded()\n+          && upperBound.isFollowing()) {\n+        // skip bracket if no ORDER BY, and if bracket is the default\n+      } else if (!orderKeys.getFieldCollations().isEmpty()\n+          && lowerBound.isUnbounded()\n+          && lowerBound.isPreceding()\n+          && upperBound.isCurrentRow()) {\n+        // skip bracket if there is ORDER BY, and if bracket is the default", "originalCommit": "2ece8a122ff1fcd778a5849cb3c0899776e33e53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMjcyNA==", "url": "https://github.com/apache/calcite/pull/1896#discussion_r403402724", "bodyText": "Good point. I've fixed in 75ee3ec.", "author": "julianhyde", "createdAt": "2020-04-04T01:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4ODc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "df3e3c652e3499ec03a224468fb2918752bae461", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/rel/core/Window.java b/core/src/main/java/org/apache/calcite/rel/core/Window.java\nindex 616e0d2b6..3285e67bf 100644\n--- a/core/src/main/java/org/apache/calcite/rel/core/Window.java\n+++ b/core/src/main/java/org/apache/calcite/rel/core/Window.java\n", "chunk": "@@ -244,38 +246,26 @@ public String toString() {\n     }\n \n     private String computeString() {\n-      final StringBuilder buf = new StringBuilder(\"window(\");\n-      final int i = buf.length();\n-      if (!keys.isEmpty()) {\n-        buf.append(\"partition \");\n-        buf.append(keys);\n-      }\n-      if (!orderKeys.getFieldCollations().isEmpty()) {\n-        buf.append(buf.length() == i ? \"order by \" : \" order by \");\n-        buf.append(orderKeys);\n-      }\n-      if (orderKeys.getFieldCollations().isEmpty()\n-          && lowerBound.isUnbounded()\n-          && lowerBound.isPreceding()\n-          && upperBound.isUnbounded()\n-          && upperBound.isFollowing()) {\n-        // skip bracket if no ORDER BY, and if bracket is the default\n-      } else if (!orderKeys.getFieldCollations().isEmpty()\n-          && lowerBound.isUnbounded()\n-          && lowerBound.isPreceding()\n-          && upperBound.isCurrentRow()) {\n-        // skip bracket if there is ORDER BY, and if bracket is the default\n-      } else {\n-        buf.append(isRows ? \" rows \" : \" range \");\n-        buf.append(\"between \");\n-        buf.append(lowerBound);\n-        buf.append(\" and \");\n+      final StringBuilder buf = new StringBuilder();\n+      buf.append(\"window(partition \");\n+      buf.append(keys);\n+      buf.append(\" order by \");\n+      buf.append(orderKeys);\n+      buf.append(isRows ? \" rows \" : \" range \");\n+      if (lowerBound != null) {\n+        if (upperBound != null) {\n+          buf.append(\"between \");\n+          buf.append(lowerBound);\n+          buf.append(\" and \");\n+          buf.append(upperBound);\n+        } else {\n+          buf.append(lowerBound);\n+        }\n+      } else if (upperBound != null) {\n         buf.append(upperBound);\n       }\n-      if (!aggCalls.isEmpty()) {\n-        buf.append(buf.length() == i ? \"aggs \" : \" aggs \");\n-        buf.append(aggCalls);\n-      }\n+      buf.append(\" aggs \");\n+      buf.append(aggCalls);\n       buf.append(\")\");\n       return buf.toString();\n     }\n", "next_change": {"commit": "ddda872b4922266c102f474042b4df27ba9a09be", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/calcite/rel/core/Window.java b/core/src/main/java/org/apache/calcite/rel/core/Window.java\nindex 3285e67bf..13d883026 100644\n--- a/core/src/main/java/org/apache/calcite/rel/core/Window.java\n+++ b/core/src/main/java/org/apache/calcite/rel/core/Window.java\n", "chunk": "@@ -246,26 +244,45 @@ public String toString() {\n     }\n \n     private String computeString() {\n-      final StringBuilder buf = new StringBuilder();\n-      buf.append(\"window(partition \");\n-      buf.append(keys);\n-      buf.append(\" order by \");\n-      buf.append(orderKeys);\n-      buf.append(isRows ? \" rows \" : \" range \");\n-      if (lowerBound != null) {\n-        if (upperBound != null) {\n-          buf.append(\"between \");\n-          buf.append(lowerBound);\n-          buf.append(\" and \");\n-          buf.append(upperBound);\n-        } else {\n-          buf.append(lowerBound);\n-        }\n-      } else if (upperBound != null) {\n+      final StringBuilder buf = new StringBuilder(\"window(\");\n+      final int i = buf.length();\n+      if (!keys.isEmpty()) {\n+        buf.append(\"partition \");\n+        buf.append(keys);\n+      }\n+      if (!orderKeys.getFieldCollations().isEmpty()) {\n+        buf.append(buf.length() == i ? \"order by \" : \" order by \");\n+        buf.append(orderKeys);\n+      }\n+      if (orderKeys.getFieldCollations().isEmpty()\n+          && lowerBound.isUnbounded()\n+          && lowerBound.isPreceding()\n+          && upperBound.isUnbounded()\n+          && upperBound.isFollowing()) {\n+        // skip bracket if no ORDER BY, and if bracket is the default,\n+        // \"RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\",\n+        // which is equivalent to\n+        // \"ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\"\n+      } else if (!orderKeys.getFieldCollations().isEmpty()\n+          && lowerBound.isUnbounded()\n+          && lowerBound.isPreceding()\n+          && upperBound.isCurrentRow()\n+          && !isRows) {\n+        // skip bracket if there is ORDER BY, and if bracket is the default,\n+        // \"RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\",\n+        // which is NOT equivalent to\n+        // \"ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\"\n+      } else {\n+        buf.append(isRows ? \" rows \" : \" range \");\n+        buf.append(\"between \");\n+        buf.append(lowerBound);\n+        buf.append(\" and \");\n         buf.append(upperBound);\n       }\n-      buf.append(\" aggs \");\n-      buf.append(aggCalls);\n+      if (!aggCalls.isEmpty()) {\n+        buf.append(buf.length() == i ? \"aggs \" : \" aggs \");\n+        buf.append(aggCalls);\n+      }\n       buf.append(\")\");\n       return buf.toString();\n     }\n", "next_change": null}]}}]}}, {"oid": "df3e3c652e3499ec03a224468fb2918752bae461", "url": "https://github.com/apache/calcite/commit/df3e3c652e3499ec03a224468fb2918752bae461", "message": "[CALCITE-3876] RelToSqlConverter should not merge a Project that contains a window function that references a window function in input Project\n\nMain fix is to RelToSqlConverter, to force a new sub-query to be created.\n\nThe problem in this case was not with ProjectMergeRule or with\nRelBuilder.project, but I fixed those also.", "committedDate": "2020-04-05T20:53:37Z", "type": "commit"}, {"oid": "ddda872b4922266c102f474042b4df27ba9a09be", "url": "https://github.com/apache/calcite/commit/ddda872b4922266c102f474042b4df27ba9a09be", "message": "[CALCITE-3877] In RexWindow, make fields upperBound and lowerBound not-nullable\n\nWhere you would previously have supplied null to RexBuilder.makeOver,\nnow supply RexWindowBounds.UNBOUNDED_PRECEDING,\nRexWindowBounds.UNBOUNDED_FOLLOWING, or RexWindowBounds.CURRENT_ROW.\n\nMove RexWindowBound.create into new class RexWindowBounds, with methods\nand constants for the various types of bound.\n\nDon't keep SqlNode inside RexWindowBound objects.\n\nDuring validation, don't mutate the lowerBound and upperBound fields in\nSqlWindow.\n\nNote that \"RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\" is not\nequivalent to \"ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\".\n\"RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\"\n(that is, not bracket) is equivalent to\n\"ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\",\nbut we require RANGE, to keep things canonical.\n\nClose apache/calcite#1896", "committedDate": "2020-04-05T20:53:38Z", "type": "commit"}, {"oid": "f1b2d3c45f085b71c18a45392337989d0d474136", "url": "https://github.com/apache/calcite/commit/f1b2d3c45f085b71c18a45392337989d0d474136", "message": "[CALCITE-3814] Support JDK 14 and guava 28.2-jre\n\nThe real work for JDK 14 was done in c60f6750d \"Update Gradle: 6.1.1 -> 6.3\".\n\nAs of Gauava 28, ImmutableList.removeIf throws even if the list is empty\n(and therefore no elements would be removed).", "committedDate": "2020-04-05T20:57:49Z", "type": "commit"}, {"oid": "9492dd4146f63ddc028010d6c4e86f6a5cb29a8d", "url": "https://github.com/apache/calcite/commit/9492dd4146f63ddc028010d6c4e86f6a5cb29a8d", "message": "[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5, classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere, or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.", "committedDate": "2020-04-05T20:57:49Z", "type": "commit"}, {"oid": "9492dd4146f63ddc028010d6c4e86f6a5cb29a8d", "url": "https://github.com/apache/calcite/commit/9492dd4146f63ddc028010d6c4e86f6a5cb29a8d", "message": "[CALCITE-3892] Make junit test classes and methods non-public where possible\n\nPrior to junit 5, classes and methods had to be public. This is no\nlonger the case.\n\nSome classes need to remain public because they are referenced from\nelsewhere, or if they use reflection somehow. The remaining 'public'\nkeyword will be informative to maintainers.", "committedDate": "2020-04-05T20:57:49Z", "type": "forcePushed"}]}