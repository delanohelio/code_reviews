{"pr_number": 1327, "pr_title": "Build Block Blooms Database", "pr_author": "ajlopezrsk", "pr_createdAt": "2020-10-05T16:35:09Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1327", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc2Nzk1Nw==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r503767957", "body": "shouldn't we handle the case when `blockNumber` is negative?", "bodyText": "shouldn't we handle the case when blockNumber is negative?", "bodyHTML": "<p dir=\"auto\">shouldn't we handle the case when <code>blockNumber</code> is negative?</p>", "author": "Vovchyk", "createdAt": "2020-10-13T08:34:46Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.logfilter;\n+\n+import org.ethereum.core.Bloom;\n+import org.ethereum.db.BlockStore;\n+\n+/**\n+ * Created by ajlopez on 29/09/2020.\n+ */\n+public class BlocksBloomProcessor {\n+    private final BlocksBloomStore blocksBloomStore;\n+    private final BlockStore blockStore;\n+\n+    private BlocksBloom blocksBloomInProcess = null;\n+\n+    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n+        this.blocksBloomStore = blocksBloomStore;\n+        this.blockStore = blockStore;\n+    }\n+\n+    public BlocksBloom getBlocksBloomInProcess() {\n+        return this.blocksBloomInProcess;\n+    }\n+\n+    public void processNewBlockNumber(long newBlockNumber) {\n+        long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();", "originalCommit": "dde21f9d4009ad359591a8d2cf97e3e58f1bf67a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzMjYyNQ==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r505032625", "bodyText": "nice catch! Done", "author": "ajlopezrsk", "createdAt": "2020-10-14T22:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc2Nzk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c8797d3860b1c70dec138220320b4a57c870c496", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nindex cad6a3280..03596ac8c 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -36,50 +49,58 @@ public class BlocksBloomProcessor {\n         this.blockStore = blockStore;\n     }\n \n+    @VisibleForTesting\n     public BlocksBloom getBlocksBloomInProcess() {\n         return this.blocksBloomInProcess;\n     }\n \n-    public void processNewBlockNumber(long newBlockNumber) {\n+    /**\n+     * Receives the new height to process.\n+     * Processes the block blooms up to that height minus the number of needed confirmations\n+     *\n+     * @param newBlockNumber    the new height to process\n+     */\n+    public synchronized void processNewBlockNumber(long newBlockNumber) {\n+        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n+            return;\n+        }\n+\n         long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n \n-        addBlocksUpToNumber(blockNumber);\n+        if (!alreadyAdded(blockNumber)) {\n+            for (long aBlockNumber = fromBlock(blockNumber); aBlockNumber <= blockNumber; aBlockNumber++) {\n+                this.addBlock(aBlockNumber);\n+            }\n+        }\n     }\n \n-    private void addBlocksUpToNumber(long blockNumber) {\n-        if (this.blocksBloomStore.hasBlockNumber(blockNumber)) {\n-            return;\n-        }\n+    private boolean alreadyAdded(long blockNumber) {\n+        return this.blocksBloomStore.hasBlockNumber(blockNumber) ||\n+                (this.blocksBloomInProcess != null && this.blocksBloomInProcess.hasBlockBloom(blockNumber));\n+    }\n \n+    private long fromBlock(long blockNumber) {\n         long fromBlock;\n-\n         if (this.blocksBloomInProcess == null) {\n             this.blocksBloomInProcess = new BlocksBloom();\n-            fromBlock = this.blocksBloomStore.\n-                    firstNumberInRange(blockNumber);\n+            fromBlock = this.blocksBloomStore.firstNumberInRange(blockNumber);\n         }\n         else {\n             fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n         }\n-\n-        if (this.blocksBloomInProcess.hasBlockBloom(blockNumber)) {\n-            return;\n-        }\n-\n-        for (long nb = fromBlock; nb <= blockNumber; nb++) {\n-            this.addBlock(nb);\n-        }\n+        return fromBlock;\n     }\n \n+    /**\n+     * Reads and collect the bloom from the block that corresponds to the provided block number\n+     *\n+     * If the BlocksBloom instance is fulfilled, it is saved into the store\n+     * and a new instance will be created at the process of the next block number\n+     *\n+     * @param blockNumber block number to process\n+     */\n     private void addBlock(long blockNumber) {\n-        Bloom bloom;\n-\n-        if (blockNumber > 0) {\n-            bloom = new Bloom(this.blockStore.getChainBlockByNumber(blockNumber).getLogBloom());\n-        }\n-        else {\n-            bloom = new Bloom();\n-        }\n+        Bloom bloom = bloomByBlockNumber(blockNumber);\n \n         if (this.blocksBloomInProcess == null) {\n             this.blocksBloomInProcess = new BlocksBloom();\n", "next_change": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\ndeleted file mode 100644\nindex 03596ac8c..000000000\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,127 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2017 RSK Labs Ltd.\n- * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.logfilter;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import org.ethereum.core.Bloom;\n-import org.ethereum.db.BlockStore;\n-\n-/**\n- * Process bloom filters from blocks\n- *\n- * It collects bloom filter from flocks with enough confirmations\n- * grouping then in a BlocksBloom instance\n- *\n- * When a new height should be processed, the\n- * BlocksBloom instance is feeded with the block blooms\n- * up to that height\n- *\n- * When the BlocksBloom instance is filled, it is saved into the BlocksBloomStore\n- * and a new instance starts to be processed\n- *\n- * Created by ajlopez on 29/09/2020.\n- */\n-public class BlocksBloomProcessor {\n-    private final BlocksBloomStore blocksBloomStore;\n-    private final BlockStore blockStore;\n-\n-    private BlocksBloom blocksBloomInProcess = null;\n-\n-    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n-        this.blocksBloomStore = blocksBloomStore;\n-        this.blockStore = blockStore;\n-    }\n-\n-    @VisibleForTesting\n-    public BlocksBloom getBlocksBloomInProcess() {\n-        return this.blocksBloomInProcess;\n-    }\n-\n-    /**\n-     * Receives the new height to process.\n-     * Processes the block blooms up to that height minus the number of needed confirmations\n-     *\n-     * @param newBlockNumber    the new height to process\n-     */\n-    public synchronized void processNewBlockNumber(long newBlockNumber) {\n-        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n-            return;\n-        }\n-\n-        long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n-\n-        if (!alreadyAdded(blockNumber)) {\n-            for (long aBlockNumber = fromBlock(blockNumber); aBlockNumber <= blockNumber; aBlockNumber++) {\n-                this.addBlock(aBlockNumber);\n-            }\n-        }\n-    }\n-\n-    private boolean alreadyAdded(long blockNumber) {\n-        return this.blocksBloomStore.hasBlockNumber(blockNumber) ||\n-                (this.blocksBloomInProcess != null && this.blocksBloomInProcess.hasBlockBloom(blockNumber));\n-    }\n-\n-    private long fromBlock(long blockNumber) {\n-        long fromBlock;\n-        if (this.blocksBloomInProcess == null) {\n-            this.blocksBloomInProcess = new BlocksBloom();\n-            fromBlock = this.blocksBloomStore.firstNumberInRange(blockNumber);\n-        }\n-        else {\n-            fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n-        }\n-        return fromBlock;\n-    }\n-\n-    /**\n-     * Reads and collect the bloom from the block that corresponds to the provided block number\n-     *\n-     * If the BlocksBloom instance is fulfilled, it is saved into the store\n-     * and a new instance will be created at the process of the next block number\n-     *\n-     * @param blockNumber block number to process\n-     */\n-    private void addBlock(long blockNumber) {\n-        Bloom bloom = bloomByBlockNumber(blockNumber);\n-\n-        if (this.blocksBloomInProcess == null) {\n-            this.blocksBloomInProcess = new BlocksBloom();\n-        }\n-\n-        this.blocksBloomInProcess.addBlockBloom(blockNumber, bloom);\n-\n-        if (blockNumber == this.blocksBloomStore.lastNumberInRange(blockNumber)) {\n-            this.blocksBloomStore.addBlocksBloom(this.blocksBloomInProcess);\n-            this.blocksBloomInProcess = null;\n-        }\n-    }\n-\n-    private Bloom bloomByBlockNumber(long blockNumber) {\n-        Bloom bloom;\n-        if (blockNumber > 0) {\n-            bloom = this.blockStore.bloomByBlockNumber(blockNumber);\n-        }\n-        else {\n-            bloom = new Bloom();\n-        }\n-        return bloom;\n-    }\n-}\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nnew file mode 100644\nindex 000000000..19fe30aff\n--- /dev/null\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.logfilter;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.ethereum.core.Bloom;\n+import org.ethereum.db.BlockStore;\n+\n+/**\n+ * Process bloom filters from blocks\n+ *\n+ * It collects bloom filter from flocks with enough confirmations\n+ * grouping then in a BlocksBloom instance\n+ *\n+ * When a new height should be processed, the\n+ * BlocksBloom instance is feeded with the block blooms\n+ * up to that height\n+ *\n+ * When the BlocksBloom instance is filled, it is saved into the BlocksBloomStore\n+ * and a new instance starts to be processed\n+ *\n+ * Created by ajlopez on 29/09/2020.\n+ */\n+public class BlocksBloomProcessor {\n+    private final BlocksBloomStore blocksBloomStore;\n+    private final BlockStore blockStore;\n+\n+    private BlocksBloom blocksBloomInProcess = null;\n+\n+    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n+        this.blocksBloomStore = blocksBloomStore;\n+        this.blockStore = blockStore;\n+    }\n+\n+    @VisibleForTesting\n+    public BlocksBloom getBlocksBloomInProcess() {\n+        return this.blocksBloomInProcess;\n+    }\n+\n+    /**\n+     * Receives the new height to process.\n+     * Processes the block blooms up to that height minus the number of needed confirmations\n+     *\n+     * @param newBlockNumber    the new height to process\n+     */\n+    public synchronized void processNewBlockNumber(long newBlockNumber) {\n+        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n+            return;\n+        }\n+\n+        long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n+\n+        addBlocksUpToNumber(blockNumber);\n+    }\n+\n+    /**\n+     * Reads and collect block blooms up the the provided block number\n+     *\n+     * @param blockNumber top block number to process\n+     */\n+    private void addBlocksUpToNumber(long blockNumber) {\n+        if (this.blocksBloomStore.hasBlockNumber(blockNumber)) {\n+            return;\n+        }\n+\n+        long fromBlock;\n+\n+        if (this.blocksBloomInProcess == null) {\n+            this.blocksBloomInProcess = new BlocksBloom();\n+            fromBlock = this.blocksBloomStore.\n+                    firstNumberInRange(blockNumber);\n+        }\n+        else {\n+            fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n+        }\n+\n+        if (this.blocksBloomInProcess.hasBlockBloom(blockNumber)) {\n+            return;\n+        }\n+\n+        for (long nb = fromBlock; nb <= blockNumber; nb++) {\n+            this.addBlock(nb);\n+        }\n+    }\n+\n+    /**\n+     * Reads and collect the bloom from the block that corresponds to the provided block number\n+     *\n+     * If the BlocksBloom instance is fulfilled, it is saved into the store\n+     * and a new instance will be created at the process of the next block number\n+     *\n+     * @param blockNumber block number to process\n+     */\n+    private void addBlock(long blockNumber) {\n+        Bloom bloom;\n+\n+        if (blockNumber > 0) {\n+            bloom = new Bloom(this.blockStore.getChainBlockByNumber(blockNumber).getLogBloom());\n+        }\n+        else {\n+            bloom = new Bloom();\n+        }\n+\n+        if (this.blocksBloomInProcess == null) {\n+            this.blocksBloomInProcess = new BlocksBloom();\n+        }\n+\n+        this.blocksBloomInProcess.addBlockBloom(blockNumber, bloom);\n+\n+        if (blockNumber == this.blocksBloomStore.lastNumberInRange(blockNumber)) {\n+            this.blocksBloomStore.addBlocksBloom(this.blocksBloomInProcess);\n+            this.blocksBloomInProcess = null;\n+        }\n+    }\n+}\n", "next_change": {"commit": "3a1c66e92205d514c6ad019b9ff9859300460fca", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nindex 19fe30aff..03596ac8c 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -129,4 +113,15 @@ public class BlocksBloomProcessor {\n             this.blocksBloomInProcess = null;\n         }\n     }\n+\n+    private Bloom bloomByBlockNumber(long blockNumber) {\n+        Bloom bloom;\n+        if (blockNumber > 0) {\n+            bloom = this.blockStore.bloomByBlockNumber(blockNumber);\n+        }\n+        else {\n+            bloom = new Bloom();\n+        }\n+        return bloom;\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgwODU1MQ==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r503808551", "body": "shouldn't we listen to `onBestBlock` event instead?", "bodyText": "shouldn't we listen to onBestBlock event instead?", "bodyHTML": "<p dir=\"auto\">shouldn't we listen to <code>onBestBlock</code> event instead?</p>", "author": "Vovchyk", "createdAt": "2020-10-13T09:35:06Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomService.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.logfilter;\n+\n+import co.rsk.config.InternalService;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.TransactionReceipt;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.listener.CompositeEthereumListener;\n+import org.ethereum.listener.EthereumListenerAdapter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+/**\n+ * Created by ajlopez on 01/10/2020.\n+ */\n+public class BlocksBloomService implements InternalService {\n+    private static final Logger logger = LoggerFactory.getLogger(\"blooms\");\n+\n+    private final CompositeEthereumListener emitter;\n+    private final BlocksBloomProcessor blocksBloomProcessor;\n+\n+    private final BlocksBloomService.OnBlockListener listener = new BlocksBloomService.OnBlockListener();\n+\n+    public BlocksBloomService(CompositeEthereumListener emitter, BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n+        this.emitter = emitter;\n+        this.blocksBloomProcessor = new BlocksBloomProcessor(blocksBloomStore, blockStore);\n+    }\n+\n+    @Override\n+    public void start() {\n+        logger.info(\"blocks bloom service started\");\n+\n+        emitter.addListener(listener);\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.info(\"blocks bloom service stopped\");\n+\n+        emitter.removeListener(listener);\n+    }\n+\n+    public void processNewBlock(long blockNumber) {\n+        this.blocksBloomProcessor.processNewBlockNumber(blockNumber);\n+    }\n+\n+    private class OnBlockListener extends EthereumListenerAdapter {\n+        @Override\n+        public void onBlock(Block block, List<TransactionReceipt> receipts) {", "originalCommit": "dde21f9d4009ad359591a8d2cf97e3e58f1bf67a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE5MjA5Mg==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r504192092", "bodyText": "We use onBlock only to take advantage of no of confirmations at the earliest time possible, in an independent way of being processing the next bestchain or not", "author": "ajlopezrsk", "createdAt": "2020-10-13T19:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgwODU1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomService.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomService.java\ndeleted file mode 100644\nindex e3593ce56..000000000\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomService.java\n+++ /dev/null\n", "chunk": "@@ -1,73 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2017 RSK Labs Ltd.\n- * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.logfilter;\n-\n-import co.rsk.config.InternalService;\n-import org.ethereum.core.Block;\n-import org.ethereum.core.TransactionReceipt;\n-import org.ethereum.db.BlockStore;\n-import org.ethereum.listener.CompositeEthereumListener;\n-import org.ethereum.listener.EthereumListenerAdapter;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.util.List;\n-\n-/**\n- * Created by ajlopez on 01/10/2020.\n- */\n-public class BlocksBloomService implements InternalService {\n-    private static final Logger logger = LoggerFactory.getLogger(\"blooms\");\n-\n-    private final CompositeEthereumListener emitter;\n-    private final BlocksBloomProcessor blocksBloomProcessor;\n-\n-    private final BlocksBloomService.OnBlockListener listener = new BlocksBloomService.OnBlockListener();\n-\n-    public BlocksBloomService(CompositeEthereumListener emitter, BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n-        this.emitter = emitter;\n-        this.blocksBloomProcessor = new BlocksBloomProcessor(blocksBloomStore, blockStore);\n-    }\n-\n-    @Override\n-    public void start() {\n-        logger.info(\"blocks bloom service started\");\n-\n-        emitter.addListener(listener);\n-    }\n-\n-    @Override\n-    public void stop() {\n-        logger.info(\"blocks bloom service stopped\");\n-\n-        emitter.removeListener(listener);\n-    }\n-\n-    public void processNewBlock(long blockNumber) {\n-        this.blocksBloomProcessor.processNewBlockNumber(blockNumber);\n-    }\n-\n-    private class OnBlockListener extends EthereumListenerAdapter {\n-        @Override\n-        public void onBlock(Block block, List<TransactionReceipt> receipts) {\n-            processNewBlock(block.getNumber());\n-        }\n-    }\n-}\n", "next_change": {"commit": "8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomService.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomService.java\nnew file mode 100644\nindex 000000000..3d2d10adf\n--- /dev/null\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomService.java\n", "chunk": "@@ -0,0 +1,65 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.logfilter;\n+\n+import co.rsk.config.InternalService;\n+import org.ethereum.core.Block;\n+import org.ethereum.core.TransactionReceipt;\n+import org.ethereum.db.BlockStore;\n+import org.ethereum.listener.CompositeEthereumListener;\n+import org.ethereum.listener.EthereumListenerAdapter;\n+\n+import java.util.List;\n+\n+/**\n+ * Created by ajlopez on 01/10/2020.\n+ */\n+public class BlocksBloomService implements InternalService {\n+    private final CompositeEthereumListener emitter;\n+    private final BlocksBloomBuilder blocksBloomBuilder;\n+\n+    private final BlocksBloomService.OnBlockListener listener = new BlocksBloomService.OnBlockListener();\n+\n+    public BlocksBloomService(CompositeEthereumListener emitter, BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n+        this.emitter = emitter;\n+        this.blocksBloomBuilder = new BlocksBloomBuilder(blocksBloomStore, blockStore);\n+    }\n+\n+    @Override\n+    public void start() {\n+        emitter.addListener(listener);\n+    }\n+\n+    @Override\n+    public void stop() {\n+        emitter.removeListener(listener);\n+    }\n+\n+    public void processNewBlock(long blockNumber) {\n+        this.blocksBloomBuilder.processNewBlockNumber(blockNumber);\n+    }\n+\n+    private class OnBlockListener extends EthereumListenerAdapter {\n+        @Override\n+        public void onBlock(Block block, List<TransactionReceipt> receipts) {\n+            processNewBlock(block.getNumber());\n+        }\n+    }\n+}\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5ODAzMw==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r504498033", "body": "Seems `dataSource` field cannot be `null` (`non-nullable`)? It's being checked for `null` in a few places in this class. But in other places (e.g. in `flush` method) it is not.", "bodyText": "Seems dataSource field cannot be null (non-nullable)? It's being checked for null in a few places in this class. But in other places (e.g. in flush method) it is not.", "bodyHTML": "<p dir=\"auto\">Seems <code>dataSource</code> field cannot be <code>null</code> (<code>non-nullable</code>)? It's being checked for <code>null</code> in a few places in this class. But in other places (e.g. in <code>flush</code> method) it is not.</p>", "author": "Vovchyk", "createdAt": "2020-10-14T08:32:19Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java", "diffHunk": "@@ -40,22 +44,25 @@ public BlocksBloomStore(int noBlocks, int noConfirmations, KeyValueDataSource da\n         this.dataSource = dataSource;\n     }\n \n-    public boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n-            return true;\n-        }\n+    public synchronized boolean hasBlockNumber(long blockNumber) {\n+        long key = this.firstNumberInRange(blockNumber);\n \n-        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n-            return true;\n-        }\n+        return hasBlockNumberInCache(key)\n+            || hasBlockNumberInStore(key);\n+    }\n+\n+    private boolean hasBlockNumberInStore(long key) {\n+        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;", "originalCommit": "742c5282110aaaeed4c569f600db2e973a14526a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzczNjI0Mg==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r507736242", "bodyText": "Done, I just added additional checks", "author": "ajlopezrsk", "createdAt": "2020-10-19T13:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5ODAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 4bd027d5d..627ca7c4b 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -44,25 +40,22 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n-    public synchronized boolean hasBlockNumber(long blockNumber) {\n-        long key = this.firstNumberInRange(blockNumber);\n-\n-        return hasBlockNumberInCache(key)\n-            || hasBlockNumberInStore(key);\n-    }\n+    public boolean hasBlockNumber(long blockNumber) {\n+        if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n+            return true;\n+        }\n \n-    private boolean hasBlockNumberInStore(long key) {\n-        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n-    }\n+        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n+            return true;\n+        }\n \n-    private boolean hasBlockNumberInCache(long key) {\n-        return this.blocksBloomCache.containsKey(key);\n+        return false;\n     }\n \n-    public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n+    public BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n-        BlocksBloom blocksBloom = this.blocksBloomCache.get(key);\n+        BlocksBloom blocksBloom = this.blocksBloom.get(key);\n \n         if (blocksBloom != null) {\n             return blocksBloom;\n", "next_change": {"commit": "8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 627ca7c4b..2fb56e64d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -52,7 +52,7 @@ public class BlocksBloomStore {\n         return false;\n     }\n \n-    public BlocksBloom getBlocksBloomByNumber(long number) {\n+    public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n         BlocksBloom blocksBloom = this.blocksBloom.get(key);\n", "next_change": {"commit": "66d033f432ba4789f324d63b635fac3bfea37470", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 2fb56e64d..135179ba6 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -55,7 +59,7 @@ public class BlocksBloomStore {\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n-        BlocksBloom blocksBloom = this.blocksBloom.get(key);\n+        BlocksBloom blocksBloom = this.blocksBloomCache.get(key);\n \n         if (blocksBloom != null) {\n             return blocksBloom;\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 135179ba6..8efc3ea82 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -44,18 +54,40 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n+    /**\n+     * Returns if a block number is included in one of the\n+     * group records (in persistence store or in cache)\n+     *\n+     * @param blockNumber block number to query\n+     * @return true if the block number is in some record, false if not\n+     */\n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n-            return true;\n-        }\n+        long key = this.firstNumberInRange(blockNumber);\n \n-        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n-            return true;\n-        }\n+        return hasBlockNumberInCache(key)\n+            || hasBlockNumberInStore(key);\n+    }\n+\n+    private boolean hasBlockNumberInStore(long key) {\n+        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n+    }\n \n-        return false;\n+    private boolean hasBlockNumberInCache(long key) {\n+        return this.blocksBloomCache.containsKey(key);\n     }\n \n+    /**\n+     * Retrieves the coalesced blooms record that contains\n+     * the bloom filter associated with the block corresponding\n+     * to the provided block number\n+     *\n+     * It retrieves the record from cache or from store\n+     *\n+     * If it is found in the store, it is added to the cache\n+     *\n+     * @param number\n+     * @return the BlocksBloom that contains that block number, null if absent\n+     */\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUwNzQwNg==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r504507406", "body": "I guess here we could use `HashMap` instead of `ConcurrentHashMap`. Access to this filed is synchronized in this class.", "bodyText": "I guess here we could use HashMap instead of ConcurrentHashMap. Access to this filed is synchronized in this class.", "bodyHTML": "<p dir=\"auto\">I guess here we could use <code>HashMap</code> instead of <code>ConcurrentHashMap</code>. Access to this filed is synchronized in this class.</p>", "author": "Vovchyk", "createdAt": "2020-10-14T08:46:40Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java", "diffHunk": "@@ -29,9 +31,11 @@\n  * Created by ajlopez on 05/02/2019.\n  */\n public class BlocksBloomStore {\n+    private static final Logger logger = LoggerFactory.getLogger(\"blooms\");\n+\n     private final int noBlocks;\n     private final int noConfirmations;\n-    private final Map<Long, BlocksBloom> blocksBloom = new ConcurrentHashMap<>();\n+    private final Map<Long, BlocksBloom> blocksBloomCache = new ConcurrentHashMap<>();", "originalCommit": "742c5282110aaaeed4c569f600db2e973a14526a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzMjgxMg==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r505032812", "bodyText": "Done!", "author": "ajlopezrsk", "createdAt": "2020-10-14T22:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUwNzQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "c8797d3860b1c70dec138220320b4a57c870c496", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 4bd027d5d..8ede7cbee 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -24,10 +24,20 @@ import org.ethereum.vm.DataWord;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**\n+ * Block blooms store\n+ *\n+ * It saves and retrieves coalesced bloom filters\n+ *\n+ * Each record represents a range of blocks\n+ *\n+ * The key is the block number of the first block in the range\n+ *\n+ * It keeps also an in-memory cache of those records\n+ *\n  * Created by ajlopez on 05/02/2019.\n  */\n public class BlocksBloomStore {\n", "next_change": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 8ede7cbee..627ca7c4b 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -21,31 +21,17 @@ package co.rsk.logfilter;\n \n import org.ethereum.datasource.KeyValueDataSource;\n import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n /**\n- * Block blooms store\n- *\n- * It saves and retrieves coalesced bloom filters\n- *\n- * Each record represents a range of blocks\n- *\n- * The key is the block number of the first block in the range\n- *\n- * It keeps also an in-memory cache of those records\n- *\n  * Created by ajlopez on 05/02/2019.\n  */\n public class BlocksBloomStore {\n-    private static final Logger logger = LoggerFactory.getLogger(\"blooms\");\n-\n     private final int noBlocks;\n     private final int noConfirmations;\n-    private final Map<Long, BlocksBloom> blocksBloomCache = new HashMap<>();\n+    private final Map<Long, BlocksBloom> blocksBloom = new ConcurrentHashMap<>();\n     private final KeyValueDataSource dataSource;\n \n     public BlocksBloomStore(int noBlocks, int noConfirmations, KeyValueDataSource dataSource) {\n", "next_change": {"commit": "8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 627ca7c4b..2fb56e64d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -40,7 +40,7 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n-    public boolean hasBlockNumber(long blockNumber) {\n+    public synchronized boolean hasBlockNumber(long blockNumber) {\n         if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n             return true;\n         }\n", "next_change": {"commit": "66d033f432ba4789f324d63b635fac3bfea37470", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 2fb56e64d..135179ba6 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -41,7 +45,7 @@ public class BlocksBloomStore {\n     }\n \n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n+        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n             return true;\n         }\n \n", "next_change": {"commit": "9341e07da0897f24fe9349b21d6ed87e3c2c5658", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 135179ba6..4bd027d5d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -45,15 +45,18 @@ public class BlocksBloomStore {\n     }\n \n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n-            return true;\n-        }\n+        long key = this.firstNumberInRange(blockNumber);\n \n-        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n-            return true;\n-        }\n+        return hasBlockNumberInCache(key)\n+            || hasBlockNumberInStore(key);\n+    }\n+\n+    private boolean hasBlockNumberInStore(long key) {\n+        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n+    }\n \n-        return false;\n+    private boolean hasBlockNumberInCache(long key) {\n+        return this.blocksBloomCache.containsKey(key);\n     }\n \n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 4bd027d5d..8efc3ea82 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -59,6 +76,18 @@ public class BlocksBloomStore {\n         return this.blocksBloomCache.containsKey(key);\n     }\n \n+    /**\n+     * Retrieves the coalesced blooms record that contains\n+     * the bloom filter associated with the block corresponding\n+     * to the provided block number\n+     *\n+     * It retrieves the record from cache or from store\n+     *\n+     * If it is found in the store, it is added to the cache\n+     *\n+     * @param number\n+     * @return the BlocksBloom that contains that block number, null if absent\n+     */\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 4bd027d5d..8ede7cbee 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -35,7 +45,7 @@ public class BlocksBloomStore {\n \n     private final int noBlocks;\n     private final int noConfirmations;\n-    private final Map<Long, BlocksBloom> blocksBloomCache = new ConcurrentHashMap<>();\n+    private final Map<Long, BlocksBloom> blocksBloomCache = new HashMap<>();\n     private final KeyValueDataSource dataSource;\n \n     public BlocksBloomStore(int noBlocks, int noConfirmations, KeyValueDataSource dataSource) {\n", "next_change": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 8ede7cbee..627ca7c4b 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -21,31 +21,17 @@ package co.rsk.logfilter;\n \n import org.ethereum.datasource.KeyValueDataSource;\n import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n /**\n- * Block blooms store\n- *\n- * It saves and retrieves coalesced bloom filters\n- *\n- * Each record represents a range of blocks\n- *\n- * The key is the block number of the first block in the range\n- *\n- * It keeps also an in-memory cache of those records\n- *\n  * Created by ajlopez on 05/02/2019.\n  */\n public class BlocksBloomStore {\n-    private static final Logger logger = LoggerFactory.getLogger(\"blooms\");\n-\n     private final int noBlocks;\n     private final int noConfirmations;\n-    private final Map<Long, BlocksBloom> blocksBloomCache = new HashMap<>();\n+    private final Map<Long, BlocksBloom> blocksBloom = new ConcurrentHashMap<>();\n     private final KeyValueDataSource dataSource;\n \n     public BlocksBloomStore(int noBlocks, int noConfirmations, KeyValueDataSource dataSource) {\n", "next_change": {"commit": "8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 627ca7c4b..2fb56e64d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -40,7 +40,7 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n-    public boolean hasBlockNumber(long blockNumber) {\n+    public synchronized boolean hasBlockNumber(long blockNumber) {\n         if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n             return true;\n         }\n", "next_change": {"commit": "66d033f432ba4789f324d63b635fac3bfea37470", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 2fb56e64d..135179ba6 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -41,7 +45,7 @@ public class BlocksBloomStore {\n     }\n \n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n+        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n             return true;\n         }\n \n", "next_change": {"commit": "9341e07da0897f24fe9349b21d6ed87e3c2c5658", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 135179ba6..4bd027d5d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -45,15 +45,18 @@ public class BlocksBloomStore {\n     }\n \n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n-            return true;\n-        }\n+        long key = this.firstNumberInRange(blockNumber);\n \n-        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n-            return true;\n-        }\n+        return hasBlockNumberInCache(key)\n+            || hasBlockNumberInStore(key);\n+    }\n+\n+    private boolean hasBlockNumberInStore(long key) {\n+        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n+    }\n \n-        return false;\n+    private boolean hasBlockNumberInCache(long key) {\n+        return this.blocksBloomCache.containsKey(key);\n     }\n \n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 4bd027d5d..8efc3ea82 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -59,6 +76,18 @@ public class BlocksBloomStore {\n         return this.blocksBloomCache.containsKey(key);\n     }\n \n+    /**\n+     * Retrieves the coalesced blooms record that contains\n+     * the bloom filter associated with the block corresponding\n+     * to the provided block number\n+     *\n+     * It retrieves the record from cache or from store\n+     *\n+     * If it is found in the store, it is added to the cache\n+     *\n+     * @param number\n+     * @return the BlocksBloom that contains that block number, null if absent\n+     */\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 8ede7cbee..627ca7c4b 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -54,44 +40,22 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n-    /**\n-     * Returns if a block number is included in one of the\n-     * group records (in persistence store or in cache)\n-     *\n-     * @param blockNumber block number to query\n-     * @return true if the block number is in some record, false if not\n-     */\n-    public synchronized boolean hasBlockNumber(long blockNumber) {\n-        long key = this.firstNumberInRange(blockNumber);\n-\n-        return hasBlockNumberInCache(key)\n-            || hasBlockNumberInStore(key);\n-    }\n+    public boolean hasBlockNumber(long blockNumber) {\n+        if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n+            return true;\n+        }\n \n-    private boolean hasBlockNumberInStore(long key) {\n-        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n-    }\n+        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n+            return true;\n+        }\n \n-    private boolean hasBlockNumberInCache(long key) {\n-        return this.blocksBloomCache.containsKey(key);\n+        return false;\n     }\n \n-    /**\n-     * Retrieves the coalesced blooms record that contains\n-     * the bloom filter associated with the block corresponding\n-     * to the provided block number\n-     *\n-     * It retrieves the record from cache or from store\n-     *\n-     * If it is found in the store, it is added to the cache\n-     *\n-     * @param number\n-     * @return the BlocksBloom that contains that block number, null if absent\n-     */\n-    public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n+    public BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n-        BlocksBloom blocksBloom = this.blocksBloomCache.get(key);\n+        BlocksBloom blocksBloom = this.blocksBloom.get(key);\n \n         if (blocksBloom != null) {\n             return blocksBloom;\n", "next_change": {"commit": "8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 627ca7c4b..2fb56e64d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -52,7 +52,7 @@ public class BlocksBloomStore {\n         return false;\n     }\n \n-    public BlocksBloom getBlocksBloomByNumber(long number) {\n+    public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n         BlocksBloom blocksBloom = this.blocksBloom.get(key);\n", "next_change": {"commit": "66d033f432ba4789f324d63b635fac3bfea37470", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 2fb56e64d..135179ba6 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -55,7 +59,7 @@ public class BlocksBloomStore {\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n-        BlocksBloom blocksBloom = this.blocksBloom.get(key);\n+        BlocksBloom blocksBloom = this.blocksBloomCache.get(key);\n \n         if (blocksBloom != null) {\n             return blocksBloom;\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 135179ba6..8efc3ea82 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -44,18 +54,40 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n+    /**\n+     * Returns if a block number is included in one of the\n+     * group records (in persistence store or in cache)\n+     *\n+     * @param blockNumber block number to query\n+     * @return true if the block number is in some record, false if not\n+     */\n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n-            return true;\n-        }\n+        long key = this.firstNumberInRange(blockNumber);\n \n-        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n-            return true;\n-        }\n+        return hasBlockNumberInCache(key)\n+            || hasBlockNumberInStore(key);\n+    }\n+\n+    private boolean hasBlockNumberInStore(long key) {\n+        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n+    }\n \n-        return false;\n+    private boolean hasBlockNumberInCache(long key) {\n+        return this.blocksBloomCache.containsKey(key);\n     }\n \n+    /**\n+     * Retrieves the coalesced blooms record that contains\n+     * the bloom filter associated with the block corresponding\n+     * to the provided block number\n+     *\n+     * It retrieves the record from cache or from store\n+     *\n+     * If it is found in the store, it is added to the cache\n+     *\n+     * @param number\n+     * @return the BlocksBloom that contains that block number, null if absent\n+     */\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxNjA4Mw==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r504516083", "body": "Looks like this method is not thread-safe. Shouldn't it be `synchronized`?", "bodyText": "Looks like this method is not thread-safe. Shouldn't it be synchronized?", "bodyHTML": "<p dir=\"auto\">Looks like this method is not thread-safe. Shouldn't it be <code>synchronized</code>?</p>", "author": "Vovchyk", "createdAt": "2020-10-14T08:59:19Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.logfilter;\n+\n+import org.ethereum.core.Bloom;\n+import org.ethereum.db.BlockStore;\n+\n+/**\n+ * Created by ajlopez on 29/09/2020.\n+ */\n+public class BlocksBloomProcessor {\n+    private final BlocksBloomStore blocksBloomStore;\n+    private final BlockStore blockStore;\n+\n+    private BlocksBloom blocksBloomInProcess = null;\n+\n+    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n+        this.blocksBloomStore = blocksBloomStore;\n+        this.blockStore = blockStore;\n+    }\n+\n+    public BlocksBloom getBlocksBloomInProcess() {\n+        return this.blocksBloomInProcess;\n+    }\n+\n+    public void processNewBlockNumber(long newBlockNumber) {", "originalCommit": "742c5282110aaaeed4c569f600db2e973a14526a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzMjkyOQ==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r505032929", "bodyText": "Currently only one thread at a time access this method, but yes, it could be fragile if new changes are added to the block processing logic (like processing blocks in multiple threads). So, done!", "author": "ajlopezrsk", "createdAt": "2020-10-14T22:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUxNjA4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c8797d3860b1c70dec138220320b4a57c870c496", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nindex cad6a3280..03596ac8c 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -36,50 +49,58 @@ public class BlocksBloomProcessor {\n         this.blockStore = blockStore;\n     }\n \n+    @VisibleForTesting\n     public BlocksBloom getBlocksBloomInProcess() {\n         return this.blocksBloomInProcess;\n     }\n \n-    public void processNewBlockNumber(long newBlockNumber) {\n+    /**\n+     * Receives the new height to process.\n+     * Processes the block blooms up to that height minus the number of needed confirmations\n+     *\n+     * @param newBlockNumber    the new height to process\n+     */\n+    public synchronized void processNewBlockNumber(long newBlockNumber) {\n+        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n+            return;\n+        }\n+\n         long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n \n-        addBlocksUpToNumber(blockNumber);\n+        if (!alreadyAdded(blockNumber)) {\n+            for (long aBlockNumber = fromBlock(blockNumber); aBlockNumber <= blockNumber; aBlockNumber++) {\n+                this.addBlock(aBlockNumber);\n+            }\n+        }\n     }\n \n-    private void addBlocksUpToNumber(long blockNumber) {\n-        if (this.blocksBloomStore.hasBlockNumber(blockNumber)) {\n-            return;\n-        }\n+    private boolean alreadyAdded(long blockNumber) {\n+        return this.blocksBloomStore.hasBlockNumber(blockNumber) ||\n+                (this.blocksBloomInProcess != null && this.blocksBloomInProcess.hasBlockBloom(blockNumber));\n+    }\n \n+    private long fromBlock(long blockNumber) {\n         long fromBlock;\n-\n         if (this.blocksBloomInProcess == null) {\n             this.blocksBloomInProcess = new BlocksBloom();\n-            fromBlock = this.blocksBloomStore.\n-                    firstNumberInRange(blockNumber);\n+            fromBlock = this.blocksBloomStore.firstNumberInRange(blockNumber);\n         }\n         else {\n             fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n         }\n-\n-        if (this.blocksBloomInProcess.hasBlockBloom(blockNumber)) {\n-            return;\n-        }\n-\n-        for (long nb = fromBlock; nb <= blockNumber; nb++) {\n-            this.addBlock(nb);\n-        }\n+        return fromBlock;\n     }\n \n+    /**\n+     * Reads and collect the bloom from the block that corresponds to the provided block number\n+     *\n+     * If the BlocksBloom instance is fulfilled, it is saved into the store\n+     * and a new instance will be created at the process of the next block number\n+     *\n+     * @param blockNumber block number to process\n+     */\n     private void addBlock(long blockNumber) {\n-        Bloom bloom;\n-\n-        if (blockNumber > 0) {\n-            bloom = new Bloom(this.blockStore.getChainBlockByNumber(blockNumber).getLogBloom());\n-        }\n-        else {\n-            bloom = new Bloom();\n-        }\n+        Bloom bloom = bloomByBlockNumber(blockNumber);\n \n         if (this.blocksBloomInProcess == null) {\n             this.blocksBloomInProcess = new BlocksBloom();\n", "next_change": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\ndeleted file mode 100644\nindex 03596ac8c..000000000\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,127 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2017 RSK Labs Ltd.\n- * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.logfilter;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import org.ethereum.core.Bloom;\n-import org.ethereum.db.BlockStore;\n-\n-/**\n- * Process bloom filters from blocks\n- *\n- * It collects bloom filter from flocks with enough confirmations\n- * grouping then in a BlocksBloom instance\n- *\n- * When a new height should be processed, the\n- * BlocksBloom instance is feeded with the block blooms\n- * up to that height\n- *\n- * When the BlocksBloom instance is filled, it is saved into the BlocksBloomStore\n- * and a new instance starts to be processed\n- *\n- * Created by ajlopez on 29/09/2020.\n- */\n-public class BlocksBloomProcessor {\n-    private final BlocksBloomStore blocksBloomStore;\n-    private final BlockStore blockStore;\n-\n-    private BlocksBloom blocksBloomInProcess = null;\n-\n-    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n-        this.blocksBloomStore = blocksBloomStore;\n-        this.blockStore = blockStore;\n-    }\n-\n-    @VisibleForTesting\n-    public BlocksBloom getBlocksBloomInProcess() {\n-        return this.blocksBloomInProcess;\n-    }\n-\n-    /**\n-     * Receives the new height to process.\n-     * Processes the block blooms up to that height minus the number of needed confirmations\n-     *\n-     * @param newBlockNumber    the new height to process\n-     */\n-    public synchronized void processNewBlockNumber(long newBlockNumber) {\n-        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n-            return;\n-        }\n-\n-        long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n-\n-        if (!alreadyAdded(blockNumber)) {\n-            for (long aBlockNumber = fromBlock(blockNumber); aBlockNumber <= blockNumber; aBlockNumber++) {\n-                this.addBlock(aBlockNumber);\n-            }\n-        }\n-    }\n-\n-    private boolean alreadyAdded(long blockNumber) {\n-        return this.blocksBloomStore.hasBlockNumber(blockNumber) ||\n-                (this.blocksBloomInProcess != null && this.blocksBloomInProcess.hasBlockBloom(blockNumber));\n-    }\n-\n-    private long fromBlock(long blockNumber) {\n-        long fromBlock;\n-        if (this.blocksBloomInProcess == null) {\n-            this.blocksBloomInProcess = new BlocksBloom();\n-            fromBlock = this.blocksBloomStore.firstNumberInRange(blockNumber);\n-        }\n-        else {\n-            fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n-        }\n-        return fromBlock;\n-    }\n-\n-    /**\n-     * Reads and collect the bloom from the block that corresponds to the provided block number\n-     *\n-     * If the BlocksBloom instance is fulfilled, it is saved into the store\n-     * and a new instance will be created at the process of the next block number\n-     *\n-     * @param blockNumber block number to process\n-     */\n-    private void addBlock(long blockNumber) {\n-        Bloom bloom = bloomByBlockNumber(blockNumber);\n-\n-        if (this.blocksBloomInProcess == null) {\n-            this.blocksBloomInProcess = new BlocksBloom();\n-        }\n-\n-        this.blocksBloomInProcess.addBlockBloom(blockNumber, bloom);\n-\n-        if (blockNumber == this.blocksBloomStore.lastNumberInRange(blockNumber)) {\n-            this.blocksBloomStore.addBlocksBloom(this.blocksBloomInProcess);\n-            this.blocksBloomInProcess = null;\n-        }\n-    }\n-\n-    private Bloom bloomByBlockNumber(long blockNumber) {\n-        Bloom bloom;\n-        if (blockNumber > 0) {\n-            bloom = this.blockStore.bloomByBlockNumber(blockNumber);\n-        }\n-        else {\n-            bloom = new Bloom();\n-        }\n-        return bloom;\n-    }\n-}\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nnew file mode 100644\nindex 000000000..19fe30aff\n--- /dev/null\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.logfilter;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.ethereum.core.Bloom;\n+import org.ethereum.db.BlockStore;\n+\n+/**\n+ * Process bloom filters from blocks\n+ *\n+ * It collects bloom filter from flocks with enough confirmations\n+ * grouping then in a BlocksBloom instance\n+ *\n+ * When a new height should be processed, the\n+ * BlocksBloom instance is feeded with the block blooms\n+ * up to that height\n+ *\n+ * When the BlocksBloom instance is filled, it is saved into the BlocksBloomStore\n+ * and a new instance starts to be processed\n+ *\n+ * Created by ajlopez on 29/09/2020.\n+ */\n+public class BlocksBloomProcessor {\n+    private final BlocksBloomStore blocksBloomStore;\n+    private final BlockStore blockStore;\n+\n+    private BlocksBloom blocksBloomInProcess = null;\n+\n+    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n+        this.blocksBloomStore = blocksBloomStore;\n+        this.blockStore = blockStore;\n+    }\n+\n+    @VisibleForTesting\n+    public BlocksBloom getBlocksBloomInProcess() {\n+        return this.blocksBloomInProcess;\n+    }\n+\n+    /**\n+     * Receives the new height to process.\n+     * Processes the block blooms up to that height minus the number of needed confirmations\n+     *\n+     * @param newBlockNumber    the new height to process\n+     */\n+    public synchronized void processNewBlockNumber(long newBlockNumber) {\n+        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n+            return;\n+        }\n+\n+        long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n+\n+        addBlocksUpToNumber(blockNumber);\n+    }\n+\n+    /**\n+     * Reads and collect block blooms up the the provided block number\n+     *\n+     * @param blockNumber top block number to process\n+     */\n+    private void addBlocksUpToNumber(long blockNumber) {\n+        if (this.blocksBloomStore.hasBlockNumber(blockNumber)) {\n+            return;\n+        }\n+\n+        long fromBlock;\n+\n+        if (this.blocksBloomInProcess == null) {\n+            this.blocksBloomInProcess = new BlocksBloom();\n+            fromBlock = this.blocksBloomStore.\n+                    firstNumberInRange(blockNumber);\n+        }\n+        else {\n+            fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n+        }\n+\n+        if (this.blocksBloomInProcess.hasBlockBloom(blockNumber)) {\n+            return;\n+        }\n+\n+        for (long nb = fromBlock; nb <= blockNumber; nb++) {\n+            this.addBlock(nb);\n+        }\n+    }\n+\n+    /**\n+     * Reads and collect the bloom from the block that corresponds to the provided block number\n+     *\n+     * If the BlocksBloom instance is fulfilled, it is saved into the store\n+     * and a new instance will be created at the process of the next block number\n+     *\n+     * @param blockNumber block number to process\n+     */\n+    private void addBlock(long blockNumber) {\n+        Bloom bloom;\n+\n+        if (blockNumber > 0) {\n+            bloom = new Bloom(this.blockStore.getChainBlockByNumber(blockNumber).getLogBloom());\n+        }\n+        else {\n+            bloom = new Bloom();\n+        }\n+\n+        if (this.blocksBloomInProcess == null) {\n+            this.blocksBloomInProcess = new BlocksBloom();\n+        }\n+\n+        this.blocksBloomInProcess.addBlockBloom(blockNumber, bloom);\n+\n+        if (blockNumber == this.blocksBloomStore.lastNumberInRange(blockNumber)) {\n+            this.blocksBloomStore.addBlocksBloom(this.blocksBloomInProcess);\n+            this.blocksBloomInProcess = null;\n+        }\n+    }\n+}\n", "next_change": {"commit": "3a1c66e92205d514c6ad019b9ff9859300460fca", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nindex 19fe30aff..03596ac8c 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -129,4 +113,15 @@ public class BlocksBloomProcessor {\n             this.blocksBloomInProcess = null;\n         }\n     }\n+\n+    private Bloom bloomByBlockNumber(long blockNumber) {\n+        Bloom bloom;\n+        if (blockNumber > 0) {\n+            bloom = this.blockStore.bloomByBlockNumber(blockNumber);\n+        }\n+        else {\n+            bloom = new Bloom();\n+        }\n+        return bloom;\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyMDcxMA==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r504520710", "body": "`blocksBloomInProcess` field is not synchronized. And it looks like it's only needed for unit testing. Shouldn't the method be marked as `synchronized` or `VisibleForTesting`?", "bodyText": "blocksBloomInProcess field is not synchronized. And it looks like it's only needed for unit testing. Shouldn't the method be marked as synchronized or VisibleForTesting?", "bodyHTML": "<p dir=\"auto\"><code>blocksBloomInProcess</code> field is not synchronized. And it looks like it's only needed for unit testing. Shouldn't the method be marked as <code>synchronized</code> or <code>VisibleForTesting</code>?</p>", "author": "Vovchyk", "createdAt": "2020-10-14T09:06:11Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.logfilter;\n+\n+import org.ethereum.core.Bloom;\n+import org.ethereum.db.BlockStore;\n+\n+/**\n+ * Created by ajlopez on 29/09/2020.\n+ */\n+public class BlocksBloomProcessor {\n+    private final BlocksBloomStore blocksBloomStore;\n+    private final BlockStore blockStore;\n+\n+    private BlocksBloom blocksBloomInProcess = null;\n+\n+    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n+        this.blocksBloomStore = blocksBloomStore;\n+        this.blockStore = blockStore;\n+    }\n+\n+    public BlocksBloom getBlocksBloomInProcess() {\n+        return this.blocksBloomInProcess;", "originalCommit": "742c5282110aaaeed4c569f600db2e973a14526a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAzMzEwMg==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r505033102", "bodyText": "Done", "author": "ajlopezrsk", "createdAt": "2020-10-14T22:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUyMDcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "c8797d3860b1c70dec138220320b4a57c870c496", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nindex cad6a3280..03596ac8c 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -36,50 +49,58 @@ public class BlocksBloomProcessor {\n         this.blockStore = blockStore;\n     }\n \n+    @VisibleForTesting\n     public BlocksBloom getBlocksBloomInProcess() {\n         return this.blocksBloomInProcess;\n     }\n \n-    public void processNewBlockNumber(long newBlockNumber) {\n+    /**\n+     * Receives the new height to process.\n+     * Processes the block blooms up to that height minus the number of needed confirmations\n+     *\n+     * @param newBlockNumber    the new height to process\n+     */\n+    public synchronized void processNewBlockNumber(long newBlockNumber) {\n+        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n+            return;\n+        }\n+\n         long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n \n-        addBlocksUpToNumber(blockNumber);\n+        if (!alreadyAdded(blockNumber)) {\n+            for (long aBlockNumber = fromBlock(blockNumber); aBlockNumber <= blockNumber; aBlockNumber++) {\n+                this.addBlock(aBlockNumber);\n+            }\n+        }\n     }\n \n-    private void addBlocksUpToNumber(long blockNumber) {\n-        if (this.blocksBloomStore.hasBlockNumber(blockNumber)) {\n-            return;\n-        }\n+    private boolean alreadyAdded(long blockNumber) {\n+        return this.blocksBloomStore.hasBlockNumber(blockNumber) ||\n+                (this.blocksBloomInProcess != null && this.blocksBloomInProcess.hasBlockBloom(blockNumber));\n+    }\n \n+    private long fromBlock(long blockNumber) {\n         long fromBlock;\n-\n         if (this.blocksBloomInProcess == null) {\n             this.blocksBloomInProcess = new BlocksBloom();\n-            fromBlock = this.blocksBloomStore.\n-                    firstNumberInRange(blockNumber);\n+            fromBlock = this.blocksBloomStore.firstNumberInRange(blockNumber);\n         }\n         else {\n             fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n         }\n-\n-        if (this.blocksBloomInProcess.hasBlockBloom(blockNumber)) {\n-            return;\n-        }\n-\n-        for (long nb = fromBlock; nb <= blockNumber; nb++) {\n-            this.addBlock(nb);\n-        }\n+        return fromBlock;\n     }\n \n+    /**\n+     * Reads and collect the bloom from the block that corresponds to the provided block number\n+     *\n+     * If the BlocksBloom instance is fulfilled, it is saved into the store\n+     * and a new instance will be created at the process of the next block number\n+     *\n+     * @param blockNumber block number to process\n+     */\n     private void addBlock(long blockNumber) {\n-        Bloom bloom;\n-\n-        if (blockNumber > 0) {\n-            bloom = new Bloom(this.blockStore.getChainBlockByNumber(blockNumber).getLogBloom());\n-        }\n-        else {\n-            bloom = new Bloom();\n-        }\n+        Bloom bloom = bloomByBlockNumber(blockNumber);\n \n         if (this.blocksBloomInProcess == null) {\n             this.blocksBloomInProcess = new BlocksBloom();\n", "next_change": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\ndeleted file mode 100644\nindex 03596ac8c..000000000\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ /dev/null\n", "chunk": "@@ -1,127 +0,0 @@\n-/*\n- * This file is part of RskJ\n- * Copyright (C) 2017 RSK Labs Ltd.\n- * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n- *\n- * This program is free software: you can redistribute it and/or modify\n- * it under the terms of the GNU Lesser General Public License as published by\n- * the Free Software Foundation, either version 3 of the License, or\n- * (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this program. If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package co.rsk.logfilter;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import org.ethereum.core.Bloom;\n-import org.ethereum.db.BlockStore;\n-\n-/**\n- * Process bloom filters from blocks\n- *\n- * It collects bloom filter from flocks with enough confirmations\n- * grouping then in a BlocksBloom instance\n- *\n- * When a new height should be processed, the\n- * BlocksBloom instance is feeded with the block blooms\n- * up to that height\n- *\n- * When the BlocksBloom instance is filled, it is saved into the BlocksBloomStore\n- * and a new instance starts to be processed\n- *\n- * Created by ajlopez on 29/09/2020.\n- */\n-public class BlocksBloomProcessor {\n-    private final BlocksBloomStore blocksBloomStore;\n-    private final BlockStore blockStore;\n-\n-    private BlocksBloom blocksBloomInProcess = null;\n-\n-    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n-        this.blocksBloomStore = blocksBloomStore;\n-        this.blockStore = blockStore;\n-    }\n-\n-    @VisibleForTesting\n-    public BlocksBloom getBlocksBloomInProcess() {\n-        return this.blocksBloomInProcess;\n-    }\n-\n-    /**\n-     * Receives the new height to process.\n-     * Processes the block blooms up to that height minus the number of needed confirmations\n-     *\n-     * @param newBlockNumber    the new height to process\n-     */\n-    public synchronized void processNewBlockNumber(long newBlockNumber) {\n-        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n-            return;\n-        }\n-\n-        long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n-\n-        if (!alreadyAdded(blockNumber)) {\n-            for (long aBlockNumber = fromBlock(blockNumber); aBlockNumber <= blockNumber; aBlockNumber++) {\n-                this.addBlock(aBlockNumber);\n-            }\n-        }\n-    }\n-\n-    private boolean alreadyAdded(long blockNumber) {\n-        return this.blocksBloomStore.hasBlockNumber(blockNumber) ||\n-                (this.blocksBloomInProcess != null && this.blocksBloomInProcess.hasBlockBloom(blockNumber));\n-    }\n-\n-    private long fromBlock(long blockNumber) {\n-        long fromBlock;\n-        if (this.blocksBloomInProcess == null) {\n-            this.blocksBloomInProcess = new BlocksBloom();\n-            fromBlock = this.blocksBloomStore.firstNumberInRange(blockNumber);\n-        }\n-        else {\n-            fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n-        }\n-        return fromBlock;\n-    }\n-\n-    /**\n-     * Reads and collect the bloom from the block that corresponds to the provided block number\n-     *\n-     * If the BlocksBloom instance is fulfilled, it is saved into the store\n-     * and a new instance will be created at the process of the next block number\n-     *\n-     * @param blockNumber block number to process\n-     */\n-    private void addBlock(long blockNumber) {\n-        Bloom bloom = bloomByBlockNumber(blockNumber);\n-\n-        if (this.blocksBloomInProcess == null) {\n-            this.blocksBloomInProcess = new BlocksBloom();\n-        }\n-\n-        this.blocksBloomInProcess.addBlockBloom(blockNumber, bloom);\n-\n-        if (blockNumber == this.blocksBloomStore.lastNumberInRange(blockNumber)) {\n-            this.blocksBloomStore.addBlocksBloom(this.blocksBloomInProcess);\n-            this.blocksBloomInProcess = null;\n-        }\n-    }\n-\n-    private Bloom bloomByBlockNumber(long blockNumber) {\n-        Bloom bloom;\n-        if (blockNumber > 0) {\n-            bloom = this.blockStore.bloomByBlockNumber(blockNumber);\n-        }\n-        else {\n-            bloom = new Bloom();\n-        }\n-        return bloom;\n-    }\n-}\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nnew file mode 100644\nindex 000000000..19fe30aff\n--- /dev/null\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -0,0 +1,132 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package co.rsk.logfilter;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.ethereum.core.Bloom;\n+import org.ethereum.db.BlockStore;\n+\n+/**\n+ * Process bloom filters from blocks\n+ *\n+ * It collects bloom filter from flocks with enough confirmations\n+ * grouping then in a BlocksBloom instance\n+ *\n+ * When a new height should be processed, the\n+ * BlocksBloom instance is feeded with the block blooms\n+ * up to that height\n+ *\n+ * When the BlocksBloom instance is filled, it is saved into the BlocksBloomStore\n+ * and a new instance starts to be processed\n+ *\n+ * Created by ajlopez on 29/09/2020.\n+ */\n+public class BlocksBloomProcessor {\n+    private final BlocksBloomStore blocksBloomStore;\n+    private final BlockStore blockStore;\n+\n+    private BlocksBloom blocksBloomInProcess = null;\n+\n+    public BlocksBloomProcessor(BlocksBloomStore blocksBloomStore, BlockStore blockStore) {\n+        this.blocksBloomStore = blocksBloomStore;\n+        this.blockStore = blockStore;\n+    }\n+\n+    @VisibleForTesting\n+    public BlocksBloom getBlocksBloomInProcess() {\n+        return this.blocksBloomInProcess;\n+    }\n+\n+    /**\n+     * Receives the new height to process.\n+     * Processes the block blooms up to that height minus the number of needed confirmations\n+     *\n+     * @param newBlockNumber    the new height to process\n+     */\n+    public synchronized void processNewBlockNumber(long newBlockNumber) {\n+        if (newBlockNumber < this.blocksBloomStore.getNoConfirmations()) {\n+            return;\n+        }\n+\n+        long blockNumber = newBlockNumber - this.blocksBloomStore.getNoConfirmations();\n+\n+        addBlocksUpToNumber(blockNumber);\n+    }\n+\n+    /**\n+     * Reads and collect block blooms up the the provided block number\n+     *\n+     * @param blockNumber top block number to process\n+     */\n+    private void addBlocksUpToNumber(long blockNumber) {\n+        if (this.blocksBloomStore.hasBlockNumber(blockNumber)) {\n+            return;\n+        }\n+\n+        long fromBlock;\n+\n+        if (this.blocksBloomInProcess == null) {\n+            this.blocksBloomInProcess = new BlocksBloom();\n+            fromBlock = this.blocksBloomStore.\n+                    firstNumberInRange(blockNumber);\n+        }\n+        else {\n+            fromBlock = this.blocksBloomInProcess.toBlock() + 1;\n+        }\n+\n+        if (this.blocksBloomInProcess.hasBlockBloom(blockNumber)) {\n+            return;\n+        }\n+\n+        for (long nb = fromBlock; nb <= blockNumber; nb++) {\n+            this.addBlock(nb);\n+        }\n+    }\n+\n+    /**\n+     * Reads and collect the bloom from the block that corresponds to the provided block number\n+     *\n+     * If the BlocksBloom instance is fulfilled, it is saved into the store\n+     * and a new instance will be created at the process of the next block number\n+     *\n+     * @param blockNumber block number to process\n+     */\n+    private void addBlock(long blockNumber) {\n+        Bloom bloom;\n+\n+        if (blockNumber > 0) {\n+            bloom = new Bloom(this.blockStore.getChainBlockByNumber(blockNumber).getLogBloom());\n+        }\n+        else {\n+            bloom = new Bloom();\n+        }\n+\n+        if (this.blocksBloomInProcess == null) {\n+            this.blocksBloomInProcess = new BlocksBloom();\n+        }\n+\n+        this.blocksBloomInProcess.addBlockBloom(blockNumber, bloom);\n+\n+        if (blockNumber == this.blocksBloomStore.lastNumberInRange(blockNumber)) {\n+            this.blocksBloomStore.addBlocksBloom(this.blocksBloomInProcess);\n+            this.blocksBloomInProcess = null;\n+        }\n+    }\n+}\n", "next_change": {"commit": "3a1c66e92205d514c6ad019b9ff9859300460fca", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\nindex 19fe30aff..03596ac8c 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomProcessor.java\n", "chunk": "@@ -129,4 +113,15 @@ public class BlocksBloomProcessor {\n             this.blocksBloomInProcess = null;\n         }\n     }\n+\n+    private Bloom bloomByBlockNumber(long blockNumber) {\n+        Bloom bloom;\n+        if (blockNumber > 0) {\n+            bloom = this.blockStore.bloomByBlockNumber(blockNumber);\n+        }\n+        else {\n+            bloom = new Bloom();\n+        }\n+        return bloom;\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMwMTAzMg==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r509301032", "body": "shouldn't we limit the size of this map?", "bodyText": "shouldn't we limit the size of this map?", "bodyHTML": "<p dir=\"auto\">shouldn't we limit the size of this map?</p>", "author": "Vovchyk", "createdAt": "2020-10-21T13:49:03Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java", "diffHunk": "@@ -21,17 +21,31 @@\n \n import org.ethereum.datasource.KeyValueDataSource;\n import org.ethereum.vm.DataWord;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n+import java.util.HashMap;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n \n /**\n+ * Block blooms store\n+ *\n+ * It saves and retrieves coalesced bloom filters\n+ *\n+ * Each record represents a range of blocks\n+ *\n+ * The key is the block number of the first block in the range\n+ *\n+ * It keeps also an in-memory cache of those records\n+ *\n  * Created by ajlopez on 05/02/2019.\n  */\n public class BlocksBloomStore {\n+    private static final Logger logger = LoggerFactory.getLogger(\"blooms\");\n+\n     private final int noBlocks;\n     private final int noConfirmations;\n-    private final Map<Long, BlocksBloom> blocksBloom = new ConcurrentHashMap<>();\n+    private final Map<Long, BlocksBloom> blocksBloomCache = new HashMap<>();", "originalCommit": "92b5ae45306d70068a406d779637b6607b01a4fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUwMjAxMg==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r509502012", "bodyText": "Good. But I though it should be to refine in another tasks. The idea is to not be disruptive with the current behavior the main consumers of the logs have now (like Lumino and token bridge). And all this work (the new blooms) are optional, only to be adopted by power users.\nEven with 2 millions of blocks, the used memory should be few megabytes.", "author": "ajlopezrsk", "createdAt": "2020-10-21T17:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMwMTAzMg=="}], "type": "inlineReview", "revised_code": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 8ede7cbee..627ca7c4b 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -21,31 +21,17 @@ package co.rsk.logfilter;\n \n import org.ethereum.datasource.KeyValueDataSource;\n import org.ethereum.vm.DataWord;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import java.util.HashMap;\n import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n \n /**\n- * Block blooms store\n- *\n- * It saves and retrieves coalesced bloom filters\n- *\n- * Each record represents a range of blocks\n- *\n- * The key is the block number of the first block in the range\n- *\n- * It keeps also an in-memory cache of those records\n- *\n  * Created by ajlopez on 05/02/2019.\n  */\n public class BlocksBloomStore {\n-    private static final Logger logger = LoggerFactory.getLogger(\"blooms\");\n-\n     private final int noBlocks;\n     private final int noConfirmations;\n-    private final Map<Long, BlocksBloom> blocksBloomCache = new HashMap<>();\n+    private final Map<Long, BlocksBloom> blocksBloom = new ConcurrentHashMap<>();\n     private final KeyValueDataSource dataSource;\n \n     public BlocksBloomStore(int noBlocks, int noConfirmations, KeyValueDataSource dataSource) {\n", "next_change": {"commit": "8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 627ca7c4b..2fb56e64d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -40,7 +40,7 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n-    public boolean hasBlockNumber(long blockNumber) {\n+    public synchronized boolean hasBlockNumber(long blockNumber) {\n         if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n             return true;\n         }\n", "next_change": {"commit": "66d033f432ba4789f324d63b635fac3bfea37470", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 2fb56e64d..135179ba6 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -41,7 +45,7 @@ public class BlocksBloomStore {\n     }\n \n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n+        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n             return true;\n         }\n \n", "next_change": {"commit": "9341e07da0897f24fe9349b21d6ed87e3c2c5658", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 135179ba6..4bd027d5d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -45,15 +45,18 @@ public class BlocksBloomStore {\n     }\n \n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n-            return true;\n-        }\n+        long key = this.firstNumberInRange(blockNumber);\n \n-        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n-            return true;\n-        }\n+        return hasBlockNumberInCache(key)\n+            || hasBlockNumberInStore(key);\n+    }\n+\n+    private boolean hasBlockNumberInStore(long key) {\n+        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n+    }\n \n-        return false;\n+    private boolean hasBlockNumberInCache(long key) {\n+        return this.blocksBloomCache.containsKey(key);\n     }\n \n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 4bd027d5d..8efc3ea82 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -59,6 +76,18 @@ public class BlocksBloomStore {\n         return this.blocksBloomCache.containsKey(key);\n     }\n \n+    /**\n+     * Retrieves the coalesced blooms record that contains\n+     * the bloom filter associated with the block corresponding\n+     * to the provided block number\n+     *\n+     * It retrieves the record from cache or from store\n+     *\n+     * If it is found in the store, it is added to the cache\n+     *\n+     * @param number\n+     * @return the BlocksBloom that contains that block number, null if absent\n+     */\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk1NjQwOA==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r501956408", "body": "Shouldn't be?\r\n```java\r\n!this.empty && this.fromBlock <= blockNumber && blockNumber <= this.toBlock;\r\n```", "bodyText": "Shouldn't be?\n!this.empty && this.fromBlock <= blockNumber && blockNumber <= this.toBlock;", "bodyHTML": "<p dir=\"auto\">Shouldn't be?</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"!this.empty &amp;&amp; this.fromBlock &lt;= blockNumber &amp;&amp; blockNumber &lt;= this.toBlock;\n\"><pre><span class=\"pl-k\">!</span><span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>empty <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>fromBlock <span class=\"pl-k\">&lt;=</span> blockNumber <span class=\"pl-k\">&amp;&amp;</span> blockNumber <span class=\"pl-k\">&lt;=</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>toBlock;</pre></div>", "author": "fedejinich", "createdAt": "2020-10-08T19:17:27Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloom.java", "diffHunk": "@@ -58,6 +58,14 @@ public long size() {\n         return this.toBlock - this.fromBlock + 1;\n     }\n \n+    public boolean hasBlockBloom(long blockNumber) {\n+        if (this.empty) {\n+            return false;\n+        }\n+\n+        return this.fromBlock <= blockNumber && blockNumber <= this.toBlock;", "originalCommit": "e601ebc1fef4d56f7233b6d05d9f234f9da12be6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY1NTUyNg==", "url": "https://github.com/rsksmart/rskj/pull/1327#discussion_r502655526", "body": "it'd be nice to abstract complex conditions\r\n\r\nmaybe something like this?\r\n```java\r\n    public synchronized boolean hasBlockNumber(long blockNumber) {\r\n        // if a block is contained in a block range\r\n        long firstNumber = this.firstNumberInRange(blockNumber);\r\n        \r\n        return isBlockInCache(firstNumber) || isBlockInDataSource(firstNumber);\r\n    }\r\n\r\n    private boolean isBlockInDataSource(long firstNumber) {\r\n        return this.dataSource != null && this.dataSource.get(longToKey(firstNumber)) != null;\r\n    }\r\n\r\n    private boolean isBlockInCache(long firstNumber) {\r\n        return this.blocksBloom.containsKey(firstNumber);\r\n    }\r\n```", "bodyText": "it'd be nice to abstract complex conditions\nmaybe something like this?\n    public synchronized boolean hasBlockNumber(long blockNumber) {\n        // if a block is contained in a block range\n        long firstNumber = this.firstNumberInRange(blockNumber);\n        \n        return isBlockInCache(firstNumber) || isBlockInDataSource(firstNumber);\n    }\n\n    private boolean isBlockInDataSource(long firstNumber) {\n        return this.dataSource != null && this.dataSource.get(longToKey(firstNumber)) != null;\n    }\n\n    private boolean isBlockInCache(long firstNumber) {\n        return this.blocksBloom.containsKey(firstNumber);\n    }", "bodyHTML": "<p dir=\"auto\">it'd be nice to abstract complex conditions</p>\n<p dir=\"auto\">maybe something like this?</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    public synchronized boolean hasBlockNumber(long blockNumber) {\n        // if a block is contained in a block range\n        long firstNumber = this.firstNumberInRange(blockNumber);\n        \n        return isBlockInCache(firstNumber) || isBlockInDataSource(firstNumber);\n    }\n\n    private boolean isBlockInDataSource(long firstNumber) {\n        return this.dataSource != null &amp;&amp; this.dataSource.get(longToKey(firstNumber)) != null;\n    }\n\n    private boolean isBlockInCache(long firstNumber) {\n        return this.blocksBloom.containsKey(firstNumber);\n    }\n\"><pre>    <span class=\"pl-k\">public</span> <span class=\"pl-k\">synchronized</span> <span class=\"pl-k\">boolean</span> hasBlockNumber(<span class=\"pl-k\">long</span> blockNumber) {\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> if a block is contained in a block range</span>\n        <span class=\"pl-k\">long</span> firstNumber <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>firstNumberInRange(blockNumber);\n        \n        <span class=\"pl-k\">return</span> isBlockInCache(firstNumber) <span class=\"pl-k\">||</span> isBlockInDataSource(firstNumber);\n    }\n\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> isBlockInDataSource(<span class=\"pl-k\">long</span> firstNumber) {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>dataSource <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>dataSource<span class=\"pl-k\">.</span>get(longToKey(firstNumber)) <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>;\n    }\n\n    <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> isBlockInCache(<span class=\"pl-k\">long</span> firstNumber) {\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>blocksBloom<span class=\"pl-k\">.</span>containsKey(firstNumber);\n    }</pre></div>", "author": "fedejinich", "createdAt": "2020-10-09T20:26:05Z", "path": "rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java", "diffHunk": "@@ -40,7 +44,7 @@ public BlocksBloomStore(int noBlocks, int noConfirmations, KeyValueDataSource da\n         this.dataSource = dataSource;\n     }\n \n-    public boolean hasBlockNumber(long blockNumber) {\n+    public synchronized boolean hasBlockNumber(long blockNumber) {", "originalCommit": "e601ebc1fef4d56f7233b6d05d9f234f9da12be6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c8797d3860b1c70dec138220320b4a57c870c496", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 947350b91..8ede7cbee 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -44,22 +54,44 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n+    /**\n+     * Returns if a block number is included in one of the\n+     * group records (in persistence store or in cache)\n+     *\n+     * @param blockNumber block number to query\n+     * @return true if the block number is in some record, false if not\n+     */\n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n-            return true;\n-        }\n+        long key = this.firstNumberInRange(blockNumber);\n \n-        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n-            return true;\n-        }\n+        return hasBlockNumberInCache(key)\n+            || hasBlockNumberInStore(key);\n+    }\n+\n+    private boolean hasBlockNumberInStore(long key) {\n+        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n+    }\n \n-        return false;\n+    private boolean hasBlockNumberInCache(long key) {\n+        return this.blocksBloomCache.containsKey(key);\n     }\n \n+    /**\n+     * Retrieves the coalesced blooms record that contains\n+     * the bloom filter associated with the block corresponding\n+     * to the provided block number\n+     *\n+     * It retrieves the record from cache or from store\n+     *\n+     * If it is found in the store, it is added to the cache\n+     *\n+     * @param number\n+     * @return the BlocksBloom that contains that block number, null if absent\n+     */\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n-        BlocksBloom blocksBloom = this.blocksBloom.get(key);\n+        BlocksBloom blocksBloom = this.blocksBloomCache.get(key);\n \n         if (blocksBloom != null) {\n             return blocksBloom;\n", "next_change": {"commit": "474fdc5288200305eebaefbc609bc448daf41212", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 8ede7cbee..627ca7c4b 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -54,44 +40,22 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n-    /**\n-     * Returns if a block number is included in one of the\n-     * group records (in persistence store or in cache)\n-     *\n-     * @param blockNumber block number to query\n-     * @return true if the block number is in some record, false if not\n-     */\n-    public synchronized boolean hasBlockNumber(long blockNumber) {\n-        long key = this.firstNumberInRange(blockNumber);\n-\n-        return hasBlockNumberInCache(key)\n-            || hasBlockNumberInStore(key);\n-    }\n+    public boolean hasBlockNumber(long blockNumber) {\n+        if (this.blocksBloom.containsKey(this.firstNumberInRange(blockNumber))) {\n+            return true;\n+        }\n \n-    private boolean hasBlockNumberInStore(long key) {\n-        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n-    }\n+        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n+            return true;\n+        }\n \n-    private boolean hasBlockNumberInCache(long key) {\n-        return this.blocksBloomCache.containsKey(key);\n+        return false;\n     }\n \n-    /**\n-     * Retrieves the coalesced blooms record that contains\n-     * the bloom filter associated with the block corresponding\n-     * to the provided block number\n-     *\n-     * It retrieves the record from cache or from store\n-     *\n-     * If it is found in the store, it is added to the cache\n-     *\n-     * @param number\n-     * @return the BlocksBloom that contains that block number, null if absent\n-     */\n-    public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n+    public BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n-        BlocksBloom blocksBloom = this.blocksBloomCache.get(key);\n+        BlocksBloom blocksBloom = this.blocksBloom.get(key);\n \n         if (blocksBloom != null) {\n             return blocksBloom;\n", "next_change": {"commit": "8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 627ca7c4b..2fb56e64d 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -52,7 +52,7 @@ public class BlocksBloomStore {\n         return false;\n     }\n \n-    public BlocksBloom getBlocksBloomByNumber(long number) {\n+    public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n         BlocksBloom blocksBloom = this.blocksBloom.get(key);\n", "next_change": {"commit": "66d033f432ba4789f324d63b635fac3bfea37470", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 2fb56e64d..135179ba6 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -55,7 +59,7 @@ public class BlocksBloomStore {\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n-        BlocksBloom blocksBloom = this.blocksBloom.get(key);\n+        BlocksBloom blocksBloom = this.blocksBloomCache.get(key);\n \n         if (blocksBloom != null) {\n             return blocksBloom;\n", "next_change": {"commit": "f6c3967ce60dfce452890206882115bdf55533a7", "changed_code": [{"header": "diff --git a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\nindex 135179ba6..8efc3ea82 100644\n--- a/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n+++ b/rskj-core/src/main/java/co/rsk/logfilter/BlocksBloomStore.java\n", "chunk": "@@ -44,18 +54,40 @@ public class BlocksBloomStore {\n         this.dataSource = dataSource;\n     }\n \n+    /**\n+     * Returns if a block number is included in one of the\n+     * group records (in persistence store or in cache)\n+     *\n+     * @param blockNumber block number to query\n+     * @return true if the block number is in some record, false if not\n+     */\n     public synchronized boolean hasBlockNumber(long blockNumber) {\n-        if (this.blocksBloomCache.containsKey(this.firstNumberInRange(blockNumber))) {\n-            return true;\n-        }\n+        long key = this.firstNumberInRange(blockNumber);\n \n-        if (this.dataSource != null && this.dataSource.get(longToKey(blockNumber)) != null) {\n-            return true;\n-        }\n+        return hasBlockNumberInCache(key)\n+            || hasBlockNumberInStore(key);\n+    }\n+\n+    private boolean hasBlockNumberInStore(long key) {\n+        return this.dataSource != null && this.dataSource.get(longToKey(key)) != null;\n+    }\n \n-        return false;\n+    private boolean hasBlockNumberInCache(long key) {\n+        return this.blocksBloomCache.containsKey(key);\n     }\n \n+    /**\n+     * Retrieves the coalesced blooms record that contains\n+     * the bloom filter associated with the block corresponding\n+     * to the provided block number\n+     *\n+     * It retrieves the record from cache or from store\n+     *\n+     * If it is found in the store, it is added to the cache\n+     *\n+     * @param number\n+     * @return the BlocksBloom that contains that block number, null if absent\n+     */\n     public synchronized BlocksBloom getBlocksBloomByNumber(long number) {\n         long key = firstNumberInRange(number);\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "c8797d3860b1c70dec138220320b4a57c870c496", "url": "https://github.com/rsksmart/rskj/commit/c8797d3860b1c70dec138220320b4a57c870c496", "message": "extracted methods for BlocksBloomProcessor", "committedDate": "2020-10-26T11:46:07Z", "type": "forcePushed"}, {"oid": "9052665e08dae3d60f9767a9932ccde20f898898", "url": "https://github.com/rsksmart/rskj/commit/9052665e08dae3d60f9767a9932ccde20f898898", "message": "extracted methods for BlocksBloomProcessor", "committedDate": "2020-11-11T18:21:16Z", "type": "forcePushed"}, {"oid": "474fdc5288200305eebaefbc609bc448daf41212", "url": "https://github.com/rsksmart/rskj/commit/474fdc5288200305eebaefbc609bc448daf41212", "message": "Adding blocks to BlocksBloomBuilder", "committedDate": "2020-11-12T17:35:58Z", "type": "commit"}, {"oid": "b5ad363c2c5d406b5f3a049853dd52eb597f042d", "url": "https://github.com/rsksmart/rskj/commit/b5ad363c2c5d406b5f3a049853dd52eb597f042d", "message": "BlocksBloomBuilder saves BlocksBloom in process", "committedDate": "2020-11-12T17:35:59Z", "type": "commit"}, {"oid": "8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "url": "https://github.com/rsksmart/rskj/commit/8c67ae53c885a46a957ac5fe68cc60eb1da7b7bc", "message": "Bloom blocks configuration, service, synchronized store", "committedDate": "2020-11-12T17:35:59Z", "type": "commit"}, {"oid": "f47d5687f3b00433f3d6419c52b352b8e5d5906f", "url": "https://github.com/rsksmart/rskj/commit/f47d5687f3b00433f3d6419c52b352b8e5d5906f", "message": "Set default no of blocks to 64; logging messages", "committedDate": "2020-11-12T17:35:59Z", "type": "commit"}, {"oid": "6c413be37569e4662b82e6123d47ecb29b459654", "url": "https://github.com/rsksmart/rskj/commit/6c413be37569e4662b82e6123d47ecb29b459654", "message": "Remove unused import", "committedDate": "2020-11-12T17:35:59Z", "type": "commit"}, {"oid": "66d033f432ba4789f324d63b635fac3bfea37470", "url": "https://github.com/rsksmart/rskj/commit/66d033f432ba4789f324d63b635fac3bfea37470", "message": "Rename BlocksBloomBuilder to BlocksBloomProcessor; rename setBlocksBloom method to addBlocksBloom; rename blocksBloom private variable to blocksBloomCache", "committedDate": "2020-11-12T17:35:59Z", "type": "commit"}, {"oid": "9341e07da0897f24fe9349b21d6ed87e3c2c5658", "url": "https://github.com/rsksmart/rskj/commit/9341e07da0897f24fe9349b21d6ed87e3c2c5658", "message": "Fix bug and refactor method BlocksBloomStore hasBlockNumber", "committedDate": "2020-11-12T17:36:00Z", "type": "commit"}, {"oid": "931289ea867b8fc2f57b5a6d1bc7c739ef6f95db", "url": "https://github.com/rsksmart/rskj/commit/931289ea867b8fc2f57b5a6d1bc7c739ef6f95db", "message": "Improve reference.conf declaration", "committedDate": "2020-11-12T17:36:00Z", "type": "commit"}, {"oid": "fa19462038b46cc30b5a1b49b1da72316b75f065", "url": "https://github.com/rsksmart/rskj/commit/fa19462038b46cc30b5a1b49b1da72316b75f065", "message": "Avoid processing negative block number; adding synchronization; adding visibility for testing; use HashMap instead of ConcurrentHashMap", "committedDate": "2020-11-12T17:36:00Z", "type": "commit"}, {"oid": "f6c3967ce60dfce452890206882115bdf55533a7", "url": "https://github.com/rsksmart/rskj/commit/f6c3967ce60dfce452890206882115bdf55533a7", "message": "Adding comments to classes and methods", "committedDate": "2020-11-12T17:36:00Z", "type": "commit"}, {"oid": "f7eda5aaee4a500e1c875ca4cdce12f8c4b0648f", "url": "https://github.com/rsksmart/rskj/commit/f7eda5aaee4a500e1c875ca4cdce12f8c4b0648f", "message": "Adding null checks to BlocksBloomStore dataSource", "committedDate": "2020-11-12T17:36:00Z", "type": "commit"}, {"oid": "3a1c66e92205d514c6ad019b9ff9859300460fca", "url": "https://github.com/rsksmart/rskj/commit/3a1c66e92205d514c6ad019b9ff9859300460fca", "message": "extracted methods for BlocksBloomProcessor", "committedDate": "2020-11-12T17:36:00Z", "type": "commit"}, {"oid": "3a1c66e92205d514c6ad019b9ff9859300460fca", "url": "https://github.com/rsksmart/rskj/commit/3a1c66e92205d514c6ad019b9ff9859300460fca", "message": "extracted methods for BlocksBloomProcessor", "committedDate": "2020-11-12T17:36:00Z", "type": "forcePushed"}]}